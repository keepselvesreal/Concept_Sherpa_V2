{
  "total_nodes": 7,
  "extracted_nodes": 7,
  "extraction_results": {
    "66": {
      "title": "7 Introduction",
      "text": "Basic data validation\n\n**Level:** 1\n**페이지 범위:** 169 - 190\n**총 페이지 수:** 22\n**ID:** 65\n\n---\n\n=== 페이지 169 ===\nBasic data validation\nA solemn gift\nThis chapter covers\n The importance of validating data at system\nboundaries\n Validating data using the JSON Schema language\n Integrating data validation into an existing code\nbase\n Getting detailed information about data validation\nfailures\nAt first glance, it may seem that embracing DOP means accessing data without validat-\ning it and engaging in wishful thinking, where data is always valid. In fact, data valida-\ntion is not only possible but recommended when we follow data-oriented principles.\nThis chapter illustrates how to validate data when data is represented with\ngeneric data structures. It focuses on data validation occurring at the boundaries of\nthe system, while in part 3, we will deal with validating data as it flows through the\nsystem. This chapter is a deep dive into the fourth principle of DOP.\nPRINCIPLE #4",
      "length": 979,
      "file": "/home/nadle/projects/Knowledge_Sherpa/v2/25-08-09/extracted_leaf_nodes/node_66_7_Introduction.txt"
    },
    "67": {
      "title": "7.1 Data validation in DOP",
      "text": "7.1 Data validation in DOP\nTheo has rescheduled his meetings. With such an imposing deadline, he’s still not sure if\nhe’s made a big mistake giving DOP a second chance.\n NOTE The reason why Theo rescheduled his meetings is explained in the opener\nfor part 2. Take a moment to read the opener if you missed it.\nJoe What aspect of OOP do you think you will miss the most in your big project?\nTheo Data validation.\nJoe Can you elaborate a bit?\nTheo In OOP, I have this strong guarantee that when a class is instantiated, its mem-\nber fields have the proper names and proper types. But with DOP, it’s so easy\nto have small mistakes in field names and field types.\nJoe Well, I have good news for you! There is a way to validate data in DOP.\nTheo How does it work? I thought DOP and data validation were two contradictory\nconcepts!\nJoe Not at all. It’s true that DOP doesn’t force you to validate data, but it doesn’t\nprevent you from doing so. In DOP, the data schema is separate from the data\nrepresentation.\nTheo I don’t get how that would eliminate data consistency issues.\nJoe According to DOP, the most important data to validate is data that crosses the\nboundaries of the system.\nTheo Which boundaries are you referring to?\nJoe In the case of a web server, it would be the areas where the web server commu-\nnicates with its clients and with its data sources.\nTheo A diagram might help me see it better.\nJoe goes to the whiteboard and picks up the pen. He then draws a diagram like the one in\nfigure 7.1.\nClient (e.g., web browser)\nData\nWeb server\nData Data\nWeb service Database Figure 7.1 High-level architecture of\na modern web server\n\n=== 페이지 171 ===\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is b",
      "length": 3448,
      "file": "/home/nadle/projects/Knowledge_Sherpa/v2/25-08-09/extracted_leaf_nodes/node_67_7.1_Data_validation_in_DOP.txt"
    },
    "68": {
      "title": "7.2 JSON Schema in a nutshell",
      "text": "7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n\n=== 페이지 172 ===\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n\n=== 페이지 173 ===\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n\n=== 페이지 174 ===\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\n=== 페이지 175 ===\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer\n\n=== 페이지 176 ===\n148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema from listing 7.6.\nListing7.7 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe Give it a try, and you’ll see.\nIndeed! When Theo executes the code to validate the search request, it returns true.\nListing7.8 Validating the search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksRequest = {\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nvalidate(searchBooksRequestSchema, searchBooksRequest);\n// → true\nJoe Now, please try an invalid request.\nTheo Let me think about what kind of invalidity to try. I know, I’ll make a typo in the\ntitle field and call it tilte with the l before the t.\nAs expected, the code with the type returns false. Theo is not surprised, and Joe is smil-\ning from ear to ear.\nListing7.9 Validating an invalid search request\nvar invalidSearchBooksRequest = {\n\"tilte\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\n\n=== 페이지 177 ===\n7.3 Schema flexibility and strictness 149\nvalidate(searchBooksRequestSchema, invalidSearchBooksRequest);\n// → false\nTheo The syntax of JSON Schema is much more verbose than the syntax for declar-\ning the members in a class. Why is that so?\nJoe For two reasons. First, because JSON Schema is language independent, it can\nbe used in any programming language. As I told you, there are JSON Schema\nvalidators available in most programming languages.\nTheo I see.\nJoe Second, JSON Schema allows you to express validation conditions that are much\nharder, if not impossible, to express when data is represented with classes.\nTIP The expressive power of JSON Schema is high!\nTheo Now you have triggered my curiosity. Can you give me some examples?\nJoe In a moment, we’ll talk about schema composition. Someday I’ll show you\nsome examples of advanced valid",
      "length": 10832,
      "file": "/home/nadle/projects/Knowledge_Sherpa/v2/25-08-09/extracted_leaf_nodes/node_68_7.2_JSON_Schema_in_a_nutshell.txt"
    },
    "69": {
      "title": "7.3 Schema flexibility and strictness",
      "text": "7.3 Schema flexibility and strictness 149\nvalidate(searchBooksRequestSchema, invalidSearchBooksRequest);\n// → false\nTheo The syntax of JSON Schema is much more verbose than the syntax for declar-\ning the members in a class. Why is that so?\nJoe For two reasons. First, because JSON Schema is language independent, it can\nbe used in any programming language. As I told you, there are JSON Schema\nvalidators available in most programming languages.\nTheo I see.\nJoe Second, JSON Schema allows you to express validation conditions that are much\nharder, if not impossible, to express when data is represented with classes.\nTIP The expressive power of JSON Schema is high!\nTheo Now you have triggered my curiosity. Can you give me some examples?\nJoe In a moment, we’ll talk about schema composition. Someday I’ll show you\nsome examples of advanced validation.\n NOTE Advanced validation is covered in chapter 12.\nTheo What kind of advanced validation?\nJoe What I mean by advanced validation is, for instance, validating that a number\nfalls within a given range or validating that a string matches a regular expression.\nTheo Is there a way to get details about why the request is invalid?\nJoe Absolutely! I’ll show you later. For now, let me show you how to make sure the\nresponse the server sends back to the client is valid.\nTheo It sounds much more complicated than a search book request!\nJoe Why?\nTheo Because a search response is made of multiple book results, and in each book\nresult, some of the fields are optional!\n7.3 Schema flexibility and strictness\nJoe Can you give me an example of what a book search response would look like?\nTheo Take a look at this example. It’s a search response with information about two\nbooks: 7 Habits of Highly Effective People and The Power of Habit.\nListing7.10 An example of a search response\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432\n},\n\n=== 페이지 178 ===\n150 CHAPTER 7 Basic data validation\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn_13\": \"978-1982137274\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n]\n}\n]\nJoe It’s funny that you mention The Power of Habit. I’m reading this book in order\nto get rid of my habit of biting my nails. Anyway, what fields are required and\nwhat fields are optional in a book search response?\nTheo In book information, the title and available fields are required. The other\nfields are optional.\nJoe As I told you when we built the schema for the book search request, fields in a\nmap are optional by default. In order to make a field mandatory, we have to\ninclude it in the required array. I’d probably implement it with something\nlike this.\nListing7.11 Schema of a search response\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, map fields are optional by default.\nTheo I must admit that specifying a list of required fields is much simpler than hav-\ning to specify that a member in a class in nullable!\nJoe Agreed!\nTheo On the other hand, I find the nesting of the book information schema in the\nsearch response schema a bit hard to read.\n\n=== 페이지 179 ===\n7.3 Schema flexibility and strictness 151\nJoe Nothing prevents you from separating the book information schema from the\nsearch response schema.\nTheo How?\nJoe It’s just JSON, my friend. It means, you are free to manipulate the schema as\nany other map in your program. For instance, you could have the book infor-\nmation schema in a variable named bookInfoSchema and use it in the search\nbooks response schema. Let me refactor the schema to show you what I mean.\nListing7.12 Schema of a search response refactored\nvar bookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n};\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": bookInfoSchema\n};\nTheo Once again, I have to admit that JSON Schemas are more composable than\nclass definitions.\nTIP JSON Schemas are just maps. We are free to compose and manipulate them like\nany other map.\nJoe Let’s move on to validating data received from external data sources.\nTheo Is that different?\nJoe Not really, but I’ll take it as an opportunity to show you some other features of\nJSON Schema.\nTheo I’m curious to learn how data validation is used when we access data from the\ndatabase.\nJoe Each time we access data from the outside, it’s a good practice to validate it.\nCan you show me an example of how a database response for a search query\nwould look?\nTIP It’s a good practice to validate data that comes from an external data source.\n\n=== 페이지 180 ===\n152 CHAPTER 7 Basic data validation\nTheo When we query books from the database, we expect to receive an array of\nbooks with three fields: title, isbn, and available. The first two values should\nbe strings, and the third one should be a Boolean.\nJoe Are those fields optional or required?\nTheo What do you mean?\nJoe Could there be books for which some of the fields are not defined?\nTheo No.\nJoe In that case, the schema is quite simple. Would you like to try writing the\nschema for the database response?\nTheo Let me see. It’s an array of objects where each object has three properties, so\nsomething like this?\nListing7.13 Schema of a database response\n{\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n}\nJoe Well done, my friend! Now, I want to tell you about the additionalProperties\nfield in JSON Schema.\nTheo What’s that?\nJoe Take a look at this array.\nListing7.14 A book array with an additional property\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"dummy_property\": 42\n},\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn\": \"978-1982137274\",\n\"dummy_property\": 45\n}\n]\n\n=== 페이지 181 ===\n7.3 Schema flexibility and strictness 153\nJoe Is it a valid database response?\nTheo No. A database response should not have a dummy_property field. It should\nhave only the three required fields specified in the schema.\nJoe It might be surprising but, by default, fields not specified in the schema of an\nobject are allowed in JSON Schema. In order to disallow them, one has to set\nadditionalProperties to false like this.\nListing7.15 Disallowing properties not mentioned in the schema\nvar booksFromDBSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"additionalProperties\": false,\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, by default, fields not specified in the schema of a map are\nallowed.\nTheo Why is that?\nJoe The reason is that usually having additional fields in a map doesn’t cause\ntrouble. If your code doesn’t care about a field, it simply ignores it. But some-\ntimes we want to be as strict as possible, and we set additionalProperties\nto false.\nTheo What about the search request and response schema from the previous discus-\nsions? Should we set additionalProperties to false?\nJoe That’s an excellent question. I’d say it’s a matter of taste. Personally, I like to\nallow additional fields in requests and disallow them in responses.\nTheo What’s the advantage?\nJoe Well, the web server is responsible for the responses it sends to its clients. It\nmakes sense then to be as strict as possible. However, the requests are created\nby the clients, and I prefer to do my best to serve my clients even when they are\nnot as strict as they should be.\nTheo Naturally. “The client is always right.”\nJoe Actually, I prefer the way Jon Postel formulated his robustness principle: “Be\nconservative in what you send, be liberal in what you accept.”\nTIP It’s a good practice to be strict with the data that you send and to be flexible with\nthe data that you recei",
      "length": 8604,
      "file": "/home/nadle/projects/Knowledge_Sherpa/v2/25-08-09/extracted_leaf_nodes/node_69_7.3_Schema_flexibility_and_strictness.txt"
    },
    "70": {
      "title": "7.4 Schema composition",
      "text": "7.4 Schema composition\nTheo What about validating data that comes from an external web service?\nJoe Can you give me an example?\nTheo In the near future, we’ll have to integrate with a service called Open Library\nBooks API that provides detailed information about books.\n NOTE For information on the Open Library Books API, see https://openlibrary\n.org/dev/docs/api/books.\nJoe Can you show me, for instance, the service response for Watchmen?\nTheo Sure. Here you go.\nTheo taps a few keys on his keyboard and brings up the response. Joe looks at the JSON for\na long time.\nListing7.16 An Open Library Books API response example\n{\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n}\nTheo asks himself, “What could be so special in this JSON?” While Joe is meditating about\nthis piece of JSON, Theo writes the JSON Schema for the Books API response. It doesn’t\nseem to be more complicated than any of the previous schemas. When Theo is done, he\nasks Joe to take a look at the schema.\nListing7.17 Schema of the Open Library Books API response\n{\n\"type\": \"object\",\n\"required\": [\"title\"],\n\n=== 페이지 183 ===\n7.4 Schema composition 155\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n}\nJoe Good job!\nTheo That wasn’t so hard. I really don’t see why you looked at this JSON response for\nsuch a long time.\nJoe Well, it has to do with the isbn_10 and isbn_13 fields. I assume that they’re\nnot both mandatory.\nTheo Right! That’s why I didn’t include them in the required field of my schema.\nJoe But one of them should always be there. Right?\nTheo Sometimes one of them and sometimes both of them, like for Watchmen. It\ndepends on the publication year of the book. Books published before 2007\nhave isbn_10, and books published after 2007 have isbn_13.\nJoe Oh, I see. And Watchmen has both because it was originally published in 1986\nbut published again after 2007.\nTheo Correct.\nJoe Then, you need your schema to indicate that one of the isbn fields is man-\ndatory. That’s a good opportunity for me to tell you about JSON Schema\ncomposition.\nTheo What’s that?\nJoe It’s a way to combine schemas, similarly to how we combine logical conditions\nwith AND, OR, and NOT.\nTheo I’d like to see that.\nJoe Sure. How would you express the schema for the Books API response as a\ncomposition of three schemas: basicBookInfoSchema, the schema that you\nwrote where only title is required; mandatoryIsbn13, a schema where only\n\n=== 페이지 184 ===\n156 CHAPTER 7 Basic data validation\nisbn_13 is required; and mandatoryIsb10, a schema where only isbn_10 is\nrequired?\nTheo I think it should be basicBookInfoSchema AND (mandatoryIsbn13 OR\nmandatoryIsbn10).\nJoe Exactly! The only thing is that in JSON Schema, we use allOf instead of AND,\nand anyOf instead of OR.\nJoe shows Theo the result in listing 7.18 and an example of its usage in listing 7.19.\nListing7.18 Schema of an external API response\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n\n=== 페이지 185 ===\n7.4 Schema composition 157\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing7.19 Validating an external API response\nvar bookInfo = {\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n};\nvalidate(bookInfoSchema, bookInfo);\n// → true\nTheo I see why they call it allOf and anyOf. The first one means that data must con-\nform to all the schemas, and the second one means that data must conform to\nany of the schemas.\nJoe Yup.\n NOTE JSON Schema also supports oneOf for cases where data must be valid against\nexactly one schema.\nTheo Nice. With schema composition, JSON Schema seems to have more expressive\npower than what I was used to when representing data with classes.\nJoe That’s only the beginning. I’ll show you more data validation conditions that\ncan’t be expressed when data is represented with classes some other tim",
      "length": 5526,
      "file": "/home/nadle/projects/Knowledge_Sherpa/v2/25-08-09/extracted_leaf_nodes/node_70_7.4_Schema_composition.txt"
    },
    "71": {
      "title": "7.5 Details about data validation failures",
      "text": "7.5 Details about data validation failures\nJoe So far, we’ve treated JSON Schema validation as though it were binary: either a\npiece of data is valid or it isn’t.\nTheo Right...\nJoe But, in fact, when a piece of data is not valid, we can get details about the\nreason of the invalidity.\nTheo Like when a required field is missing, can we get the name of the missing field?\nJoe Yes. When a piece of data is not of the expected type, we can get information\nabout that also.\nTheo That sounds very useful!\nJoe Indeed. Let me show you how it works. Until now, we used a generic validate\nfunction, but when we deal with validation failures, we need to be more specific.\nTheo Why?\nJoe Because each data validator library has its own way of exposing the details of\nadata validation failure. For instance, in JavaScript Ajv, the errors from the\nlast data validation are stored as an array inside the validator instance.\nTheo Why an array?\nJoe Because there could be several failures. But let’s start with the case of a single\nfailure. Imagine we encounter a search book request where the title field is\nnamed myTitle instead of title. Take a look at this example. As you can see,\nwe first instantiate a validator instance.\nListing7.20 Accessing validation errors in Ajv\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nInstantiates a\nvar ajv = new Ajv(); validator instance\najv.validate(searchBooksRequestSchema, invalidSearchBooksRequest);\najv.errors\nDisplays the\nvalidation errors\n\n=== 페이지 187 ===\n7.5 Details about data validation failures 159\nTheo And what does the information inside the errors array look like?\nJoe Execute the code snippet. You’ll see.\nWhen Theo executes the code snippets from listing 7.20, he can hardly believe his eyes. He\nlooks at the details, finding the results hard to digest.\nListing7.21 Details for a single data validation failure in an array format\n[\n{\n\"instancePath\": \"\",\n\"schemaPath\": \"#/required\",\n\"keyword\": \"required\",\n\"params\": {\n\"missingProperty\":\"title\"\n},\n\"message\": \"must have required property 'title'\"\n}\n]\nTheo I find the contents of the errors array a bit hard to understand.\nJoe Me too. Fortunately, Ajv provides a errorsText utility function to convert the\nerrors array in a human readable format. See, for instance, what is returned\nwhen you call errorsText.\nListing7.22 Displaying the errors in human readable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title'\"\nTheo Let me see what happens when there are more than one validation failure in\nthe data.\nJoe By default, Ajv catches only one validation error.\nTIP By default, Ajv catches only the first validation failure.\nTheo I guess that’s for performance reasons. Once the validator encounters an\nerror, it doesn’t continue the data parsing.\nJoe Probably. Anyway, in order to catch more than one validation failure, you need\nto pass the allErrors options to the Ajv constructor. Check out this code.\nListing7.23 Catching multiple validation failures\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n\n=== 페이지 188 ===\n160 CHAPTER 7 Basic data validation\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nA request with\nthree failures\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [1, 2]\n}; Instantiates the Ajv constructor\nwith allErrors: true in order to\ncatch more than one failure\nvar ajv = new Ajv({allErrors: true});\najv.validate(searchBooksRequestSchema,\ninvalidSearchBooksRequest); Converts the\nerrors to a human\nreadable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title',\n// → data/fields/0 must be string,\n// → data/fields/1 must be string\"\nJoe We validate a search request with myTitle instead of title and numbers\ninstead of strings in the fields array. As you can see in the output of the code\nsnippet, three errors are returned.\nTheo Great! I think I have all that I need in order to add data validation to the\nboundaries of my system when Nancy asks me to make the Library Manage-\nment System into a web server.\nJoe Would you allow me to give you a small gift as a token of our friendship?\nTheo I’d be honored.\nJoe takes a small package out of his bag, wrapped in a light-green ribbon. He hands Theo\nthe package with a solemn gesture.\nWhen Theo undoes the ribbon, he discovers an elegant piece of paper decorated with\npretty little designs. In the center of the paper, Theo manages to read the inscription\n“JSON Schema cheat sheet.” He smiles while browsing the cheat sheet. It’s exactly what he",
      "length": 4824,
      "file": "/home/nadle/projects/Knowledge_Sherpa/v2/25-08-09/extracted_leaf_nodes/node_71_7.5_Details_about_data_validation_failures.txt"
    },
    "72": {
      "title": "Summary",
      "text": "Summary 161\n\"additionalProperties\": false\nWe don’t allow fields that\n}\nare not explicitly mentioned\n}\nin the schema.\nThen, Theo turns the paper over to find that the back is also filled with drawings. In the\ncenter of the paper, he reads the inscription, “An example of valid data.”\nListing7.25 An example of valid data\n[\n{\nThis map is valid\n\"myNumber\": 42,\nbecause all its\n\"myString\": \"Hello\",\nfields are valid.\n\"myEnum\": \"myVal\",\n\"myBool\": true\n},\n{\nThis map is valid\n\"myNumber\": 54,\nbecause it contains all\n\"myString\": \"Happy\"\nthe required fields.\n}\n]\nSummary\n DOP Principle #4 is to separate data schema and data representation.\n The boundaries of a system are defined to be the areas where the system\nexchanges data.\n Some examples of data validation at the boundaries of the system are validation\nof client requests and responses, and validation of data that comes from exter-\nnal sources.\n Data validation in DOP means checking whether a piece of data conforms to a\nschema.\n When a piece of data is not valid, we get information about the validation fail-\nures and send this information back to the client in a human readable format.\n When data at system boundaries is valid, it’s not critical to validate data again\ninside the system.\n JSON Schema is a language that allows us to separate data validation from data\nrepresentation.\n JSON Schema syntax is a bit verbose.\n The expressive power of JSON Schema is high.\n JSON Schemas are just maps and, as so, we are free to manipulate them like any\nother maps in our programs.\n We can store a schema definition in a variable and use this variable in another\nschema.\n In JSON Schema, map fields are optional by default.\n It’s good practice to validate data that comes from an external data source.\n\n=== 페이지 190 ===\n162 CHAPTER 7 Basic data validation\n It’s good practice to be strict regarding data that you send and to be flexible\nregarding data that you receive.\n Ajv is a JSON Schema library in JavaScript.\n By default, Ajv catches only the first validation failure.\n Advanced validation is covered in chapter 12.",
      "length": 2086,
      "file": "/home/nadle/projects/Knowledge_Sherpa/v2/25-08-09/extracted_leaf_nodes/node_72_Summary.txt"
    }
  }
}