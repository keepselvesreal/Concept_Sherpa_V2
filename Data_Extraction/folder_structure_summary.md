# 폴더 구조 요약

**Root 폴더:** Data-Oriented Programming
**전체 노드 수:** 239
**Internal 노드 (폴더):** 168
**Leaf 노드 (파일 대상):** 71

## 폴더 구조

```
Data_Oriented_Programming/
├── Part_1_Flexibility/
│   ├── 10_Introduction_사용자_추가/
│   ├── 1_Complexity_of_object_oriented_programming/
│   │   ├── 10_Introduction_사용자_추가/
│   │   ├── 11_OOP_design_Classic_or_classical/
│   │   │   ├── 📄 1.1.0 Introduction (사용자 추가) (node4)
│   │   │   ├── 📄 1.1.1 The design phase (node4)
│   │   │   ├── 📄 1.1.2 UML 101 (node4)
│   │   │   ├── 📄 1.1.3 Explaining each piece of the class diagram (node4)
│   │   │   └── 📄 1.1.4 The implementation phase (node4)
│   │   ├── 12_Sources_of_complexity/
│   │   │   ├── 📄 1.2.0 Introduction (사용자 추가) (node4)
│   │   │   ├── 📄 1.2.1 Many relations between classes (node4)
│   │   │   ├── 📄 1.2.2 Unpredictable code behavior (node4)
│   │   │   ├── 📄 1.2.3 Not trivial data serialization (node4)
│   │   │   └── 📄 1.2.4 Complex class hierarchies (node4)
│   │   └── Summary/
│   ├── 2_Separation_between_code_and_data/
│   │   ├── 21_The_two_parts_of_a_DOP_system/
│   │   ├── 22_Data_entities/
│   │   ├── 23_Code_modules/
│   │   ├── 24_DOP_systems_are_easy_to_understand/
│   │   ├── 20_Introduction_사용자_추가/
│   │   ├── 25_DOP_systems_are_flexible/
│   │   └── Summary/
│   ├── 3_Basic_data_manipulation/
│   │   ├── 30_Introduction_사용자_추가/
│   │   ├── 31_Designing_a_data_model/
│   │   ├── 32_Representing_records_as_maps/
│   │   ├── 33_Manipulating_data_with_generic_functions/
│   │   ├── 34_Calculating_search_results/
│   │   ├── 35_Handling_records_of_different_types/
│   │   └── Summary/
│   ├── 4_State_management/
│   │   ├── 40_Introduction_사용자_추가/
│   │   ├── 41_Multiple_versions_of_the_system_data/
│   │   ├── 42_Structural_sharing/
│   │   ├── 43_Implementing_structural_sharing/
│   │   ├── 44_Data_safety/
│   │   ├── 45_The_commit_phase_of_a_mutation/
│   │   ├── 46_Ensuring_system_state_integrity/
│   │   ├── 47_Restoring_previous_states/
│   │   └── Summary/
│   ├── 5_Basic_concurrency_control/
│   │   ├── 50_Introduction_사용자_추가/
│   │   ├── 51_Optimistic_concurrency_control/
│   │   ├── 52_Reconciliation_between_concurrent_mutations/
│   │   ├── 53_Reducing_collections/
│   │   ├── 54_Structural_difference/
│   │   ├── 55_Implementing_the_reconciliation_algorithm/
│   │   └── Summary/
│   └── 6_Unit_tests/
│       ├── 61_The_simplicity_of_data_oriented_test_cases/
│       ├── 60_Introduction_사용자_추가/
│       ├── 62_Unit_tests_for_data_manipulation_code/
│       │   ├── 📄 6.2.0 Introduction (사용자 추가) (node4)
│       │   ├── 📄 6.2.1 The tree of function calls (node4)
│       │   ├── 📄 6.2.2 Unit tests for functions down the tree (node4)
│       │   └── 📄 6.2.3 Unit tests for nodes in the tree (node4)
│       ├── 63_Unit_tests_for_queries/
│       ├── 64_Unit_tests_for_mutations/
│       ├── Moving_forward/
│       └── Summary/
├── Part_2_Scalability/
│   ├── 20_Introduction_사용자_추가/
│   ├── 7_Basic_data_validation/
│   │   ├── 71_Data_validation_in_DOP/
│   │   ├── 70_Introduction_사용자_추가/
│   │   ├── 72_JSON_Schema_in_a_nutshell/
│   │   ├── 73_Schema_flexibility_and_strictness/
│   │   ├── 74_Schema_composition/
│   │   ├── 75_Details_about_data_validation_failures/
│   │   └── Summary/
│   ├── 8_Advanced_concurrency_control/
│   │   ├── 81_The_complexity_of_locks/
│   │   ├── 80_Introduction_사용자_추가/
│   │   ├── 82_Thread_safe_counter_with_atoms/
│   │   ├── 83_Thread_safe_cache_with_atoms/
│   │   ├── 84_State_management_with_atoms/
│   │   └── Summary/
│   ├── 9_Persistent_data_structures/
│   │   ├── 91_The_need_for_persistent_data_structures/
│   │   ├── 90_Introduction_사용자_추가/
│   │   ├── 92_The_efficiency_of_persistent_data_structures/
│   │   ├── 93_Persistent_data_structures_libraries/
│   │   │   ├── 📄 9.3.0 Introduction (사용자 추가) (node4)
│   │   │   ├── 📄 9.3.1 Persistent data structures in Java (node4)
│   │   │   └── 📄 9.3.2 Persistent data structures in JavaScript (node4)
│   │   ├── 94_Persistent_data_structures_in_action/
│   │   │   ├── 📄 9.4.0 Introduction (사용자 추가) (node4)
│   │   │   ├── 📄 9.4.1 Writing queries with persistent data structures (node4)
│   │   │   ├── 📄 9.4.2 Writing mutations with persistent data structures (node4)
│   │   │   ├── 📄 9.4.3 Serialization and deserialization (node4)
│   │   │   └── 📄 9.4.4 Structural diff (node4)
│   │   └── Summary/
│   ├── 10_Database_operations/
│   │   ├── 101_Fetching_data_from_the_database/
│   │   ├── 100_Introduction_사용자_추가/
│   │   ├── 102_Storing_data_in_the_database/
│   │   ├── 103_Simple_data_manipulation/
│   │   ├── 104_Advanced_data_manipulation/
│   │   └── Summary/
│   └── 11_Web_services/
│       ├── 111_Another_feature_request/
│       ├── 112_Building_the_insides_like_the_outsides/
│       ├── 110_Introduction_사용자_추가/
│       ├── 113_Representing_a_client_request_as_a_map/
│       ├── 114_Representing_a_server_response_as_a_map/
│       ├── 115_Passing_information_forward/
│       ├── 116_Search_result_enrichment_in_action/
│       ├── Delivering_on_time/
│       └── Summary/
├── Part_3_Maintainability/
│   ├── 30_Introduction_사용자_추가/
│   ├── 12_Advanced_data_validation/
│   │   ├── 121_Function_arguments_validation/
│   │   ├── 120_Introduction_사용자_추가/
│   │   ├── 122_Return_value_validation/
│   │   ├── 123_Advanced_data_validation/
│   │   ├── 124_Automatic_generation_of_data_model_diagrams/
│   │   ├── 125_Automatic_generation_of_schema_based_unit_tests/
│   │   ├── 126_A_new_gift/
│   │   └── Summary/
│   ├── 13_Polymorphism/
│   │   ├── 131_The_essence_of_polymorphism/
│   │   ├── 130_Introduction_사용자_추가/
│   │   ├── 132_Multimethods_with_single_dispatch/
│   │   ├── 133_Multimethods_with_multiple_dispatch/
│   │   ├── 134_Multimethods_with_dynamic_dispatch/
│   │   ├── 135_Integrating_multimethods_in_a_production_system/
│   │   └── Summary/
│   ├── 14_Advanced_data_manipulation/
│   │   ├── 141_Updating_a_value_in_a_map_with_eloquence/
│   │   ├── 140_Introduction_사용자_추가/
│   │   ├── 142_Manipulating_nested_data/
│   │   ├── 143_Using_the_best_tool_for_the_job/
│   │   ├── 144_Unwinding_at_ease/
│   │   └── Summary/
│   └── 15_Debugging/
│       ├── 151_Determinism_in_programming/
│       ├── 150_Introduction_사용자_추가/
│       ├── 152_Reproducibility_with_numbers_and_strings/
│       ├── 153_Reproducibility_with_any_data/
│       ├── 154_Unit_tests/
│       ├── 155_Dealing_with_external_data_sources/
│       ├── Farewell/
│       └── Summary/
└── Appendices/
    ├── Appendix_A_Principles_of_data_oriented_programming/
    │   ├── A1_Principle_1_Separate_code_from_data/
    │   │   ├── 📄 A.1.0 Introduction (사용자 추가) (node4)
    │   │   ├── 📄 A.1.1 Illustration of Principle #1 (node4)
    │   │   ├── 📄 A.1.2 Benefits of Principle #1 (node4)
    │   │   ├── 📄 A.1.3 Cost for Principle #1 (node4)
    │   │   └── 📄 A.1.4 Summary of Principle #1 (node4)
    │   ├── A2_Principle_2_Represent_data_with_generic_data_structures/
    │   │   ├── 📄 A.2.0 Introduction (사용자 추가) (node4)
    │   │   ├── 📄 A.2.1 Illustration of Principle #2 (node4)
    │   │   ├── 📄 A.2.2 Benefits of Principle #2 (node4)
    │   │   ├── 📄 A.2.3 Cost for Principle #2 (node4)
    │   │   └── 📄 A.2.4 Summary of Principle #2 (node4)
    │   ├── A3_Principle_3_Data_is_immutable/
    │   │   ├── 📄 A.3.0 Introduction (사용자 추가) (node4)
    │   │   ├── 📄 A.3.1 Illustration of Principle #3 (node4)
    │   │   ├── 📄 A.3.2 Benefits of Principle #3 (node4)
    │   │   ├── 📄 A.3.3 Cost for Principle #3 (node4)
    │   │   └── 📄 A.3.4 Summary of Principle #3 (node4)
    │   ├── A4_Principle_4_Separate_data_schema_from_data_representation/
    │   │   ├── 📄 A.4.0 Introduction (사용자 추가) (node4)
    │   │   ├── 📄 A.4.1 Illustration of Principle #4 (node4)
    │   │   ├── 📄 A.4.2 Benefits of Principle #4 (node4)
    │   │   ├── 📄 A.4.3 Cost for Principle #4 (node4)
    │   │   └── 📄 A.4.4 Summary of Principle #4 (node4)
    │   └── Conclusion/
    ├── Appendix_B_Generic_data_access_in_statically_typed_languages/
    │   ├── B1_Dynamic_getters_for_string_maps/
    │   │   ├── 📄 B.1.0 Introduction (사용자 추가) (node4)
    │   │   ├── 📄 B.1.1 Accessing non-nested map fields with dynamic getters (node4)
    │   │   └── 📄 B.1.2 Accessing nested map fields with dynamic getters (node4)
    │   ├── B2_Value_getters_for_maps/
    │   │   ├── 📄 B.2.0 Introduction (사용자 추가) (node4)
    │   │   ├── 📄 B.2.1 Accessing non-nested map fields with value getters (node4)
    │   │   └── 📄 B.2.2 Accessing nested map fields with value getters (node4)
    │   ├── B3_Typed_getters_for_maps/
    │   │   ├── 📄 B.3.0 Introduction (사용자 추가) (node4)
    │   │   ├── 📄 B.3.1 Accessing non-nested map fields with typed getters (node4)
    │   │   └── 📄 B.3.2 Accessing nested map fields with typed getters (node4)
    │   ├── B4_Generic_access_to_class_members/
    │   │   ├── 📄 B.4.0 Introduction (사용자 추가) (node4)
    │   │   ├── 📄 B.4.1 Generic access to non-nested class members (node4)
    │   │   ├── 📄 B.4.2 Generic access to nested class members (node4)
    │   │   └── 📄 B.4.3 Automatic JSON serialization of objects (node4)
    │   └── Summary/
    ├── Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/
    │   ├── C1_Time_line/
    │   │   ├── 📄 C.1.1 1958: Lisp (node4)
    │   │   ├── 📄 C.1.0 Introduction (사용자 추가) (node4)
    │   │   ├── 📄 C.1.2 1981: Values and objects (node4)
    │   │   ├── 📄 C.1.3 2000: Ideal hash trees (node4)
    │   │   ├── 📄 C.1.4 2006: Out of the Tar Pit (node4)
    │   │   ├── 📄 C.1.5 2007: Clojure (node4)
    │   │   └── 📄 C.1.6 2009: Immutability for all (node4)
    │   ├── C2_DOP_principles_as_best_practices/
    │   │   ├── 📄 C.2.0 Introduction (사용자 추가) (node4)
    │   │   ├── 📄 C.2.1 Principle #1: Separate code from data (node4)
    │   │   ├── 📄 C.2.2 Principle #2: Represent data with generic data structures (node4)
    │   │   ├── 📄 C.2.3 Principle #3: Data is immutable (node4)
    │   │   └── 📄 C.2.4 Principle #4: Separate data schema from data representation (node4)
    │   ├── C3_DOP_and_other_data_related_paradigms/
    │   │   ├── 📄 C.3.0 Introduction (사용자 추가) (node4)
    │   │   ├── 📄 C.3.1 Data-oriented design (node4)
    │   │   ├── 📄 C.3.2 Data-driven programming (node4)
    │   │   └── 📄 C.3.3 Data-oriented programming (DOP) (node4)
    │   └── Summary/
    ├── Appendix_D_Lodash_reference/
    ├── A/
    ├── B/
    ├── C/
    ├── D/
    ├── E/
    ├── F/
    ├── G/
    ├── H/
    ├── I/
    ├── J/
    ├── K/
    ├── L/
    ├── M/
    ├── N/
    ├── O/
    ├── P/
    ├── Q/
    ├── R/
    ├── S/
    ├── T/
    ├── U/
    ├── V/
    └── W/
```

## Leaf 노드 목록 (콘텐츠 추출 대상)

- **1.1.0 Introduction (사용자 추가)** (node4)
  - 경로: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/11_OOP_design_Classic_or_classical`

- **1.1.1 The design phase** (node4)
  - 경로: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/11_OOP_design_Classic_or_classical`

- **1.1.2 UML 101** (node4)
  - 경로: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/11_OOP_design_Classic_or_classical`

- **1.1.3 Explaining each piece of the class diagram** (node4)
  - 경로: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/11_OOP_design_Classic_or_classical`

- **1.1.4 The implementation phase** (node4)
  - 경로: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/11_OOP_design_Classic_or_classical`

- **1.2.0 Introduction (사용자 추가)** (node4)
  - 경로: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/12_Sources_of_complexity`

- **1.2.1 Many relations between classes** (node4)
  - 경로: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/12_Sources_of_complexity`

- **1.2.2 Unpredictable code behavior** (node4)
  - 경로: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/12_Sources_of_complexity`

- **1.2.3 Not trivial data serialization** (node4)
  - 경로: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/12_Sources_of_complexity`

- **1.2.4 Complex class hierarchies** (node4)
  - 경로: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/12_Sources_of_complexity`

- **6.2.0 Introduction (사용자 추가)** (node4)
  - 경로: `Part_1_Flexibility/6_Unit_tests/62_Unit_tests_for_data_manipulation_code`

- **6.2.1 The tree of function calls** (node4)
  - 경로: `Part_1_Flexibility/6_Unit_tests/62_Unit_tests_for_data_manipulation_code`

- **6.2.2 Unit tests for functions down the tree** (node4)
  - 경로: `Part_1_Flexibility/6_Unit_tests/62_Unit_tests_for_data_manipulation_code`

- **6.2.3 Unit tests for nodes in the tree** (node4)
  - 경로: `Part_1_Flexibility/6_Unit_tests/62_Unit_tests_for_data_manipulation_code`

- **9.3.0 Introduction (사용자 추가)** (node4)
  - 경로: `Part_2_Scalability/9_Persistent_data_structures/93_Persistent_data_structures_libraries`

- **9.3.1 Persistent data structures in Java** (node4)
  - 경로: `Part_2_Scalability/9_Persistent_data_structures/93_Persistent_data_structures_libraries`

- **9.3.2 Persistent data structures in JavaScript** (node4)
  - 경로: `Part_2_Scalability/9_Persistent_data_structures/93_Persistent_data_structures_libraries`

- **9.4.0 Introduction (사용자 추가)** (node4)
  - 경로: `Part_2_Scalability/9_Persistent_data_structures/94_Persistent_data_structures_in_action`

- **9.4.1 Writing queries with persistent data structures** (node4)
  - 경로: `Part_2_Scalability/9_Persistent_data_structures/94_Persistent_data_structures_in_action`

- **9.4.2 Writing mutations with persistent data structures** (node4)
  - 경로: `Part_2_Scalability/9_Persistent_data_structures/94_Persistent_data_structures_in_action`

- **9.4.3 Serialization and deserialization** (node4)
  - 경로: `Part_2_Scalability/9_Persistent_data_structures/94_Persistent_data_structures_in_action`

- **9.4.4 Structural diff** (node4)
  - 경로: `Part_2_Scalability/9_Persistent_data_structures/94_Persistent_data_structures_in_action`

- **A.1.0 Introduction (사용자 추가)** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A1_Principle_1_Separate_code_from_data`

- **A.1.1 Illustration of Principle #1** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A1_Principle_1_Separate_code_from_data`

- **A.1.2 Benefits of Principle #1** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A1_Principle_1_Separate_code_from_data`

- **A.1.3 Cost for Principle #1** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A1_Principle_1_Separate_code_from_data`

- **A.1.4 Summary of Principle #1** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A1_Principle_1_Separate_code_from_data`

- **A.2.0 Introduction (사용자 추가)** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A2_Principle_2_Represent_data_with_generic_data_structures`

- **A.2.1 Illustration of Principle #2** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A2_Principle_2_Represent_data_with_generic_data_structures`

- **A.2.2 Benefits of Principle #2** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A2_Principle_2_Represent_data_with_generic_data_structures`

- **A.2.3 Cost for Principle #2** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A2_Principle_2_Represent_data_with_generic_data_structures`

- **A.2.4 Summary of Principle #2** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A2_Principle_2_Represent_data_with_generic_data_structures`

- **A.3.0 Introduction (사용자 추가)** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A3_Principle_3_Data_is_immutable`

- **A.3.1 Illustration of Principle #3** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A3_Principle_3_Data_is_immutable`

- **A.3.2 Benefits of Principle #3** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A3_Principle_3_Data_is_immutable`

- **A.3.3 Cost for Principle #3** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A3_Principle_3_Data_is_immutable`

- **A.3.4 Summary of Principle #3** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A3_Principle_3_Data_is_immutable`

- **A.4.0 Introduction (사용자 추가)** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A4_Principle_4_Separate_data_schema_from_data_representation`

- **A.4.1 Illustration of Principle #4** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A4_Principle_4_Separate_data_schema_from_data_representation`

- **A.4.2 Benefits of Principle #4** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A4_Principle_4_Separate_data_schema_from_data_representation`

- **A.4.3 Cost for Principle #4** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A4_Principle_4_Separate_data_schema_from_data_representation`

- **A.4.4 Summary of Principle #4** (node4)
  - 경로: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A4_Principle_4_Separate_data_schema_from_data_representation`

- **B.1.0 Introduction (사용자 추가)** (node4)
  - 경로: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B1_Dynamic_getters_for_string_maps`

- **B.1.1 Accessing non-nested map fields with dynamic getters** (node4)
  - 경로: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B1_Dynamic_getters_for_string_maps`

- **B.1.2 Accessing nested map fields with dynamic getters** (node4)
  - 경로: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B1_Dynamic_getters_for_string_maps`

- **B.2.0 Introduction (사용자 추가)** (node4)
  - 경로: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B2_Value_getters_for_maps`

- **B.2.1 Accessing non-nested map fields with value getters** (node4)
  - 경로: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B2_Value_getters_for_maps`

- **B.2.2 Accessing nested map fields with value getters** (node4)
  - 경로: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B2_Value_getters_for_maps`

- **B.3.0 Introduction (사용자 추가)** (node4)
  - 경로: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B3_Typed_getters_for_maps`

- **B.3.1 Accessing non-nested map fields with typed getters** (node4)
  - 경로: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B3_Typed_getters_for_maps`

- **B.3.2 Accessing nested map fields with typed getters** (node4)
  - 경로: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B3_Typed_getters_for_maps`

- **B.4.0 Introduction (사용자 추가)** (node4)
  - 경로: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B4_Generic_access_to_class_members`

- **B.4.1 Generic access to non-nested class members** (node4)
  - 경로: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B4_Generic_access_to_class_members`

- **B.4.2 Generic access to nested class members** (node4)
  - 경로: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B4_Generic_access_to_class_members`

- **B.4.3 Automatic JSON serialization of objects** (node4)
  - 경로: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B4_Generic_access_to_class_members`

- **C.1.1 1958: Lisp** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.1.0 Introduction (사용자 추가)** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.1.2 1981: Values and objects** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.1.3 2000: Ideal hash trees** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.1.4 2006: Out of the Tar Pit** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.1.5 2007: Clojure** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.1.6 2009: Immutability for all** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.2.0 Introduction (사용자 추가)** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C2_DOP_principles_as_best_practices`

- **C.2.1 Principle #1: Separate code from data** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C2_DOP_principles_as_best_practices`

- **C.2.2 Principle #2: Represent data with generic data structures** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C2_DOP_principles_as_best_practices`

- **C.2.3 Principle #3: Data is immutable** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C2_DOP_principles_as_best_practices`

- **C.2.4 Principle #4: Separate data schema from data representation** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C2_DOP_principles_as_best_practices`

- **C.3.0 Introduction (사용자 추가)** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C3_DOP_and_other_data_related_paradigms`

- **C.3.1 Data-oriented design** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C3_DOP_and_other_data_related_paradigms`

- **C.3.2 Data-driven programming** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C3_DOP_and_other_data_related_paradigms`

- **C.3.3 Data-oriented programming (DOP)** (node4)
  - 경로: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C3_DOP_and_other_data_related_paradigms`

