# í´ë” êµ¬ì¡° ìš”ì•½

**Root í´ë”:** Data-Oriented Programming
**ì „ì²´ ë…¸ë“œ ìˆ˜:** 239
**Internal ë…¸ë“œ (í´ë”):** 168
**Leaf ë…¸ë“œ (íŒŒì¼ ëŒ€ìƒ):** 71

## í´ë” êµ¬ì¡°

```
Data_Oriented_Programming/
â”œâ”€â”€ Part_1_Flexibility/
â”‚   â”œâ”€â”€ 10_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”œâ”€â”€ 1_Complexity_of_object_oriented_programming/
â”‚   â”‚   â”œâ”€â”€ 10_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 11_OOP_design_Classic_or_classical/
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.1.1 The design phase (node4)
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.1.2 UML 101 (node4)
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.1.3 Explaining each piece of the class diagram (node4)
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ 1.1.4 The implementation phase (node4)
â”‚   â”‚   â”œâ”€â”€ 12_Sources_of_complexity/
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.2.1 Many relations between classes (node4)
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.2.2 Unpredictable code behavior (node4)
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.2.3 Not trivial data serialization (node4)
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ 1.2.4 Complex class hierarchies (node4)
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 2_Separation_between_code_and_data/
â”‚   â”‚   â”œâ”€â”€ 21_The_two_parts_of_a_DOP_system/
â”‚   â”‚   â”œâ”€â”€ 22_Data_entities/
â”‚   â”‚   â”œâ”€â”€ 23_Code_modules/
â”‚   â”‚   â”œâ”€â”€ 24_DOP_systems_are_easy_to_understand/
â”‚   â”‚   â”œâ”€â”€ 20_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 25_DOP_systems_are_flexible/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 3_Basic_data_manipulation/
â”‚   â”‚   â”œâ”€â”€ 30_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 31_Designing_a_data_model/
â”‚   â”‚   â”œâ”€â”€ 32_Representing_records_as_maps/
â”‚   â”‚   â”œâ”€â”€ 33_Manipulating_data_with_generic_functions/
â”‚   â”‚   â”œâ”€â”€ 34_Calculating_search_results/
â”‚   â”‚   â”œâ”€â”€ 35_Handling_records_of_different_types/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 4_State_management/
â”‚   â”‚   â”œâ”€â”€ 40_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 41_Multiple_versions_of_the_system_data/
â”‚   â”‚   â”œâ”€â”€ 42_Structural_sharing/
â”‚   â”‚   â”œâ”€â”€ 43_Implementing_structural_sharing/
â”‚   â”‚   â”œâ”€â”€ 44_Data_safety/
â”‚   â”‚   â”œâ”€â”€ 45_The_commit_phase_of_a_mutation/
â”‚   â”‚   â”œâ”€â”€ 46_Ensuring_system_state_integrity/
â”‚   â”‚   â”œâ”€â”€ 47_Restoring_previous_states/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 5_Basic_concurrency_control/
â”‚   â”‚   â”œâ”€â”€ 50_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 51_Optimistic_concurrency_control/
â”‚   â”‚   â”œâ”€â”€ 52_Reconciliation_between_concurrent_mutations/
â”‚   â”‚   â”œâ”€â”€ 53_Reducing_collections/
â”‚   â”‚   â”œâ”€â”€ 54_Structural_difference/
â”‚   â”‚   â”œâ”€â”€ 55_Implementing_the_reconciliation_algorithm/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â””â”€â”€ 6_Unit_tests/
â”‚       â”œâ”€â”€ 61_The_simplicity_of_data_oriented_test_cases/
â”‚       â”œâ”€â”€ 60_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚       â”œâ”€â”€ 62_Unit_tests_for_data_manipulation_code/
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ 6.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ 6.2.1 The tree of function calls (node4)
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ 6.2.2 Unit tests for functions down the tree (node4)
â”‚       â”‚   â””â”€â”€ ğŸ“„ 6.2.3 Unit tests for nodes in the tree (node4)
â”‚       â”œâ”€â”€ 63_Unit_tests_for_queries/
â”‚       â”œâ”€â”€ 64_Unit_tests_for_mutations/
â”‚       â”œâ”€â”€ Moving_forward/
â”‚       â””â”€â”€ Summary/
â”œâ”€â”€ Part_2_Scalability/
â”‚   â”œâ”€â”€ 20_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”œâ”€â”€ 7_Basic_data_validation/
â”‚   â”‚   â”œâ”€â”€ 71_Data_validation_in_DOP/
â”‚   â”‚   â”œâ”€â”€ 70_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 72_JSON_Schema_in_a_nutshell/
â”‚   â”‚   â”œâ”€â”€ 73_Schema_flexibility_and_strictness/
â”‚   â”‚   â”œâ”€â”€ 74_Schema_composition/
â”‚   â”‚   â”œâ”€â”€ 75_Details_about_data_validation_failures/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 8_Advanced_concurrency_control/
â”‚   â”‚   â”œâ”€â”€ 81_The_complexity_of_locks/
â”‚   â”‚   â”œâ”€â”€ 80_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 82_Thread_safe_counter_with_atoms/
â”‚   â”‚   â”œâ”€â”€ 83_Thread_safe_cache_with_atoms/
â”‚   â”‚   â”œâ”€â”€ 84_State_management_with_atoms/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 9_Persistent_data_structures/
â”‚   â”‚   â”œâ”€â”€ 91_The_need_for_persistent_data_structures/
â”‚   â”‚   â”œâ”€â”€ 90_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 92_The_efficiency_of_persistent_data_structures/
â”‚   â”‚   â”œâ”€â”€ 93_Persistent_data_structures_libraries/
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 9.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 9.3.1 Persistent data structures in Java (node4)
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ 9.3.2 Persistent data structures in JavaScript (node4)
â”‚   â”‚   â”œâ”€â”€ 94_Persistent_data_structures_in_action/
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 9.4.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 9.4.1 Writing queries with persistent data structures (node4)
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 9.4.2 Writing mutations with persistent data structures (node4)
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 9.4.3 Serialization and deserialization (node4)
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ 9.4.4 Structural diff (node4)
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 10_Database_operations/
â”‚   â”‚   â”œâ”€â”€ 101_Fetching_data_from_the_database/
â”‚   â”‚   â”œâ”€â”€ 100_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 102_Storing_data_in_the_database/
â”‚   â”‚   â”œâ”€â”€ 103_Simple_data_manipulation/
â”‚   â”‚   â”œâ”€â”€ 104_Advanced_data_manipulation/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â””â”€â”€ 11_Web_services/
â”‚       â”œâ”€â”€ 111_Another_feature_request/
â”‚       â”œâ”€â”€ 112_Building_the_insides_like_the_outsides/
â”‚       â”œâ”€â”€ 110_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚       â”œâ”€â”€ 113_Representing_a_client_request_as_a_map/
â”‚       â”œâ”€â”€ 114_Representing_a_server_response_as_a_map/
â”‚       â”œâ”€â”€ 115_Passing_information_forward/
â”‚       â”œâ”€â”€ 116_Search_result_enrichment_in_action/
â”‚       â”œâ”€â”€ Delivering_on_time/
â”‚       â””â”€â”€ Summary/
â”œâ”€â”€ Part_3_Maintainability/
â”‚   â”œâ”€â”€ 30_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”œâ”€â”€ 12_Advanced_data_validation/
â”‚   â”‚   â”œâ”€â”€ 121_Function_arguments_validation/
â”‚   â”‚   â”œâ”€â”€ 120_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 122_Return_value_validation/
â”‚   â”‚   â”œâ”€â”€ 123_Advanced_data_validation/
â”‚   â”‚   â”œâ”€â”€ 124_Automatic_generation_of_data_model_diagrams/
â”‚   â”‚   â”œâ”€â”€ 125_Automatic_generation_of_schema_based_unit_tests/
â”‚   â”‚   â”œâ”€â”€ 126_A_new_gift/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 13_Polymorphism/
â”‚   â”‚   â”œâ”€â”€ 131_The_essence_of_polymorphism/
â”‚   â”‚   â”œâ”€â”€ 130_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 132_Multimethods_with_single_dispatch/
â”‚   â”‚   â”œâ”€â”€ 133_Multimethods_with_multiple_dispatch/
â”‚   â”‚   â”œâ”€â”€ 134_Multimethods_with_dynamic_dispatch/
â”‚   â”‚   â”œâ”€â”€ 135_Integrating_multimethods_in_a_production_system/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 14_Advanced_data_manipulation/
â”‚   â”‚   â”œâ”€â”€ 141_Updating_a_value_in_a_map_with_eloquence/
â”‚   â”‚   â”œâ”€â”€ 140_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 142_Manipulating_nested_data/
â”‚   â”‚   â”œâ”€â”€ 143_Using_the_best_tool_for_the_job/
â”‚   â”‚   â”œâ”€â”€ 144_Unwinding_at_ease/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â””â”€â”€ 15_Debugging/
â”‚       â”œâ”€â”€ 151_Determinism_in_programming/
â”‚       â”œâ”€â”€ 150_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚       â”œâ”€â”€ 152_Reproducibility_with_numbers_and_strings/
â”‚       â”œâ”€â”€ 153_Reproducibility_with_any_data/
â”‚       â”œâ”€â”€ 154_Unit_tests/
â”‚       â”œâ”€â”€ 155_Dealing_with_external_data_sources/
â”‚       â”œâ”€â”€ Farewell/
â”‚       â””â”€â”€ Summary/
â””â”€â”€ Appendices/
    â”œâ”€â”€ Appendix_A_Principles_of_data_oriented_programming/
    â”‚   â”œâ”€â”€ A1_Principle_1_Separate_code_from_data/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.1.1 Illustration of Principle #1 (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.1.2 Benefits of Principle #1 (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.1.3 Cost for Principle #1 (node4)
    â”‚   â”‚   â””â”€â”€ ğŸ“„ A.1.4 Summary of Principle #1 (node4)
    â”‚   â”œâ”€â”€ A2_Principle_2_Represent_data_with_generic_data_structures/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.2.1 Illustration of Principle #2 (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.2.2 Benefits of Principle #2 (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.2.3 Cost for Principle #2 (node4)
    â”‚   â”‚   â””â”€â”€ ğŸ“„ A.2.4 Summary of Principle #2 (node4)
    â”‚   â”œâ”€â”€ A3_Principle_3_Data_is_immutable/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.3.1 Illustration of Principle #3 (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.3.2 Benefits of Principle #3 (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.3.3 Cost for Principle #3 (node4)
    â”‚   â”‚   â””â”€â”€ ğŸ“„ A.3.4 Summary of Principle #3 (node4)
    â”‚   â”œâ”€â”€ A4_Principle_4_Separate_data_schema_from_data_representation/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.4.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.4.1 Illustration of Principle #4 (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.4.2 Benefits of Principle #4 (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.4.3 Cost for Principle #4 (node4)
    â”‚   â”‚   â””â”€â”€ ğŸ“„ A.4.4 Summary of Principle #4 (node4)
    â”‚   â””â”€â”€ Conclusion/
    â”œâ”€â”€ Appendix_B_Generic_data_access_in_statically_typed_languages/
    â”‚   â”œâ”€â”€ B1_Dynamic_getters_for_string_maps/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.1.1 Accessing non-nested map fields with dynamic getters (node4)
    â”‚   â”‚   â””â”€â”€ ğŸ“„ B.1.2 Accessing nested map fields with dynamic getters (node4)
    â”‚   â”œâ”€â”€ B2_Value_getters_for_maps/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.2.1 Accessing non-nested map fields with value getters (node4)
    â”‚   â”‚   â””â”€â”€ ğŸ“„ B.2.2 Accessing nested map fields with value getters (node4)
    â”‚   â”œâ”€â”€ B3_Typed_getters_for_maps/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.3.1 Accessing non-nested map fields with typed getters (node4)
    â”‚   â”‚   â””â”€â”€ ğŸ“„ B.3.2 Accessing nested map fields with typed getters (node4)
    â”‚   â”œâ”€â”€ B4_Generic_access_to_class_members/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.4.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.4.1 Generic access to non-nested class members (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.4.2 Generic access to nested class members (node4)
    â”‚   â”‚   â””â”€â”€ ğŸ“„ B.4.3 Automatic JSON serialization of objects (node4)
    â”‚   â””â”€â”€ Summary/
    â”œâ”€â”€ Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/
    â”‚   â”œâ”€â”€ C1_Time_line/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.1.1 1958: Lisp (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.1.2 1981: Values and objects (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.1.3 2000: Ideal hash trees (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.1.4 2006: Out of the Tar Pit (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.1.5 2007: Clojure (node4)
    â”‚   â”‚   â””â”€â”€ ğŸ“„ C.1.6 2009: Immutability for all (node4)
    â”‚   â”œâ”€â”€ C2_DOP_principles_as_best_practices/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.2.1 Principle #1: Separate code from data (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.2.2 Principle #2: Represent data with generic data structures (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.2.3 Principle #3: Data is immutable (node4)
    â”‚   â”‚   â””â”€â”€ ğŸ“„ C.2.4 Principle #4: Separate data schema from data representation (node4)
    â”‚   â”œâ”€â”€ C3_DOP_and_other_data_related_paradigms/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.3.1 Data-oriented design (node4)
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.3.2 Data-driven programming (node4)
    â”‚   â”‚   â””â”€â”€ ğŸ“„ C.3.3 Data-oriented programming (DOP) (node4)
    â”‚   â””â”€â”€ Summary/
    â”œâ”€â”€ Appendix_D_Lodash_reference/
    â”œâ”€â”€ A/
    â”œâ”€â”€ B/
    â”œâ”€â”€ C/
    â”œâ”€â”€ D/
    â”œâ”€â”€ E/
    â”œâ”€â”€ F/
    â”œâ”€â”€ G/
    â”œâ”€â”€ H/
    â”œâ”€â”€ I/
    â”œâ”€â”€ J/
    â”œâ”€â”€ K/
    â”œâ”€â”€ L/
    â”œâ”€â”€ M/
    â”œâ”€â”€ N/
    â”œâ”€â”€ O/
    â”œâ”€â”€ P/
    â”œâ”€â”€ Q/
    â”œâ”€â”€ R/
    â”œâ”€â”€ S/
    â”œâ”€â”€ T/
    â”œâ”€â”€ U/
    â”œâ”€â”€ V/
    â””â”€â”€ W/
```

## Leaf ë…¸ë“œ ëª©ë¡ (ì½˜í…ì¸  ì¶”ì¶œ ëŒ€ìƒ)

- **1.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/11_OOP_design_Classic_or_classical`

- **1.1.1 The design phase** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/11_OOP_design_Classic_or_classical`

- **1.1.2 UML 101** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/11_OOP_design_Classic_or_classical`

- **1.1.3 Explaining each piece of the class diagram** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/11_OOP_design_Classic_or_classical`

- **1.1.4 The implementation phase** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/11_OOP_design_Classic_or_classical`

- **1.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/12_Sources_of_complexity`

- **1.2.1 Many relations between classes** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/12_Sources_of_complexity`

- **1.2.2 Unpredictable code behavior** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/12_Sources_of_complexity`

- **1.2.3 Not trivial data serialization** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/12_Sources_of_complexity`

- **1.2.4 Complex class hierarchies** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object_oriented_programming/12_Sources_of_complexity`

- **6.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/6_Unit_tests/62_Unit_tests_for_data_manipulation_code`

- **6.2.1 The tree of function calls** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/6_Unit_tests/62_Unit_tests_for_data_manipulation_code`

- **6.2.2 Unit tests for functions down the tree** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/6_Unit_tests/62_Unit_tests_for_data_manipulation_code`

- **6.2.3 Unit tests for nodes in the tree** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/6_Unit_tests/62_Unit_tests_for_data_manipulation_code`

- **9.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/93_Persistent_data_structures_libraries`

- **9.3.1 Persistent data structures in Java** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/93_Persistent_data_structures_libraries`

- **9.3.2 Persistent data structures in JavaScript** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/93_Persistent_data_structures_libraries`

- **9.4.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/94_Persistent_data_structures_in_action`

- **9.4.1 Writing queries with persistent data structures** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/94_Persistent_data_structures_in_action`

- **9.4.2 Writing mutations with persistent data structures** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/94_Persistent_data_structures_in_action`

- **9.4.3 Serialization and deserialization** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/94_Persistent_data_structures_in_action`

- **9.4.4 Structural diff** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/94_Persistent_data_structures_in_action`

- **A.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A1_Principle_1_Separate_code_from_data`

- **A.1.1 Illustration of Principle #1** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A1_Principle_1_Separate_code_from_data`

- **A.1.2 Benefits of Principle #1** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A1_Principle_1_Separate_code_from_data`

- **A.1.3 Cost for Principle #1** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A1_Principle_1_Separate_code_from_data`

- **A.1.4 Summary of Principle #1** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A1_Principle_1_Separate_code_from_data`

- **A.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A2_Principle_2_Represent_data_with_generic_data_structures`

- **A.2.1 Illustration of Principle #2** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A2_Principle_2_Represent_data_with_generic_data_structures`

- **A.2.2 Benefits of Principle #2** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A2_Principle_2_Represent_data_with_generic_data_structures`

- **A.2.3 Cost for Principle #2** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A2_Principle_2_Represent_data_with_generic_data_structures`

- **A.2.4 Summary of Principle #2** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A2_Principle_2_Represent_data_with_generic_data_structures`

- **A.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A3_Principle_3_Data_is_immutable`

- **A.3.1 Illustration of Principle #3** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A3_Principle_3_Data_is_immutable`

- **A.3.2 Benefits of Principle #3** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A3_Principle_3_Data_is_immutable`

- **A.3.3 Cost for Principle #3** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A3_Principle_3_Data_is_immutable`

- **A.3.4 Summary of Principle #3** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A3_Principle_3_Data_is_immutable`

- **A.4.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A4_Principle_4_Separate_data_schema_from_data_representation`

- **A.4.1 Illustration of Principle #4** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A4_Principle_4_Separate_data_schema_from_data_representation`

- **A.4.2 Benefits of Principle #4** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A4_Principle_4_Separate_data_schema_from_data_representation`

- **A.4.3 Cost for Principle #4** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A4_Principle_4_Separate_data_schema_from_data_representation`

- **A.4.4 Summary of Principle #4** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data_oriented_programming/A4_Principle_4_Separate_data_schema_from_data_representation`

- **B.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B1_Dynamic_getters_for_string_maps`

- **B.1.1 Accessing non-nested map fields with dynamic getters** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B1_Dynamic_getters_for_string_maps`

- **B.1.2 Accessing nested map fields with dynamic getters** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B1_Dynamic_getters_for_string_maps`

- **B.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B2_Value_getters_for_maps`

- **B.2.1 Accessing non-nested map fields with value getters** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B2_Value_getters_for_maps`

- **B.2.2 Accessing nested map fields with value getters** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B2_Value_getters_for_maps`

- **B.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B3_Typed_getters_for_maps`

- **B.3.1 Accessing non-nested map fields with typed getters** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B3_Typed_getters_for_maps`

- **B.3.2 Accessing nested map fields with typed getters** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B3_Typed_getters_for_maps`

- **B.4.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B4_Generic_access_to_class_members`

- **B.4.1 Generic access to non-nested class members** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B4_Generic_access_to_class_members`

- **B.4.2 Generic access to nested class members** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B4_Generic_access_to_class_members`

- **B.4.3 Automatic JSON serialization of objects** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically_typed_languages/B4_Generic_access_to_class_members`

- **C.1.1 1958: Lisp** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.1.2 1981: Values and objects** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.1.3 2000: Ideal hash trees** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.1.4 2006: Out of the Tar Pit** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.1.5 2007: Clojure** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.1.6 2009: Immutability for all** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C1_Time_line`

- **C.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C2_DOP_principles_as_best_practices`

- **C.2.1 Principle #1: Separate code from data** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C2_DOP_principles_as_best_practices`

- **C.2.2 Principle #2: Represent data with generic data structures** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C2_DOP_principles_as_best_practices`

- **C.2.3 Principle #3: Data is immutable** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C2_DOP_principles_as_best_practices`

- **C.2.4 Principle #4: Separate data schema from data representation** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C2_DOP_principles_as_best_practices`

- **C.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C3_DOP_and_other_data_related_paradigms`

- **C.3.1 Data-oriented design** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C3_DOP_and_other_data_related_paradigms`

- **C.3.2 Data-driven programming** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C3_DOP_and_other_data_related_paradigms`

- **C.3.3 Data-oriented programming (DOP)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data_oriented_programming_A_link_in_the_chain_of_programming_paradigm/C3_DOP_and_other_data_related_paradigms`

