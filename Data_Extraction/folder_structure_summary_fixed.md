# í´ë” êµ¬ì¡° ìš”ì•½ (ìˆ˜ì •íŒ)

**Root í´ë”:** Data-Oriented Programming
**ì „ì²´ ë…¸ë“œ ìˆ˜:** 216
**Internal ë…¸ë“œ (í´ë”):** 145
**Leaf ë…¸ë“œ (íŒŒì¼ ëŒ€ìƒ):** 71

## ìˆ˜ì •ì‚¬í•­
- í´ë”ëª…: 1.1 -> 1-1, A.1 -> A-1
- Appendicesì˜ ë‹¨ì¼ ë¬¸ì í´ë”(A, B, C ë“±) ì œê±°
- metadata.json íŒŒì¼ ìƒì„± ì•ˆí•¨

## í´ë” êµ¬ì¡°

```
Data-Oriented_Programming/
â”œâ”€â”€ Part_1_Flexibility/
â”‚   â”œâ”€â”€ 1-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”œâ”€â”€ 1_Complexity_of_object-oriented_programming/
â”‚   â”‚   â”œâ”€â”€ 1-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 1-1_OOP_design_Classic_or_classical/
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.1.1 The design phase (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.1.2 UML 101 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.1.3 Explaining each piece of the class diagram (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ 1.1.4 The implementation phase (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”œâ”€â”€ 1-2_Sources_of_complexity/
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.2.1 Many relations between classes (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.2.2 Unpredictable code behavior (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 1.2.3 Not trivial data serialization (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ 1.2.4 Complex class hierarchies (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 2_Separation_between_code_and_data/
â”‚   â”‚   â”œâ”€â”€ 2-1_The_two_parts_of_a_DOP_system/
â”‚   â”‚   â”œâ”€â”€ 2-2_Data_entities/
â”‚   â”‚   â”œâ”€â”€ 2-3_Code_modules/
â”‚   â”‚   â”œâ”€â”€ 2-4_DOP_systems_are_easy_to_understand/
â”‚   â”‚   â”œâ”€â”€ 2-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 2-5_DOP_systems_are_flexible/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 3_Basic_data_manipulation/
â”‚   â”‚   â”œâ”€â”€ 3-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 3-1_Designing_a_data_model/
â”‚   â”‚   â”œâ”€â”€ 3-2_Representing_records_as_maps/
â”‚   â”‚   â”œâ”€â”€ 3-3_Manipulating_data_with_generic_functions/
â”‚   â”‚   â”œâ”€â”€ 3-4_Calculating_search_results/
â”‚   â”‚   â”œâ”€â”€ 3-5_Handling_records_of_different_types/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 4_State_management/
â”‚   â”‚   â”œâ”€â”€ 4-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 4-1_Multiple_versions_of_the_system_data/
â”‚   â”‚   â”œâ”€â”€ 4-2_Structural_sharing/
â”‚   â”‚   â”œâ”€â”€ 4-3_Implementing_structural_sharing/
â”‚   â”‚   â”œâ”€â”€ 4-4_Data_safety/
â”‚   â”‚   â”œâ”€â”€ 4-5_The_commit_phase_of_a_mutation/
â”‚   â”‚   â”œâ”€â”€ 4-6_Ensuring_system_state_integrity/
â”‚   â”‚   â”œâ”€â”€ 4-7_Restoring_previous_states/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 5_Basic_concurrency_control/
â”‚   â”‚   â”œâ”€â”€ 5-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 5-1_Optimistic_concurrency_control/
â”‚   â”‚   â”œâ”€â”€ 5-2_Reconciliation_between_concurrent_mutations/
â”‚   â”‚   â”œâ”€â”€ 5-3_Reducing_collections/
â”‚   â”‚   â”œâ”€â”€ 5-4_Structural_difference/
â”‚   â”‚   â”œâ”€â”€ 5-5_Implementing_the_reconciliation_algorithm/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â””â”€â”€ 6_Unit_tests/
â”‚       â”œâ”€â”€ 6-1_The_simplicity_of_data-oriented_test_cases/
â”‚       â”œâ”€â”€ 6-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚       â”œâ”€â”€ 6-2_Unit_tests_for_data_manipulation_code/
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ 6.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ 6.2.1 The tree of function calls (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚       â”‚   â”œâ”€â”€ ğŸ“„ 6.2.2 Unit tests for functions down the tree (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚       â”‚   â””â”€â”€ ğŸ“„ 6.2.3 Unit tests for nodes in the tree (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚       â”œâ”€â”€ 6-3_Unit_tests_for_queries/
â”‚       â”œâ”€â”€ 6-4_Unit_tests_for_mutations/
â”‚       â”œâ”€â”€ Moving_forward/
â”‚       â””â”€â”€ Summary/
â”œâ”€â”€ Part_2_Scalability/
â”‚   â”œâ”€â”€ 2-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”œâ”€â”€ 7_Basic_data_validation/
â”‚   â”‚   â”œâ”€â”€ 7-1_Data_validation_in_DOP/
â”‚   â”‚   â”œâ”€â”€ 7-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 7-2_JSON_Schema_in_a_nutshell/
â”‚   â”‚   â”œâ”€â”€ 7-3_Schema_flexibility_and_strictness/
â”‚   â”‚   â”œâ”€â”€ 7-4_Schema_composition/
â”‚   â”‚   â”œâ”€â”€ 7-5_Details_about_data_validation_failures/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 8_Advanced_concurrency_control/
â”‚   â”‚   â”œâ”€â”€ 8-1_The_complexity_of_locks/
â”‚   â”‚   â”œâ”€â”€ 8-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 8-2_Thread-safe_counter_with_atoms/
â”‚   â”‚   â”œâ”€â”€ 8-3_Thread-safe_cache_with_atoms/
â”‚   â”‚   â”œâ”€â”€ 8-4_State_management_with_atoms/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 9_Persistent_data_structures/
â”‚   â”‚   â”œâ”€â”€ 9-1_The_need_for_persistent_data_structures/
â”‚   â”‚   â”œâ”€â”€ 9-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 9-2_The_efficiency_of_persistent_data_structures/
â”‚   â”‚   â”œâ”€â”€ 9-3_Persistent_data_structures_libraries/
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 9.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 9.3.1 Persistent data structures in Java (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ 9.3.2 Persistent data structures in JavaScript (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”œâ”€â”€ 9-4_Persistent_data_structures_in_action/
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 9.4.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 9.4.1 Writing queries with persistent data structures (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 9.4.2 Writing mutations with persistent data structures (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ 9.4.3 Serialization and deserialization (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ 9.4.4 Structural diff (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 10_Database_operations/
â”‚   â”‚   â”œâ”€â”€ 10-1_Fetching_data_from_the_database/
â”‚   â”‚   â”œâ”€â”€ 10-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 10-2_Storing_data_in_the_database/
â”‚   â”‚   â”œâ”€â”€ 10-3_Simple_data_manipulation/
â”‚   â”‚   â”œâ”€â”€ 10-4_Advanced_data_manipulation/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â””â”€â”€ 11_Web_services/
â”‚       â”œâ”€â”€ 11-1_Another_feature_request/
â”‚       â”œâ”€â”€ 11-2_Building_the_insides_like_the_outsides/
â”‚       â”œâ”€â”€ 11-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚       â”œâ”€â”€ 11-3_Representing_a_client_request_as_a_map/
â”‚       â”œâ”€â”€ 11-4_Representing_a_server_response_as_a_map/
â”‚       â”œâ”€â”€ 11-5_Passing_information_forward/
â”‚       â”œâ”€â”€ 11-6_Search_result_enrichment_in_action/
â”‚       â”œâ”€â”€ Delivering_on_time/
â”‚       â””â”€â”€ Summary/
â”œâ”€â”€ Part_3_Maintainability/
â”‚   â”œâ”€â”€ 3-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”œâ”€â”€ 12_Advanced_data_validation/
â”‚   â”‚   â”œâ”€â”€ 12-1_Function_arguments_validation/
â”‚   â”‚   â”œâ”€â”€ 12-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 12-2_Return_value_validation/
â”‚   â”‚   â”œâ”€â”€ 12-3_Advanced_data_validation/
â”‚   â”‚   â”œâ”€â”€ 12-4_Automatic_generation_of_data_model_diagrams/
â”‚   â”‚   â”œâ”€â”€ 12-5_Automatic_generation_of_schema-based_unit_tests/
â”‚   â”‚   â”œâ”€â”€ 12-6_A_new_gift/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 13_Polymorphism/
â”‚   â”‚   â”œâ”€â”€ 13-1_The_essence_of_polymorphism/
â”‚   â”‚   â”œâ”€â”€ 13-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 13-2_Multimethods_with_single_dispatch/
â”‚   â”‚   â”œâ”€â”€ 13-3_Multimethods_with_multiple_dispatch/
â”‚   â”‚   â”œâ”€â”€ 13-4_Multimethods_with_dynamic_dispatch/
â”‚   â”‚   â”œâ”€â”€ 13-5_Integrating_multimethods_in_a_production_system/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â”œâ”€â”€ 14_Advanced_data_manipulation/
â”‚   â”‚   â”œâ”€â”€ 14-1_Updating_a_value_in_a_map_with_eloquence/
â”‚   â”‚   â”œâ”€â”€ 14-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚   â”‚   â”œâ”€â”€ 14-2_Manipulating_nested_data/
â”‚   â”‚   â”œâ”€â”€ 14-3_Using_the_best_tool_for_the_job/
â”‚   â”‚   â”œâ”€â”€ 14-4_Unwinding_at_ease/
â”‚   â”‚   â””â”€â”€ Summary/
â”‚   â””â”€â”€ 15_Debugging/
â”‚       â”œâ”€â”€ 15-1_Determinism_in_programming/
â”‚       â”œâ”€â”€ 15-0_Introduction_ì‚¬ìš©ì_ì¶”ê°€/
â”‚       â”œâ”€â”€ 15-2_Reproducibility_with_numbers_and_strings/
â”‚       â”œâ”€â”€ 15-3_Reproducibility_with_any_data/
â”‚       â”œâ”€â”€ 15-4_Unit_tests/
â”‚       â”œâ”€â”€ 15-5_Dealing_with_external_data_sources/
â”‚       â”œâ”€â”€ Farewell/
â”‚       â””â”€â”€ Summary/
â””â”€â”€ Appendices/
    â”œâ”€â”€ Appendix_A_Principles_of_data-oriented_programming/
    â”‚   â”œâ”€â”€ A-1_Principle_1_Separate_code_from_data/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.1.1 Illustration of Principle #1 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.1.2 Benefits of Principle #1 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.1.3 Cost for Principle #1 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â””â”€â”€ ğŸ“„ A.1.4 Summary of Principle #1 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”œâ”€â”€ A-2_Principle_2_Represent_data_with_generic_data_structures/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.2.1 Illustration of Principle #2 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.2.2 Benefits of Principle #2 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.2.3 Cost for Principle #2 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â””â”€â”€ ğŸ“„ A.2.4 Summary of Principle #2 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”œâ”€â”€ A-3_Principle_3_Data_is_immutable/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.3.1 Illustration of Principle #3 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.3.2 Benefits of Principle #3 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.3.3 Cost for Principle #3 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â””â”€â”€ ğŸ“„ A.3.4 Summary of Principle #3 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”œâ”€â”€ A-4_Principle_4_Separate_data_schema_from_data_representation/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.4.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.4.1 Illustration of Principle #4 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.4.2 Benefits of Principle #4 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ A.4.3 Cost for Principle #4 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â””â”€â”€ ğŸ“„ A.4.4 Summary of Principle #4 (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â””â”€â”€ Conclusion/
    â”œâ”€â”€ Appendix_B_Generic_data_access_in_statically-typed_languages/
    â”‚   â”œâ”€â”€ B-1_Dynamic_getters_for_string_maps/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.1.1 Accessing non-nested map fields with dynamic getters (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â””â”€â”€ ğŸ“„ B.1.2 Accessing nested map fields with dynamic getters (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”œâ”€â”€ B-2_Value_getters_for_maps/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.2.1 Accessing non-nested map fields with value getters (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â””â”€â”€ ğŸ“„ B.2.2 Accessing nested map fields with value getters (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”œâ”€â”€ B-3_Typed_getters_for_maps/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.3.1 Accessing non-nested map fields with typed getters (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â””â”€â”€ ğŸ“„ B.3.2 Accessing nested map fields with typed getters (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”œâ”€â”€ B-4_Generic_access_to_class_members/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.4.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.4.1 Generic access to non-nested class members (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ B.4.2 Generic access to nested class members (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â””â”€â”€ ğŸ“„ B.4.3 Automatic JSON serialization of objects (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â””â”€â”€ Summary/
    â”œâ”€â”€ Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/
    â”‚   â”œâ”€â”€ C-1_Time_line/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.1.1 1958: Lisp (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.1.2 1981: Values and objects (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.1.3 2000: Ideal hash trees (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.1.4 2006: Out of the Tar Pit (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.1.5 2007: Clojure (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â””â”€â”€ ğŸ“„ C.1.6 2009: Immutability for all (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”œâ”€â”€ C-2_DOP_principles_as_best_practices/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.2.1 Principle #1: Separate code from data (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.2.2 Principle #2: Represent data with generic data structures (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.2.3 Principle #3: Data is immutable (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â””â”€â”€ ğŸ“„ C.2.4 Principle #4: Separate data schema from data representation (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”œâ”€â”€ C-3_DOP_and_other_data-related_paradigms/
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.3.1 Data-oriented design (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â”œâ”€â”€ ğŸ“„ C.3.2 Data-driven programming (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â”‚   â””â”€â”€ ğŸ“„ C.3.3 Data-oriented programming (DOP) (node4) [LEAF - íŒŒì¼ ìƒì„± ëŒ€ìƒ]
    â”‚   â””â”€â”€ Summary/
    â””â”€â”€ Appendix_D_Lodash_reference/
```

## Leaf ë…¸ë“œ ëª©ë¡ (ì½˜í…ì¸  ì¶”ì¶œ ëŒ€ìƒ)

- **1.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object-oriented_programming/1-1_OOP_design_Classic_or_classical`

- **1.1.1 The design phase** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object-oriented_programming/1-1_OOP_design_Classic_or_classical`

- **1.1.2 UML 101** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object-oriented_programming/1-1_OOP_design_Classic_or_classical`

- **1.1.3 Explaining each piece of the class diagram** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object-oriented_programming/1-1_OOP_design_Classic_or_classical`

- **1.1.4 The implementation phase** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object-oriented_programming/1-1_OOP_design_Classic_or_classical`

- **1.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object-oriented_programming/1-2_Sources_of_complexity`

- **1.2.1 Many relations between classes** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object-oriented_programming/1-2_Sources_of_complexity`

- **1.2.2 Unpredictable code behavior** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object-oriented_programming/1-2_Sources_of_complexity`

- **1.2.3 Not trivial data serialization** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object-oriented_programming/1-2_Sources_of_complexity`

- **1.2.4 Complex class hierarchies** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/1_Complexity_of_object-oriented_programming/1-2_Sources_of_complexity`

- **6.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/6_Unit_tests/6-2_Unit_tests_for_data_manipulation_code`

- **6.2.1 The tree of function calls** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/6_Unit_tests/6-2_Unit_tests_for_data_manipulation_code`

- **6.2.2 Unit tests for functions down the tree** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/6_Unit_tests/6-2_Unit_tests_for_data_manipulation_code`

- **6.2.3 Unit tests for nodes in the tree** (node4)
  - ê²½ë¡œ: `Part_1_Flexibility/6_Unit_tests/6-2_Unit_tests_for_data_manipulation_code`

- **9.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/9-3_Persistent_data_structures_libraries`

- **9.3.1 Persistent data structures in Java** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/9-3_Persistent_data_structures_libraries`

- **9.3.2 Persistent data structures in JavaScript** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/9-3_Persistent_data_structures_libraries`

- **9.4.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/9-4_Persistent_data_structures_in_action`

- **9.4.1 Writing queries with persistent data structures** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/9-4_Persistent_data_structures_in_action`

- **9.4.2 Writing mutations with persistent data structures** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/9-4_Persistent_data_structures_in_action`

- **9.4.3 Serialization and deserialization** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/9-4_Persistent_data_structures_in_action`

- **9.4.4 Structural diff** (node4)
  - ê²½ë¡œ: `Part_2_Scalability/9_Persistent_data_structures/9-4_Persistent_data_structures_in_action`

- **A.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-1_Principle_1_Separate_code_from_data`

- **A.1.1 Illustration of Principle #1** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-1_Principle_1_Separate_code_from_data`

- **A.1.2 Benefits of Principle #1** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-1_Principle_1_Separate_code_from_data`

- **A.1.3 Cost for Principle #1** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-1_Principle_1_Separate_code_from_data`

- **A.1.4 Summary of Principle #1** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-1_Principle_1_Separate_code_from_data`

- **A.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-2_Principle_2_Represent_data_with_generic_data_structures`

- **A.2.1 Illustration of Principle #2** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-2_Principle_2_Represent_data_with_generic_data_structures`

- **A.2.2 Benefits of Principle #2** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-2_Principle_2_Represent_data_with_generic_data_structures`

- **A.2.3 Cost for Principle #2** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-2_Principle_2_Represent_data_with_generic_data_structures`

- **A.2.4 Summary of Principle #2** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-2_Principle_2_Represent_data_with_generic_data_structures`

- **A.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-3_Principle_3_Data_is_immutable`

- **A.3.1 Illustration of Principle #3** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-3_Principle_3_Data_is_immutable`

- **A.3.2 Benefits of Principle #3** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-3_Principle_3_Data_is_immutable`

- **A.3.3 Cost for Principle #3** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-3_Principle_3_Data_is_immutable`

- **A.3.4 Summary of Principle #3** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-3_Principle_3_Data_is_immutable`

- **A.4.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-4_Principle_4_Separate_data_schema_from_data_representation`

- **A.4.1 Illustration of Principle #4** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-4_Principle_4_Separate_data_schema_from_data_representation`

- **A.4.2 Benefits of Principle #4** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-4_Principle_4_Separate_data_schema_from_data_representation`

- **A.4.3 Cost for Principle #4** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-4_Principle_4_Separate_data_schema_from_data_representation`

- **A.4.4 Summary of Principle #4** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_A_Principles_of_data-oriented_programming/A-4_Principle_4_Separate_data_schema_from_data_representation`

- **B.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically-typed_languages/B-1_Dynamic_getters_for_string_maps`

- **B.1.1 Accessing non-nested map fields with dynamic getters** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically-typed_languages/B-1_Dynamic_getters_for_string_maps`

- **B.1.2 Accessing nested map fields with dynamic getters** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically-typed_languages/B-1_Dynamic_getters_for_string_maps`

- **B.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically-typed_languages/B-2_Value_getters_for_maps`

- **B.2.1 Accessing non-nested map fields with value getters** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically-typed_languages/B-2_Value_getters_for_maps`

- **B.2.2 Accessing nested map fields with value getters** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically-typed_languages/B-2_Value_getters_for_maps`

- **B.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically-typed_languages/B-3_Typed_getters_for_maps`

- **B.3.1 Accessing non-nested map fields with typed getters** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically-typed_languages/B-3_Typed_getters_for_maps`

- **B.3.2 Accessing nested map fields with typed getters** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically-typed_languages/B-3_Typed_getters_for_maps`

- **B.4.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically-typed_languages/B-4_Generic_access_to_class_members`

- **B.4.1 Generic access to non-nested class members** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically-typed_languages/B-4_Generic_access_to_class_members`

- **B.4.2 Generic access to nested class members** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically-typed_languages/B-4_Generic_access_to_class_members`

- **B.4.3 Automatic JSON serialization of objects** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_B_Generic_data_access_in_statically-typed_languages/B-4_Generic_access_to_class_members`

- **C.1.1 1958: Lisp** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-1_Time_line`

- **C.1.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-1_Time_line`

- **C.1.2 1981: Values and objects** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-1_Time_line`

- **C.1.3 2000: Ideal hash trees** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-1_Time_line`

- **C.1.4 2006: Out of the Tar Pit** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-1_Time_line`

- **C.1.5 2007: Clojure** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-1_Time_line`

- **C.1.6 2009: Immutability for all** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-1_Time_line`

- **C.2.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-2_DOP_principles_as_best_practices`

- **C.2.1 Principle #1: Separate code from data** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-2_DOP_principles_as_best_practices`

- **C.2.2 Principle #2: Represent data with generic data structures** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-2_DOP_principles_as_best_practices`

- **C.2.3 Principle #3: Data is immutable** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-2_DOP_principles_as_best_practices`

- **C.2.4 Principle #4: Separate data schema from data representation** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-2_DOP_principles_as_best_practices`

- **C.3.0 Introduction (ì‚¬ìš©ì ì¶”ê°€)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-3_DOP_and_other_data-related_paradigms`

- **C.3.1 Data-oriented design** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-3_DOP_and_other_data-related_paradigms`

- **C.3.2 Data-driven programming** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-3_DOP_and_other_data-related_paradigms`

- **C.3.3 Data-oriented programming (DOP)** (node4)
  - ê²½ë¡œ: `Appendices/Appendix_C_Data-oriented_programming_A_link_in_the_chain_of_programming_paradigm/C-3_DOP_and_other_data-related_paradigms`

