# 추가 정보

## 핵심 내용
DOP(데이터 지향 프로그래밍)에서는 데이터 스키마와 데이터 표현을 분리하는 4번째 원칙에 따라, 시스템 경계(클라이언트, 데이터베이스, 웹 서비스와의 교환 지점)에서 들어오고 나가는 데이터의 유효성을 JSON Schema를 통해 검증합니다. JSON Schema는 클래스보다 더 유연하고 표현력이 높은 검증을 제공하며, `allOf`, `anyOf`, `oneOf` 같은 조합 기능으로 복잡한 비즈니스 로직을 구현할 수 있고, `additionalProperties` 설정을 통해 "받는 데이터에는 관대하게, 보내는 데이터에는 엄격하게" 하는 견고성 원칙을 실현할 수 있습니다. 시스템 경계에서 데이터를 철저히 검증하면 시스템 내부에서의 예상치 못한 데이터 발생 가능성이 현저히 줄어들어 추가 검증 필요성이 크게 감소하며, 검증 실패 시에는 구체적인 오류 정보를 제공하여 효과적인 디버깅과 사용자 경험을 지원합니다.

## 상세 핵심 내용
### DOP 제4원칙: 데이터 스키마와 표현의 분리

Data-Oriented Programming의 네 번째 핵심 원칙으로, 데이터의 구조를 정의하는 스키마와 실제 데이터의 표현 방식을 명확히 분리하는 것을 의미합니다. 이는 객체지향 프로그래밍에서 클래스 인스턴스화 시점에서 검증하는 방식과 달리, 명시적 검증 시점에서 데이터의 유효성을 확인하는 유연한 접근법을 제공합니다. DOP를 채택할 때 흔히 오해하는 것은 데이터 검증 없이 데이터에 접근하고, 데이터가 항상 유효하다고 가정하는 희망적 사고에 빠진다는 것이지만, 실제로는 데이터 지향 원칙을 따를 때도 데이터 검증이 가능할 뿐만 아니라 권장됩니다.

### 시스템 경계 중심의 데이터 검증 전략

시스템 경계는 데이터 교환이 발생하는 지점으로 정의되며, DOP에서는 이러한 경계에서의 데이터 검증이 핵심입니다. 웹 서버 환경에서는 세 가지 주요 경계가 존재합니다:

- **클라이언트 경계**: 웹 브라우저와 웹 서버 간 데이터 교환 지점
- **데이터베이스 경계**: 웹 서버와 데이터베이스 간 데이터 교환 지점
- **웹 서비스 경계**: 웹 서버와 외부 웹 서비스 간 데이터 교환 지점

시스템 경계에서의 검증은 잘못된 데이터가 시스템에 들어오거나 나가는 것을 방지하고, 무효한 데이터 발견 시 정보성 오류를 표시하는 목적을 가집니다. 경계에서의 데이터가 유효성을 확보하면 시스템 내부에서의 예상치 못한 데이터 발생 가능성이 현저히 낮아지므로, 내부에서의 추가 검증 필요성이 크게 줄어들어 시스템의 성능과 개발 효율성이 향상됩니다.

### JSON Schema: DOP 데이터 검증의 핵심 도구

JSON Schema는 데이터 검증을 데이터 표현으로부터 분리할 수 있게 해주는 언어독립적 스키마 언어입니다. 이는 클래스 기반 데이터 표현보다 훨씬 강력한 표현력을 제공하며, 다음과 같은 특징을 가집니다:

#### 기본 구조와 점진적 구축
```json
{
  "type": "object",
  "properties": {
    "title": {"type": "string"},
    "fields": {
      "type": "array",
      "items": {
        "enum": [
          "publishers", "number_of_pages", "weight",
          "physical_format", "subjects", "publish_date",
          "physical_dimensions"
        ]
      }
    }
  },
  "required": ["title", "fields"]
}
```

JSON Schema는 기본 객체 구조 정의부터 시작하여 배열 요소 타입 명시, 열거형 값 적용, 필수 필드 지정 순서로 점진적으로 구축할 수 있습니다.

#### 스키마의 조합성과 재사용성
JSON Schema가 일반적인 맵 구조로 표현되므로, 클래스 정의보다 높은 조합성과 재사용성을 제공합니다. 스키마를 변수에 저장하여 다른 스키마에서 참조할 수 있으며, 복잡한 중첩 구조를 모듈화하여 관리할 수 있습니다.

### 유연성과 엄격성의 균형 제어

JSON Schema는 `additionalProperties` 설정을 통해 스키마의 유연성과 엄격성을 세밀하게 제어할 수 있습니다:

- **기본값 `true`**: 스키마에 명시되지 않은 추가 필드 허용
- **`false` 설정**: 명시된 필드만 허용하여 엄격한 검증 수행

실무에서는 "보내는 것은 보수적으로, 받아들이는 것은 관대하게"라는 견고성 원칙(Robustness Principle)에 따라 차별화된 검증 전략을 적용합니다:

- **클라이언트 요청 검증**: `additionalProperties: true` - 미래 확장성과 클라이언트 유연성 제공
- **서버 응답 검증**: `additionalProperties: false` - 클라이언트에게 일관된 데이터 구조 보장
- **외부 API 응답**: 상황에 따라 유연하게 적용 - 외부 시스템의 변경 사항에 대한 내성 확보

### 스키마 조합을 통한 복합 검증 로직

JSON Schema composition은 논리 연산자와 유사한 방식으로 여러 스키마를 조합하여 복잡한 검증 규칙을 구현할 수 있습니다:

- **`allOf` (논리적 AND)**: 데이터가 모든 하위 스키마를 만족해야 함
- **`anyOf` (논리적 OR)**: 데이터가 하위 스키마 중 하나 이상을 만족하면 됨
- **`oneOf` (배타적 OR)**: 데이터가 하위 스키마 중 정확히 하나만 만족해야 함

실제 사례로 Open Library Books API 응답에서 ISBN-10과 ISBN-13 중 적어도 하나는 반드시 존재해야 하는 조건을 다음과 같이 표현할 수 있습니다:

```javascript
var bookInfoSchema = {
  "allOf": [
    basicBookInfoSchema,
    {
      "anyOf": [mandatoryIsbn13, mandatoryIsbn10]
    }
  ]
};
```

이러한 조합 방식은 클래스 기반 데이터 표현으로는 표현하기 어려운 조건부 필수 필드, 상호 의존성 등의 복잡한 비즈니스 로직을 효과적으로 구현할 수 있게 합니다.

### 검증 실패 시 상세 정보 처리

JSON Schema 검증은 단순한 성공/실패 판정이 아닌 구체적인 실패 원인에 대한 상세 정보를 제공합니다. JavaScript의 Ajv 라이브러리를 예로 들면:

```javascript
var ajv = new Ajv({allErrors: true}); // 모든 오류 수집
var validate = ajv.compile(schema);
var valid = validate(data);

if (!valid) {
  console.log(ajv.errorsText(validate.errors));
  // "data must have required property 'title'"
}
```

기본적으로는 첫 번째 검증 실패만 감지하지만, `allErrors: true` 옵션을 통해 모든 검증 실패를 수집할 수 있어 클라이언트가 한 번의 요청으로 모든 수정 사항을 파악할 수 있습니다. 이는 시스템 경계에서 잘못된 데이터 발견 시 정보성 오류를 표시하여 효율적인 디버깅과 사용자 경험을 제공하는 DOP의 목적에 부합합니다.

### 언어 독립적 지원과 실무 적용

JSON Schema는 언어독립적 특성으로 인해 다양한 프로그래밍 언어에서 지원됩니다:

| 언어 | 라이브러리 | 특징 |
|------|-----------|------|
| JavaScript | Ajv | 고성능, 다양한 오류 수집 옵션 |
| Java | Snow | 경량화된 검증 엔진 |
| C# | JSON.net Schema | .NET 생태계 통합 |
| Python | jschon | Python 네이티브 구현 |
| Ruby | JSONSchemer | Ruby 관례 준수 |

### 고급 검증 기능과 표현력

JSON Schema는 클래스 기반 데이터 표현보다 훨씬 강력한 검증 조건들을 표현할 수 있습니다:

- **숫자 범위 검증**: minimum, maximum을 통한 값 범위 제한
- **정규표현식 매칭**: pattern 키워드를 통한 문자열 형식 검증
- **조건부 검증**: if-then-else 구조를 통한 복잡한 검증 로직
- **스키마 조합**: allOf, anyOf, oneOf를 통한 논리적 스키마 결합

이러한 고급 기능들은 시스템 경계에서 발생하는 복잡한 데이터 검증 요구사항을 효과적으로 해결할 수 있게 하며, DOP에서 추구하는 데이터 중심적 사고와 완벽히 부합합니다.

### 실무 적용 시나리오와 전략적 균형

현재 메모리 기반 라이브러리 관리 시스템에서 출발하여 실제 웹 서버 환경으로 확장할 때, JSON Schema는 다음과 같은 실무 시나리오에서 활용됩니다:

#### 1. 외부 API 응답 검증
- 서드파티 서비스의 불일치하는 응답 형식 대응
- 버전별 API 응답 차이 처리
- 시스템 경계에서의 데이터 무결성 보장

#### 2. 조건부 필수 필드 처리
- 사용자 유형에 따른 다른 필수 필드 요구사항
- 워크플로우 단계별 요구 데이터 차이
- 비즈니스 규칙의 유연한 표현

#### 3. 다형성 데이터 검증
- 동일한 엔드포인트에서 다양한 형태의 데이터 처리
- 타입별 특화된 검증 규칙 적용

이러한 접근법을 통해 DOP는 시스템 내부 안정성, 외부 호환성, 진화 가능성, 오류 최소화라는 네 가지 핵심 가치를 동시에 달성할 수 있습니다. JSON Schema의 조합 기능과 유연한 제어 메커니즘은 실제 운영 환경에서 유연하면서도 안정적인 데이터 검증을 가능하게 하며, DOP의 데이터 검증 철학을 실현하는 실용적 도구로 기능합니다.

## 주요 화제
- DOP에서의 데이터 검증: DOP를 채택할 때 데이터 검증 없이 데이터에 접근하고 항상 유효하다고 가정하는 것이 아니라, 실제로는 제네릭 데이터 구조를 사용할 때도 데이터 검증이 가능할 뿐만 아니라 권장되며, DOP의 4번째 원칙인 "데이터 스키마와 데이터 표현의 분리"를 구현하는 핵심 개념 [출처: 7_Introduction]

- 시스템 경계에서의 데이터 검증: 웹서버 환경에서 클라이언트, 데이터베이스, 웹서비스와의 데이터 교환이 이루어지는 경계 지점들에서 발생하는 데이터 검증 과정으로, 시스템 내외부로 오가는 무효한 데이터를 방지하고 시스템 내부에서 예상치 못한 데이터 발생 가능성을 현저히 낮추는 방법 [출처: 7.1_Data_validation_in_DOP]

- 경계에서의 데이터 검증 vs 내부 데이터 검증: 시스템 경계에서의 검증(프로덕션 환경에서 시스템 보호 목적)과 시스템 내부 검증(개발 편의성 목적)의 구분과 각각의 역할, 경계에서의 검증이 더 중요하며 경계에서 유효한 데이터를 보장하면 내부 검증의 필요성이 크게 줄어든다는 원칙 [출처: 7.1_Data_validation_in_DOP]

- JSON Schema 기본 구조와 작성 방법: 데이터의 구조와 타입을 정의하는 언어로서 `type`으로 데이터 타입을 지정하고, `properties`로 객체의 필드들을 정의하며, `required`로 필수 필드를 명시하는 방식의 기본 구조와 점진적 스키마 구축 과정 [출처: 7.2_JSON_Schema_in_a_nutshell]

- JSON Schema의 필드 요구사항과 additionalProperties 제어: JSON Schema에서 필드는 기본적으로 선택사항이며 필수 필드로 만들려면 `required` 배열에 명시해야 하고, 스키마에 정의되지 않은 추가 속성은 기본적으로 허용되지만 `additionalProperties: false`로 설정하여 엄격하게 제한할 수 있는 방법 [출처: 7.3_Schema_flexibility_and_strictness]

- 견고성 원칙의 실제 적용: "보내는 데이터는 엄격하게, 받는 데이터는 유연하게"라는 Jon Postel의 견고성 원칙을 시스템 경계에서의 데이터 검증에 적용하여 클라이언트 요청에는 유연하게, 서버 응답에는 엄격하게 대응하는 차별화된 검증 전략 [출처: 7.3_Schema_flexibility_and_strictness]

- JSON Schema Composition: `allOf`(AND), `anyOf`(OR), `oneOf`(배타적 OR) 등의 논리 연산자를 사용하여 여러 스키마를 조합하고, ISBN-10과 ISBN-13 중 적어도 하나는 필수로 존재해야 하는 복잡한 비즈니스 규칙을 구현하는 방법 [출처: 7.4_Schema_composition]

- JSON Schema의 높은 표현력과 조합성: 클래스 기반 데이터 표현보다 더 강력한 검증 조건들(범위, 정규식, 열거형 등)을 표현할 수 있고, 일반적인 맵 구조로 표현되므로 높은 재사용성과 모듈화가 가능한 특징 [출처: 7.4_Schema_composition]

- JSON Schema 검증 실패 상세 정보 처리: 데이터가 유효하지 않을 때 단순히 실패 여부만이 아니라 실패 원인에 대한 구체적인 정보(필수 필드 누락, 타입 불일치 등)를 얻을 수 있고, Ajv 라이브러리에서 `allErrors: true` 옵션을 통해 모든 검증 오류를 동시에 확인할 수 있는 방법 [출처: 7.5_Details_about_data_validation_failures]

- DOP 원칙 #4의 실무적 구현: 데이터 스키마와 데이터 표현을 분리하는 DOP의 핵심 원칙을 JSON Schema를 통해 실제로 구현하며, 시스템 경계에서의 철저한 검증을 통해 전체 시스템의 안정성을 확보하는 실용적 접근법 [출처: 전체 관점]

- 언어 독립적 데이터 검증 체계: JSON Schema가 언어독립적 특성으로 인해 JavaScript(Ajv), Java(Snow), C#(JSON.net Schema), Python(jschon), Ruby(JSONSchemer) 등 다양한 프로그래밍 언어에서 일관된 데이터 검증을 제공하는 범용적 솔루션 [출처: 전체 관점]

## 부차 화제
- 데이터 지향 프로그래밍(DOP)에서 데이터 검증의 일반적 오해: DOP를 따를 때 데이터 검증 없이 데이터에 접근하고 항상 유효하다고 가정하는 희망적 사고에 빠진다는 잘못된 이해에 대한 설명 [출처: 7_Introduction]

- 시스템 내부 vs 시스템 경계에서의 데이터 검증 구분: 목적(시스템 보호 vs 개발 편의성)과 환경(프로덕션 vs 개발)에 따른 차별화된 접근법 [출처: 7_Introduction]

- 파트 3에서의 시스템 내부 데이터 검증 예고: 시스템 전체를 흐르는 데이터의 검증을 다룰 예정인 향후 내용에 대한 언급 [출처: 7_Introduction]

- Theo의 프로젝트 일정 변경: DOP 도입으로 인한 마감일 압박으로 회의 일정을 재조정한 상황적 맥락 [출처: 7.1_Data_validation_in_DOP]

- OOP vs DOP의 데이터 검증 차이점: OOP의 클래스 인스턴스화 시 자동 보장되는 필드명/타입 검증과 달리 DOP에서는 실수하기 쉬운 구조적 특성 [출처: 7.1_Data_validation_in_DOP]

- 웹 서버의 시스템 경계 식별: 클라이언트, 데이터베이스, 웹 서비스와의 데이터 교환 지점을 통한 시스템 아키텍처 이해 [출처: 7.1_Data_validation_in_DOP]

- 코드베이스 성장에 따른 검증 전략: 시스템 규모가 커질 때까지 내부 검증 학습을 연기하는 단계적 접근법 [출처: 7.1_Data_validation_in_DOP]

- 라이브러리 관리 시스템의 시스템 아키텍처: 현재는 인메모리로 실행되지만 향후 실제 웹서버, 클라이언트, 데이터베이스, 외부 서비스를 포함한 시스템으로 발전시킬 계획 [출처: 7.2_JSON_Schema_in_a_nutshell]

- 도서 검색 API 설계: 클라이언트가 도서를 검색할 때 사용할 요청 구조(제목 문자열과 반환받을 필드 배열)에 대한 구체적인 설계 논의 [출처: 7.2_JSON_Schema_in_a_nutshell]

- JSON Schema 검증 라이브러리: JavaScript(Ajv), Java(Snow), C#(JSON.net Schema), Python(jschon), Ruby(JSONSchemer) 등 각 프로그래밍 언어별 JSON Schema 검증 라이브러리 목록과 URL 정보 [출처: 7.2_JSON_Schema_in_a_nutshell]

- JSON Schema의 고급 검증 기능: 숫자 범위 검증, 정규표현식 매칭 등 클래스 기반 데이터 표현으로는 구현하기 어려운 고급 검증 기능들 [출처: 7.2_JSON_Schema_in_a_nutshell]

- 검증 오류 세부 정보: 데이터가 유효하지 않을 때 구체적인 오류 원인을 파악할 수 있는 방법 [출처: 7.2_JSON_Schema_in_a_nutshell]

- 도서 검색 응답 구조의 복잡성: 여러 도서 결과와 각 도서의 선택적 필드들로 구성된 검색 응답의 복잡한 구조 [출처: 7.2_JSON_Schema_in_a_nutshell]

- 개인적 습관과 독서: Joe가 손톱 물어뜯는 습관을 고치기 위해 "The Power of Habit" 책을 읽고 있다는 일화 [출처: 7.3_Schema_flexibility_and_strictness]

- Open Library Books API: 외부 웹 서비스인 Open Library Books API의 책 정보 제공 기능과 API 응답 구조 [출처: 7.4_Schema_composition]

- Watchmen 예제: Open Library Books API의 실제 응답 예시로 Watchmen 책의 JSON 데이터 구조와 필드 정보 [출처: 7.4_Schema_composition]

- ISBN 시스템: ISBN-10과 ISBN-13의 차이점, 출간 연도에 따른 ISBN 형식 변화(2007년 기준), 재출간 도서의 복수 ISBN 보유 특성 [출처: 7.4_Schema_composition]

- JSON Schema 논리 연산자: allOf(AND), anyOf(OR), oneOf(정확히 하나) 키워드를 사용한 스키마 조합 방법 [출처: 7.4_Schema_composition]

- 스키마 분할 설계: 기본 도서 정보 스키마와 필수 ISBN 스키마를 분리하여 조합하는 모듈화 접근법 [출처: 7.4_Schema_composition]

- 클래스 기반 데이터 표현의 한계: JSON Schema composition이 전통적인 클래스 기반 데이터 모델링보다 더 표현력이 뛰어나다는 비교 분석 [출처: 7.4_Schema_composition]

- 데이터 검증 오류 처리: 복합 스키마 사용 시 검증 실패 원인 파악의 어려움에 대한 문제 제기 [출처: 7.4_Schema_composition]

- JSON Schema 치트 시트: 다양한 데이터 타입과 검증 규칙을 포함한 JSON Schema 작성 가이드 [출처: 7.5_Details_about_data_validation_failures]

- 유효한 데이터 예제: JSON Schema에 부합하는 올바른 데이터 구조의 실제 사례 [출처: 7.5_Details_about_data_validation_failures]

- JSON Schema 언어별 지원 범위: JavaScript, Java, C#, Python, Ruby 등 다양한 프로그래밍 언어에서 JSON Schema 검증 라이브러리가 제공되는 현황 [출처: 전체 관점]

- 견고성 원칙의 실무 적용: "보내는 데이터는 엄격하게, 받는 데이터는 유연하게"라는 원칙을 시스템 경계별로 차별화하여 적용하는 전략 [출처: 전체 관점]

- 스키마 조합성과 재사용성: JSON Schema가 일반적인 맵 구조로 표현되어 높은 조합성과 재사용성을 제공한다는 DOP의 핵심 장점 [출처: 전체 관점]

- 12장에서 다룰 고급 검증 기능 예고: 더 복잡한 데이터 구조와 비즈니스 로직에 대한 검증 방법을 포함할 향후 내용 [출처: Summary]
