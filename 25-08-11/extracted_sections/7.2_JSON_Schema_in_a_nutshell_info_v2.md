# 추가 정보

## 핵심 내용
JSON Schema는 데이터의 구조와 타입을 정의하는 언어로, DOP의 핵심 원칙인 데이터 스키마와 데이터 표현 분리를 구현합니다. 기본 구조는 `type`으로 데이터 타입을 지정하고, `properties`로 객체의 필드들을 정의하며, `required`로 필수 필드를 명시하는 방식으로 작성됩니다. JSON Schema는 언어 독립적이며 클래스보다 훨씬 강력한 검증 조건들(범위, 정규식, 열거형 등)을 표현할 수 있어, 시스템 경계에서 들어오고 나가는 데이터의 유효성을 철저히 검증하는 DOP의 데이터 검증 전략에 최적화된 도구입니다.

## 상세 핵심 내용
### JSON Schema 기본 개념과 구조

JSON Schema는 DOP(Data-Oriented Programming)의 핵심 원칙인 데이터 스키마와 데이터 표현의 분리를 구현하는 언어독립적 스키마 언어입니다. 이는 클래스 인스턴스화 시점이 아닌 명시적 검증 시점에서 데이터 유효성을 확인하는 DOP의 특징적 접근법을 보여줍니다.

#### 데이터 표현과 스키마의 분리

JSON Schema의 핵심은 데이터와 스키마가 완전히 독립적으로 존재한다는 점입니다. 이러한 분리를 통해 언제든지 원하는 시점에 데이터가 스키마에 부합하는지 검증할 수 있으며, 이는 시스템 경계에서의 데이터 검증에 특히 중요합니다.

#### JSON Schema 기본 구조

JSON Schema는 JSON 형식으로 작성되며, 다음과 같은 기본 구조를 가집니다:

```json
{
  "type": "object",
  "properties": {
    "title": {"type": "string"},
    "fields": {
      "type": "array",
      "items": {"type": "string"}
    }
  },
  "required": ["title", "fields"]
}
```

### 점진적 스키마 구축 과정

실제 도서 검색 요청 스키마를 구축하는 과정을 통해 JSON Schema 작성 방법을 체계적으로 살펴볼 수 있습니다.

#### 1단계: 기본 객체 구조 정의

```json
{
  "type": "object", 
  "properties": {
    "title": {"type": "string"},
    "fields": {"type": "array"}
  }
}
```

#### 2단계: 배열 요소 타입 명시

```json
{
  "type": "object",
  "properties": {
    "title": {"type": "string"},
    "fields": {
      "type": "array",
      "items": {"type": "string"}
    }
  }
}
```

#### 3단계: 열거형 값(Enumeration) 적용

```json
{
  "type": "object",
  "properties": {
    "title": {"type": "string"},
    "fields": {
      "type": "array", 
      "items": {
        "enum": [
          "publishers", "number_of_pages", "weight",
          "physical_format", "subjects", "publish_date",
          "physical_dimensions"
        ]
      }
    }
  }
}
```

#### 4단계: 필수 필드 지정

```json
{
  "type": "object",
  "properties": {...},
  "required": ["title", "fields"]
}
```

### 데이터 검증과 오류 처리

JSON Schema의 검증은 단순한 참/거짓 판단을 넘어 상세한 오류 정보를 제공합니다. 이는 시스템 경계에서 잘못된 데이터 발견 시 정보성 오류를 표시하는 DOP의 목적에 부합합니다.

#### 검증 예시

유효한 데이터:
```javascript
var searchBooksRequest = {
  "title": "habit",
  "fields": ["title", "weight", "number_of_pages"]
};
validate(searchBooksRequestSchema, searchBooksRequest); // → true
```

무효한 데이터:
```javascript
var invalidRequest = {
  "tilte": "habit",  // 오타: title → tilte
  "fields": ["title", "weight", "number_of_pages"]
};
validate(searchBooksRequestSchema, invalidRequest); // → false
```

### 언어별 검증 라이브러리

JSON Schema는 언어독립적 특성으로 인해 다양한 프로그래밍 언어에서 지원됩니다:

| 언어 | 라이브러리 | 특징 |
|------|-----------|------|
| JavaScript | Ajv | 고성능, 다양한 오류 수집 옵션 |
| Java | Snow | 경량화된 검증 엔진 |
| C# | JSON.net Schema | .NET 생태계 통합 |
| Python | jschon | Python 네이티브 구현 |
| Ruby | JSONSchemer | Ruby 관례 준수 |

### JSON Schema의 고급 특징

JSON Schema는 클래스 기반 데이터 표현보다 훨씬 강력한 검증 조건들을 표현할 수 있습니다:

- **숫자 범위 검증**: minimum, maximum을 통한 값 범위 제한
- **정규표현식 매칭**: pattern 키워드를 통한 문자열 형식 검증
- **조건부 검증**: if-then-else 구조를 통한 복잡한 검증 로직
- **스키마 조합**: allOf, anyOf, oneOf를 통한 논리적 스키마 결합

이러한 특징들은 시스템 경계에서 발생하는 복잡한 데이터 검증 요구사항을 효과적으로 해결할 수 있게 합니다.

### 실무 적용 맥락

현재 메모리 기반 라이브러리 관리 시스템에서 출발하여 실제 웹 서버 환경으로 확장할 때, JSON Schema는 클라이언트 요청, 데이터베이스 응답, 외부 웹 서비스 연동 등 모든 시스템 경계에서 일관된 데이터 검증 방법을 제공합니다. 이는 DOP에서 강조하는 시스템 경계에서의 데이터 검증 원칙을 실용적으로 구현하는 핵심 도구입니다.

## JSON Schema 기본 개념

### 1. 데이터 표현과 스키마의 분리
- **핵심 원칙**: DOP(Data-Oriented Programming)에서 데이터 스키마는 데이터 표현과 별도로 독립적으로 존재
- **분리의 의미**: 
  - 데이터 표현은 그 자체로 독립적
  - 데이터 스키마는 별도로 독립적  
  - 언제든지 원하는 때에 데이터가 스키마에 부합하는지 검증 가능

### 2. JSON Schema 언어
- **공식 정보**: https://json-schema.org
- **사용 버전**: JSON Schema version 2020-12
- **목적**: JSON 데이터의 구조와 유효성을 정의하는 스키마 언어

## JSON Schema 구조 작성 과정

### 1. 기본 스키마 골격 (Map/Object 타입)
```json
{
  "type": "object",
  "properties": {...}
}
```
- **type**: "object" - JSON Schema에서 맵(map) 데이터 타입
- **properties**: 맵 필드들의 스키마를 포함하는 객체

### 2. 검색 요청 예시 구조
```json
{
  "title": "habit",
  "fields": ["title", "weight", "number_of_pages"]
}
```
- **title**: 문자열 타입 (검색할 제목)
- **fields**: 문자열 배열 타입 (반환받을 필드 목록)

### 3. 점진적 스키마 구축

#### 단계 1: 기본 필드 타입 정의
```json
{
  "type": "object", 
  "properties": {
    "title": {"type": "string"},
    "fields": {"type": "array"}
  }
}
```

#### 단계 2: 배열 요소 타입 정의
```json
{
  "type": "object",
  "properties": {
    "title": {"type": "string"},
    "fields": {
      "type": "array",
      "items": {"type": "string"}
    }
  }
}
```
- **items**: 배열 요소들의 스키마 정의

#### 단계 3: 열거형 값(Enumeration) 적용
```json
{
  "type": "object",
  "properties": {
    "title": {"type": "string"},
    "fields": {
      "type": "array", 
      "items": {
        "enum": [
          "publishers",
          "number_of_pages", 
          "weight",
          "physical_format",
          "subjects",
          "publish_date",
          "physical_dimensions"
        ]
      }
    }
  }
}
```
- **enum**: 허용되는 값들의 제한된 목록 정의

#### 단계 4: 필수 필드 정의
```json
{
  "type": "object",
  "properties": {...},
  "required": ["title", "fields"]
}
```
- **required**: 필수 필드들의 이름 배열

## 데이터 검증 (Validation)

### 1. 검증의 정의
- **의미**: 데이터가 스키마에 부합하는지 확인하는 과정
- **결과**: 유효하면 true, 무효하면 false 반환

### 2. 검증 라이브러리
| 언어 | 라이브러리 | URL |
|------|-----------|-----|
| JavaScript | Ajv | https://github.com/ajv-validator/ajv |
| Java | Snow | https://github.com/ssilverman/snowy-json |
| C# | JSON.net Schema | https://www.newtonsoft.com/jsonschema |
| Python | jschon | https://github.com/marksparkza/jschon |
| Ruby | JSONSchemer | https://github.com/davishmcclurg/json_schemer |

### 3. 검증 예시

#### 유효한 요청 검증
```javascript
var searchBooksRequest = {
  "title": "habit",
  "fields": ["title", "weight", "number_of_pages"]
};
validate(searchBooksRequestSchema, searchBooksRequest);
// → true
```

#### 무효한 요청 검증
```javascript
var invalidSearchBooksRequest = {
  "tilte": "habit",  // 오타: title → tilte
  "fields": ["title", "weight", "number_of_pages"]
};
validate(searchBooksRequestSchema, invalidSearchBooksRequest);
// → false
```

## JSON Schema의 특징과 장점

### 1. 언어 독립성
- **장점**: 모든 프로그래밍 언어에서 사용 가능
- **가용성**: 대부분의 프로그래밍 언어에서 JSON Schema 검증기 제공

### 2. 높은 표현력
- **클래스 기반 방식 대비 장점**: 클래스로는 표현하기 어렵거나 불가능한 검증 조건들을 표현 가능
- **고급 검증 기능**:
  - 숫자 범위 검증
  - 정규 표현식 문자열 매칭
  - 복잡한 조건부 검증

### 3. 상세한 오류 정보
- **검증 실패 시**: 실패 원인에 대한 상세 정보 제공 가능
- **디버깅 지원**: 어떤 부분이 스키마에 위반되었는지 구체적 정보 제공

## 실무 적용 관점

### 1. 시스템 발전 과정
- **현재 상태**: 메모리 기반 라이브러리 관리 시스템
- **향후 계획**: 실제 웹 서버, 클라이언트, 데이터베이스, 외부 서비스 연동

### 2. API 요청/응답 검증
- **요청 검증**: 클라이언트 요청의 유효성 확인
- **응답 검증**: 서버 응답의 정확성 보장
- **복잡성 관리**: 다중 결과, 선택적 필드 등 복잡한 구조 처리

이 장에서는 JSON Schema의 기본 개념부터 실제 검증까지의 전체 과정을 체계적으로 설명하며, DOP에서 데이터와 스키마를 분리하는 핵심 원칙의 실용적 적용을 보여줍니다.

## 주요 화제



## 부차 화제
Looking at this text about JSON Schema, I can identify several secondary topics that are discussed alongside the main focus on JSON Schema fundamentals:

- **라이브러리 관리 시스템의 시스템 아키텍처**: 현재는 인메모리로 실행되지만 향후 실제 웹서버, 클라이언트, 데이터베이스, 외부 서비스를 포함한 시스템으로 발전시킬 계획에 대한 논의

- **도서 검색 API 설계**: 클라이언트가 도서를 검색할 때 사용할 요청 구조(제목 문자열과 반환받을 필드 배열)에 대한 구체적인 설계 논의

- **DOP(Data-Oriented Programming) 원칙**: 데이터 표현과 데이터 스키마를 분리하는 DOP의 핵심 개념과 이를 통한 데이터 검증 방법론

- **JSON Schema 검증 라이브러리**: JavaScript(Ajv), Java(Snow), C#(JSON.net Schema), Python(jschon), Ruby(JSONSchemer) 등 각 프로그래밍 언어별 JSON Schema 검증 라이브러리 목록과 URL 정보

- **JSON Schema의 고급 검증 기능**: 숫자 범위 검증, 정규표현식 매칭 등 클래스 기반 데이터 표현으로는 구현하기 어려운 고급 검증 기능들에 대한 언급

- **검증 오류 세부 정보**: 데이터가 유효하지 않을 때 구체적인 오류 원인을 파악할 수 있는 방법에 대한 간략한 언급

- **도서 검색 응답 구조의 복잡성**: 여러 도서 결과와 각 도서의 선택적 필드들로 구성된 검색 응답의 복잡한 구조에 대한 예고
