# 추가 정보

## 핵심 내용
JSON Schema composition을 사용하면 `allOf`(AND), `anyOf`(OR), `oneOf` 등의 논리 연산자로 여러 스키마를 조합할 수 있습니다. Open Library Books API 응답에서 isbn_10과 isbn_13 중 적어도 하나는 반드시 존재해야 하는 조건을 `allOf`와 `anyOf`를 결합하여 표현할 수 있습니다. 이러한 스키마 조합 방식은 DOP에서 데이터 스키마와 표현의 분리 원칙을 구현하며, 시스템 경계에서의 복잡한 검증 규칙을 클래스 기반 데이터 표현보다 더 강력하고 유연하게 표현할 수 있습니다.

## 상세 핵심 내용
### JSON Schema 조합(Composition) 개념

JSON Schema의 조합 기능은 DOP의 4번째 원칙인 "데이터 스키마와 데이터 표현의 분리"를 실현하는 핵심 기술입니다. 여러 개의 스키마를 논리적으로 결합하여 복잡한 검증 규칙을 만들 수 있으며, 이는 AND, OR, NOT과 같은 논리 연산자와 유사한 방식으로 작동합니다. 클래스 기반 데이터 표현과 달리, JSON Schema composition은 시스템 경계에서 들어오는 다양한 데이터 형태를 유연하면서도 엄격하게 검증할 수 있는 강력한 표현력을 제공합니다.

### 실제 사례: Open Library Books API 응답 검증

#### API 응답 예시 - Watchmen 도서 정보
```json
{
  "publishers": ["DC Comics"],
  "number_of_pages": 334,
  "weight": "1.4 pounds",
  "physical_format": "Paperback",
  "subjects": ["Graphic Novels", "Comics & Graphic Novels", "Fiction", "Fantastic fiction"],
  "isbn_13": ["9780930289232"],
  "title": "Watchmen",
  "isbn_10": ["0930289234"],
  "publish_date": "April 1, 1995",
  "physical_dimensions": "10.1 x 6.6 x 0.8 inches"
}
```

이 예시는 웹 서비스 경계에서 외부 API로부터 받은 데이터의 전형적인 형태입니다. 시스템 경계에서 이러한 외부 데이터를 검증하는 것은 잘못된 데이터가 시스템 내부로 유입되는 것을 방지하는 중요한 보안 장치입니다.

#### 비즈니스 요구사항의 복잡성
- **title**: 항상 필수 필드
- **isbn_10과 isbn_13**: 둘 중 최소 하나는 반드시 존재해야 함
- **출간 년도별 ISBN 규칙**:
  - 2007년 이전 출간: isbn_10 사용
  - 2007년 이후 출간: isbn_13 사용
  - 재출간된 경우: 두 ISBN 모두 존재 가능 (Watchmen의 경우)

이러한 조건부 필수 필드 요구사항은 클래스 기반 데이터 모델로는 표현하기 어려운 복잡한 비즈니스 로직의 대표적인 예시입니다.

### Schema Composition 키워드

#### allOf (논리적 AND)
- 데이터가 **모든** 하위 스키마를 만족해야 함
- 여러 스키마의 제약 조건을 모두 적용
- 시스템 경계에서 기본 스키마와 추가 제약사항을 동시에 적용할 때 사용

#### anyOf (논리적 OR)  
- 데이터가 하위 스키마 중 **하나 이상**을 만족하면 됨
- 여러 조건 중 선택적 만족
- "받는 데이터에는 관대하게" 원칙을 구현할 때 유용

#### oneOf (배타적 OR)
- 데이터가 하위 스키마 중 **정확히 하나만** 만족해야 함
- 상호 배타적인 조건 설정
- "보내는 데이터에는 엄격하게" 원칙을 적용할 때 활용

### 조합 스키마 구현 사례

#### 기본 스키마 분리
```javascript
// 기본 도서 정보 (title만 필수)
var basicBookInfoSchema = {
  "type": "object",
  "required": ["title"],
  "properties": {
    "title": {"type": "string"},
    "publishers": {"type": "array", "items": {"type": "string"}},
    "number_of_pages": {"type": "integer"},
    "weight": {"type": "string"},
    "physical_format": {"type": "string"},
    "subjects": {"type": "array", "items": {"type": "string"}},
    "isbn_13": {"type": "array", "items": {"type": "string"}},
    "isbn_10": {"type": "array", "items": {"type": "string"}},
    "publish_date": {"type": "string"},
    "physical_dimensions": {"type": "string"}
  },
  "additionalProperties": true  // 관대한 수용 원칙 적용
};

// ISBN-13 필수 조건
var mandatoryIsbn13 = {
  "type": "object",
  "required": ["isbn_13"]
};

// ISBN-10 필수 조건  
var mandatoryIsbn10 = {
  "type": "object",
  "required": ["isbn_10"]
};
```

#### 최종 조합 스키마
```javascript
var bookInfoSchema = {
  "allOf": [
    basicBookInfoSchema,
    {
      "anyOf": [mandatoryIsbn13, mandatoryIsbn10]
    }
  ]
};
```

이 스키마 조합은 일반적인 맵 구조로 표현되므로 다른 맵과 동일하게 조작할 수 있으며, 변수에 저장하여 다른 스키마에서 재사용할 수 있어 높은 조합성을 제공합니다.

### 논리적 표현식 매핑

**요구사항**: `basicBookInfoSchema AND (mandatoryIsbn13 OR mandatoryIsbn10)`

**JSON Schema 표현**:
- **AND** → `allOf`
- **OR** → `anyOf`
- **배타적 OR** → `oneOf`

### Schema Composition의 장점

#### 1. 높은 표현력
- 클래스 기반 데이터 표현보다 더 복잡한 검증 규칙 구현 가능
- 조건부 필수 필드, 상호 의존성 등 복잡한 비즈니스 로직 표현
- 숫자 범위 검증, 정규표현식 패턴 매칭 등 고급 검증 기능 활용

#### 2. 모듈화와 재사용성
- 공통 스키마를 분리하여 재사용 가능
- 복잡한 스키마를 논리적 단위로 분해하여 관리 용이
- 스키마 자체가 일반적인 맵 구조이므로 프로그래밍 언어의 맵 조작 기능 활용 가능

#### 3. 시스템 경계 최적화
- 클라이언트 요청에는 유연한 검증(`additionalProperties: true`)
- 서버 응답에는 엄격한 검증(`additionalProperties: false`)
- 견고성 원칙("보수적으로 전송하고, 관대하게 수용하라")의 효과적 구현

### 검증 실패 처리와 오류 정보

```javascript
var ajv = new Ajv({allErrors: true}); // 모든 오류 수집
var validate = ajv.compile(bookInfoSchema);
var valid = validate(bookData);

if (!valid) {
  console.log(ajv.errorsText(validate.errors));
  // "data should have required property 'isbn_10', 
  //  data should have required property 'isbn_13'"
}
```

조합 스키마의 검증 실패는 단순한 참/거짓 판단이 아닌 실패 원인에 대한 상세 정보를 제공하며, 시스템 경계에서 잘못된 데이터 발견 시 정보성 오류를 표시하여 디버깅을 지원합니다.

### 한계점과 고려사항

#### 1. 오류 메시지의 복잡성
- 검증 실패 시 정확한 원인 파악이 어려움
- 어떤 조합 조건에서 실패했는지 명확하지 않음
- 중첩된 조합 구조에서는 오류 추적이 복잡해짐

#### 2. 복잡도 증가
- 중첩된 조합 구조는 이해하기 어려움
- 디버깅과 유지보수 복잡성 증가
- 스키마 자체의 검증과 문서화 필요성

### 실무 적용 시나리오

#### 1. 외부 API 응답 검증
- 서드파티 서비스의 불일치하는 응답 형식 대응
- 버전별 API 응답 차이 처리
- 시스템 경계에서의 데이터 무결성 보장

#### 2. 조건부 필수 필드
- 사용자 유형에 따른 다른 필수 필드
- 워크플로우 단계별 요구 데이터 차이
- 비즈니스 규칙의 유연한 표현

#### 3. 다형성 데이터 검증
- 동일한 엔드포인트에서 다양한 형태의 데이터 처리
- 타입별 특화된 검증 규칙 적용
- 언어독립적 스키마 언어로서의 이식성 활용

JSON Schema의 조합 기능은 DOP에서 데이터 검증의 핵심 기술로, 시스템 경계에서 들어오고 나가는 데이터의 유효성을 유연하면서도 엄격하게 관리할 수 있게 해줍니다. 이를 통해 시스템 내부에서의 예상치 못한 데이터 발생 가능성을 현저히 줄이고, 복잡한 실제 비즈니스 요구사항을 정교하게 모델링할 수 있는 강력한 도구가 됩니다.

## 주요 화제
- JSON Schema 기본 구조: Open Library Books API 응답 데이터에 대한 JSON Schema 작성 방법과 필수 필드 지정

- Schema Composition 개념: JSON Schema에서 여러 스키마를 논리적으로 결합하는 방법 (AND, OR, NOT과 유사한 방식)

- allOf와 anyOf 키워드: JSON Schema에서 스키마 조합을 위한 핵심 키워드들의 사용법과 의미

- ISBN 필드 검증 로직: ISBN-10과 ISBN-13 중 적어도 하나는 필수로 존재해야 하는 비즈니스 규칙의 스키마 구현

- 외부 API 응답 검증: 웹 서비스에서 받은 데이터의 유효성을 검사하는 실제 사용 사례

- 스키마 모듈화: 기본 스키마와 조건별 스키마를 분리하여 재사용 가능한 구조로 설계하는 방법

- JSON Schema의 표현력: 클래스 기반 데이터 표현보다 더 강력한 검증 조건 표현 능력

## 부차 화제
- Open Library Books API: 외부 웹 서비스인 Open Library Books API의 책 정보 제공 기능과 API 응답 구조에 대한 설명

- Watchmen 예제: Open Library Books API의 실제 응답 예시로 Watchmen 책의 JSON 데이터 구조와 필드 정보

- ISBN 시스템: ISBN-10과 ISBN-13의 차이점, 출간 연도에 따른 ISBN 형식 변화(2007년 기준), 재출간 도서의 복수 ISBN 보유

- JSON Schema 논리 연산자: allOf(AND), anyOf(OR), oneOf(정확히 하나) 키워드를 사용한 스키마 조합 방법

- 스키마 분할 설계: 기본 도서 정보 스키마와 필수 ISBN 스키마를 분리하여 조합하는 모듈화 접근법

- 클래스 기반 데이터 표현의 한계: JSON Schema composition이 전통적인 클래스 기반 데이터 모델링보다 더 표현력이 뛰어나다는 비교 분석

- 데이터 검증 오류 처리: 복합 스키마 사용 시 검증 실패 원인 파악의 어려움에 대한 문제 제기
