# Chapter 1 핵심 내용 문서

## 목차 형태 핵심 내용 요약 (임베딩용)

### Chapter 1 전체 핵심 내용
**OOP의 구조적 복잡성과 DOP 대안의 필요성**: OOP는 객체 내 상태와 메서드 결합이라는 근본 설계로 인해 구조적 복잡성이 증가하며, 코드-데이터 분리, 불변성, 제네릭 접근을 통한 DOP 패러다임이 근본적 해결책

### Chapter Introduction 핵심 내용  
**OOP 복잡성의 근본 원인과 DOP 동기**: OOP 시스템의 복잡성은 객체에 상태와 메서드를 함께 구성하는 근본적 설계 철학에서 비롯되며, 기술적 보완책으로도 해결되지 않아 시스템 복잡성을 줄이는 DOP 패러다임 탐구가 필요

### Section 1.1 핵심 내용
**OOP 설계 과정과 겉보기 완전성**: Klafim 도서관 시스템 설계를 통해 OOP의 전형적 설계 과정(클래스 식별, UML 관계 정의, 상세 구조 설명)을 보여주며, 체계적이고 완전해 보이는 설계가 실제로는 복잡성 문제의 근원임을 암시

#### Section 1.1.1 핵심 내용
**체계적 OOP 설계의 시작**: 비즈니스 요구사항을 클래스로 매핑하고 주요 엔티티(Library, Book, Member 등)를 식별하는 전형적인 OOP 설계 과정이 이후 복잡성 문제의 씨앗이 됨

#### Section 1.1.2 핵심 내용  
**UML 관계의 복잡성**: 상속, 컴포지션, 연관, 사용 등 다양한 UML 관계들이 클래스 간 복잡한 의존성을 형성하여 시스템 이해를 어렵게 만드는 구조적 기반 제공

#### Section 1.1.3 핵심 내용
**클래스 상세 구조와 책임 분산**: 각 클래스의 데이터와 행동을 상세히 정의하는 과정에서 클래스 간 복잡한 관계가 형성되어 향후 계층구조 복잡성 문제의 직접적 원인이 됨

#### Section 1.1.4 핵심 내용
**설계에서 구현으로의 전환점**: 완벽해 보이는 설계 완료 후 구현 단계로의 이동이 실제 복잡성 문제들을 마주하는 시작점이 됨

### Section 1.2 핵심 내용
**OOP 복잡성의 4가지 근본 원인**: 코드-데이터 혼합(과다 관계), 가변성(예측 불가능성), 데이터 캡슐화(직렬화 어려움), 코드 캡슐화(유연성 부족)이 서로 연결되어 시스템 전체의 이해와 유지보수를 어렵게 만드는 구조적 문제

#### Section 1.2.1 핵심 내용
**코드-데이터 혼합으로 인한 과다 관계**: OOP에서 클래스에 코드와 데이터가 함께 존재하여 각 클래스가 많은 관계에 연루되며, 분리했을 때 두 개의 독립적이고 단순한 부분으로 나뉘어 이해가 쉬워짐

#### Section 1.2.2 핵심 내용
**가변 객체로 인한 예측 불가능한 동작**: 객체의 가변성으로 인해 동일한 코드도 실행 시점에 따라 다른 결과를 보이며, 멀티스레드 환경에서 더욱 예측 불가능해져 추가적인 동기화 메커니즘이 필요

#### Section 1.2.3 핵심 내용  
**데이터 캡슐화로 인한 직렬화 어려움**: 데이터가 클래스 멤버로 잠겨있어 제네릭한 접근이 불가능하고, JSON 직렬화 같은 단순한 작업도 매번 새로운 클래스와 코드가 필요한 비효율성

#### Section 1.2.4 핵심 내용
**코드 캡슐화로 인한 복잡한 계층구조**: 코드가 클래스에 잠겨있어 새로운 요구사항 추가 시 복잡한 상속 구조가 필요하고, 다중 상속으로 인한 다이아몬드 문제가 발생하여 시스템이 감당할 수 없을 정도로 복잡해짐

### Summary 핵심 내용
**OOP 복잡성 원인 총정리와 DOP 방향 제시**: OOP의 코드-데이터 혼합, 가변성, 캡슐화가 시스템 복잡성을 증가시키는 구조적 원인임을 확인하고, 분리와 불변성을 통한 DOP 접근법이 근본적 해결책임을 제시

---

## 상세 핵심 내용 (세부사항 검색용)

### Chapter Introduction 상세 분석

**OOP 복잡성의 본질적 특성**
- OOP 시스템의 복잡성은 특정 언어의 문법이나 의미론 문제가 아니라 객체에 상태와 메서드를 함께 구성하는 OOP의 근본적 통찰에서 비롯되는 구조적 문제
- 익명 클래스, 익명 함수 같은 언어 기능이나 Spring, Jackson 같은 프레임워크로 복잡성을 완화하려 했지만, 내부적으로는 리플렉션과 커스텀 어노테이션 같은 더 고급 기능에 의존하여 근본적 해결이 되지 못함
- 이 장의 목적은 OOP 비판이 아니라 복잡성 증가 경향에 대한 인식을 높여 시스템 복잡성을 줄이는 Data-Oriented Programming(DOP) 패러다임 발견을 동기부여하는 것

### Section 1.1 상세 분석

#### 1.1.1 The design phase 상세 내용
**전형적인 OOP 설계 접근법**
- Theo는 Klafim 도서관 시스템 설계 시 "모든 비즈니스 엔티티는 객체로, 모든 객체는 클래스로"라는 전형적인 OOP 사고방식을 적용
- 시스템 요구사항: 회원/사서 구분, 이메일/패스워드 로그인, 회원의 도서 대출, 제목/저자별 도서 검색, 사서의 회원 차단/해제, 사서의 회원별 대출 도서 조회, 도서의 복사본 관리, 물리적 도서관 소속

**클래스 식별과 관계 설정의 어려움**  
- 주요 클래스 식별: Library(중앙 클래스), Book(도서), BookItem(도서 복사본), BookLending(대출 기록), Member(회원), Librarian(사서), User(기본 사용자), Catalog(도서 목록), Author(저자)
- 클래스 식별은 상대적으로 쉬웠지만 클래스 간 관계 정의가 진짜 어려운 부분으로, 2시간 정도 소요되어 첫 번째 설계 초안 완성
- 이 설계는 의도적으로 naive하게 구성되었으며 경험 있는 OOP 개발자라면 디자인 패턴을 사용해 더 나은 설계를 할 수 있지만, 개발자에게는 코딩 시작에 충분하고 저자에게는 OOP 시스템의 복잡성을 보여주기에 충분

#### 1.1.2 UML 101 상세 내용
**UML 관계 유형의 복잡성**
- Composition 관계: 객체 생명주기가 의존적 - 한 객체가 죽으면 다른 객체도 죽음 (plain diamond + optional star)
  - Library-Catalog (일대일), Library-Member (일대다)
- Association 관계: 독립적인 객체 생명주기 - Book-Author 다대다 관계 (empty diamond + star at both edges)  
- Usage 관계: 한 클래스가 다른 클래스의 메서드 사용 - Librarian::blockMember가 Member::block 호출 (dashed arrow)
- Inheritance 관계: 클래스 상속 - Member와 Librarian이 User에서 상속 (plain arrow with empty triangle)

**관계 복잡성의 누적 효과**
- 각 관계 유형이 개별적으로는 이해 가능하지만, 시스템 전체에서는 여러 관계가 복합적으로 얽혀 복잡성을 기하급수적으로 증가시킴

#### 1.1.3 Explaining each piece 상세 내용  
**Library 클래스의 중앙 집권적 구조**
- Library 클래스는 시스템의 루트로서 모든 것을 소유하지만 직접적인 동작은 하지 않고 소유한 객체들에게 모든 것을 위임하는 구조
- 소유 관계: 다수의 Member 객체, 다수의 Librarian 객체, 단일 Catalog 객체

**User 기반 상속 구조의 한계**
- User 클래스: 최소한의 데이터(id, email, password)와 login 기능만 제공
- Member 클래스: User 상속, 추가 데이터 없음, checkout/returnBook/block/unblock/isBlocked 기능, BookLending 객체 소유, BookItem 사용
- Librarian 클래스: User 상속, 추가 데이터 없음, blockMember/unblockMember/getBookLendings/addBookItem 기능, Member/BookItem/BookLending 사용

**데이터 관리 클래스들의 복잡한 관계**
- Catalog 클래스: 도서 관리 책임, search/addBookItem 기능, Librarian 사용, Book 객체 소유
- Book 클래스: 최소 데이터(id, title), Author와 다대다 연관, BookItem 객체 소유  
- BookItem 클래스: 최소 데이터(id, libId), BookLending 객체 소유, checkout 기능

#### 1.1.4 Implementation phase 상세 내용
**설계 완성에 대한 만족과 구현 시작**
- Dave의 감탄과 Theo의 상세한 설계에 대한 자부심, 설계가 코딩 시간을 절약해줄 것이라는 믿음
- 설계에 몰입하느라 커피가 식었다는 디테일을 통해 설계 과정의 집중도를 보여주면서, 곧 시작될 구현 과정에서 마주할 현실적 문제들을 예고

### Section 1.2 상세 분석

#### 1.2 Introduction 상세 내용
**복잡성의 정의와 DOP의 위치**  
- 복잡성은 Ben Moseley와 Peter Marks의 "Out of the Tar Pit" 논문에서 정의한 "이해하기 어려운" 특성으로, 자원 소비량과는 무관한 개념
- 복잡성과 단순성은 절대적이 아닌 상대적 개념으로, 두 시스템을 비교하여 상대적 복잡도를 판단 가능
- DOP는 OOP와 FP 모두와 호환되며, OOP 시스템도 DOP 원칙을 따르면 덜 복잡해질 수 있음

**OOP 복잡성의 4가지 근본 원인**
- 코드와 데이터가 혼합: 클래스가 많은 관계에 연루됨  
- 객체가 가변적: 코드 동작 예측이 어려움
- 데이터가 객체에 잠김: 데이터 직렬화가 복잡함
- 코드가 클래스에 잠김: 클래스 계층구조가 복잡함

#### 1.2.1 Many relations 상세 내용
**코드-데이터 혼합의 구체적 문제점**
- 클래스 다이어그램 복잡성 평가 시 멤버와 메서드를 무시하고 엔티티와 관계만 봐도 복잡함이 드러남
- Member 클래스 분석: 5개 관계 연루 (Library-Member, Member-BookLending 데이터 관계 + Member-User 상속, Librarian-Member 사용, Member-BookItem 사용 코드 관계)

**분리를 통한 복잡성 해결**
- Member를 MemberCode(3개 관계)와 MemberData(2개 관계)로 분리하면 각각 더 단순해짐
- 전체 시스템을 코드 엔티티와 데이터 엔티티로 분리하면 두 개의 독립적인 부분으로 나뉘어 각각 별도로 이해 가능
- 독립적인 여러 단순 부분이 하나의 복잡한 부분보다 덜 복잡한 것은 논리적 필연

#### 1.2.2 Unpredictable behavior 상세 내용
**가변성으로 인한 예측 불가능성**
- 변수 할당 후 두 번 출력하는 코드(Listing 1.1)는 예측 가능: 첫 번째가 true면 두 번째도 true
- 객체 멤버를 직접 두 번 접근하는 코드(Listing 1.2)는 예측 불가능: 단일 스레드에서는 true이지만 멀티스레드에서는 context switch로 상태 변경 가능
- JavaScript같은 단일 스레드 환경에서도 비동기 코드로 인해 동일한 예측 불가능성 발생 가능

**해결책과 그 한계**
- OOP에서는 mutex 같은 동시성 안전 메커니즘 사용하지만 성능 저하와 데드락 위험 존재
- DOP에서는 원시 타입과 컬렉션 타입 모두를 불변값으로 처리하여 개발자에게 평온함을 제공하고 더 중요한 비즈니스 로직에 집중 가능

#### 1.2.3 Data serialization 상세 내용
**REST API 구현의 복잡함**
- Theo의 꿈 시나리오: Nancy가 JSON 기반 REST API 요구
- /search 엔드포인트 입력 예제: {"searchCriteria": "author", "query": "albert"}
- 출력 예제: 책 제목과 저자 정보를 포함한 JSON 배열

**반복적인 클래스 생성의 비효율성**
- 각 엔드포인트마다 3개 클래스 필요: Controller(쿼리 처리), Query(JSON → 데이터), Result(데이터 → JSON)
- /add-book-item 엔드포인트를 위해서도 동일한 패턴으로 3개 클래스 추가 필요
- JSON 직렬화/역직렬화 코드를 매번 새로 작성해야 하는 중복성

**근본적 문제와 해결 방향**
- 직렬화는 본질적으로 단순한 작업 (데이터 필드 순회, 이름과 값을 쉼표로 연결)이지만 OOP에서는 복잡
- 데이터가 클래스 멤버로 잠겨있어 제네릭한 접근이 불가능한 것이 근본 원인
- DOP에서는 제네릭한 데이터 접근 방법을 제공하여 이 문제를 해결 (구체적 방법은 후속 장에서 설명)

#### 1.2.4 Complex hierarchies 상세 내용
**상속을 통한 코드 재사용의 한계**
- 초기 설계에서는 User-Member-Librarian 상속 구조로 login 기능 공유가 잘 작동
- 하지만 새로운 요구사항 도입 시 (VIP 회원, Super 회원) 기존 상속 구조로는 대응 불가능

**VIP 회원 추가의 복잡성**
- VIP 회원 요구사항: 일반 회원이면서 도서 아이템 추가 권한 보유
- 문제점: Librarian의 addBookItem 코드가 클래스에 잠겨있어 재사용 불가
- VIP 회원과 Librarian의 비선형적 관계: 일부 기능은 같지만(도서 추가) 일부 기능은 다름(회원 차단, 대출 조회)

**다중 상속과 다이아몬드 문제**
- 해결책: UserWithBookItemRight 중간 클래스 도입, addBookItem 메서드 이동, VIPMember와 Librarian 모두 상속
- Super 회원 추가로 UserWithBlockMemberRight까지 필요하게 되어 3개의 "죽음의 다이아몬드" 발생
- 클래스 D가 B, C에서 상속받고 B, C 모두 A에서 상속받는 다중 상속 모호성 문제

**컴포지션 vs 상속과 현실적 한계**
- "컴포지션을 상속보다 선호하라"는 OOP 원칙이 있지만 데드라인 압박 상황에서는 적용 어려움
- 시스템이 너무 복잡해져서 Super 회원 기능을 포기하고 기본 기능만으로 출시하게 됨
- 기술적 부채가 쌓여 향후 기능 확장이 더욱 어려워지는 악순환

### Summary 상세 분석

**핵심 개념과 용어 정리**
- 복잡성 = 이해하기 어려운 특성 (자원 소비와 무관)
- 코드와 행동은 상호교환 가능한 용어
- DOP(Data-Oriented Programming), OOP(Object-Oriented Programming), FP(Functional Programming)
- UML 관계 표현법: 컴포지션(plain diamond), 연관(empty diamond), 사용(dashed arrow), 상속(empty triangle)

**OOP 복잡성의 구조적 원인들**
- 전통적인 OOP 시스템은 이해하기 어려운 복잡성을 증가시키는 경향
- 코드-데이터 혼합으로 클래스가 많은 관계에 연루됨
- 객체 가변성으로 코드 동작 이해에 추가적 사고 필요
- 멀티스레드 환경에서 명시적 동기화 메커니즘 필요
- 데이터 잠금으로 직렬화가 복잡함
- 코드 잠금으로 클래스 계층구조가 복잡함

**DOP의 해결책과 호환성**
- 코드와 데이터를 독립적인 두 부분으로 분리하면 시스템이 단순해짐
- 다수의 단순한 독립 부분이 하나의 복잡한 부분보다 덜 복잡
- 데이터 불변성이 개발자에게 평안함을 제공
- DOP는 OOP와 FP 모두와 호환 가능
- 디자인 패턴의 전략적 사용으로 전통적 OOP 복잡성을 어느 정도 완화 가능하지만 근본적 해결책은 아님

**현실적 제약과 미래 방향**  
- 대부분의 OOP 언어가 JSON 변환 어려움을 완화하려 하지만 리플렉션(복잡) 또는 코드 장황성이 필요
- DOP는 데이터에 대한 재사고를 통해 복잡성을 줄이는 근본적 접근법 제시
- 이론적 우수성과 현실적 적용 사이의 간극을 줄이는 것이 향후 과제