# 9.3.1 Persistent data structures in Java

**페이지**: 210-211
**계층**: Data-Oriented Programming (node0) > Part2—Scalability (node1) > 9 Persistent data structures (node2) > Chapter 9
**추출 시간**: 2025-08-06 19:47:06

---


--- 페이지 210 ---

182 CHAPTER 9 Persistent data structures
Theo That’s true: 2 to the power of 5 is 32.
Joe Back to our list of 100,000 elements, can you tell me how many operations are
required to access an element if the branching factor is 32?
Theo With a branching factor of 2, it was 16.6. If I divide 16.6 by 5, I get 3.3.
Joe Correct!
TIP By using a branching factor of 32, we make elements accessed in persistent lists
more efficient.
Theo Does this trick also improve the performance of updating an element in a list?
Joe Yes, indeed, it does.
Theo How? We’d have to copy 32 elements at each level instead of 2 elements. It’s a
16× performance hit that’s not compensated for by the fact that the tree depth
is reduced by 5×!
Joe I see that you are quite sharp with numbers. There is another thing to take
into consideration in our practical analysis of the performance: modern CPU
architecture.
Theo Interesting. The more you tell me about persistent data structures, the more I
understand why you wanted to have this session at a university: it’s because
we’re dealing with all this academic stuff.
Joe Yep. So, to continue, modern CPUs read and write data from and to the main
memory in units of cache lines, often 32 or 64 bytes long.
Theo What difference does that make?
Joe A nice consequence of this data access pattern is that copying an array of size
32 is much faster than copying 16 arrays of size 2 that belong to different levels
of the tree.
Theo Why is that?
Joe The reason is that copying an array of size 32 can be done in a single pair of
cache accesses: one for read and one for write. Although for arrays that belong
to different tree levels, each array requires its own pair of cache accesses, even
if there are only 2 elements in the array.
Theo In other words, the performance of updating a persistent list is dominated by
the depth of the tree.
TIP In modern CPU architectures, the performance of updating a persistent list is
dominated much more by the depth of the tree than by the number of nodes at each
level of the tree.
Joe That’s correct, up to a certain point. With today’s CPUs, using a branching fac-
tor of 64 would, in fact, decrease the performance of update operations.
Theo I see.
Joe Now, I am going to make another interesting claim that is not accurate from a
theoretical perspective but accurate in practice.
Theo What is it?

--- 페이지 210 끝 ---


--- 페이지 211 ---

9.2 The efficiency of persistent data structures 183
Joe The number of operations it takes to get or update an element in a persistent
list with branching factor 32 is constant.
Theo How can that be? You just made the point that the number of operations is
log32 N.
Joe Be patient, my friend. What is the highest number of elements that you can
have in a list, in practice?
Theo I don’t know. I never thought about that.
Joe Let’s assume that it takes 4 bytes to store an element in a list.
Theo OK.
Joe Now, can you tell me how much memory it would take to hold a list with 10 bil-
lion elements?
Theo You mean 1 with 10 zeros?
Joe Yes.
Theo Each element take 4 bytes, so it would be around 40 GB!
Joe Correct. Do you agree that it doesn’t make sense to hold a list that takes 40 GB
of memory?
Theo I agree.
Joe So let’s take 10 billion as an upper bound to the number of elements in a list.
What is log32 of 10 billion?
Once again, Theo uses the blackboard to clarify his thoughts. With that, he quickly finds
the answer.
Theo 1 billion is approximately 2^30. Therefore, 10 billion is around 2^33. That
means that log2 of 10 billion is 33, so log32 of 10 billion should be around
33/5, which is a bit less than 7.
Joe I am impressed again by your sharpness with numbers. To be precise, log32 of
10 billion is 6.64.
Theo (smiling) I didn’t get that far.
Joe Did I convince you that, in practice, accessing or updating an element in a per-
sistent list is essentially constant?
Theo Yes, and I find it quite amazing!
TIP Persistent lists can be manipulated in near constant time.
Joe Me too.
Theo What about persistent maps?
Joe It’s quite similar, but I don’t think we have time to discuss it now.
Startled, Theo looks at his watch. This morning’s session has gone by so quickly. He notices
that it’s time to get back to the office and have lunch.

--- 페이지 211 끝 ---
