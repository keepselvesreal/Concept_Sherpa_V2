# 9.4.4 Structural diff

**페이지**: 220-221
**계층**: Data-Oriented Programming (node0) > Part2—Scalability (node1) > 9 Persistent data structures (node2) > Chapter 9
**추출 시간**: 2025-08-06 19:47:08

---


--- 페이지 220 ---

192 CHAPTER 9 Persistent data structures
}
}
});
var result = UserManagement.addMember(userManagementStateBefore, jessie);
Immutable.isEqual(result, expectedUserManagementStateAfter);
// → true
Joe Great!
9.4.3 Serialization and deserialization
Theo Does Immutable.js also support JSON serialization and deserialization?
Joe It supports serialization out of the box. As for deserialization, we need to write
our own function.
Theo Does Immutable.js provide an Immutable.stringify() function?
Joe That’s not necessary because the native JSON.stringify() function works
with Immutable.js objects. Here’s another example.
Listing9.17 JSON serialization of an Immutable.js collection
var bookInfo = Immutable.fromJS({
"isbn": "978-1779501127",
"title": "Watchmen",
"authorNames": ["Alan Moore",
"Dave Gibbons"]
});
JSON.stringify(bookInfo);
// → {\"isbn\":\"978-1779501127\",\"title\":\"Watchmen\",
// → \"authorNames\":[\"Alan Moore\",\"Dave Gibbons\"]}
Theo How does JSON.stringify() know how to handle an Immutable.js collection?
Joe As an OOP developer, you shouldn’t be surprised by that.
Theo Hmm...let me think a minute. OK, here’s my guess. Is that because JSON
.stringify() calls some method on its argument?
Joe Exactly! If the object passed to JSON.stringify() has a .toJSON() method,
it’s called by JSON.stringify().
Theo Nice. What about JSON deserialization?
Joe That needs to be done in two steps. You first convert the JSON string to a Java-
Script object and then to an immutable collection.
Theo Something like this piece of code?
Listing9.18 Converting a JSON string into an immutable collection
Immutable.parseJSON = function(jsonString) {
return Immutable.fromJS(JSON.parse(jsonString));
};
Joe Exactly.

--- 페이지 220 끝 ---


--- 페이지 221 ---

9.4 Persistent data structures in action 193
9.4.4 Structural diff
Theo So far, we have ported pieces of code that dealt with simple data manipula-
tions. I’m curious to see how it goes with complex data manipulations such as
the code that computes the structural diff between two maps.
 NOTE Chapter 5 introduces structural diff.
Joe That also works smoothly, but we need to port another eight functions.
Listing9.19 Porting Lodash functions involved in structural diff computation
Immutable.reduce = function(coll, reducer, initialReduction) {
return coll.reduce(reducer, initialReduction);
};
Immutable.isEmpty = function(coll) {
return coll.isEmpty();
};
Immutable.keys = function(coll) {
return coll.keySeq();
};
Immutable.isObject = function(coll) {
return Immutable.Map.isMap(coll);
};
Immutable.isArray = Immutable.isIndexed;
Immutable.union = function() {
return Immutable.Set.union(arguments);
};
Theo Everything looks trivial with one exception: the use of arguments in Immutable
.union.
Joe In JavaScript, arguments is an implicit array-like object that contains the values
of the function arguments.
Theo I see. It’s one of those pieces of JavaScript magic!
Joe Yep. We need to use arguments because Lodash and Immutable.js differ slightly
in the signature of the union function. Immutable.Set.union receives an array
of lists, whereas a Lodash _.union receives several arrays.
Theo Makes sense. Let me give it a try.
Blowing on his fingers like a seasoned safecracker, first one hand and then the next, Theo
begins typing. Once again, Theo is surprised to discover that after replacing the _ with
Immutable in listing 9.20, the tests pass with the code in listing 9.21.
Listing9.20 Implementing structural diff with persistent data structures
function diffObjects(data1, data2) {
var emptyObject = Immutable.isArray(data1) ?
Immutable.fromJS([]) :

--- 페이지 221 끝 ---
