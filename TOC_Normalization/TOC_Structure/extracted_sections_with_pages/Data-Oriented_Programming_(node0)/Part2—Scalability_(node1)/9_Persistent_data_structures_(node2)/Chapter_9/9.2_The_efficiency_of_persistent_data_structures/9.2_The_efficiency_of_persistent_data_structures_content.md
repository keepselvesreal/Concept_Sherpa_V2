# 9.2 The efficiency of persistent data structures

**페이지**: 206-207
**계층**: Data-Oriented Programming (node0) > Part2—Scalability (node1) > 9 Persistent data structures (node2) > Chapter 9
**추출 시간**: 2025-08-06 19:47:05

---


--- 페이지 206 ---

178 CHAPTER 9 Persistent data structures
return Object.freeze(object);
}
Theo I see that it’s possible to ensure that data is never mutated, which answers my
concerns about safety. Now, let me share my concerns about performance.
TIP It’s possible to manually ensure that our data isn’t mutated, but it’s cumbersome.
Joe Sure.
Theo If I understand correctly, the main idea behind structural sharing is that most
data is usually shared between two versions.
Joe Correct.
Theo This insight allows us to create new versions of our collections using a shallow
copy instead of a deep copy, and you claimed that it was efficient.
Joe Exactly!
Theo Now, here is my concern. In the case of a collection with many entries, a shal-
low copy might be expensive.
Joe Could you give me an example of a collection with many entries?
Theo A catalog with 100,000 books, for instance.
Joe On my machine, making a shallow copy of a collection with 100,000 entries
doesn’t take more than 50 milliseconds.
Theo Sometimes, even 50 milliseconds per update isn’t acceptable.
Joe I totally agree with you. When one needs data immutability at scale, naive struc-
tural sharing is not appropriate.
Theo Also, shallow copying an array of 100,000 elements on each update would
increase the program memory by 100 KB.
Joe Indeed, at scale, we have a problem both with memory and computation.
TIP At scale, naive structural sharing causes a performance hit, both in terms of
memory and computation.
Theo Is there a better solution?
Joe Yes! For that, you’ll need to learn the real way to handle immutability. It’s
called persistent data structures.
9.2 The efficiency of persistent data structures
Theo In what sense are those data structures persistent?
Joe Persistent data structures are so named because they always preserve their pre-
vious versions.
TIP Persistent data structures always preserve the previous version of themselves
when they are modified.
Joe Persistent data structures address the two main limitations of naive structural
sharing: safety and performance.

--- 페이지 206 끝 ---


--- 페이지 207 ---

9.2 The efficiency of persistent data structures 179
Theo Let’s start with safety. How do persistent data structures prevent data from
being mutated accidentally?
Joe In a language like Java, they implement the mutation methods of the collec-
tion interfaces by throwing the run-time exception UnsupportedOperation-
Exception.
Theo And, in a language like JavaScript?
Joe In JavaScript, persistent data structures provide their own methods to access
data, and none of those methods mutate data.
Theo Does that mean that we can’t use the dot notation to access fields?
Joe Correct. Fields of persistent data structures are accessed via a specific API.
Theo What about efficiency? How do persistent data structures make it possible to
create a new version of a huge collection in an efficient way?
Joe Persistent data structures organize data in such a way that we can use structural
sharing at the level of the data structure.
Theo Could you explain?
Joe Certainly. Let’s start with the simplest data structure: a linked list. Imagine that
you have a linked list with 100,000 elements.
Theo OK.
Joe What would it take to prepend an element to the head of the list?
Theo You mean to create a new version of the list with an additional element?
Joe Exactly!
Theo Well, we could copy the list and then prepend an element to the list, but it
would be quite expensive.
Joe What if I tell you that the original linked list is guaranteed to be immutable?
Theo In that case, I could create a new list with a new head that points to the head of
the original list.
Theo goes to the classroom blackboard. He picks up a piece of chalk and draws the dia-
gram shown in figure 9.1.
New list Original list
Figure 9.1 Structural sharing
0 1 2 3 4 5 with linked lists
Joe Would the efficiency of this operation depend on the size of the list?
Theo No, it would be efficient, no matter the size of the list.
Joe That’s what I mean by structural sharing at the level of the data structure itself.
It relies on a simple but powerful insight—when data is immutable, it is safe to
share it.
TIP When data is immutable, it is safe to share it.

--- 페이지 207 끝 ---
