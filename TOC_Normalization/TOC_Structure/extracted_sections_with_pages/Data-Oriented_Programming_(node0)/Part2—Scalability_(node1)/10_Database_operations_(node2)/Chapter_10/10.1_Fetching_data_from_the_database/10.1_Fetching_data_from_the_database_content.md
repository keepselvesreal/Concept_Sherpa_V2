# 10.1 Fetching data from the database

**페이지**: 228-231
**계층**: Data-Oriented Programming (node0) > Part2—Scalability (node1) > 10 Database operations (node2) > Chapter 10
**추출 시간**: 2025-08-06 19:47:09

---


--- 페이지 228 ---

200 CHAPTER 10 Database operations
Joe Great! Let’s start with the simplest case. We’re going to write code that searches
for books matching a title and that returns basic information about the books.
By basic information, I mean title, ISBN, and publication year.
Theo What about the book authors?
Joe We’ll deal with that later, as it’s a bit more complicated. Can you write an SQL
query for retrieving books that contain he word habit in their title?
Theo Sure.
This assignment is quite easy for Theo. First, he jots down the SQL query, then he displays
the results in table 10.4.
Listing10.1 SQL query to retrieve books whose title contains habit
SELECT
title,
isbn,
publication_year
FROM
books
WHERE title LIKE '%habit%';
Table 10.4 Results of the SQL query for books whose title contains the word habit
title isbn publication_year
The Power of Habit 978-0812981605 2012
7 Habits of Highly Effective People 978-1982137274 1989
Joe How would you describe these results as a data collection?
Theo I would say it’s a list of maps.
TIP In DOP, accessing data from a NoSQL database is similar to the way we access
data from a relational database.
Joe Right! Now, can you write the search results as a list of maps?
Theo It doesn’t sound too complicated. How about this?
Listing10.2 Search results as a list of maps
[
{
"title": "7 Habits of Highly Effective People",
"isbn": "978-1982137274",
"publication_year": 1989
},
{
"title": "The Power of Habit",
"isbn": "978-0812981605",
"publication_year": 2012
}
]

--- 페이지 228 끝 ---


--- 페이지 229 ---

10.1 Fetching data from the database 201
Joe What about the JSON schema for the search results?
Theo It shouldn’t be too difficult if you allow me to take a look at the JSON schema
cheat sheet you kindly offered me the other day.
Joe Of course. The purpose of a gift is to be used by the one who receives it.
Theo takes a look at the JSON Schema cheat sheet to refresh his memory about the JSON
Schema syntax. After a few minutes, Theo comes up with a schema for the search results.
He certainly is putting Joe’s gift to good use.
Listing10.3 JSON schema cheat sheet
{
"type": "array",
"items": {
"type": "object",
"properties": {
"myNumber": {"type": "number"},
"myString": {"type": "string"},
"myEnum": {"enum": ["myVal", "yourVal"]},
"myBool": {"type": "boolean"}
},
"required": ["myNumber", "myString"],
"additionalProperties": false
}
}
Listing10.4 The JSON schema for search results from the database
var dbSearchResultSchema = {
"type": "array",
"items": {
"type": "object",
"required": ["title", "isbn", "publication_year"],
"properties": {
"title": {"type": "string"},
"isbn": {"type": "string"},
"publication_year": {"type": "integer"}
}
}
};
Joe Excellent. Now I’m going to show you how to implement searchBooks in a
way that fetches data from the database and returns a JSON string with the
results. The cool thing is that we’re only going to use generic data collections
from the database layer down to the JSON serialization.
Theo Will it be similar to the implementation of searchBooks that we wrote when
you taught me the basis of DOP?
Joe Absolutely. The only difference is that then the state of the system was stored
locally, and we queried it with a function like _.filter. Now, we use SQL

--- 페이지 229 끝 ---


--- 페이지 230 ---

202 CHAPTER 10 Database operations
queries to fetch the state from the database. In terms of data representation
and manipulation, it’s exactly the same.
Joe goes to the whiteboard and sketches out the data flow in figure 10.2. Theo studies the
diagram.
Database
Database driver
Data (list of maps)
Data manipulation
Data Figure 10.2 Data flow for serving
a request that fetches data from
JSON serialize
the database
Joe The data manipulation step in the diagram is implemented via generic func-
tions that manipulate data collections. As our examples get more elaborate, I
think you’ll see the benefits of being able to manipulate data collections with
generic functions.
Theo Sounds intriguing...
Joe For the communication with the database, we use a driver that returns a list of
maps. In JavaScript, you could use an SQL driver like node-postgres.
 NOTE See https://node-postgres.com for more information about this collection of
node.js modules for interfacing with PostgreSQL databases.
Theo And in Java?
Joe In Java, you could use JDBC (Java database connectivity) in addition to a small
utility function that converts a JDBC result set into a list of maps. If I can use
your laptop, I’ll show you what I mean.
Joe pulls a piece of code from one of his personal GitHub repositories. He then shows the
code for the JDBC conversion to Theo, who seems a bit surprised.
Listing10.5 Converting a JDBC result set into a list of hash maps
List<Map<String, Object>> convertJDBCResultSetToListOfMaps(ResultSet rs) {
List<Map<String, Object>> listOfMaps =
new ArrayList<Map<String, Object>>();
ResultSetMetaData meta = rs.getMetaData();
while (rs.next()) {
Map map = new HashMap();
for (int i = 1; i <= meta.getColumnCount(); i++) {
String key = meta.getColumnLabel(i);
Object value = rs.getObject(i);

--- 페이지 230 끝 ---


--- 페이지 231 ---

10.1 Fetching data from the database 203
map.put(key, value);
}
listOfMaps.add(map);
}
return listOfMaps;
}
TIP Converting a JDBC result set into a list of hash maps is quite straightforward.
Theo I expected it to be much more complicated to convert a JDBC result set into a
list of hash maps.
Joe It’s straightforward because, in a sense, JDBC is data-oriented.
Theo What about the field types?
Joe When we convert a JDBC result set into a list of maps, each value is considered
an Object.
Theo That’s annoying because it means that in order to access the value, we need to
cast it to its type.
Joe Yes and no. Look at our book search use case. We pass all the values along with-
out really looking at their type. The concrete value type only matters when we
serialize the result into JSON and that’s handled by the JSON serialization
library. It’s called late binding.
 NOTE With late binding, we defer dealing with data types as long as possible.
Theo Does that mean in my application that I’m allowed to manipulate data without
dealing with concrete types?
TIP In DOP, flexibility is increased as many parts of the system are free to manipulate
data without dealing with concrete types.
Joe Exactly. You’ll see late binding in action in a moment. That’s one of the great-
est benefits of DOP.
Theo Interesting, I can’t wait to see that!
Joe One last thing before I show you the code for retrieving search results from the
database. In order to make it easier to read, I’m going to write JavaScript code
as if JavaScript were dealing with I/O is a synchronous way.
Theo What do you mean?
Joe In JavaScript, an I/O operation like sending a query to the database is done
asynchronously. In real life, it means using either callback functions or using
async and await keywords.
Theo Oh yeah, that’s because JavaScript is single-threaded.
 NOTE For sake of simplicity, the JavaScript snippets in this chapter are written as if
JavaScript were dealing with I/O in a synchronous way. In real-life JavaScript, we need
to use async and await around I/O calls.
Joe Indeed, so I’ll be writing the code that communicates with the database as
though JavaScript were dealing with I/O synchronously. Here’s an example.

--- 페이지 231 끝 ---
