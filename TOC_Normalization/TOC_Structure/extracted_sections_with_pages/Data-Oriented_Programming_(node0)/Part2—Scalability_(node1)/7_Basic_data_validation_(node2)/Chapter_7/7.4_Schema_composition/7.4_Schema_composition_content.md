# 7.4 Schema composition

**페이지**: 181-183
**계층**: Data-Oriented Programming (node0) > Part2—Scalability (node1) > 7 Basic data validation (node2) > Chapter 7
**추출 시간**: 2025-08-06 19:47:02

---


--- 페이지 181 ---

7.3 Schema flexibility and strictness 153
Joe Is it a valid database response?
Theo No. A database response should not have a dummy_property field. It should
have only the three required fields specified in the schema.
Joe It might be surprising but, by default, fields not specified in the schema of an
object are allowed in JSON Schema. In order to disallow them, one has to set
additionalProperties to false like this.
Listing7.15 Disallowing properties not mentioned in the schema
var booksFromDBSchema = {
"type": "array",
"items": {
"type": "object",
"required": ["title", "isbn", "available"],
"additionalProperties": false,
"properties": {
"title": {"type": "string"},
"available": {"type": "boolean"},
"isbn": {"type": "string"}
}
}
};
TIP In JSON Schema, by default, fields not specified in the schema of a map are
allowed.
Theo Why is that?
Joe The reason is that usually having additional fields in a map doesn’t cause
trouble. If your code doesn’t care about a field, it simply ignores it. But some-
times we want to be as strict as possible, and we set additionalProperties
to false.
Theo What about the search request and response schema from the previous discus-
sions? Should we set additionalProperties to false?
Joe That’s an excellent question. I’d say it’s a matter of taste. Personally, I like to
allow additional fields in requests and disallow them in responses.
Theo What’s the advantage?
Joe Well, the web server is responsible for the responses it sends to its clients. It
makes sense then to be as strict as possible. However, the requests are created
by the clients, and I prefer to do my best to serve my clients even when they are
not as strict as they should be.
Theo Naturally. “The client is always right.”
Joe Actually, I prefer the way Jon Postel formulated his robustness principle: “Be
conservative in what you send, be liberal in what you accept.”
TIP It’s a good practice to be strict with the data that you send and to be flexible with
the data that you receive.

--- 페이지 181 끝 ---


--- 페이지 182 ---

154 CHAPTER 7 Basic data validation
7.4 Schema composition
Theo What about validating data that comes from an external web service?
Joe Can you give me an example?
Theo In the near future, we’ll have to integrate with a service called Open Library
Books API that provides detailed information about books.
 NOTE For information on the Open Library Books API, see https://openlibrary
.org/dev/docs/api/books.
Joe Can you show me, for instance, the service response for Watchmen?
Theo Sure. Here you go.
Theo taps a few keys on his keyboard and brings up the response. Joe looks at the JSON for
a long time.
Listing7.16 An Open Library Books API response example
{
"publishers": [
"DC Comics"
],
"number_of_pages": 334,
"weight": "1.4 pounds",
"physical_format": "Paperback",
"subjects": [
"Graphic Novels",
"Comics & Graphic Novels",
"Fiction",
"Fantastic fiction"
],
"isbn_13": [
"9780930289232"
],
"title": "Watchmen",
"isbn_10": [
"0930289234"
],
"publish_date": "April 1, 1995",
"physical_dimensions": "10.1 x 6.6 x 0.8 inches"
}
Theo asks himself, “What could be so special in this JSON?” While Joe is meditating about
this piece of JSON, Theo writes the JSON Schema for the Books API response. It doesn’t
seem to be more complicated than any of the previous schemas. When Theo is done, he
asks Joe to take a look at the schema.
Listing7.17 Schema of the Open Library Books API response
{
"type": "object",
"required": ["title"],

--- 페이지 182 끝 ---


--- 페이지 183 ---

7.4 Schema composition 155
"properties": {
"title": {"type": "string"},
"publishers": {
"type": "array",
"items": {"type": "string"}
},
"number_of_pages": {"type": "integer"},
"weight": {"type": "string"},
"physical_format": {"type": "string"},
"subjects": {
"type": "array",
"items": {"type": "string"}
},
"isbn_13": {
"type": "array",
"items": {"type": "string"}
},
"isbn_10": {
"type": "array",
"items": {"type": "string"}
},
"publish_date": {"type": "string"},
"physical_dimensions": {"type": "string"}
}
}
Joe Good job!
Theo That wasn’t so hard. I really don’t see why you looked at this JSON response for
such a long time.
Joe Well, it has to do with the isbn_10 and isbn_13 fields. I assume that they’re
not both mandatory.
Theo Right! That’s why I didn’t include them in the required field of my schema.
Joe But one of them should always be there. Right?
Theo Sometimes one of them and sometimes both of them, like for Watchmen. It
depends on the publication year of the book. Books published before 2007
have isbn_10, and books published after 2007 have isbn_13.
Joe Oh, I see. And Watchmen has both because it was originally published in 1986
but published again after 2007.
Theo Correct.
Joe Then, you need your schema to indicate that one of the isbn fields is man-
datory. That’s a good opportunity for me to tell you about JSON Schema
composition.
Theo What’s that?
Joe It’s a way to combine schemas, similarly to how we combine logical conditions
with AND, OR, and NOT.
Theo I’d like to see that.
Joe Sure. How would you express the schema for the Books API response as a
composition of three schemas: basicBookInfoSchema, the schema that you
wrote where only title is required; mandatoryIsbn13, a schema where only

--- 페이지 183 끝 ---
