# 8.4 State management with atoms

**페이지**: 198-199
**계층**: Data-Oriented Programming (node0) > Part2—Scalability (node1) > 8 Advanced concurrency control (node2) > Chapter 8
**추출 시간**: 2025-08-06 19:47:04

---


--- 페이지 198 ---

170 CHAPTER 8 Advanced concurrency control
Listing8.5 Using an Atom in Java
Atom<Integer> counter = new Atom<Integer>();
counter.set(0);
counter.swap(x -> x + 1);
counter.get();
Theo takes a couple of minutes to meditate about this atom stuff and to digest what he’s
just learned. Then, he asks Joe:
Theo What if swap never succeeds? I mean, could the while loop inside the code of
swap turn out to be an infinite loop?
Joe No! By definition, when atomicCompareAndSet fails on a thread, it means that
the same atom was changed on another thread during the execution of swap.
In this race between threads, there is always a winner.
Theo But isn’t it possible that some thread never succeeds because it always loses the
race against other threads?
Joe In theory, yes, but I’ve never encountered such a situation. If you have thou-
sands of threads that do nothing besides swapping an atom, it could happen I
suppose. But, in practice, once the atom is swapped, the threads do some real
work, for example, database access or I/O. This gives other threads the oppor-
tunity to swap the atom successfully.
 NOTE In theory, atoms could create starvation in a system with thousands of threads
that do nothing beside swapping an atom. In practice, once an atom is swapped, the
threads do some real work (e.g., database access), which creates an opportunity for
other threads to swap the atom successfully.
Theo Interesting.... Indeed, atoms look much easier to manage than locks.
Joe Now let me show you how to use atoms with composite data.
Theo Why would that be different?
Joe Usually, dealing with composite data is more difficult than dealing with primi-
tive types.
Theo When you sold me on DOP, you told me that we are able to manage data with
the same simplicity as we manage numbers.
TIP In DOP, data is managed with the same simplicity as numbers.
Joe That’s exactly what I am about to show you.
8.3 Thread-safe cache with atoms
Joe Are you familiar with the notion of in-memory cache?
Theo You mean memoization?

--- 페이지 198 끝 ---


--- 페이지 199 ---

8.3 Thread-safe cache with atoms 171
Joe Kind of. Imagine that database queries don’t vary too much in your applica-
tion. It makes sense in that case to store the results of previous queries in mem-
ory in order to improve the response time.
Theo Yes, of course!
Joe What data structure would you use to store the in-memory cache?
Theo Probably a string map, where the keys are the queries, and the values are the
results from the database.
TIP It’s quite common to represent an in-memory cache as a string map.
Joe Excellent! Now can you write the code to cache database queries in a thread-
safe way using a lock?
Theo Let me see: I’m going to use an immutable string map. Therefore, I don’t
need to protect read access with a lock. Only the cache update needs to be
protected.
Joe You’re getting the hang of this!
Theo The code should be something like this.
Listing8.6 Thread-safe cache with locks
var mutex = new Mutex();
var cache = {};
function dbAccessCached(query) {
var resultFromCache = _.get(cache, query);
if (resultFromCache != nil) {
return resultFromCache;
}
var result = dbAccess(query);
mutex.lock();
cache = _.set(cache, query, result);
mutex.unlock();
return result;
}
Joe Nice! Now, let me show you how to write the same code using an atom instead
of a lock. Take a look at this code and let me know if it’s clear to you.
Listing8.7 Thread-safe cache with atoms
var cache = new Atom();
cache.set({});
function dbAccessCached(query) {
var resultFromCache = _.get(cache.get(), query);
if (resultFromCache != nil) {
return resultFromCache;
}
var result = dbAccess(query);
cache.swap(function(oldCache) {

--- 페이지 199 끝 ---
