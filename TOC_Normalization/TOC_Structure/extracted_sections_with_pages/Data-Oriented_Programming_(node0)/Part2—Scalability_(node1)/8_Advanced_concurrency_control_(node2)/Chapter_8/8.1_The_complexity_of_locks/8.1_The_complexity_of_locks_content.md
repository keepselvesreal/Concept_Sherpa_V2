# 8.1 The complexity of locks

**페이지**: 192-193
**계층**: Data-Oriented Programming (node0) > Part2—Scalability (node1) > 8 Advanced concurrency control (node2) > Chapter 8
**추출 시간**: 2025-08-06 19:47:03

---


--- 페이지 192 ---

164 CHAPTER 8 Advanced concurrency control
8.1 The complexity of locks
This Sunday afternoon, while riding his bike across the Golden Gate Bridge, Theo thinks
about the Klafim project with concern, not yet sure that betting on DOP was a good
choice. Suddenly, Theo realizes that he hasn’t yet scheduled the next session with Joe. He
gets off his bike to call Joe. Bad luck, the line is busy.
When Theo gets home, he tries to call Joe again, but once again the phone is busy. After
dinner, Theo tries to call Joe one more time, with the same result—a busy signal. “Obvi-
ously, Joe is very busy today,” Theo tells himself. Exhausted by his 50-mile bike ride at an
average of 17 miles per hour, he falls asleep on the sofa. When Theo wakes up, he’s elated
to see a text message from Joe, “See you Monday morning at 11 AM?” Theo answers with a
thumbs up and prepares for another week of work.
When Joe arrives at the office, Theo asks him why his phone was constantly busy the day
before. Joe answers that he was about to ask Theo the same question. They look at each
other, puzzled, and then simultaneously break into laughter as they realize what hap-
pened: in an amazing coincidence, they’d tried to phone each other at exactly the same
times. They both say at once:
“A deadlock!”
They both head for Theo’s office. When they get to Theo’s desk, Joe tells him that today’s
session is going to be about concurrency management in multi-threaded environments.
Joe How do you usually manage concurrency in a multi-threaded environment?
Theo I protect access to critical sections with a lock mechanism, a mutex, for instance.
Joe When you say access, do you mean write access or also read access?
Theo Both!
Joe Why do you need to protect read access with a lock?
Theo Because, without a lock protection, in the middle of a read, a write could hap-
pen in another thread. It would make my read logically inconsistent.
Joe Another option would be to clone the data before processing it in a read.
Theo Sometimes I would clone the data; but in many cases, when it’s large, it’s too
expensive to clone.
TIP Cloning data to avoid read locks doesn’t scale.
Joe In DOP, we don’t need to clone or to protect read access.
Theo Because data is immutable?
Joe Right. When data is immutable, even if a write happens in another thread
during a read, it won’t make the read inconsistent because the write never
mutates the data that is read.
Theo In a sense, a read always works on a data snapshot.
Joe Exactly!
TIP When data is immutable, a read is always safe.
Theo But what about write access? Don’t you need to protect that with locks?
Joe Nope.

--- 페이지 192 끝 ---


--- 페이지 193 ---

8.2 Thread-safe counter with atoms 165
Theo Why not?
Joe We have a simpler mechanism—it’s called an atom.
Theo I am glad to hear there is a something simpler than locks. I really struggle each
time I have to integrate locks into a multi-threaded system.
Joe Me too! I remember a bug we had in production 10 years ago. We forgot to
release a lock when an exception was thrown in a critical section. It caused a
terrible deadlock.
Theo Deadlocks are really hard to avoid. Last year, we had a deadlock issue when two
locks were not released in the proper order.
Joe I have great news for you. With atoms, deadlocks never happen!
TIP With atoms, deadlocks never happen.
Theo That sounds great. Tell me more!
TIP Atoms provide a way to manage concurrency without locks.
8.2 Thread-safe counter with atoms
Joe Let’s start with a simple case: a counter shared between threads.
Theo What do you mean by a counter?
Joe Imagine that we’d like to count the number of database accesses and write the
total number of accesses to a log every minute.
Theo OK.
Joe Could you write JavaScript code for this multi-threaded counter using locks?
Theo But JavaScript is single-threaded!
Joe I know, but it’s just for the sake of illustration. Imagine that JavaScript were
multi-threaded and that it provided a Mutex object that you could lock and
unlock.
Theo It’s a bit awkward. I guess it would look like this.
Theo goes to the whiteboard. He writes what he imagines to be JavaScript code for a multi-
threaded counter with locks.
Listing8.1 A thread-safe counter protected by a mutex
var mutex = new Mutex();
var counter = 0;
function dbAccess() {
mutex.lock();
counter = counter + 1;
mutex.unlock();
// access the database
}
function logCounter() {
mutex.lock();

--- 페이지 193 끝 ---
