# 8.2 Thread-safe counter with atoms

**페이지**: 194-195
**계층**: Data-Oriented Programming (node0) > Part2—Scalability (node1) > 8 Advanced concurrency control (node2) > Chapter 8
**추출 시간**: 2025-08-06 19:47:03

---


--- 페이지 194 ---

166 CHAPTER 8 Advanced concurrency control
console.log('Number of database accesses: ' + counter);
mutex.unlock();
}
Joe Excellent. Now, I am going to show you how to write the same code with atoms.
An atom provides three methods:
 get returns the current value of the atom.
 set overwrites the current value of the atom.
 swap receives a function and updates the value of the atom with the result
of the function called on the current value of the atom.
Joe unzips a pocket in his laptop case and takes out a piece of paper. He hands it to
Theo. Theo is pleasantly surprised as the sheet of paper succinctly describes the methods
(table 8.1).
Table 8.1 The three methods of an atom
Method Description
get Returns the current value
set Overwrites the current value
swap Updates the current value with a function
Theo How would it look like to implement a thread-safe counter with an atom?
Joe It’s quite simple, actually.
Joe pulls out his laptop, fires it up, and begins to type. When he’s done, he turns the laptop
around so that Theo can see the code to implement a thread-safe counter in an atom.
Listing8.2 A thread-safe counter stored in an atom
var counter = new Atom();
counter.set(0);
function dbAccess() {
counter.swap(function(x) {
The argument x is the
return x + 1;
current value of the atom,
});
same as counter.get().
// access the database
}
function logCounter() {
console.log('Number of database accesses: ' + counter.get());
}
Theo Could you tell me what’s going on here?
Joe Sure! First, we create an empty atom. Then, we initialize the value of the atom
with counter.set(0). In the logger thread, we read the current value of the
atom with counter.get().
Theo And how do you increment the counter in the threads that access the database?

--- 페이지 194 끝 ---


--- 페이지 195 ---

8.2 Thread-safe counter with atoms 167
Joe We call swap with a function that receives x and returns x + 1.
Theo I don’t understand how swap could be thread-safe without using any locks.
Joe quickly goes to the whiteboard. He sketches the diagram in figure 8.1.
Take snapshot
Compute next state
Yes
State changed?
No
Update state
Figure 8.1 High-level flow of swap
Joe You see, swap computes the next value of the atom, and before modifying the
current value of the atom, it checks whether the value of the atom has changed
during the computation. If so, swap tries again, until no changes occur during
the computation.
Theo Is swap easy to implement?
Joe Let me show you the implementation of the Atom class and you’ll see.
Listing8.3 Implementation of the Atom class
class Atom {
state;
constructor() {}
get() {
return this.state;
}
set(state) {
this.state = state;
}
swap(f) {
while(true) {
var stateSnapshot = this.state;
var nextState = f(stateSnapshot);
if (!atomicCompareAndSet(this.state,

--- 페이지 195 끝 ---
