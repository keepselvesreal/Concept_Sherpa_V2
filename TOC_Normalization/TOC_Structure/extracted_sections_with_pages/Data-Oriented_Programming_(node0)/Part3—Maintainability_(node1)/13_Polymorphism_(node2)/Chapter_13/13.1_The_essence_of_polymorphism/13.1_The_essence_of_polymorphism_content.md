# 13.1 The essence of polymorphism

**페이지**: 303-305
**계층**: Data-Oriented Programming (node0) > Part3—Maintainability (node1) > 13 Polymorphism (node2) > Chapter 13
**추출 시간**: 2025-08-06 19:47:20

---


--- 페이지 303 ---

13.1 The essence of polymorphism 275
Dave How would animal look, exactly?
Theo Like I just said, a map with two fields: name and type. Let me input that for you.
Listing13.3 Representing animals with maps
var myDog = {
"type": "dog",
"name": "Fido"
};
var myCat = {
"type": "cat",
"name": "Milo"
};
var myCow = {
"type": "cow",
"name": "Clarabelle"
};
Dave Could you have given another name to the field that holds the animal type?
Theo Absolutely. It could be anything.
Dave I see. You’re asking me the fundamental difference between your code with a
switch statement and my code with an interface and three classes?
Theo Exactly.
Dave First of all, if you pass an invalid map to your greet function, bad things will
happen.
Theo You’re right. Let me fix that and validate input data.
Listing13.4 Data validation
var animalSchema = {
"type": "object",
"properties": {
"name": {"type": "string"},
"type": {"type": "string"}
},
"required": ["name", "type"],
};
See chapter 12 about
data validation for
function greet(animal) {
details.
if(dev()) {
if(!ajv.validate(animalSchema, animal)) {
var errors = ajv.errorsText(ajv.errors);
throw ("greet called with invalid arguments: " + errors);
}
}
switch (animal.type) {
case "dog":

--- 페이지 303 끝 ---


--- 페이지 304 ---

276 CHAPTER 13 Polymorphism
console.log("Woof Woof! My name is: " + animal.name);
break;
case "cat":
console.log("Meow! I am: " + animal.name);
break;
case "cow":
console.log("Moo! Call me " + animal.name);
break;
};
}
 NOTE You should not use switch statements like this in your production code.
We use them here for didactic purposes only as a step towards distilling the essence of
polymorphism.
Dave Another drawback of your approach is that when you want to modify the
implementation of greet for a specific animal, you have to change the code
that deals with all the animals, while in my approach, you would change only a
specific animal class.
Theo I agree, and I could also fix that by having a separate function for each animal,
something like this.
Listing13.5 Different implementations in different functions
function greetDog(animal) {
console.log("Woof Woof! My name is: " + animal.name);
}
function greetCat(animal) {
console.log("Meow! I am: " + animal.name);
}
function greetCow(animal) {
console.log("Moo! Call me " + animal.name);
}
function greet(animal) {
if(dev()) {
if(!ajv.validate(animalSchema, animal)) {
var errors = ajv.errorsText(ajv.errors);
throw ("greet called with invalid arguments: " + errors);
}
}
switch (animal.type) {
case "dog":
greetDog(animal);
break;
case "cat":
greetCat(animal);
break;
case "cow":
greetCow(animal);

--- 페이지 304 끝 ---


--- 페이지 305 ---

13.2 Multimethods with single dispatch 277
break;
};
}
Dave But what if you want to extend the functionality of greet and add a new animal?
Theo Now you got me. I admit that with a switch statement, I can’t add a new animal
without modifying the original code, whereas in OOP, I can add a new class
without having to modify the original code.
Dave Yeah, but you helped me to realize that the main benefit of polymorphism is
that it makes the code easily extensible.
TIP The main benefit of polymorphism is extensibility.
Theo I’m going to ask Joe if there’s a way to benefit from polymorphism without
objects.
Theo sends a message to Joe and asks him about polymorphism in DOP. Joe answers that
he doesn’t have time to get into a deep response because he is in a tech conference where
he is about to give a talk about DOP. The only thing he has time to tell Theo is that he
should take a look at multimethods.
Theo and Dave read some online material about multimethods. It doesn’t look too
complicated. They decide that after lunch they will give multimethods a try.
13.2 Multimethods with single dispatch
During lunch, Theo asks Dave how it feels to have grown up in the country. Dave starts
with an enthusiastic description about being in direct contact with nature and living a sim-
pler life than in the city. He’s grateful for the experience, but he admits that country life
can sometimes be hard without the conveniences of the city. But who said simple was easy?
After lunch, they decide to have coffee. Dave asks Theo if he’d like to grind the coffee
beans himself. Theo accepts with joy. Next, Dave explains how to use a French press coffee
maker to get the ideal tradeoff between bitterness and rich taste. While savoring their
French press coffee in the garden, Theo and Dave continue their exploration of polymor-
phism à la DOP.
Theo From what I read before lunch, it seems that multimethods are a software con-
struct that provide polymorphism without the need for objects.
Dave I don’t get how that’s possible.
Theo Multimethods have two parts: a dispatch function and a set of methods that
provide an implementation for each dispatched value.
Dave I’m not sure I’m clear on that. Is a dispatch function like an interface?
Theo It’s like an interface in the sense that it defines the way the function needs to
be called, but it goes beyond that. It also dispatches a value that differentiates
between the different implementations.
Dave That’s a bit abstract for me.
Theo I think I understand how to implement the animal greeting capabilities. If we
use a multimethod called greet, we need a dispatch function and three
methods. Let’s call the dispatch function greetDispatch. It dispatches the
animal type, either "dog", "cat", or "cow". Then, each dispatch value is

--- 페이지 305 끝 ---
