# 12.2 Return value validation

**페이지**: 281-283
**계층**: Data-Oriented Programming (node0) > Part3—Maintainability (node1) > 12 Advanced data validation (node2) > Chapter 12
**추출 시간**: 2025-08-06 19:47:17

---


--- 페이지 281 ---

12.1 Function arguments validation 253
Theo I think we could use additionalProperties. Here’s the JSON Schema for an
homogeneous map where the values are numbers.
Listing12.5 The JSON Schema for an homogeneous map with values as numbers
{
"type": "object",
"additionalProperties": {"type": "number"}
}
Dave I thought that additionalProperties was supposed to be a boolean and that
it was used to allow or forbid properties not mentioned in the schema.
Theo That’s correct. Usually additionalProperties is a boolean, but the documen-
tation says it could also be a map that defines a schema. In that case, it means
properties not mentioned in the schema should have the value of the schema
associated with additionalProperties.
Dave I see. But what does that have to do with homogeneous maps?
Theo Well, a homogeneous map could be seen as a map with no predefined proper-
ties, where all the additional properties are of an expected type.
Dave Tricky!
TIP In JSON Schema, homogeneous string maps have type: object with no
properties and additionalProperties associated to a schema.
Theo Indeed. Now, let me show you what the catalog schema looks like.
Theo types briefly on his laptop. He shows Dave the catalog schema.
Listing12.6 The schema for catalog data
var catalogSchema = {
"type": "object",
"properties": {
"booksByIsbn": {
"type": "object",
"additionalProperties": bookSchema
},
"authorsById": {
"type": "object",
"additionalProperties": authorSchema
}
},
"required": ["booksByIsbn", "authorsById"]
};
Dave Are we ready to plug the catalog and the query schema into the Catalog
.searchBooksByTitle implementation?
Theo We could, but I think we can do better by defining a single schema that com-
bines both the catalog and query schemas.
Dave How would we combine two schemas into a single schema?

--- 페이지 281 끝 ---


--- 페이지 282 ---

254 CHAPTER 12 Advanced data validation
Theo Do you know what a tuple is?
Dave I think I know, but I can’t define it formally.
Theo A tuple is an array where the size is fixed, and the elements can be of different
shapes.
Dave OK. So, how do we define tuples in JSON Schema?
Once again, Theo explores the JSON Schema online documentation. Fortunately, he has
bookmarked the page, and in no time at all, finds the information he needs.
Theo I found it! We use prefixItems in the definition of a tuple made of a string
and a number, for instance.
Theo types more code on his laptop. When he finishes, he shows Dave the schema for a
tuple.
Listing12.7 The schema for a tuple made of a string and a number
{
"type": "array",
"prefixItems": [
{ "type": "string" },
{ "type": "number" }
]
}
Dave I see. And how would you define the schema for the arguments of Catalog
.searchBooksByTitle?
Theo Well, it’s a tuple of size 2, where the first element is a catalog and the second
element is a string.
Dave Something like this schema?
Listing12.8 The schema for the arguments of Catalog.searchBooksByTitle
var searchBooksArgsSchema = {
"type": "array",
"prefixItems": [
catalogSchema,
{ "type": "string" },
]
};
Theo Exactly!
Dave Now that we have the schema for the arguments, how do we plug it into the
implementation of search books?
Theo That’s similar to the way we validate data at system boundaries. The main dif-
ference is that the data validation for data that flows inside the system should
run only at development time, and it should be disabled when the code runs in
production.
Dave Why?

--- 페이지 282 끝 ---


--- 페이지 283 ---

12.2 Return value validation 255
Theo Because that data has been already validated up front at a system boundary.
Validating it again on a function call is superfluous, and it would impact
performance.
Dave When you say development time, does that include testing and staging
environments?
Theo Yes, all the environments besides production.
Dave I see. It’s like assertions in Java. They are disabled in production code.
TIP Data validation inside the system should be disabled in production.
Theo Exactly. For now, I am going to assume that we have a dev function that returns
true when the code runs in the development environment and false when it
runs in production. Having said that, take a look at this code.
Listing12.9 Implementation of search with validation of function arguments
Catalog.searchBooksByTitle = function(catalogData, query) {
if(dev()) {
var args = [catalogData, query];
if(!ajv.validate(searchBooksArgsSchema, args)) {
var errors = ajv.errorsText(ajv.errors);
throw ("searchBooksByTitle called with invalid arguments: " +
errors);
The implementation of dev() depends on the run-time
}
environment: it returns true when the code runs in dev
}
environments and false when it runs in production.
var allBooks = _.get(catalogData, "booksByIsbn");
var matchingBooks = _.filter(allBooks, function(book) {
return _.get(book, "title").includes(query);
});
var bookInfos = _.map(matchingBooks, function(book) {
return Catalog.bookInfo(catalogData, book);
});
return bookInfos;
};
Dave Do you think we should validate the arguments of all the functions?
Theo No. I think we should treat data validation like we treat unit tests. We should
validate function arguments only for functions for whom we would write unit
tests.
TIP Treat data validation like unit tests.
12.2 Return value validation
Dave Do you think it would make sense to also validate the return value of functions?
Theo Absolutely.
Dave Cool. Let me try to write the JSON Schema for the return value of Catalog
.searchBooksByTitle.

--- 페이지 283 끝 ---
