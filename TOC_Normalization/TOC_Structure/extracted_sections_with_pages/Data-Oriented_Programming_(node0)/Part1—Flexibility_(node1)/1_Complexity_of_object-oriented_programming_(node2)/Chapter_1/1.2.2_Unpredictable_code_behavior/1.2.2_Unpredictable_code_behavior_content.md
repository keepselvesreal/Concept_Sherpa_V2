# 1.2.2 Unpredictable code behavior

**페이지**: 44-45
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 1 Complexity of object-oriented programming (node2) > Chapter 1
**추출 시간**: 2025-08-06 19:46:42

---


--- 페이지 44 ---

16 CHAPTER 1 Complexity of object-orientedprogramming
The class diagram where Member is split into MemberCode and MemberData is made of
two independent parts. Each part is easier to understand than the original diagram.
Let’s split every class of our original class diagram into code and data entities.
Figure 1.13 shows the resulting diagram. Now the system is made of two indepen-
dent parts:
 A part that involves only data entities.
 A part that involves only code entities.
C LibraryData * C LibrarianData C CatalogCode
*
C MemberData C CatalogData C LibrarianCode
*
C BookData C MemberCode C BookLendingCode C BookItemCode
*
* *
C BookItemData C AuthorData C UserCode C BookItem
*
C BookLendingData
Figure 1.13 A class diagram where every class is split into code and data entities
TIP A system where every class is split into two independent parts, code and data, is
simpler than a system where code and data are mixed.
The resulting system, made up of two independent subsystems, is easier to understand
than the original system. The fact that the two subsystems are independent means that
each subsystem can be understood separately and in any order. The resulting system
not simpler by accident; it is a logical consequence of separating code from data.
TIP A system made of multiple simple independent parts is less complex than a sys-
tem made of a single complex part.
1.2.2 Unpredictable code behavior
You might be a bit tired after the system-level analysis that we presented in the previ-
ous section. Let’s get refreshed and look at some code.
Take a look at the code in listing 1.1, where we get the blocked status of a member
and display it twice. If I tell you that when I called displayBlockedStatusTwice, the
program displayed true on the first console.log call, can you tell me what the pro-
gram displayed on the second console.log call?

--- 페이지 44 끝 ---


--- 페이지 45 ---

1.2 Sources of complexity 17
Listing1.1 Really simple code
class Member {
isBlocked;
displayBlockedStatusTwice() {
var isBlocked = this.isBlocked;
console.log(isBlocked);
console.log(isBlocked);
}
}
member.displayBlockedStatusTwice();
“Of course, it displayed true again,” you say. And you are right!
Now, take a look at a slightly different pseudocode as shown in listing 1.2. Here we
display, twice, the blocked status of a member without assigning a variable. Same ques-
tion as before: if I tell you that when I called displayBlockedStatusTwice, the pro-
gram displayed true on the first console.log call, can you tell me what the program
displayed on the second console.log call?
Listing1.2 Apparently simple code
class Member {
isBlocked;
displayBlockedStatusTwice() {
console.log(this.isBlocked);
console.log(this.isBlocked);
}
}
member.displayBlockedStatusTwice();
The correct answer is...in a single-threaded environment, it displays true, while in a
multi-threaded environment, it’s unpredictable. Indeed, in a multi-threaded environ-
ment between the two console.log calls, there could be a context switch that changes
the state of the object (e.g., a librarian unblocked the member). In fact, with a slight
modification, the same kind of code unpredictability could occur even in a single-
threaded environment like JavaScript, when data is modified via asynchronous code
(see the section about Principle #3 in appendix A). The difference between the two
code snippets is that
 In the first listing (listing 1.1), we access a Boolean value twice , which is a prim-
itive value.
 In the second listing (listing 1.2), we access a member of an object twice.
TIP When data is mutable, code is unpredictable.

--- 페이지 45 끝 ---
