# 1.2.0 Introduction (사용자 추가)

**페이지**: 42-44
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 1 Complexity of object-oriented programming (node2) > Chapter 1
**추출 시간**: 2025-08-06 19:46:41

---


--- 페이지 42 ---

14 CHAPTER 1 Complexity of object-orientedprogramming
In the remaining sections of this chapter, we will illustrate each of the previous
aspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project
and explain in what sense these aspects are a source of complexity.
Table 1.1 Aspects of OOP and their impact on system complexity
Aspect Impact on complexity
Code and data are mixed. Classes tend to be involved in many relations.
Objects are mutable. Extra thinking is needed when reading code.
Objects are mutable. Explicit synchronization is required on multi-threaded environments.
Data is locked in objects. Data serialization is not trivial.
Code is locked in classes. Class hierarchies are complex.
1.2.1 Many relations between classes
One way to assess the complexity of a class diagram is to look only at the entities and
their relations, ignoring members and methods, as in figure 1.10. When we design a
system, we have to define the relations between different pieces of code and data.
That’s unavoidable.
C Library
C Catalog
* *
C Book C Librarian
*
*
C Member
*
C Author
C BookItem C User
Figure 1.10 A class
diagram overview for
C BookLending * Klafim’s Library
Management System
TIP In OOP, code and data are mixed together in classes: data as members and code as
methods.

--- 페이지 42 끝 ---


--- 페이지 43 ---

1.2 Sources of complexity 15
From a system analysis perspective, the fact that code and data are mixed together
makes the system complex in the sense that entities tend to be involved in many rela-
tions. In figure 1.11, we take a closer look at the Member class. Member is involved in five
relations: two data relations and three code relations.
 Data relations:
– Library has many Members.
– Member has many BookLendings.
 Code relations:
– Member extends User.
– Librarian uses Member.
– Member uses BookItem.
C Librarian
C Library * C Member
*
C User C BookLending C BookItem Figure 1.11 The class Member is
involved in five relations.
Imagine for a moment that we were able, somehow, to split the Member class into two
separate entities:
 MemberCode for the code
 MemberData for the data
Instead of a Member class with five relations, we would have the diagram shown in fig-
ure 1.12 with:
 A MemberCode entity and three relations.
 A MemberData entity and two relations.
C Library C Librarian
*
C MemberData C MemberCode
*
C BookLending C User C BookItem Figure 1.12 A class diagram where Member
is split into code and data entities

--- 페이지 43 끝 ---


--- 페이지 44 ---

16 CHAPTER 1 Complexity of object-orientedprogramming
The class diagram where Member is split into MemberCode and MemberData is made of
two independent parts. Each part is easier to understand than the original diagram.
Let’s split every class of our original class diagram into code and data entities.
Figure 1.13 shows the resulting diagram. Now the system is made of two indepen-
dent parts:
 A part that involves only data entities.
 A part that involves only code entities.
C LibraryData * C LibrarianData C CatalogCode
*
C MemberData C CatalogData C LibrarianCode
*
C BookData C MemberCode C BookLendingCode C BookItemCode
*
* *
C BookItemData C AuthorData C UserCode C BookItem
*
C BookLendingData
Figure 1.13 A class diagram where every class is split into code and data entities
TIP A system where every class is split into two independent parts, code and data, is
simpler than a system where code and data are mixed.
The resulting system, made up of two independent subsystems, is easier to understand
than the original system. The fact that the two subsystems are independent means that
each subsystem can be understood separately and in any order. The resulting system
not simpler by accident; it is a logical consequence of separating code from data.
TIP A system made of multiple simple independent parts is less complex than a sys-
tem made of a single complex part.
1.2.2 Unpredictable code behavior
You might be a bit tired after the system-level analysis that we presented in the previ-
ous section. Let’s get refreshed and look at some code.
Take a look at the code in listing 1.1, where we get the blocked status of a member
and display it twice. If I tell you that when I called displayBlockedStatusTwice, the
program displayed true on the first console.log call, can you tell me what the pro-
gram displayed on the second console.log call?

--- 페이지 44 끝 ---
