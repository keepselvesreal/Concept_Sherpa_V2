# 4.7 Restoring previous states

**페이지**: 113-115
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 4 State management (node2) > Chapter 4
**추출 시간**: 2025-08-06 19:46:52

---


--- 페이지 113 ---

4.6 Ensuring system state integrity 85
var next = Library.addMember(previous, member);
SystemState.commit(previous, next);
SystemState is covered
}
in listing 4.8.
}
Theo What does SystemState look like?
Joe I had a feeling you were going to ask that. Here’s the code for the System-
State class, which is a stateful class!
Listing4.8 The SystemState class
class SystemState {
systemState;
get() {
return this.systemState;
}
commit(previous, next) {
this.systemState = next;
}
}
Theo I don’t get the point of SystemState. It’s a simple class with a getter and a
commit function, right?
Joe In a moment, we are going to enrich the code of the SystemState.commit
method so that it provides data validation and history tracking. For now, the
important thing to notice is that the code of the calculation phase is stateless
and is decoupled from the code of the commit phase, which is stateful.
TIP The calculation phase is stateless. The commit phase is stateful.
4.6 Ensuring system state integrity
Theo Something still bothers me about the way functions manipulate immutable
data in the calculation phase. How do we preserve data integrity?
Joe What do you mean?
Theo In OOP, data is manipulated only by methods that belong to the same class as
the data. It prevents other classes from corrupting the inner state of the class.
Joe Could you give me an example of an invalid state of the library?
Theo For example, imagine that the code of a mutation adds a book item to the
book lendings of a member without marking the book item as lent in the cata-
log. Then the system data would be corrupted.
Joe In DOP, we have the privilege of ensuring data integrity at the level of the
whole system instead of scattering the validation among many classes.
Theo How does that work?
Joe The fact that the code for the commit phase is common to all the mutations
allows us to validate the system data in a central place. At the beginning of the
commit phase, there is a step that checks whether the version of the system

--- 페이지 113 끝 ---


--- 페이지 114 ---

86 CHAPTER 4 State management
state to be committed is valid. If the data is invalid, the commit is rejected.
Here let me show you.
Listing4.9 Data validation inside the commit phase
SystemState.commit = function(previous, next) {
if(!SystemValidity.validate(previous, next)) { // not implemented for now
throw "The system data to be committed is not valid!";
};
this.systemData = next;
};
Theo It sounds similar to a commit hook in Git.
Joe I like your analogy!
Theo Why are you passing the previous state in previous and the next state in next
to SystemValidity.validate?
Joe Because it allows SystemValidity.validate to optimize the validation in
terms of computation. For example, we could validate just the data that has
changed.
TIP In DOP, we validate the system data as a whole. Data validation is decoupled
from data manipulation.
Theo What does the code of SystemValidity.validate look like?
Joe Someday, I will show you how to define a data schema and to validate that a
piece of data conforms to a schema.
 NOTE See chapters 7 and 12 to see how Joe defines this data schema.
4.7 Restoring previous states
Another advantage of the multi-version state approach with immutable data that is
manipulated via structural sharing is that we can keep track of the history of all the
versions of the data without exploding the memory of our program. It allows us, for
instance, to restore the system back to an earlier state easily.
Theo You told me earlier that it was easy to restore the system to a previous state.
Could you show me how?
Joe Happily, but before that, I’d like to make sure you understand why keeping
track of all the versions of the data is efficient in terms of memory.
Theo I think it’s related to the fact that immutable functions use structural sharing,
and most of the data between subsequent versions of the state is shared.
TIP Structural sharing allows us to keep many versions of the system state without
exploding memory use.
Joe Perfect! Now, I’ll show you how simple it is to undo a mutation. In order to
implement an undo mechanism, our SystemState class needs to have two

--- 페이지 114 끝 ---


--- 페이지 115 ---

4.7 Restoring previous states 87
references to the system data: systemData references the current state of the
system, and previousSystemData references the previous state of the system.
Theo That makes sense.
Joe In the commit phase, we update both previousSystemData and systemData.
Theo What does it take to implement an undo mechanism?
Joe The undo is achieved by having systemData reference the same version of the
system data as previousSystemData.
Theo Could you walk me through an example?
Joe To make things simple, I am going to give a number to each version of the sys-
tem state. It starts at V0, and each time a mutation is committed, the version is
incremented: V1, V2, V3, and so forth.
Theo OK.
Joe Let’s say that currently our system state is at V12 (see figure 4.8). In the
SystemState object, systemData refers to V12, and previousSystemData
refers to V11.
previousSystemData
MutationA Mutation B
Data V10 Data V11 Data V12
systemData
Figure 4.8 When the system state is at V12, systemData refers to V12, and
previousSystemData refers to V11.
Theo So far, so good...
Joe Now, when a mutation is committed (for instance, adding a member), both
references move forward: systemData refers to V13, and previousSystem-
Data refers to V12.
Joe erases the whiteboard to make room for another diagram (figure 4.9). When he’s
through with his drawing, he shows it to Theo.
previousSystemData
MutationA Mutation B Mutation C
Data V10 Data V11 Data V12 Data V13
systemData
Figure 4.9 When a mutation is committed, systemData refers to V13, and
previousSystemData refers to V12.

--- 페이지 115 끝 ---
