# 4.4 Data safety

**페이지**: 110-113
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 4 State management (node2) > Chapter 4
**추출 시간**: 2025-08-06 19:46:51

---


--- 페이지 110 ---

82 CHAPTER 4 State management
4.4 Data safety
Joe is about to start the day’s lesson. Theo asks him a question about yesterday’s material
instead.
Theo Something isn’t clear to me regarding this structural sharing stuff. What hap-
pens if we write code that modifies the data part that’s shared between the two
versions of the data? Does the change affect both versions?
Joe Could you please write a code snippet that illustrates your question?
Theo starts typing on his laptop. He comes up with this code to illustrate modifying a piece
of data shared between two versions.
Listing4.5 Modifying data that’s shared between two versions
var books = {
"978-1779501127": {
"isbn": "978-1779501127",
"title": "Watchmen",
"publicationYear": 1987,
"authorIds": ["alan-moore",
"dave-gibbons"]
}
};
var nextBooks = _.set(books, ["978-1779501127", "publicationYear"], 1986)
console.log("Before:", nextBooks["978-1779501127"]["authorIds"][1]);
books["978-1779501127"]["authorIds"][1] = "dave-chester-gibbons";
console.log("After:", nextBooks["978-1779501127"]["authorIds"][1]);
// → Before: dave-gibbons
// → After: dave-chester-gibbons
Theo My question is, what is the value of isBlocked in updatedMember?
Joe The answer is that mutating data via the native hash map setter is forbidden.
All the data manipulation must be done via immutable functions.
 NOTE All data manipulation must be done with immutable functions. It is forbid-
den to use the native hash map setter.
Theo When you say “forbidden,” you mean that it’s up to the developer to make sure
it doesn’t happen. Right?
Joe Exactly.
Theo Is there a way to protect our system from a developer’s mistake?
Joe Yes, there is a way to ensure the immutability of the data at the level of the data
structure. It’s called persistent data structures.
Theo Are persistent data structures also efficient in terms of memory and computation?
Joe Actually, the way data is organized inside persistent data structures make them
even more efficient than immutable functions.

--- 페이지 110 끝 ---


--- 페이지 111 ---

4.5 The commit phase of a mutation 83
TIP Persistent data structures are immutable at the level of the data. There is no way
to mutate them, even by mistake.
Theo Are there libraries providing persistent data structures?
Joe Definitely. I just happen to have a list of those libraries on my computer.
Joe, being well-organized for a programmer, quickly brings up his list. He shows it to Theo:
 Immutable.js in JavaScript at https://immutable-js.com/
 Paguro in Java at https://github.com/GlenKPeterson/Paguro
 Immutable Collections in C# at http://mng.bz/y4Ke
 Pyrsistent in Python at https://github.com/tobgu/pyrsistent
 Hamster in Ruby at https://github.com/hamstergem/hamster
Theo Why not use persistent data structures instead of immutable functions?
Joe The drawback of persistent data structures is that they are not native. This
means that working with them requires conversion from native to persistent
and from persistent to native.
Theo What approach would you recommend?
Joe If you want to play around a bit, then start with immutable functions. But for a
production application, I’d recommend using persistent data structures.
Theo Too bad the native data structures aren’t persistent!
Joe That’s one of the reasons why I love Clojure—the native data structures of the
language are immutable!
4.5 The commit phase of a mutation
So far, we saw how to implement the calculation phase of a mutation. The calculation
phase is stateless in the sense that it doesn’t make any change to the system. Now, let’s
see how to update the state of the system inside the commit phase.
Theo takes another look at the code for Library.addMember. Something bothers him:
this function returns a new state of the library that contains an additional member, but it
doesn’t affect the current state of the library.
Listing4.6 The commit phase moves the system state forward
Library.addMember = function(library, member) {
var currentUserManagement = _.get(library, "userManagement");
var nextUserManagement = UserManagement.addMember(
currentUserManagement,
member);
var nextLibrary = _.set(library, "userManagement", nextUserManagement);
return nextLibrary;
};
Theo I see that Library.addMember doesn’t change the state of the library. How
does the library state get updated?

--- 페이지 111 끝 ---


--- 페이지 112 ---

84 CHAPTER 4 State management
Joe That’s an excellent question. Library.addMember deals only with data calcula-
tion and is stateless. The state is updated in the commit phase by moving for-
ward the version of the state that the system state refers to.
Theo What do you mean by that?
Joe Here’s what happens when we add a member to the system. The calculation
phase creates a version of the state that has two members. Before the commit
phase, the system state refers to the version of the state with one member. The
responsibility of the commit phase is to move the system state forward so that it
refers to the version of the state with two members.
TIP The responsibility of the commit phase is to move the system state forward to the
version of the state returned by the calculation phase.
Joe draws another illustration on the whiteboard (figure 4.7). He hopes it helps to clear up
any misunderstanding Theo may have.
Before Commit After Commit
State with one State with one
System State
member member
addMember addMember
State with two State with two
System State
members members
Figure 4.7 The commit phase moves the system state forward.
Theo How is this implemented?
Joe The code is made of two classes: System, a singleton stateful class that imple-
ments the mutations, and SystemState, a singleton stateful class that manages
the system state.
Theo It sounds to me like classic OOP.
Joe Right, and this part of the system being stateful is OOP-like.
Theo I’m happy to see that you still find some utility in OOP.
Joe Meditation taught me that every part of our universe has a role to play.
Theo Nice! Could you show me some code?
Joe Sure.
Joe thinks for a moment before starting to type. He wants to show the System class and its
implementation of the addMember mutation.
Listing4.7 The System class
class System {
addMember(member) {
var previous = SystemState.get();

--- 페이지 112 끝 ---


--- 페이지 113 ---

4.6 Ensuring system state integrity 85
var next = Library.addMember(previous, member);
SystemState.commit(previous, next);
SystemState is covered
}
in listing 4.8.
}
Theo What does SystemState look like?
Joe I had a feeling you were going to ask that. Here’s the code for the System-
State class, which is a stateful class!
Listing4.8 The SystemState class
class SystemState {
systemState;
get() {
return this.systemState;
}
commit(previous, next) {
this.systemState = next;
}
}
Theo I don’t get the point of SystemState. It’s a simple class with a getter and a
commit function, right?
Joe In a moment, we are going to enrich the code of the SystemState.commit
method so that it provides data validation and history tracking. For now, the
important thing to notice is that the code of the calculation phase is stateless
and is decoupled from the code of the commit phase, which is stateful.
TIP The calculation phase is stateless. The commit phase is stateful.
4.6 Ensuring system state integrity
Theo Something still bothers me about the way functions manipulate immutable
data in the calculation phase. How do we preserve data integrity?
Joe What do you mean?
Theo In OOP, data is manipulated only by methods that belong to the same class as
the data. It prevents other classes from corrupting the inner state of the class.
Joe Could you give me an example of an invalid state of the library?
Theo For example, imagine that the code of a mutation adds a book item to the
book lendings of a member without marking the book item as lent in the cata-
log. Then the system data would be corrupted.
Joe In DOP, we have the privilege of ensuring data integrity at the level of the
whole system instead of scattering the validation among many classes.
Theo How does that work?
Joe The fact that the code for the commit phase is common to all the mutations
allows us to validate the system data in a central place. At the beginning of the
commit phase, there is a step that checks whether the version of the system

--- 페이지 113 끝 ---
