# 4.2 Structural sharing

**페이지**: 100-103
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 4 State management (node2) > Chapter 4
**추출 시간**: 2025-08-06 19:46:50

---


--- 페이지 100 ---

72 CHAPTER 4 State management
technique called structural sharing, where parts of the data that are common between
two versions are shared instead of being copied. In DOP, a mutation is split into two
distinct phases:
 In the calculation phase, we compute the next version of the system data.
 In the commit phase, we move the system state forward so that it refers to the
version of the system data computed by the calculation phase.
This distinction between calculation and commit phases allows us to reduce the part
of our system that is stateful to its bare minimum. Only the code of the commit phase
is stateful, while the code in the calculation phase of a mutation is stateless and is
made of generic functions similar to the code of a query. The implementation of the
commit phase is common to all mutations. As a consequence, inside the commit
phase, we have the ability to ensure that the state always refers to a valid version of the
system data.
Another benefit of this state management approach is that we can keep track of
the history of previous versions of the system data. Restoring the system to a previous
state (if needed) becomes straightforward. Table 4.1 shows the two phases.
Table 4.1 The two phases of a mutation
Phase Responsibility State Implementation
Calculation Computes the next version of system data Stateless Specific
Commit Moves the system state forward Stateful Common
In this chapter, we assume that no mutations occur concurrently in our system. In the
next chapter, we will deal with concurrency control.
4.1 Multiple versions of the system data
When Joe comes in to the office on Monday, he tells Theo that he needs to exercise before
starting to work with his mind. Theo and Joe go for a walk around the block, and the dis-
cussion turns toward version control systems. They discuss how Git keeps track of the
whole commit history and how easy and fast it is to restore the code to a previous state.
When Theo tells Joe that Git’s ability to “time travel” reminds him one of his favorite mov-
ies, Back to the Future, Joe shares that a month ago he watched the Back to the Future trilogy
with Neriah, his 14-year-old son.
Their walk complete, they arrive back at Theo’s office. Theo and Joe partake of the
espresso machine in the kitchen before they begin today’s lesson.
Joe So far, we’ve seen how we manage queries that retrieve information from the
system in DOP. Now I’m going to show you how we manage mutations. By a
mutation, I mean an operation that changes the state of the system.
 NOTE A mutation is an operation that changes the state of the system.

--- 페이지 100 끝 ---


--- 페이지 101 ---

4.1 Multiple versions of the system data 73
Theo Is there a fundamental difference between queries and mutations in DOP?
After all, the whole state of the system is represented as a hash map. I could
easily write code that modifies part of the hash map, and it would be similar to
the code that retrieves information from the hash map.
Joe You could mutate the data in place, but then it would be challenging to ensure
that the code of a mutation doesn’t put the system into an invalid date. You
would also lose the ability to track previous versions of the system state.
Theo I see. So, how do you handle mutations in DOP?
Joe We adopt a multi-version state approach, similar to what a version control sys-
tem like Git does; we manage different versions of the system data. At a specific
point in time, the state of the system refers to a version of the system data. After
a mutation is executed, we move the reference forward.
Theo I’m confused. Is the system state mutable or immutable?
Joe The data is immutable, but the state reference is mutable.
TIP The data is immutable, but the state reference is mutable.
Noticing the look of confusion on Theo’s face, Joe draws a quick diagram on the white-
board. He then shows Theo figure 4.1, hoping that it will clear up Theo’s perplexity.
After mutation B After mutation C
Data V10 Data V10
MutationA MutationA
Data V11 Data V11
Mutation B Mutation B
System State Data V12 Data V12
Mutation C
System State Data V13
Figure 4.1 After mutation B is executed, the system state refers to Data V12. After
mutation C is executed, the system state refers to Data V13.
Theo Does that mean that before the code of a mutation runs, we make a copy of the
system data?
Joe No, that would be inefficient, as we would have to do a deep copy of the data.

--- 페이지 101 끝 ---


--- 페이지 102 ---

74 CHAPTER 4 State management
Theo How does it work then?
Joe It works by using a technique called structural sharing, where most of the data
between subsequent versions of the state is shared instead of being copied.
This technique efficiently creates new versions of the system data, both in
terms of memory and computation.
Theo I’m intrigued.
TIP With structural sharing, it’s efficient (in terms of memory and computation) to
create new versions of data.
Joe I’ll explain in detail how structural sharing works in a moment.
Theo takes another look at the diagram in figure 4.1, which illustrates how the system state
refers to a version of the system data. Suddenly, a question emerges.
Theo Are the previous versions of the system data kept?
Joe In a simple application, previous versions are automatically removed by the
garbage collector. But, in some cases, we maintain historical references to pre-
vious versions of the data.
Theo What kind of cases?
Joe For example, if we want to support time travel in our system, as in Git, we can
move the system back to a previous version of the state easily.
Theo Now I understand what you mean by data is immutable, but the state reference
is mutable!
4.2 Structural sharing
As mentioned in the previous section, structural sharing enables the efficient cre-
ation of new versions of immutable data. In DOP, we use structural sharing in the
calculation phase of a mutation to compute the next state of the system based on
the current state of the system. Inside the calculation phase, we don’t have to deal
with state management; that is delayed to the commit phase. As a consequence, the
code involved in the calculation phase of a mutation is stateless and is as simple as
the code of a query.
Theo I’m really intrigued by this more efficient way to create new versions of data.
How does it work?
Joe Let’s take a simple example from our library system. Imagine that you want to
modify the value of a field in a book in the catalog; for instance, the publica-
tion year of Watchmen. Can you tell me the information path for Watchmen’s
publication year?
Theo takes a quick look at the catalog data in figure 4.2. Then he answers Joe’s question.

--- 페이지 102 끝 ---


--- 페이지 103 ---

4.2 Structural sharing 75
catalog
booksByIsbn authorsById
978-1779501127 alan-moore
title isbn name
Watchmen 978-1779501127 Alan Moore
authorIds publicationYear bookIsbns
1987
1 0 0
bookItems
dave-gibbons alan-moore 978-1779501127
1 0 dave-gibbons
id id name
book-item-2 book-item-1 Dave Gibbons
libId libId bookIsbns
la-central-lib nyc-cental-lib
0
isLent isLent
978-1779501127
false true
Figure 4.2 Visualization of the catalog data. The nodes in the information path to Watchmen’s publication
year are marked with a dotted border.
Theo The information path for Watchmen’s publication year is ["catalog", "books-
ByIsbn", "978-1779501127", "publicationYear"].
Joe Now, let me show how you to use the immutable function _.set that Lodash
also provides.
Theo Wait! What do you mean by an immutable function? When I looked at the
Lodash documentation for _.set on their website, it said that it mutates the
object.
Joe You’re right, but the default Lodash functions are not immutable. In order to
use an immutable version of the functions, we need to use the Lodash FP mod-
ule as explained in the Lodash FP guide.
 NOTE See https://lodash.com/docs/4.17.15#set to view Lodash’s documentation
for _.set, and see https://github.com/lodash/lodash/wiki/FP-Guide to view the
Lodash FP guide.
Theo Do the immutable functions have the same signature as the mutable functions?
Joe By default, the order of the arguments in immutable functions is shuffled.
The Lodash FP guide explains how to resolve this. With this piece of code,

--- 페이지 103 끝 ---
