# 5.0 Introduction (사용자 추가)

**페이지**: 119-120
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 5 Basic concurrency control (node2) > Chapter 5
**추출 시간**: 2025-08-06 19:46:53

---


--- 페이지 119 ---

Basic concurrency control
Conflicts at home
This chapter covers
 Managing concurrent mutations with a lock-free
optimistic concurrency control strategy
 Supporting high throughput of reads and writes
 Reconciliation between concurrent mutations
The changes required for system manage concurrency are only in the commit
phase. They involve a reconciliation algorithm that is universal, in the sense that it
can be used in any system where data is represented as an immutable hash map.
The implementation of the reconciliation algorithm is efficient because subse-
quent versions of the system state are created via structural sharing.
In the previous chapter, we illustrated the multiversion approach to state man-
agement, where a mutation is split into two distinct phases: the calculation phase
that deals only with computation, and the commit phase that moves the state ref-
erence forward. Usually, in a production system, mutations occur concurrently.
Moving the state forward naively like we did in the previous chapter is not appro-
priate. In the present chapter, we are going to learn how to handle concurrent
mutations.
91

--- 페이지 119 끝 ---


--- 페이지 120 ---

92 CHAPTER 5 Basic concurrency control
In DOP, because only the code of the commit phase is stateful, that allows us to use
an optimistic concurrency control strategy that doesn’t involve any locking mechanism. As
a consequence, the throughput of reads and writes is high. The modifications to the
code are not trivial, as we have to implement an algorithm that reconciles concurrent
mutations. But the modifications impact only the commit phase. The code for the cal-
culation phase stays the same as in the previous chapter.
 NOTE This chapter requires more of an effort to grasp. The flow of the reconcilia-
tion algorithm is definitely not trivial, and the implementation involves a nontrivial
recursion.
5.1 Optimistic concurrency control
This morning, before getting to work, Theo takes Joe to the fitness room in the office and,
while running on the step machine, the two men talk about their personal lives again. Joe
talks about a fight he had last night with Kay, who thinks that he pays more attention to his
work than to his family. Theo recounts the painful conflict he had with Jane, his wife,
about house budget management. They went to see a therapist, an expert in Imago Rela-
tionship Therapy. Imago allowed them to transform their conflict into an opportunity to
grow and heal.
Joe’s ears perk up when he hears the word conflict because today’s lesson is going to be
about resolving conflicts and concurrent mutations. A different kind of conflict, though....
After a shower and a healthy breakfast, Theo and Joe get down to work.
Joe Yesterday, I showed you how to manage state with immutable data, assuming
that no mutations occur concurrently. Today, I am going to show you how to
deal with concurrency control in DOP.
Theo I’m curious to discover what kind of lock mechanisms you use in DOP to syn-
chronize concurrent mutations.
Joe In fact, we don’t use any lock mechanism!
Theo Why not?
Joe Locks hit performance, and if you’re not careful, your system could get into a
deadlock.
Theo So, how do you handle possible conflicts between concurrent mutations in
DOP?
Joe In DOP, we use a lock-free strategy called optimistic concurrency control. It’s a
strategy that allows databases like Elasticsearch to be highly scalable.
 NOTE See https://www.elastic.co/elasticsearch/ to find out more about Elastic-
search.
Theo You sound like my couples therapist and her anger-free, optimistic conflict
resolution strategy.
Joe Optimistic concurrency control and DOP fit together well. As you will see in a
moment, optimistic concurrency control is super efficient when the system
data is immutable.

--- 페이지 120 끝 ---
