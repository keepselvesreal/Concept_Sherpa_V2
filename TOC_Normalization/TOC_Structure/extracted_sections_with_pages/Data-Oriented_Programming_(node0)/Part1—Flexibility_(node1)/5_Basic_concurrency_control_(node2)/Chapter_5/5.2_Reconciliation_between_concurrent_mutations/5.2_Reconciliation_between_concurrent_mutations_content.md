# 5.2 Reconciliation between concurrent mutations

**페이지**: 124-125
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 5 Basic concurrency control (node2) > Chapter 5
**추출 시간**: 2025-08-06 19:46:54

---


--- 페이지 124 ---

96 CHAPTER 5 Basic concurrency control
Joe We calculate the diff between previous and next and between previous and
current. If the two diffs have no fields in common, then there is no conflict
between the mutations that have run concurrently. We can safely apply the
changes from previous to next into current.
Joe makes his explanation visual with another diagram on the whiteboard. He then shows
figure 5.4 to Theo.
diffPreviousCurrent diffPreviousNext
current
previous merged
diffPreviousNext
next
Figure 5.4 In a three-way merge, we calculate the diff between previous and
next, and we apply it to current.
Theo What if there is a conflict?
Joe Then we abort the mutation.
Theo Aborting a user request seems unacceptable.
Joe In fact, in a user-facing system, conflicting concurrent mutations are fairly rare.
That’s why it’s OK to abort and let the user run the mutation again. Here, let
me draft a table to show you the differences between Git and DOP (table 5.2).
Table 5.2 The analogy between Git and data-oriented programming
Data-oriented programming Git
Concurrent mutations Different branches
A version of the system data A commit
State A reference
Calculation phase Branching
Validation Precommit hook
Reconciliation Merge
Fast-forward Fast-forward
Three-way merge Three-way merge
Abort Manual conflict resolution
Hash map Tree (folder)
Leaf node Blob (file)
Data field Line of code

--- 페이지 124 끝 ---


--- 페이지 125 ---

5.3 Reducing collections 97
Theo Great! That helps, but in cases where two mutations update the same field of
the same entity, I think it’s fair enough to let the user know that the request
can’t be processed.
TIP In a user-facing system, conflicting concurrent mutations are fairly rare.
5.3 Reducing collections
Joe Are you ready to challenge your mind with the implementation of the diff
algorithm?
Theo Let’s take a short coffee break before, if you don’t mind. Then, I’ll be ready to
tackle anything.
After enjoying large mug of hot coffee and a few butter cookies, Theo and Joe are back to
work. Their discussion on the diff algorithm continues.
Joe In the implementation of the diff algorithm, we’re going to reduce collections.
Theo I heard about reducing collections in a talk about FP, but I don’t remember
the details. Could you remind me how this works?
Joe Imagine you want to calculate the sum of the elements in a collection of num-
bers. With Lodash’s _.reduce, it would look like this.
Listing5.1 Summing numbers with _.reduce
_.reduce([1, 2, 3], function(res, elem) {
return res + elem;
}, 0);
// → 6
Theo I don’t understand.
Joe goes to the whiteboard and writes the description of _.reduce. Theo waits patiently
until Joe puts the pen down before looking at the description.
Description of _.reduce
_.reduce receives three arguments:
 coll—A collection of elements
 f—A function that receives two arguments
 initVal—A value
Logic flow:
1 Initialize currentRes with initVal.
2 For each element x of coll, update currentRes with f(currentRes, x).
3 Return currentRes.

--- 페이지 125 끝 ---
