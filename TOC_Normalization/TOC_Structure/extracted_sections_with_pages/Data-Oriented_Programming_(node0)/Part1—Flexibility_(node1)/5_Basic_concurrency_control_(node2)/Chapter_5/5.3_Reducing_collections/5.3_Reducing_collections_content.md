# 5.3 Reducing collections

**페이지**: 126-128
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 5 Basic concurrency control (node2) > Chapter 5
**추출 시간**: 2025-08-06 19:46:54

---


--- 페이지 126 ---

98 CHAPTER 5 Basic concurrency control
Theo Would you mind if I manually expand the logic flow of that code you just wrote
for _.reduce?
Joe I think it’s a great idea!
Theo In our case, initVal is 0. It means that the first call to f will be f(0, 1). Then,
we’ll have f(f(0, 1), 2) and, finally, f(f(f(0, 1), 2), 3).
Joe I like your manual expansion, Theo! Let’s make it visual.
Now Theo goes to the whiteboard and draws a diagram. Figure 5.5 shows what that looks like.
f
f a
2
f a
1
a 0 initVal Figure 5.5 Visualization
of _.reduce
Theo It’s much clearer now. I think that by implementing my custom version of
_.reduce, it will make things 100% clear.
It takes Theo much less time than he expected to implement reduce(). In no time at all,
he shows Joe the code.
Listing5.2 Custom implementation of _.reduce
function reduce(coll, f, initVal) {
var currentRes = initVal;
for (var i = 0; i < coll.length; i++) {
We could use
currentRes = f(currentRes, coll[i])
forEach instead
}
of a for loop.
return currentRes;
}
After checking that Theo’s code works as expected (see listing 5.3), Joe is proud of Theo.
He seems to be catching on better than he anticipated.
Listing5.3 Testing the custom implementation of reduce()
reduce([1, 2, 3], function(res, elem) {
return res + elem;
}, 0);
// → 6
Joe Well done!

--- 페이지 126 끝 ---


--- 페이지 127 ---

5.4 Structural difference 99
5.4 Structural difference
 NOTE This section deals with the implementation of a structural diff algorithm. Feel
free to skip this section if you don’t want to challenge your mind right now with the
details of a sophisticated use of recursion. It won’t prevent you from enjoying the rest
of the book. You can come back to this section later.
Theo How do you calculate the diff between various versions of the system state?
Joe That’s the most challenging part of the reconciliation algorithm. We need to
implement a structural diff algorithm for hash maps.
Theo In what sense is the diff structural?
Joe The structural diff algorithm looks at the structure of the hash maps and
ignores the order of the fields.
Theo Could you give me an example?
Joe Let’s start with maps without nested fields. Basically, there are three kinds of
diffs: field replacement, field addition, and field deletion. In order to make
things not too complicated, for now, we’ll deal only with replacement and
addition.
Joe once again goes to the whiteboard and draws table 5.3, representing the three kinds of
diffs. Theo is thinking the whiteboard is really starting to fill up today.
Table 5.3 Kinds of structural differences between maps without nested fields
Kind First map Second map Diff
Replacement {"a": 1} {"a": 2} {"a": 2}
Addition {"a": 1} {"a": 1, "b": 2} {"b": 2}
Deletion {"a": 1, "b": 2} {"a": 1} Not supported
Theo I notice that the order of the maps matters a lot. What about nested fields?
Joe It’s the same idea, but the nesting makes it a bit more difficult to grasp.
Joe changes several of the columns in table 5.3. When he’s through, he shows Theo the
nested fields in table 5.4.
Table 5.4 Kinds of structural differences between maps with nested fields
Kind First map Second map Diff
Replacement { { {
"a": { "a": { "a": {
"x": 1 "x": 2 "x": 2
} } }
} } }

--- 페이지 127 끝 ---


--- 페이지 128 ---

100 CHAPTER 5 Basic concurrency control
Table 5.4 Kinds of structural differences between maps with nested fields (continued)
Kind First map Second map Diff
Addition { { {
"a": { "a": { "a": {
"x": 1 "x": 1, "y": 2
} "y": 2, }
} } }
}
Deletion { { Not supported
"a": { "a": {
"x": 1, "y": 2
"y": 2, }
} }
}
 NOTE The version of the structural diff algorithm illustrated in this chapter does
not deal with deletions. Dealing with deletions is definitely possible, but it requires a
more complicated algorithm.
Theo As you said, it’s harder to grasp. What about arrays?
Joe We compare the elements of the arrays in order: if they are equal, the diff is
null; if they differ, the diff has the value of the second array.
Joe summarizes the various kinds of diffs in another table on the whiteboard. Theo looks
at the result in table 5.5.
Table 5.5 Kinds of structural differences between arrays without nested elements
Kind First array Second array Diff
Replacement [1] [2] [2]
Addition [1] [1, 2] [null, 2]
Deletion [1, 2] [1] Not supported
Theo This usage of null is a bit weird but OK. Is it complicated to implement the
structural diff algorithm?
Joe Definitely! It took a good dose of mental gymnastics to come up with these 30
lines of code.
Joe downloads the code from one his personal repositories. Theo, with thumb and forefin-
gers touching his chin and his forehead slightly tilted, studies the code.
Listing5.4 The implementation of a structural diff
function diffObjects(data1, data2) {
_.isArray checks whether
var emptyObject = _.isArray(data1) ? [] : {};
its argument is an array.
if(data1 == data2) {

--- 페이지 128 끝 ---
