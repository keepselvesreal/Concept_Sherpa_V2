# 5.4 Structural difference

**페이지**: 129-130
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 5 Basic concurrency control (node2) > Chapter 5
**추출 시간**: 2025-08-06 19:46:54

---


--- 페이지 129 ---

5.4 Structural difference 101
return emptyObject;
_.union creates an
} array of unique
var keys = _.union(_.keys(data1), _.keys(data2)); values from two
return _.reduce(keys, arrays (like union of
function (acc, k) { two sets in Maths).
var res = diff(
_.get(data1, k),
_.isObject checks
_.get(data2, k));
whether its argument
if((_.isObject(res) && _.isEmpty(res)) ||
is a collection (either
a map or an array).
(res == "no-diff")) {
return acc;
_.isEmpty }
checks return _.set(acc, [k], res);
whether its },
argument
emptyObject);
is an empty
} "no-diff" is how
collection.
we mark that
function diff(data1, data2) { two values are
if(_.isObject(data1) && _.isObject(data2)) { the same.
return diffObjects(data1, data2);
}
if(data1 !== data2) {
return data2;
}
return "no-diff";
}
Theo Wow! It involves a recursion inside a reduce! I’m sure Dave will love this, but
I’m too tired to understand this code right now. Let’s focus on what it does
instead of how it does it.
In order familiarize himself with the structural diff algorithm, Theo runs the algorithm
with examples from the table that Joe drew on the whiteboard. While Theo occupies his
fingers with more and more complicated examples, his mind wanders in the realm of
performance.
Listing5.5 An example of usage of a structural diff
var data1 = {
"a": {
"x": 1,
"y": [2, 3],
"z": 4
}
};
var data2 = {
"a": {
"x": 2,
"y": [2, 4],
"z": 4
}
}

--- 페이지 129 끝 ---


--- 페이지 130 ---

102 CHAPTER 5 Basic concurrency control
diff(data1, data2);
//{
// "a": {
// "x": 2,
// "y": [
// undefined,
// 4
// ]
// }
//}
Theo What about the performance of the structural diff algorithm? It seems that the
algorithm goes over the leaves of both pieces of data?
Joe In the general case, that’s true. But, in the case of system data that’s manipu-
lated with structural sharing, the code is much more efficient.
Theo What do you mean?
Joe With structural sharing, most of the nested objects are shared between two ver-
sions of the system state. Therefore, most of the time, when the code enters
diffObjects, it will immediately return because data1 and data2 are the same.
TIP Calculating the diff between two versions of the state is efficient because two
hash maps created via structural sharing from the same hash map have most of their
nodes in common.
Theo Another benefit of immutable data... Let me see how the diff algorithm
behaves with concurrent mutations. I think I’ll start with a tiny library with no
users and a catalog with a single book, Watchmen.
Listing5.6 The data for a tiny library
var library = {
"catalog": {
"booksByIsbn": {
"978-1779501127": {
"isbn": "978-1779501127",
"title": "Watchmen",
"publicationYear": 1987,
"authorIds": ["alan-moore", "dave-gibbons"]
}
},
"authorsById": {
"alan-moore": {
"name": "Alan Moore",
"bookIsbns": ["978-1779501127"]
},
"dave-gibbons": {
"name": "Dave Gibbons",
"bookIsbns": ["978-1779501127"]
}
}
}
};

--- 페이지 130 끝 ---
