# 5.1 Optimistic concurrency control

**페이지**: 121-123
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 5 Basic concurrency control (node2) > Chapter 5
**추출 시간**: 2025-08-06 19:46:53

---


--- 페이지 121 ---

5.1 Optimistic concurrency control 93
TIP Optimistic concurrency control with immutable data is super efficient.
Theo How does it work?
Joe Optimistic concurrency control occurs when we let mutations ask forgiveness
instead of permission.
TIP Optimistic concurrency control occurs when we let mutations ask forgiveness
instead of permission.
Theo What do you mean?
Joe The calculation phase does its calculation as if it were the only mutation run-
ning. The commit phase is responsible for reconciling concurrent mutations
when they don’t conflict or for aborting the mutation.
TIP The calculation phase does its calculation as if it were the only mutation running.
The commit phase is responsible for trying to reconcile concurrent mutations.
Theo That sounds quite challenging to implement.
Joe Dealing with state is never trivial. But the good news is that the code for the
reconciliation logic in the commit phase is universal.
Theo Does that mean that the same code for the commit phase can be used in any
DOP system?
Joe Definitely. The code that implements the commit phase assumes nothing
about the details of the system except that the system data is represented as an
immutable map.
TIP The implementation of the commit phase in optimistic concurrency control is
universal. It can be used in any system where the data is represented by an immutable
hash map.
Theo That’s awesome!
Joe Another cool thing is that handling concurrency doesn’t require any changes
to the code in the calculation phase. From the calculation phase perspective,
the next version of the system data is computed in isolation as if no other muta-
tions were running concurrently.
Joe stands up to illustrate what he means on the whiteboard. While Theo looks at the draw-
ing in figure 5.1, Joe summarizes the information in table 5.1.
Table 5.1 The two phases of a mutation with optimistic concurrency control
Phase Responsibility State Implementation
Calculation Compute next state in isolation Stateless Specific
Commit Reconcile and update system state Stateful Common

--- 페이지 121 끝 ---


--- 페이지 122 ---

94 CHAPTER 5 Basic concurrency control
Calculation phase
Capturesystem state
Computenext version
Commit phase
Yes No
Concurrent mutations?
Yes No
Conflict?
Updatesystem state
Abortmutation Reconcilemutations
Updatesystem state
Figure 5.1 The logic flow
of optimistic concurrency
control
5.2 Reconciliation between concurrent mutations
Theo Could you give me some examples of conflicting concurrent mutations?
Joe Sure. One example would be two members trying to borrow the same book
copy. Another example might be when two librarians update the publication
year of the same book.
Theo You mentioned that the code for the reconciliation logic in the commit phase
is universal. What do you mean exactly by reconciliation logic?
Joe It’s quite similar to what could happen in Git when you merge a branch back
into the main branch.
Theo I love it when the main branch stays the same.
Joe Yes, it’s nice when the merge has no conflicts and can be done automatically.
Do you remember how Git handles the merge in that case?
Theo Git does a fast-forward; it updates the main branch to be the same as the merge
branch.
Joe Right! And what happens when you discover that, meanwhile, another devel-
oper has committed their code to the main branch?
Theo Then Git does a three-way merge, trying to combine all the changes from the
two merge branches with the main branch.
Joe Does it always go smoothly?
Theo Usually, yes, but it’s possible that two developers have modified the same line
in the same file. I then have to manually resolve the conflict. I hate when that
happens!
TIP In a production system, multiple mutations run concurrently. Before updating
the state, we need to reconcile the conflicts between possible concurrent mutations.

--- 페이지 122 끝 ---


--- 페이지 123 ---

5.2 Reconciliation between concurrent mutations 95
Joe In DOP, the reconciliation algorithm in the commit phase is quite similar to a
merge in Git, except instead of a manual conflict resolution, we abort the
mutation. There are three possibilities to reconcile between possible concur-
rent mutations: fast-forward, three-way merge, or abort.
Joe goes to the whiteboard again. He draws the two diagrams shown in figures 5.2 and 5.3.
Yes No
State has stayed the same
Yes No
Concurrent mutations compatible?
Fast forward
3-way Merge Abort
Figure 5.2 The
reconciliation flow
The version during
the Commit phase
current
previous
next
The base version
for the Calculation
The version Figure 5.3 When the commit phase
phase
returned by the starts, there are three versions of the
Calculation phase system state.
Theo Could you explain in more detail?
Joe When the commit phase of a mutation starts, we have three versions of the sys-
tem state: previous, which is the version on which the calculation phase based
its computation; current, which is the current version during the commit
phase; and next, which is the version returned by the calculation phase.
Theo Why would current be different than previous?
Joe It happens when other mutations have run concurrently with our mutation.
Theo I see.
Joe If we are in a situation where the current state is the same as the previous state,
it means that no mutations run concurrently. Therefore, as in Git, we can
safely fast-forward and update the state of the system with the next version.
Theo What if the state has not stayed the same?
Joe Then it means that mutations have run concurrently. We have to check for
conflicts in a way similar to the three-way merge used by Git. The difference is
that instead of comparing lines, we compare fields of the system hash map.
Theo Could you explain that?

--- 페이지 123 끝 ---
