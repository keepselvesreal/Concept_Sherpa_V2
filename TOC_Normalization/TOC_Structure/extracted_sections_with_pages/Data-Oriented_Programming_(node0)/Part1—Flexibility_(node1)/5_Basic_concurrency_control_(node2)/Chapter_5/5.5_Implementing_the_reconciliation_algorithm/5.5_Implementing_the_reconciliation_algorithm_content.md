# 5.5 Implementing the reconciliation algorithm

**페이지**: 131-133
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 5 Basic concurrency control (node2) > Chapter 5
**추출 시간**: 2025-08-06 19:46:55

---


--- 페이지 131 ---

5.4 Structural difference 103
Joe I suggest that we start with nonconflicting mutations. What do you suggest?
Theo A mutation that updates the publication year of Watchmen and a mutation that
updates both the title of Watchmen and the name of the author of Watchmen.
On his laptop, Theo creates three versions of the library. He shows Joe his code, where one
mutation updates the publication year of Watchmen, and the other one updates the title of
Watchmen and the author’s name.
Listing5.7 Two nonconflicting mutations
var previous = library;
var next = _.set(
library,
["catalog", "booksByIsbn", "978-1779501127", "publicationYear"],
1986);
var libraryWithUpdatedTitle = _.set(
library,
["catalog", "booksByIsbn", "978-1779501127", "title"],
"The Watchmen");
var current = _.set(
libraryWithUpdatedTitle,
["catalog", "authorsById", "dave-gibbons", "name"],
"David Chester Gibbons");
Theo I’m curious to see what the diff between previous and current looks like.
Joe Run the code and you’ll see.
Theo runs the code snippets for the structural diff between previous and next and for
the structural diff between previous and current. His curiosity satisfied, Theo finds it’s
all beginning to make sense.
Listing5.8 Structural diff between maps with a single difference
diff(previous, next);
//{
// "catalog": {
// "booksByIsbn": {
// "978-1779501127": {
// "publicationYear": 1986
// }
// }
// }
//}
Listing5.9 Structural diff between maps with two differences
diff(previous, current);
//{
// "authorsById": {
// "dave-gibbons": {
// "name": "David Chester Gibbons",

--- 페이지 131 끝 ---


--- 페이지 132 ---

104 CHAPTER 5 Basic concurrency control
// }
// },
// "catalog": {
// "booksByIsbn": {
// "978-1779501127": {
// "title": "The Watchmen"
// }
// }
// }
//}
//
Joe Can you give me the information path of the single field in the structural diff
between previous and next?
Theo It’s ["catalog", "booksByIsbn", "978-1779501127", "publicationYear"].
Joe Right. And what are the information paths of the fields in the structural diff
between previous and current?
Theo It’s ["catalog", "booksByIsbn", "978-1779501127", "title"] for the book
title and ["authorsById", "dave-gibbons", "name"] for the author’s name.
Joe Perfect! Now, can you figure out how to detect conflicting mutations by
inspecting the information paths of the structural diffs?
Theo We need to check if they have an information path in common or not.
Joe Exactly! If they have, it means the mutations are conflicting.
Theo But I have no idea how to write code that retrieves the information paths of a
nested map.
Joe Once again, it’s a nontrivial piece of code that involves a recursion inside a
reduce. Let me download another piece of code from my repository and show
it to you.
Listing5.10 Calculating the information paths of a (nested) map
function informationPaths (obj, path = []) {
return _.reduce(obj,
function(acc, v, k) {
if (_.isObject(v)) {
return _.concat(acc,
informationPaths(v,
_.concat(path, k)));
}
return _.concat(acc, [_.concat(path, k)]);
},
[]);
}
Theo Let me see if your code works as expected with the structural diffs of the
mutations.
Theo tests Joe’s code with two code snippets. The first shows the information paths of the
structural diff between previous and next, and the second shows the information paths
of the structural diff between previous and current.

--- 페이지 132 끝 ---


--- 페이지 133 ---

5.4 Structural difference 105
Listing5.11 Fields that differ between previous and next
informationPaths(diff(previous, next));
// → ["catalog.booksByIsbn.978-1779501127.publicationYear"]
Listing5.12 Fields that differ between previous and current
informationPaths(diff(previous, current));
// [
// [
// "catalog",
// "booksByIsbn",
// "978-1779501127",
// "title"
// ],
// [
// "authorsById",
// "dave-gibbons",
// "name"
// ]
//]
Theo Nice! I assume that Lodash has a function that checks whether two arrays have
an element in common.
Joe Almost. There is _.intersection, which returns an array of the unique values
that are in two given arrays. For our purpose, though, we need to check
whether the intersection is empty. Here, look at this example.
Listing5.13 Checking whether two diff maps have a common information path
function havePathInCommon(diff1, diff2) {
return !_.isEmpty(_.intersection(informationPaths(diff1),
informationPaths(diff2)));
}
Theo You told me earlier that in the case of nonconflicting mutations, we can
safely patch the changes induced by the transition from previous to next
into current. How do you implement that?
Joe We do a recursive merge between current and the diff between previous and
next.
Theo Does Lodash provide an immutable version of recursive merge?
Joe Yes, here’s another example. Take a look at this code.
Listing5.14 Applying a patch
_.merge(current, (diff(previous, next)));
//{
// "authorsById": {
// "dave-gibbons": {
// "name": "David Chester Gibbons"
// }
// },

--- 페이지 133 끝 ---
