# 2.4 DOP systems are easy to understand

**페이지**: 64-65
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 2 Separation between code and data (node2) > Chapter 2
**추출 시간**: 2025-08-06 19:46:45

---


--- 페이지 64 ---

36 CHAPTER 2 Separation between code and data
It’s not 100% clear for Theo at this point how the data entities get passed between mod-
ules. For the moment, he thinks of libraryData as a class with two members:
 catalog holds the catalog data.
 userManagement holds the user management data.
Theo also sees that the functions of Library share a common pattern. (Later on in this
chapter, we’ll see the code for some functions of the Library module.)
 They receive libraryData as an argument.
 They pass libraryData.catalog to the functions of Catalog.
 They pass libraryData.userManagement to the functions of UserManagement.
TIP The high-level modules of a DOP system correspond to the high-level data enti-
ties.
2.4 DOP systems are easy to understand
Theo takes a look at the two diagrams that represent the high-level design of his system:
 The data entities in the data mind map in figure 2.8
 The code modules in the module diagram in figure 2.9
A bit perplexed, Theo asks Joe:
Theo I’m not sure that this system is better than a traditional OOP system where
objects encapsulate data.
Joe The main benefit of a DOP system over a traditional OOP system is that it’s eas-
ier to understand.
Theo What makes it easier to understand?
Joe The fact that the system is split cleanly into code modules and data entities.
Theo How does that help?
Joe When you try to understand the data entities of the system, you don’t have to
think about the details of the code that manipulates the data entities.
Theo So, when I look at the data mind map of my Library Management System, I can
understand it on its own?
Joe Exactly, and similarly, when you try to understand the code modules of the sys-
tem, you don’t have to think about the details of the data entities manipulated
by the code. There is a clear separation of concerns between the code and the
data.
Theo looks again at the data mind map in figure 2.8. He has kind of an Aha! moment:
Data lives on its own!
 NOTE A DOP system is easier to understand because the system is split into two
parts: data entities and code modules.

--- 페이지 64 끝 ---


--- 페이지 65 ---

2.4 DOP systems are easy to understand 37
Books
Authors
Catalog
Book items
Library data Book lendings
Users
User management Members
Figure 2.8 A data mind map of the
Librarians
Library Management System
Now, Theo looks at the module diagram in figure 2.9. He feels a bit confused and asks Joe
for clarification:
 On one hand, the module diagram looks similar to the class diagrams from classic
OOP, boxes for classes and arrows for relations between classes.
 On the other hand, the code module diagram looks much simpler than the class
diagrams from classic OOP, but he cannot explain why.
C Library
searchBook(libraryData, searchQuery)
addBookItem(libraryData, bookItemInfo)
blockMember(libraryData, memberId)
unblockMember(libraryData, memberId)
login(libraryData, loginInfo)
getBookLendings(libraryData, userId)
checkoutBook(libraryData, userId, bookItemId)
returnBook(libraryData, userId, bookItemId)
C Catalog
C UserManagement
searchBook(catalogData, searchQuery)
blockMember(userManagementData, memberId)
addBookItem(catalogData, bookItemInfo)
unblockMember(userManagementData, memberId)
checkoutBook(catalogData, bookItemId)
login(userManagementData, loginInfo)
returnBook(catalogData, bookItemId)
isLibrarian(userManagementData, userId)
getBookLendings(catalogData, userId)
Figure 2.9 The modules of the Library Management System with the function arguments
Theo The module diagram seems much simpler than the class diagrams I am used to
in OOP. I feel it, but I can’t put it into words.
Joe The reason is that module diagrams have constraints.

--- 페이지 65 끝 ---
