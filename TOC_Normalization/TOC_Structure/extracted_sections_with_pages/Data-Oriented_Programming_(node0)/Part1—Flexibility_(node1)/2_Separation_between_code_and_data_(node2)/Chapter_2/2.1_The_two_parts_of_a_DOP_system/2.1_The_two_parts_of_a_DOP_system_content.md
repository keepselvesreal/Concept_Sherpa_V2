# 2.1 The two parts of a DOP system

**페이지**: 55-58
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 2 Separation between code and data (node2) > Chapter 2
**추출 시간**: 2025-08-06 19:46:44

---


--- 페이지 55 ---

2.1 The two parts of a DOP system 27
Stateless (static)
Functions
Data asfirst argument
Code modules
Usage
Relations
No inheritance
Separate code from data
Only members
Data entities No code
Association
Relations
Composition
Figure 2.1 DOP principle #1 summarized: Separate code from data.
In this chapter, we’ll illustrate the separation between code and data in the context of
Klafim’s Library Management System that we introduced in chapter 1. We’ll also unveil
the benefits that this separation brings to the system:
 The system is simple. It is easy to understand.
 The system is flexible and extensible. Quite often, it requires no design changes to
adapt to changing requirements.
This chapter focuses on the design of the code in a system where code and data are
separate. In the next chapter, we’ll focus on the design of the data. As we progress in
the book, we’ll discover other benefits of separating code from data.
2.1 The two parts of a DOP system
While Theo is driving home after delivering the prototype, he asks himself whether the
Klafim project was a success or not. Sure, he was able to satisfy the customer, but it was
more luck than brains. He wouldn’t have made it on time if Nancy had decided to keep
the Super members feature. Why was it so complicated to add tiny features to the system?
Why was the system he built so complex? He thought there should be a way to build more
flexible systems!
The next morning, Theo asks on Hacker News and on Reddit for ways to reduce system
complexity and build flexible systems. Some folks mention using different programming
languages, while others talk about advanced design patterns. Finally, Theo’s attention gets
captured by a comment from a user named Joe. He mentions data-oriented programming and
claims that its main goal is to reduce system complexity. Theo has never heard this term
before. Out of curiosity, he decides to contact Joe by email. What a coincidence! Joe lives
in San Francisco too. Theo invites him to a meeting in his office.
Joe is a 40-year-old developer. He was a Java developer for nearly a decade before adopt-
ing Clojure around 7 years ago. When Theo tells Joe about the Library Management System

--- 페이지 55 끝 ---


--- 페이지 56 ---

28 CHAPTER 2 Separation between code and data
he designed and built, and about his struggles to adapt to changing requirements, Joe is
not surprised.
Joe tells Theo that the systems that he and his team have built in Clojure over the last 7
years are less complex and more flexible than the systems he used to build in Java. Accord-
ing to Joe, the systems they build now tend to be much simpler because they follow the
principles of DOP.
Theo I’ve never heard of data-oriented programming. Is it a new concept?
Joe Yes and no. Most of the foundational ideas of data-oriented programming, or
DOP as we like to call it, are well known to programmers as best practices. The
novelty of DOP, however, is that it combines best practices into a cohesive
whole.
Theo That’s a bit abstract for me. Can you give me an example?
Joe Sure! Take, for instance, the first insight of DOP. It’s about the relations between
code and data.
Theo You mean the encapsulation of data in objects?
Joe Actually, DOP is against data encapsulation.
Theo Why is that? I thought data encapsulation was a positive programming paradigm.
Joe Data encapsulation has both merits and drawbacks. Think about the way you
designed the Library Management System. According to DOP, the main cause
of complexity and inflexibility in systems is that code and data are mixed
together in objects.
TIP DOP is against data encapsulation.
Theo It sounds similar to what I’ve heard about functional programming. So, if I
want to adopt DOP, do I need to get rid of object-oriented programming and
learn functional programming?
Joe No, DOP principles are language-agnostic. They can be applied in both object-
oriented and functional programming languages.
Theo That’s a relief! I was afraid that you were going to teach me about monads,
algebraic data types, and higher order functions.
Joe No, none of that is required in DOP.
TIP DOP principles are language-agnostic.
Theo What does the separation between code and data look like in DOP then?
Joe Data is represented by data entities that only hold members. Code is aggre-
gated into modules where all functions are stateless.
Theo What do you mean by stateless functions?
Joe Instead of having the state encapsulated in the object, the data entity is passed
as an argument.
Theo I don’t get that.
Joe Here, let’s make it visual.

--- 페이지 56 끝 ---


--- 페이지 57 ---

2.2 Data entities 29
Joe steps up to a whiteboard and quickly draws a diagram to illustrate his comment. Fig-
ure 2.2 shows Joe’s drawing.
Code modules Stateless functions
Separate code from data
Data entities Only members
Figure 2.2 The separation between code and data
Theo It’s still not clear.
Joe It will become clearer when I show you how it looks in the context of your
Library Management System.
Theo OK. Shall we start with code or with data?
Joe Well, it’s data-oriented programming, so let’s start with data.
2.2 Data entities
In DOP, we start the design process by discovering the data entities of our system.
Here’s what Joe and Theo have to say about data entities.
Joe What are the data entities of your system?
Theo What do you mean by data entities?
Joe I mean the parts of your system that hold information.
 NOTE Data entities are the parts of your system that hold information.
Theo Well, it’s a Library Management System, so we have books and members.
Joe Of course, but there are more. One way to discover the data entities of a system
is to look for nouns and noun phrases in the requirements of the system.
Theo looks at Nancy’s requirement napkin. He highlights the nouns and noun phrases
that seem to represent data entities.
Highlighting terms in the requirements that correspond to data entities
 There are two kinds of users: library members and librarians.
 Users log in to the system via email and password.
 Members can borrow books.
 Members and librarians can search books by title or by author.
 Librarians can block and unblock members (e.g., when they are late in return-
ing a book).
 Librarians can list the books currently lent to a member.
 There could be several copies of a book.

--- 페이지 57 끝 ---


--- 페이지 58 ---

30 CHAPTER 2 Separation between code and data
Joe Excellent. Can you see a natural way to group these entities?
Theo Not sure, but it seems to me that users, members, and librarians form one
group, whereas books, authors, and book copies form another group.
Joe Sounds good to me. What would you call each group?
Theo Probably user management for the first group and catalog for the second
group.
The data entities of the system organized in a nested list
 The catalog data
– Data about books
– Data about authors
– Data about book items
– Data about book lendings
 The user management data
– Data about users
– Data about members
– Data about librarians
Theo I’m not sure about the relations between books and authors. Should it be asso-
ciation or composition?
Joe Don’t worry too much about the details for the moment. We’ll refine our data
entity design later. For now, let’s visualize the two groups in a mind map.
Theo and Joe confer for a bit. Figure 2.3 shows the mind map they come up with.
Books
Authors
Catalog
Book items
Library data Book lendings
Users
User management Members
Librarians Figure 2.3 The data entities of the
system organized in a mind map

--- 페이지 58 끝 ---
