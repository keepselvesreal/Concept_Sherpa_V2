# 6.2.1 The tree of function calls

**페이지**: 145-147
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 6 Unit tests (node2) > Chapter 6
**추출 시간**: 2025-08-06 19:46:57

---


--- 페이지 145 ---

6.2 Unit tests for data manipulation code 117
Joe You could use your big catalogData map for the unit test, but you could also
use a smaller map in the context of Catalog.authorNames. You can get rid of
the booksByIsbn field of the catalogData and the bookIsbns fields of the
authors.
Joe deletes a few lines from catalogData and gets a much smaller map. He shows the revi-
sion to Theo.
Listing6.7 A minimal version of catalogData
var catalogData = {
"authorsById": {
"alan-moore": {
"name": "Alan Moore"
},
"dave-gibbons": {
"name": "Dave Gibbons"
}
}
};
Theo Wait a minute! This catalogData is not valid.
Joe In DOP, data validity depends on the context. In the context of Library
.searchBooksByTitleJSON and Catalog.searchBooksByTitle, the mini-
mal version of catalogData is indeed not valid. However, in the context of
Catalog.bookInfo and Catalog.authorNames, it is perfectly valid. The reason
is that those two functions access only the authorsById field of catalogData.
TIP The validity of the data depends on the context.
Theo Why is it better to use a minimal version of the data in a test case?
Joe For a very simple reason—the smaller the data, the easier it is to manipulate.
TIP The smaller the data, the easier it is to manipulate.
Theo I’ll appreciate that when I write the unit tests!
Joe Definitely! One last thing before we start coding: how would you check that the
output of Catalog.authorNames is as expected?
Theo I would check that the value returned by Catalog.authorNames is an array
with the expected author names.
Joe How would you handle the array comparison?
Theo Let me think. I want to compare by value, not by reference. I guess I’ll have to
check that the array is of the expected size and then check member by mem-
ber, recursively.
Joe That’s too much of a mental burden when you’re in a coffee shop. As I showed
you earlier (see listing 6.1), we can recursively compare two data collections by
value with _.isEqual from Lodash.

--- 페이지 145 끝 ---


--- 페이지 146 ---

118 CHAPTER 6 Unit tests
TIP We can compare the output and the expected output of our functions with
_.isEqual.
Theo Sounds good! Let me write the test cases.
Theo starts typing on his laptop. After a few minutes, he has some test cases for Catalog
.authorNames, each made from a function call to Catalog.authorNames wrapped in
_.isEqual.
Listing6.8 Unit test for Catalog.authorNames
var catalogData = {
"authorsById": {
"alan-moore": {
"name": "Alan Moore"
},
"dave-gibbons": {
"name": "Dave Gibbons"
}
}
};
_.isEqual(Catalog.authorNames(catalogData, []), []);
_.isEqual(Catalog.authorNames(
catalogData,
["alan-moore"]),
["Alan Moore"]);
_.isEqual(Catalog.authorNames(catalogData, ["alan-moore", "dave-gibbons"]),
["Alan Moore", "Dave Gibbons"]);
Joe Well done! Can you think of more test cases?
Theo Yes. There are test cases where the author ID doesn’t appear in the catalog
data, and test cases with empty catalog data. With minimal catalog data and
_.isEqual, it’s really easy to write lots of test cases!
Theo really enjoys this challenge. He creates a few more test cases to present to Joe.
Listing6.9 More test cases for Catalog.authorNames
_.isEqual(Catalog.authorNames({}, []), []);
_.isEqual(Catalog.authorNames({}, ["alan-moore"]), [undefined]);
_.isEqual(Catalog.authorNames(catalogData, ["alan-moore",
"albert-einstein"]), ["Alan Moore", undefined]);
_.isEqual(Catalog.authorNames(catalogData, []), []);
_.isEqual(Catalog.authorNames(catalogData, ["albert-einstein"]),
[undefined]);
Theo How do I run these unit tests?
Joe You use your preferred test framework.

--- 페이지 146 끝 ---


--- 페이지 147 ---

6.2 Unit tests for data manipulation code 119
 NOTE We don’t deal here with test runners and test frameworks. We deal only with
the logic of the test cases.
6.2.3 Unit tests for nodes in the tree
Theo I’m curious to see what unit tests for an upper node in the tree of function calls
look like.
Joe Sure. Let’s write a unit test for Catalog.bookInfo. How many test cases would
you have for Catalog.bookInfo?
Listing6.10 The code of Catalog.bookInfo
Catalog.bookInfo = function (catalogData, book) {
return {
"title": _.get(book, "title"),
"isbn": _.get(book, "isbn"),
"authorNames": Catalog.authorNames(catalogData,
_.get(book, "authorIds"))
};
};
Theo takes another look at the code for Catalog.bookInfo on his laptop. Then, reaching
for another napkin, he draws a diagram of its input and output (see figure 6.3).
catalogData book
Catalog.bookInfo()
Figure 6.3 Visualization of the input
bookInfo and output of Catalog.bookInfo
Theo I would have a similar number of test cases for Catalog.authorNames: a book
with a single author, with two authors, with existing authors, with non-existent
authors, with...
Joe Whoa! That’s not necessary. Given that we have already written unit tests for
Catalog.authorNames, we don’t need to check all the cases again. We simply
need to write a minimal test case to confirm that the code works.
TIP When we write a unit test for a function, we assume that the functions called by
this function are covered by unit tests and work as expected. It significantly reduces
the quantity of test cases in our unit tests.
Theo That makes sense.
Joe How would you write a minimal test case for Catalog.bookInfo?
Theo once again takes a look at the code for Catalog.bookInfo (see listing 6.10). Now he
can answer Joe’s question.

--- 페이지 147 끝 ---
