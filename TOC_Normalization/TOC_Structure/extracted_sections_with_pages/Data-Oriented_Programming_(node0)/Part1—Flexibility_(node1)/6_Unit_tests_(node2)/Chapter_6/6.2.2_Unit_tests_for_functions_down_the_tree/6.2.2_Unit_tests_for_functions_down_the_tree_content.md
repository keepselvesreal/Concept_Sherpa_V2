# 6.2.2 Unit tests for functions down the tree

**페이지**: 148-149
**계층**: Data-Oriented Programming (node0) > Part1—Flexibility (node1) > 6 Unit tests (node2) > Chapter 6
**추출 시간**: 2025-08-06 19:46:57

---


--- 페이지 148 ---

120 CHAPTER 6 Unit tests
Theo I would use the same catalog data as for Catalog.authorNames and a book
record. I’d test that the function behaves as expected by comparing its return
value with a book info record using _.isEqual. Here, let me show you.
It takes Theo a bit more time to write the unit test. The reason is that the input and the
output of Catalog.authorNames are both records. Dealing with a record is more complex
than dealing with an array of strings (as it was the case for Catalog.authorNames). Theo
appreciates the fact that _.isEqual saves him from writing code that compares the two
maps property by property. When he’s through, he shows the result to Joe and takes a nap-
kin to wipe his forehead.
Listing6.11 Unit test for Catalog.bookInfo
var catalogData = {
"authorsById": {
"alan-moore": {
"name": "Alan Moore"
},
"dave-gibbons": {
"name": "Dave Gibbons"
}
}
};
var book = {
"isbn": "978-1779501127",
"title": "Watchmen",
"publicationYear": 1987,
"authorIds": ["alan-moore", "dave-gibbons"]
};
var expectedResult = {
"authorNames": ["Alan Moore", "Dave Gibbons"],
"isbn": "978-1779501127",
"title": "Watchmen",
};
var result = Catalog.bookInfo(catalogData, book);
_.isEqual(result, expectedResult);
Joe Perfect! Now, how would you compare the kind of unit tests for Catalog
.bookInfo with the unit tests for Catalog.authorNames?
Theo On one hand, there is only a single test case in the unit test for Catalog.book-
Info. On the other hand, the data involved in the test case is more complex
than the data involved in the test cases for Catalog.authorNames.
Joe Exactly! Functions that appear in a deep node in the tree of function calls tend
to require more test cases, but the data involved in the test cases is less complex.
TIP Functions that appear in a lower level in the tree of function calls tend to
involve less complex data than functions that appear in a higher level in the tree
(see table 6.2).

--- 페이지 148 끝 ---


--- 페이지 149 ---

6.3 Unit tests for queries 121
Table 6.2 The correlation between the depth of a function in the tree of function calls and the
quality and quantity of the test cases
Depth in the tree Complexity of the data Number of test cases
Lower Higher Lower
Higher Lower Higher
6.3 Unit tests for queries
In the previous section, we saw how to write unit tests for utility functions like Catalog
.bookInfo and Catalog.authorNames. Now, we are going to see how to write unit tests
for the nodes of a query tree of function calls that are close to the root of the tree.
Joe Theo, how would you write a unit test for the code of the entry point of the
search query?
To recall the particulars, Theo checks the code for Library.searchBooksByTitleJSON.
Although Joe was right about today’s topic being easy enough to enjoy the ambience of a
coffee shop, he has been doing quite a lot of coding this morning.
Listing6.12 The code of Library.searchBooksByTitleJSON
Library.searchBooksByTitleJSON = function (libraryData, query) {
var catalogData = _.get(libraryData, "catalog");
var results = Catalog.searchBooksByTitle(catalogData, query);
var resultsJSON = JSON.stringify(results);
return resultsJSON;
};
He then takes a moment to think about how he’d write a unit test for that code. After
another Aha! moment, now he’s got it.
Theo The inputs of Library.searchBooksByTitleJSON are library data and a
query string, and the output is a JSON string (see figure 6.4). So, I would cre-
ate a library data record with a single book and write tests with query strings
that match the name of the book and ones that don’t match.
libraryData query
Library.searchBooksByTitleJSON()
Figure 6.4 The input and output of
resultsJSON Library.searchBooksByTitleJSON
Joe What about the expected results of the test cases?

--- 페이지 149 끝 ---
