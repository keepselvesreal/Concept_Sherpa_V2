{
  "chapter": "7",
  "title": "Basic data validation",
  "page_info": {
    "page": 176,
    "title": "Basic data validation",
    "pattern_matched": "Chapter 7",
    "text_preview": "148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema"
  },
  "leaf_nodes": [
    {
      "text": "- 7.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "raw_line": "- 7.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 57,
      "chapter_info": {
        "page": 176,
        "title": "Basic data validation",
        "pattern_matched": "Chapter 7",
        "text_preview": "148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema"
      },
      "chapter_sections": {
        "start_page": 176,
        "end_page": 201,
        "content": "\n--- Page 176 ---\n148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema from listing 7.6.\nListing7.7 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe Give it a try, and you’ll see.\nIndeed! When Theo executes the code to validate the search request, it returns true.\nListing7.8 Validating the search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksRequest = {\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nvalidate(searchBooksRequestSchema, searchBooksRequest);\n// → true\nJoe Now, please try an invalid request.\nTheo Let me think about what kind of invalidity to try. I know, I’ll make a typo in the\ntitle field and call it tilte with the l before the t.\nAs expected, the code with the type returns false. Theo is not surprised, and Joe is smil-\ning from ear to ear.\nListing7.9 Validating an invalid search request\nvar invalidSearchBooksRequest = {\n\"tilte\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\n--- Page 177 ---\n7.3 Schema flexibility and strictness 149\nvalidate(searchBooksRequestSchema, invalidSearchBooksRequest);\n// → false\nTheo The syntax of JSON Schema is much more verbose than the syntax for declar-\ning the members in a class. Why is that so?\nJoe For two reasons. First, because JSON Schema is language independent, it can\nbe used in any programming language. As I told you, there are JSON Schema\nvalidators available in most programming languages.\nTheo I see.\nJoe Second, JSON Schema allows you to express validation conditions that are much\nharder, if not impossible, to express when data is represented with classes.\nTIP The expressive power of JSON Schema is high!\nTheo Now you have triggered my curiosity. Can you give me some examples?\nJoe In a moment, we’ll talk about schema composition. Someday I’ll show you\nsome examples of advanced validation.\n NOTE Advanced validation is covered in chapter 12.\nTheo What kind of advanced validation?\nJoe What I mean by advanced validation is, for instance, validating that a number\nfalls within a given range or validating that a string matches a regular expression.\nTheo Is there a way to get details about why the request is invalid?\nJoe Absolutely! I’ll show you later. For now, let me show you how to make sure the\nresponse the server sends back to the client is valid.\nTheo It sounds much more complicated than a search book request!\nJoe Why?\nTheo Because a search response is made of multiple book results, and in each book\nresult, some of the fields are optional!\n7.3 Schema flexibility and strictness\nJoe Can you give me an example of what a book search response would look like?\nTheo Take a look at this example. It’s a search response with information about two\nbooks: 7 Habits of Highly Effective People and The Power of Habit.\nListing7.10 An example of a search response\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432\n},\n--- Page 178 ---\n150 CHAPTER 7 Basic data validation\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn_13\": \"978-1982137274\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n]\n}\n]\nJoe It’s funny that you mention The Power of Habit. I’m reading this book in order\nto get rid of my habit of biting my nails. Anyway, what fields are required and\nwhat fields are optional in a book search response?\nTheo In book information, the title and available fields are required. The other\nfields are optional.\nJoe As I told you when we built the schema for the book search request, fields in a\nmap are optional by default. In order to make a field mandatory, we have to\ninclude it in the required array. I’d probably implement it with something\nlike this.\nListing7.11 Schema of a search response\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, map fields are optional by default.\nTheo I must admit that specifying a list of required fields is much simpler than hav-\ning to specify that a member in a class in nullable!\nJoe Agreed!\nTheo On the other hand, I find the nesting of the book information schema in the\nsearch response schema a bit hard to read.\n--- Page 179 ---\n7.3 Schema flexibility and strictness 151\nJoe Nothing prevents you from separating the book information schema from the\nsearch response schema.\nTheo How?\nJoe It’s just JSON, my friend. It means, you are free to manipulate the schema as\nany other map in your program. For instance, you could have the book infor-\nmation schema in a variable named bookInfoSchema and use it in the search\nbooks response schema. Let me refactor the schema to show you what I mean.\nListing7.12 Schema of a search response refactored\nvar bookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n};\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": bookInfoSchema\n};\nTheo Once again, I have to admit that JSON Schemas are more composable than\nclass definitions.\nTIP JSON Schemas are just maps. We are free to compose and manipulate them like\nany other map.\nJoe Let’s move on to validating data received from external data sources.\nTheo Is that different?\nJoe Not really, but I’ll take it as an opportunity to show you some other features of\nJSON Schema.\nTheo I’m curious to learn how data validation is used when we access data from the\ndatabase.\nJoe Each time we access data from the outside, it’s a good practice to validate it.\nCan you show me an example of how a database response for a search query\nwould look?\nTIP It’s a good practice to validate data that comes from an external data source.\n--- Page 180 ---\n152 CHAPTER 7 Basic data validation\nTheo When we query books from the database, we expect to receive an array of\nbooks with three fields: title, isbn, and available. The first two values should\nbe strings, and the third one should be a Boolean.\nJoe Are those fields optional or required?\nTheo What do you mean?\nJoe Could there be books for which some of the fields are not defined?\nTheo No.\nJoe In that case, the schema is quite simple. Would you like to try writing the\nschema for the database response?\nTheo Let me see. It’s an array of objects where each object has three properties, so\nsomething like this?\nListing7.13 Schema of a database response\n{\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n}\nJoe Well done, my friend! Now, I want to tell you about the additionalProperties\nfield in JSON Schema.\nTheo What’s that?\nJoe Take a look at this array.\nListing7.14 A book array with an additional property\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"dummy_property\": 42\n},\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn\": \"978-1982137274\",\n\"dummy_property\": 45\n}\n]\n--- Page 181 ---\n7.3 Schema flexibility and strictness 153\nJoe Is it a valid database response?\nTheo No. A database response should not have a dummy_property field. It should\nhave only the three required fields specified in the schema.\nJoe It might be surprising but, by default, fields not specified in the schema of an\nobject are allowed in JSON Schema. In order to disallow them, one has to set\nadditionalProperties to false like this.\nListing7.15 Disallowing properties not mentioned in the schema\nvar booksFromDBSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"additionalProperties\": false,\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, by default, fields not specified in the schema of a map are\nallowed.\nTheo Why is that?\nJoe The reason is that usually having additional fields in a map doesn’t cause\ntrouble. If your code doesn’t care about a field, it simply ignores it. But some-\ntimes we want to be as strict as possible, and we set additionalProperties\nto false.\nTheo What about the search request and response schema from the previous discus-\nsions? Should we set additionalProperties to false?\nJoe That’s an excellent question. I’d say it’s a matter of taste. Personally, I like to\nallow additional fields in requests and disallow them in responses.\nTheo What’s the advantage?\nJoe Well, the web server is responsible for the responses it sends to its clients. It\nmakes sense then to be as strict as possible. However, the requests are created\nby the clients, and I prefer to do my best to serve my clients even when they are\nnot as strict as they should be.\nTheo Naturally. “The client is always right.”\nJoe Actually, I prefer the way Jon Postel formulated his robustness principle: “Be\nconservative in what you send, be liberal in what you accept.”\nTIP It’s a good practice to be strict with the data that you send and to be flexible with\nthe data that you receive.\n--- Page 182 ---\n154 CHAPTER 7 Basic data validation\n7.4 Schema composition\nTheo What about validating data that comes from an external web service?\nJoe Can you give me an example?\nTheo In the near future, we’ll have to integrate with a service called Open Library\nBooks API that provides detailed information about books.\n NOTE For information on the Open Library Books API, see https://openlibrary\n.org/dev/docs/api/books.\nJoe Can you show me, for instance, the service response for Watchmen?\nTheo Sure. Here you go.\nTheo taps a few keys on his keyboard and brings up the response. Joe looks at the JSON for\na long time.\nListing7.16 An Open Library Books API response example\n{\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n}\nTheo asks himself, “What could be so special in this JSON?” While Joe is meditating about\nthis piece of JSON, Theo writes the JSON Schema for the Books API response. It doesn’t\nseem to be more complicated than any of the previous schemas. When Theo is done, he\nasks Joe to take a look at the schema.\nListing7.17 Schema of the Open Library Books API response\n{\n\"type\": \"object\",\n\"required\": [\"title\"],\n--- Page 183 ---\n7.4 Schema composition 155\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n}\nJoe Good job!\nTheo That wasn’t so hard. I really don’t see why you looked at this JSON response for\nsuch a long time.\nJoe Well, it has to do with the isbn_10 and isbn_13 fields. I assume that they’re\nnot both mandatory.\nTheo Right! That’s why I didn’t include them in the required field of my schema.\nJoe But one of them should always be there. Right?\nTheo Sometimes one of them and sometimes both of them, like for Watchmen. It\ndepends on the publication year of the book. Books published before 2007\nhave isbn_10, and books published after 2007 have isbn_13.\nJoe Oh, I see. And Watchmen has both because it was originally published in 1986\nbut published again after 2007.\nTheo Correct.\nJoe Then, you need your schema to indicate that one of the isbn fields is man-\ndatory. That’s a good opportunity for me to tell you about JSON Schema\ncomposition.\nTheo What’s that?\nJoe It’s a way to combine schemas, similarly to how we combine logical conditions\nwith AND, OR, and NOT.\nTheo I’d like to see that.\nJoe Sure. How would you express the schema for the Books API response as a\ncomposition of three schemas: basicBookInfoSchema, the schema that you\nwrote where only title is required; mandatoryIsbn13, a schema where only\n--- Page 184 ---\n156 CHAPTER 7 Basic data validation\nisbn_13 is required; and mandatoryIsb10, a schema where only isbn_10 is\nrequired?\nTheo I think it should be basicBookInfoSchema AND (mandatoryIsbn13 OR\nmandatoryIsbn10).\nJoe Exactly! The only thing is that in JSON Schema, we use allOf instead of AND,\nand anyOf instead of OR.\nJoe shows Theo the result in listing 7.18 and an example of its usage in listing 7.19.\nListing7.18 Schema of an external API response\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n--- Page 185 ---\n7.4 Schema composition 157\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing7.19 Validating an external API response\nvar bookInfo = {\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n};\nvalidate(bookInfoSchema, bookInfo);\n// → true\nTheo I see why they call it allOf and anyOf. The first one means that data must con-\nform to all the schemas, and the second one means that data must conform to\nany of the schemas.\nJoe Yup.\n NOTE JSON Schema also supports oneOf for cases where data must be valid against\nexactly one schema.\nTheo Nice. With schema composition, JSON Schema seems to have more expressive\npower than what I was used to when representing data with classes.\nJoe That’s only the beginning. I’ll show you more data validation conditions that\ncan’t be expressed when data is represented with classes some other time.\n NOTE Advanced data validation is covered in chapter 12.\nTheo Something still bothers me, though. When data isn’t valid, you don’t know what\nwent wrong.\n--- Page 186 ---\n158 CHAPTER 7 Basic data validation\n7.5 Details about data validation failures\nJoe So far, we’ve treated JSON Schema validation as though it were binary: either a\npiece of data is valid or it isn’t.\nTheo Right...\nJoe But, in fact, when a piece of data is not valid, we can get details about the\nreason of the invalidity.\nTheo Like when a required field is missing, can we get the name of the missing field?\nJoe Yes. When a piece of data is not of the expected type, we can get information\nabout that also.\nTheo That sounds very useful!\nJoe Indeed. Let me show you how it works. Until now, we used a generic validate\nfunction, but when we deal with validation failures, we need to be more specific.\nTheo Why?\nJoe Because each data validator library has its own way of exposing the details of\nadata validation failure. For instance, in JavaScript Ajv, the errors from the\nlast data validation are stored as an array inside the validator instance.\nTheo Why an array?\nJoe Because there could be several failures. But let’s start with the case of a single\nfailure. Imagine we encounter a search book request where the title field is\nnamed myTitle instead of title. Take a look at this example. As you can see,\nwe first instantiate a validator instance.\nListing7.20 Accessing validation errors in Ajv\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nInstantiates a\nvar ajv = new Ajv(); validator instance\najv.validate(searchBooksRequestSchema, invalidSearchBooksRequest);\najv.errors\nDisplays the\nvalidation errors\n--- Page 187 ---\n7.5 Details about data validation failures 159\nTheo And what does the information inside the errors array look like?\nJoe Execute the code snippet. You’ll see.\nWhen Theo executes the code snippets from listing 7.20, he can hardly believe his eyes. He\nlooks at the details, finding the results hard to digest.\nListing7.21 Details for a single data validation failure in an array format\n[\n{\n\"instancePath\": \"\",\n\"schemaPath\": \"#/required\",\n\"keyword\": \"required\",\n\"params\": {\n\"missingProperty\":\"title\"\n},\n\"message\": \"must have required property 'title'\"\n}\n]\nTheo I find the contents of the errors array a bit hard to understand.\nJoe Me too. Fortunately, Ajv provides a errorsText utility function to convert the\nerrors array in a human readable format. See, for instance, what is returned\nwhen you call errorsText.\nListing7.22 Displaying the errors in human readable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title'\"\nTheo Let me see what happens when there are more than one validation failure in\nthe data.\nJoe By default, Ajv catches only one validation error.\nTIP By default, Ajv catches only the first validation failure.\nTheo I guess that’s for performance reasons. Once the validator encounters an\nerror, it doesn’t continue the data parsing.\nJoe Probably. Anyway, in order to catch more than one validation failure, you need\nto pass the allErrors options to the Ajv constructor. Check out this code.\nListing7.23 Catching multiple validation failures\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n--- Page 188 ---\n160 CHAPTER 7 Basic data validation\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nA request with\nthree failures\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [1, 2]\n}; Instantiates the Ajv constructor\nwith allErrors: true in order to\ncatch more than one failure\nvar ajv = new Ajv({allErrors: true});\najv.validate(searchBooksRequestSchema,\ninvalidSearchBooksRequest); Converts the\nerrors to a human\nreadable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title',\n// → data/fields/0 must be string,\n// → data/fields/1 must be string\"\nJoe We validate a search request with myTitle instead of title and numbers\ninstead of strings in the fields array. As you can see in the output of the code\nsnippet, three errors are returned.\nTheo Great! I think I have all that I need in order to add data validation to the\nboundaries of my system when Nancy asks me to make the Library Manage-\nment System into a web server.\nJoe Would you allow me to give you a small gift as a token of our friendship?\nTheo I’d be honored.\nJoe takes a small package out of his bag, wrapped in a light-green ribbon. He hands Theo\nthe package with a solemn gesture.\nWhen Theo undoes the ribbon, he discovers an elegant piece of paper decorated with\npretty little designs. In the center of the paper, Theo manages to read the inscription\n“JSON Schema cheat sheet.” He smiles while browsing the cheat sheet. It’s exactly what he\nneeds.\nListing7.24 JSON Schema cheat sheet\n{ At the root level,\ndata is an array.\n\"type\": \"array\",\n\"items\": { Each element of the\narray is a map.\n\"type\": \"object\",\nmyNumber \"properties\": {\nThe properties of\nis a number. \"myNumber\": {\"type\": \"number\"},\neach field in the map\n\"myString\": {\"type\": \"string\"},\nmyString is\n\"myEnum\": {\"enum\": [\"myVal\", \"yourVal\"]},\na string. myEnum is a\n\"myBool\": {\"type\": \"boolean\"}\nenumeration\nmyBool is a }, value with two\nboolean. \"required\": [\"myNumber\", \"myString\"], possibilities:\nThe mandatory fields in the map \"myVal\" and\nare myNumber and myString; \"yourVal\".\nother fields are optional.\n--- Page 189 ---\nSummary 161\n\"additionalProperties\": false\nWe don’t allow fields that\n}\nare not explicitly mentioned\n}\nin the schema.\nThen, Theo turns the paper over to find that the back is also filled with drawings. In the\ncenter of the paper, he reads the inscription, “An example of valid data.”\nListing7.25 An example of valid data\n[\n{\nThis map is valid\n\"myNumber\": 42,\nbecause all its\n\"myString\": \"Hello\",\nfields are valid.\n\"myEnum\": \"myVal\",\n\"myBool\": true\n},\n{\nThis map is valid\n\"myNumber\": 54,\nbecause it contains all\n\"myString\": \"Happy\"\nthe required fields.\n}\n]\nSummary\n DOP Principle #4 is to separate data schema and data representation.\n The boundaries of a system are defined to be the areas where the system\nexchanges data.\n Some examples of data validation at the boundaries of the system are validation\nof client requests and responses, and validation of data that comes from exter-\nnal sources.\n Data validation in DOP means checking whether a piece of data conforms to a\nschema.\n When a piece of data is not valid, we get information about the validation fail-\nures and send this information back to the client in a human readable format.\n When data at system boundaries is valid, it’s not critical to validate data again\ninside the system.\n JSON Schema is a language that allows us to separate data validation from data\nrepresentation.\n JSON Schema syntax is a bit verbose.\n The expressive power of JSON Schema is high.\n JSON Schemas are just maps and, as so, we are free to manipulate them like any\nother maps in our programs.\n We can store a schema definition in a variable and use this variable in another\nschema.\n In JSON Schema, map fields are optional by default.\n It’s good practice to validate data that comes from an external data source.\n--- Page 190 ---\n162 CHAPTER 7 Basic data validation\n It’s good practice to be strict regarding data that you send and to be flexible\nregarding data that you receive.\n Ajv is a JSON Schema library in JavaScript.\n By default, Ajv catches only the first validation failure.\n Advanced validation is covered in chapter 12.\n--- Page 191 ---\nAdvanced\nconcurrency control\nNo more deadlocks!\nThis chapter covers\n Atoms as an alternative to locks\n Managing a thread-safe counter and a thread-safe\nin-memory cache with atoms\n Managing the whole system state in a thread-safe\nway with atoms\nThe traditional way to manage concurrency in a multi-threaded environment\ninvolves lock mechanisms like mutexes. Lock mechanisms tend to increase the com-\nplexity of the system because it’s not trivial to make sure the system is free of dead-\nlocks. In DOP, we leverage the fact that data is immutable, and we use a lock-free\nmechanism, called an atom, to manage concurrency. Atoms are simpler to manage\nthan locks because they are lock-free. As a consequence, the usual complexity of\nlocks that are required to avoid deadlocks don’t apply to atoms.\n NOTE This chapter is mostly relevant to multi-threaded environments like Java,\nC#, Python, and Ruby. It is less relevant to single-threaded environments like Java-\nScript. The JavaScript code snippets in this chapter are written as though JavaScript\nwere multi-threaded.\n163\n--- Page 192 ---\n164 CHAPTER 8 Advanced concurrency control\n8.1 The complexity of locks\nThis Sunday afternoon, while riding his bike across the Golden Gate Bridge, Theo thinks\nabout the Klafim project with concern, not yet sure that betting on DOP was a good\nchoice. Suddenly, Theo realizes that he hasn’t yet scheduled the next session with Joe. He\ngets off his bike to call Joe. Bad luck, the line is busy.\nWhen Theo gets home, he tries to call Joe again, but once again the phone is busy. After\ndinner, Theo tries to call Joe one more time, with the same result—a busy signal. “Obvi-\nously, Joe is very busy today,” Theo tells himself. Exhausted by his 50-mile bike ride at an\naverage of 17 miles per hour, he falls asleep on the sofa. When Theo wakes up, he’s elated\nto see a text message from Joe, “See you Monday morning at 11 AM?” Theo answers with a\nthumbs up and prepares for another week of work.\nWhen Joe arrives at the office, Theo asks him why his phone was constantly busy the day\nbefore. Joe answers that he was about to ask Theo the same question. They look at each\nother, puzzled, and then simultaneously break into laughter as they realize what hap-\npened: in an amazing coincidence, they’d tried to phone each other at exactly the same\ntimes. They both say at once:\n“A deadlock!”\nThey both head for Theo’s office. When they get to Theo’s desk, Joe tells him that today’s\nsession is going to be about concurrency management in multi-threaded environments.\nJoe How do you usually manage concurrency in a multi-threaded environment?\nTheo I protect access to critical sections with a lock mechanism, a mutex, for instance.\nJoe When you say access, do you mean write access or also read access?\nTheo Both!\nJoe Why do you need to protect read access with a lock?\nTheo Because, without a lock protection, in the middle of a read, a write could hap-\npen in another thread. It would make my read logically inconsistent.\nJoe Another option would be to clone the data before processing it in a read.\nTheo Sometimes I would clone the data; but in many cases, when it’s large, it’s too\nexpensive to clone.\nTIP Cloning data to avoid read locks doesn’t scale.\nJoe In DOP, we don’t need to clone or to protect read access.\nTheo Because data is immutable?\nJoe Right. When data is immutable, even if a write happens in another thread\nduring a read, it won’t make the read inconsistent because the write never\nmutates the data that is read.\nTheo In a sense, a read always works on a data snapshot.\nJoe Exactly!\nTIP When data is immutable, a read is always safe.\nTheo But what about write access? Don’t you need to protect that with locks?\nJoe Nope.\n--- Page 193 ---\n8.2 Thread-safe counter with atoms 165\nTheo Why not?\nJoe We have a simpler mechanism—it’s called an atom.\nTheo I am glad to hear there is a something simpler than locks. I really struggle each\ntime I have to integrate locks into a multi-threaded system.\nJoe Me too! I remember a bug we had in production 10 years ago. We forgot to\nrelease a lock when an exception was thrown in a critical section. It caused a\nterrible deadlock.\nTheo Deadlocks are really hard to avoid. Last year, we had a deadlock issue when two\nlocks were not released in the proper order.\nJoe I have great news for you. With atoms, deadlocks never happen!\nTIP With atoms, deadlocks never happen.\nTheo That sounds great. Tell me more!\nTIP Atoms provide a way to manage concurrency without locks.\n8.2 Thread-safe counter with atoms\nJoe Let’s start with a simple case: a counter shared between threads.\nTheo What do you mean by a counter?\nJoe Imagine that we’d like to count the number of database accesses and write the\ntotal number of accesses to a log every minute.\nTheo OK.\nJoe Could you write JavaScript code for this multi-threaded counter using locks?\nTheo But JavaScript is single-threaded!\nJoe I know, but it’s just for the sake of illustration. Imagine that JavaScript were\nmulti-threaded and that it provided a Mutex object that you could lock and\nunlock.\nTheo It’s a bit awkward. I guess it would look like this.\nTheo goes to the whiteboard. He writes what he imagines to be JavaScript code for a multi-\nthreaded counter with locks.\nListing8.1 A thread-safe counter protected by a mutex\nvar mutex = new Mutex();\nvar counter = 0;\nfunction dbAccess() {\nmutex.lock();\ncounter = counter + 1;\nmutex.unlock();\n// access the database\n}\nfunction logCounter() {\nmutex.lock();\n--- Page 194 ---\n166 CHAPTER 8 Advanced concurrency control\nconsole.log('Number of database accesses: ' + counter);\nmutex.unlock();\n}\nJoe Excellent. Now, I am going to show you how to write the same code with atoms.\nAn atom provides three methods:\n get returns the current value of the atom.\n set overwrites the current value of the atom.\n swap receives a function and updates the value of the atom with the result\nof the function called on the current value of the atom.\nJoe unzips a pocket in his laptop case and takes out a piece of paper. He hands it to\nTheo. Theo is pleasantly surprised as the sheet of paper succinctly describes the methods\n(table 8.1).\nTable 8.1 The three methods of an atom\nMethod Description\nget Returns the current value\nset Overwrites the current value\nswap Updates the current value with a function\nTheo How would it look like to implement a thread-safe counter with an atom?\nJoe It’s quite simple, actually.\nJoe pulls out his laptop, fires it up, and begins to type. When he’s done, he turns the laptop\naround so that Theo can see the code to implement a thread-safe counter in an atom.\nListing8.2 A thread-safe counter stored in an atom\nvar counter = new Atom();\ncounter.set(0);\nfunction dbAccess() {\ncounter.swap(function(x) {\nThe argument x is the\nreturn x + 1;\ncurrent value of the atom,\n});\nsame as counter.get().\n// access the database\n}\nfunction logCounter() {\nconsole.log('Number of database accesses: ' + counter.get());\n}\nTheo Could you tell me what’s going on here?\nJoe Sure! First, we create an empty atom. Then, we initialize the value of the atom\nwith counter.set(0). In the logger thread, we read the current value of the\natom with counter.get().\nTheo And how do you increment the counter in the threads that access the database?\n--- Page 195 ---\n8.2 Thread-safe counter with atoms 167\nJoe We call swap with a function that receives x and returns x + 1.\nTheo I don’t understand how swap could be thread-safe without using any locks.\nJoe quickly goes to the whiteboard. He sketches the diagram in figure 8.1.\nTake snapshot\nCompute next state\nYes\nState changed?\nNo\nUpdate state\nFigure 8.1 High-level flow of swap\nJoe You see, swap computes the next value of the atom, and before modifying the\ncurrent value of the atom, it checks whether the value of the atom has changed\nduring the computation. If so, swap tries again, until no changes occur during\nthe computation.\nTheo Is swap easy to implement?\nJoe Let me show you the implementation of the Atom class and you’ll see.\nListing8.3 Implementation of the Atom class\nclass Atom {\nstate;\nconstructor() {}\nget() {\nreturn this.state;\n}\nset(state) {\nthis.state = state;\n}\nswap(f) {\nwhile(true) {\nvar stateSnapshot = this.state;\nvar nextState = f(stateSnapshot);\nif (!atomicCompareAndSet(this.state,\n--- Page 196 ---\n168 CHAPTER 8 Advanced concurrency control\nstateSnapshot,\nnextState)) {\nUses a special thread-safe comparison operation\ncontinue;\nas this.state might have changed in another\n}\nthread during execution of the function f.\nreturn nextState;\n}\n}\n}\nTheo comes closer to the whiteboard. He modifies Joe’s diagram a bit to make the flow of\nthe swap operation more detailed. The resulting diagram is in figure 8.2. Theo still has a\nfew questions, though.\nTake snapshot\nsnapshot = state\nCompute next state\nnextState = f(snapshot)\nCheck if state has changed\nstate == snapshot\nYes\nState changed?\nNo\nUpdate state\nstate = nextState\nFigure 8.2 Detailed flow of swap\nTheo What is atomicCompareAndSet?\nJoe It’s the core operation of an atom. atomicCompareAndSet atomically sets the\nstate to a new value if, and only if, the state equals the provided old value. It\nreturns true upon success and false upon failure.\nTheo How could it be atomic without using locks?\nJoe That’s a great question! In fact, atomicCompareAndSet is a compare-and-swap\noperation, provided by the language that relies on a functionality of the CPU\nitself. For example, in Java the java.util.concurrent.atomic package has\nan AtomicReference generic class that provides a compareAndSet() method.\n NOTE See http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html\nfor general information about compare-and-swap operations. Implementations for\nmulti-threaded languages appear in table 8.2.\n--- Page 197 ---\n8.2 Thread-safe counter with atoms 169\nTable 8.2 Implementation of an atomic compare and set in various languages\nLanguage Link\nJava http://mng.bz/mx0W\nJavaScript Not relevant (single-threaded language)\nRuby http://mng.bz/5KG8\nPython https://github.com/maxcountryman/atomos\nC# http://mng.bz/6Zzp\nTheo Apropos Java, how would the implementation of an atom look?\nJoe It’s quite the same, besides the fact that Atom has to use generics, and the inner\nstate has to be stored in an AtomicReference.\nJoe brings up a Java implementation of Atom on his laptop. Theo looks over the code.\nListing8.4 Implementation of the Atom class in Java\nclass Atom<ValueType> {\nprivate AtomicReference<ValueType> state;\npublic Atom() {}\nValueType get() {\nreturn this.state.get();\n}\nthis.state might have\nchanged in another thread\nvoid set(ValueType state) {\nduring the execution of f.\nthis.state.set(state);\n}\nValueType swap(UnaryOPerator<ValueType> f) {\nwhile(true) {\nValueType stateSnapshot = this.state.get();\nValueType nextState = f(stateSnapshot);\nif (!this.state.compareAndSet(stateSnapshot,\nnextState)) {\ncontinue;\n}\n}\nreturn nextState;\n}\n}\nTheo What about using an atom in Java?\nJoe Here, take a look. It’s quite simple.\n--- Page 198 ---\n170 CHAPTER 8 Advanced concurrency control\nListing8.5 Using an Atom in Java\nAtom<Integer> counter = new Atom<Integer>();\ncounter.set(0);\ncounter.swap(x -> x + 1);\ncounter.get();\nTheo takes a couple of minutes to meditate about this atom stuff and to digest what he’s\njust learned. Then, he asks Joe:\nTheo What if swap never succeeds? I mean, could the while loop inside the code of\nswap turn out to be an infinite loop?\nJoe No! By definition, when atomicCompareAndSet fails on a thread, it means that\nthe same atom was changed on another thread during the execution of swap.\nIn this race between threads, there is always a winner.\nTheo But isn’t it possible that some thread never succeeds because it always loses the\nrace against other threads?\nJoe In theory, yes, but I’ve never encountered such a situation. If you have thou-\nsands of threads that do nothing besides swapping an atom, it could happen I\nsuppose. But, in practice, once the atom is swapped, the threads do some real\nwork, for example, database access or I/O. This gives other threads the oppor-\ntunity to swap the atom successfully.\n NOTE In theory, atoms could create starvation in a system with thousands of threads\nthat do nothing beside swapping an atom. In practice, once an atom is swapped, the\nthreads do some real work (e.g., database access), which creates an opportunity for\nother threads to swap the atom successfully.\nTheo Interesting.... Indeed, atoms look much easier to manage than locks.\nJoe Now let me show you how to use atoms with composite data.\nTheo Why would that be different?\nJoe Usually, dealing with composite data is more difficult than dealing with primi-\ntive types.\nTheo When you sold me on DOP, you told me that we are able to manage data with\nthe same simplicity as we manage numbers.\nTIP In DOP, data is managed with the same simplicity as numbers.\nJoe That’s exactly what I am about to show you.\n8.3 Thread-safe cache with atoms\nJoe Are you familiar with the notion of in-memory cache?\nTheo You mean memoization?\n--- Page 199 ---\n8.3 Thread-safe cache with atoms 171\nJoe Kind of. Imagine that database queries don’t vary too much in your applica-\ntion. It makes sense in that case to store the results of previous queries in mem-\nory in order to improve the response time.\nTheo Yes, of course!\nJoe What data structure would you use to store the in-memory cache?\nTheo Probably a string map, where the keys are the queries, and the values are the\nresults from the database.\nTIP It’s quite common to represent an in-memory cache as a string map.\nJoe Excellent! Now can you write the code to cache database queries in a thread-\nsafe way using a lock?\nTheo Let me see: I’m going to use an immutable string map. Therefore, I don’t\nneed to protect read access with a lock. Only the cache update needs to be\nprotected.\nJoe You’re getting the hang of this!\nTheo The code should be something like this.\nListing8.6 Thread-safe cache with locks\nvar mutex = new Mutex();\nvar cache = {};\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache, query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\nmutex.lock();\ncache = _.set(cache, query, result);\nmutex.unlock();\nreturn result;\n}\nJoe Nice! Now, let me show you how to write the same code using an atom instead\nof a lock. Take a look at this code and let me know if it’s clear to you.\nListing8.7 Thread-safe cache with atoms\nvar cache = new Atom();\ncache.set({});\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache.get(), query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\ncache.swap(function(oldCache) {\n--- Page 200 ---\n172 CHAPTER 8 Advanced concurrency control\nreturn _.set(oldCache, query, result);\n});\nreturn result;\n}\nTheo I don’t understand the function you’re passing to the swap method.\nJoe The function passed to swap receives the current value of the cache, which is a\nstring map, and returns a new version of the string map with an additional key-\nvalue pair.\nTheo I see. But something bothers me with the performance of the swap method in\nthe case of a string map. How does the comparison work? I mean, comparing\ntwo string maps might take some time.\nJoe Not if you compare them by reference. As we discussed in the past, when data\nis immutable, it is safe to compare by reference, and it’s super fast.\nTIP When data is immutable, it is safe (and fast) to compare it by reference.\nTheo Cool. So atoms play well with immutable data.\nJoe Exactly!\n8.4 State management with atoms\nJoe Do you remember a couple of weeks ago when I showed you how we resolve\npotential conflicts between mutations? You told me that the code was not\nthread-safe.\nTheo Let me look again at the code.\nTheo takes a look at the code for the SystemData class that he wrote some time ago\n(repeated in listing 8.8). Without the validation logic, it makes the code easier to grasp.\nListing8.8 SystemData class from part 1\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nthis.systemData = SystemConsistency.reconcile(this.systemData,\nprevious,\nnext);\n}\n}\n--- Page 201 ---\n8.4 State management with atoms 173\nIt takes him a few minutes to remember how the commit method works. Suddenly, he has\nan Aha! moment.\nTheo This code is not thread-safe because the SystemConsistency.reconcile\ncode inside the commit method is not protected. Nothing prevents the two\nthreads from executing this code concurrently.\nJoe Right! Now, can you tell me how to make it thread-safe?\nTheo With locks?\nJoe Come on...\nTheo I was kidding, of course. We make the code thread-safe not with a lock but with\nan atom.\nJoe Nice joke!\nTheo Let me see. I’d need to store the system data inside an atom. The get and set\nmethod of SystemData would simply call the get and set methods of the\natom. How does this look?\nListing8.9 SystemData class with atom (without the commit method)\nclass SystemState {\nsystemData;\nconstructor() {\nthis.systemData = new Atom();\n}\nget() {\nreturn this.systemData.get();\n}\ncommit(prev, next) {\nthis.systemData.set(next);\n}\n}\nJoe Excellent. Now for the fun part. Implement the commit method by calling the\nswap method of the atom.\nTheo Instead of calling SystemConsistency.reconcile() directly, I need to wrap\nit into a call to swap. So, something like this?\nListing8.10 Implementation of SystemData.commit with atom\nSystemData.commit = function(previous, next) {\nthis.systemData.swap(function(current) {\nreturn SystemConsistency.reconcile(current,\nprevious,\nnext);\n});\n};",
        "sections_found": []
      },
      "accurate_page_range": "176-201"
    },
    {
      "text": "- 7.1 Data validation in DOP",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "raw_line": "- 7.1 Data validation in DOP (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 58,
      "chapter_info": {
        "page": 176,
        "title": "Basic data validation",
        "pattern_matched": "Chapter 7",
        "text_preview": "148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema"
      },
      "chapter_sections": {
        "start_page": 176,
        "end_page": 201,
        "content": "\n--- Page 176 ---\n148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema from listing 7.6.\nListing7.7 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe Give it a try, and you’ll see.\nIndeed! When Theo executes the code to validate the search request, it returns true.\nListing7.8 Validating the search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksRequest = {\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nvalidate(searchBooksRequestSchema, searchBooksRequest);\n// → true\nJoe Now, please try an invalid request.\nTheo Let me think about what kind of invalidity to try. I know, I’ll make a typo in the\ntitle field and call it tilte with the l before the t.\nAs expected, the code with the type returns false. Theo is not surprised, and Joe is smil-\ning from ear to ear.\nListing7.9 Validating an invalid search request\nvar invalidSearchBooksRequest = {\n\"tilte\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\n--- Page 177 ---\n7.3 Schema flexibility and strictness 149\nvalidate(searchBooksRequestSchema, invalidSearchBooksRequest);\n// → false\nTheo The syntax of JSON Schema is much more verbose than the syntax for declar-\ning the members in a class. Why is that so?\nJoe For two reasons. First, because JSON Schema is language independent, it can\nbe used in any programming language. As I told you, there are JSON Schema\nvalidators available in most programming languages.\nTheo I see.\nJoe Second, JSON Schema allows you to express validation conditions that are much\nharder, if not impossible, to express when data is represented with classes.\nTIP The expressive power of JSON Schema is high!\nTheo Now you have triggered my curiosity. Can you give me some examples?\nJoe In a moment, we’ll talk about schema composition. Someday I’ll show you\nsome examples of advanced validation.\n NOTE Advanced validation is covered in chapter 12.\nTheo What kind of advanced validation?\nJoe What I mean by advanced validation is, for instance, validating that a number\nfalls within a given range or validating that a string matches a regular expression.\nTheo Is there a way to get details about why the request is invalid?\nJoe Absolutely! I’ll show you later. For now, let me show you how to make sure the\nresponse the server sends back to the client is valid.\nTheo It sounds much more complicated than a search book request!\nJoe Why?\nTheo Because a search response is made of multiple book results, and in each book\nresult, some of the fields are optional!\n7.3 Schema flexibility and strictness\nJoe Can you give me an example of what a book search response would look like?\nTheo Take a look at this example. It’s a search response with information about two\nbooks: 7 Habits of Highly Effective People and The Power of Habit.\nListing7.10 An example of a search response\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432\n},\n--- Page 178 ---\n150 CHAPTER 7 Basic data validation\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn_13\": \"978-1982137274\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n]\n}\n]\nJoe It’s funny that you mention The Power of Habit. I’m reading this book in order\nto get rid of my habit of biting my nails. Anyway, what fields are required and\nwhat fields are optional in a book search response?\nTheo In book information, the title and available fields are required. The other\nfields are optional.\nJoe As I told you when we built the schema for the book search request, fields in a\nmap are optional by default. In order to make a field mandatory, we have to\ninclude it in the required array. I’d probably implement it with something\nlike this.\nListing7.11 Schema of a search response\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, map fields are optional by default.\nTheo I must admit that specifying a list of required fields is much simpler than hav-\ning to specify that a member in a class in nullable!\nJoe Agreed!\nTheo On the other hand, I find the nesting of the book information schema in the\nsearch response schema a bit hard to read.\n--- Page 179 ---\n7.3 Schema flexibility and strictness 151\nJoe Nothing prevents you from separating the book information schema from the\nsearch response schema.\nTheo How?\nJoe It’s just JSON, my friend. It means, you are free to manipulate the schema as\nany other map in your program. For instance, you could have the book infor-\nmation schema in a variable named bookInfoSchema and use it in the search\nbooks response schema. Let me refactor the schema to show you what I mean.\nListing7.12 Schema of a search response refactored\nvar bookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n};\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": bookInfoSchema\n};\nTheo Once again, I have to admit that JSON Schemas are more composable than\nclass definitions.\nTIP JSON Schemas are just maps. We are free to compose and manipulate them like\nany other map.\nJoe Let’s move on to validating data received from external data sources.\nTheo Is that different?\nJoe Not really, but I’ll take it as an opportunity to show you some other features of\nJSON Schema.\nTheo I’m curious to learn how data validation is used when we access data from the\ndatabase.\nJoe Each time we access data from the outside, it’s a good practice to validate it.\nCan you show me an example of how a database response for a search query\nwould look?\nTIP It’s a good practice to validate data that comes from an external data source.\n--- Page 180 ---\n152 CHAPTER 7 Basic data validation\nTheo When we query books from the database, we expect to receive an array of\nbooks with three fields: title, isbn, and available. The first two values should\nbe strings, and the third one should be a Boolean.\nJoe Are those fields optional or required?\nTheo What do you mean?\nJoe Could there be books for which some of the fields are not defined?\nTheo No.\nJoe In that case, the schema is quite simple. Would you like to try writing the\nschema for the database response?\nTheo Let me see. It’s an array of objects where each object has three properties, so\nsomething like this?\nListing7.13 Schema of a database response\n{\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n}\nJoe Well done, my friend! Now, I want to tell you about the additionalProperties\nfield in JSON Schema.\nTheo What’s that?\nJoe Take a look at this array.\nListing7.14 A book array with an additional property\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"dummy_property\": 42\n},\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn\": \"978-1982137274\",\n\"dummy_property\": 45\n}\n]\n--- Page 181 ---\n7.3 Schema flexibility and strictness 153\nJoe Is it a valid database response?\nTheo No. A database response should not have a dummy_property field. It should\nhave only the three required fields specified in the schema.\nJoe It might be surprising but, by default, fields not specified in the schema of an\nobject are allowed in JSON Schema. In order to disallow them, one has to set\nadditionalProperties to false like this.\nListing7.15 Disallowing properties not mentioned in the schema\nvar booksFromDBSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"additionalProperties\": false,\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, by default, fields not specified in the schema of a map are\nallowed.\nTheo Why is that?\nJoe The reason is that usually having additional fields in a map doesn’t cause\ntrouble. If your code doesn’t care about a field, it simply ignores it. But some-\ntimes we want to be as strict as possible, and we set additionalProperties\nto false.\nTheo What about the search request and response schema from the previous discus-\nsions? Should we set additionalProperties to false?\nJoe That’s an excellent question. I’d say it’s a matter of taste. Personally, I like to\nallow additional fields in requests and disallow them in responses.\nTheo What’s the advantage?\nJoe Well, the web server is responsible for the responses it sends to its clients. It\nmakes sense then to be as strict as possible. However, the requests are created\nby the clients, and I prefer to do my best to serve my clients even when they are\nnot as strict as they should be.\nTheo Naturally. “The client is always right.”\nJoe Actually, I prefer the way Jon Postel formulated his robustness principle: “Be\nconservative in what you send, be liberal in what you accept.”\nTIP It’s a good practice to be strict with the data that you send and to be flexible with\nthe data that you receive.\n--- Page 182 ---\n154 CHAPTER 7 Basic data validation\n7.4 Schema composition\nTheo What about validating data that comes from an external web service?\nJoe Can you give me an example?\nTheo In the near future, we’ll have to integrate with a service called Open Library\nBooks API that provides detailed information about books.\n NOTE For information on the Open Library Books API, see https://openlibrary\n.org/dev/docs/api/books.\nJoe Can you show me, for instance, the service response for Watchmen?\nTheo Sure. Here you go.\nTheo taps a few keys on his keyboard and brings up the response. Joe looks at the JSON for\na long time.\nListing7.16 An Open Library Books API response example\n{\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n}\nTheo asks himself, “What could be so special in this JSON?” While Joe is meditating about\nthis piece of JSON, Theo writes the JSON Schema for the Books API response. It doesn’t\nseem to be more complicated than any of the previous schemas. When Theo is done, he\nasks Joe to take a look at the schema.\nListing7.17 Schema of the Open Library Books API response\n{\n\"type\": \"object\",\n\"required\": [\"title\"],\n--- Page 183 ---\n7.4 Schema composition 155\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n}\nJoe Good job!\nTheo That wasn’t so hard. I really don’t see why you looked at this JSON response for\nsuch a long time.\nJoe Well, it has to do with the isbn_10 and isbn_13 fields. I assume that they’re\nnot both mandatory.\nTheo Right! That’s why I didn’t include them in the required field of my schema.\nJoe But one of them should always be there. Right?\nTheo Sometimes one of them and sometimes both of them, like for Watchmen. It\ndepends on the publication year of the book. Books published before 2007\nhave isbn_10, and books published after 2007 have isbn_13.\nJoe Oh, I see. And Watchmen has both because it was originally published in 1986\nbut published again after 2007.\nTheo Correct.\nJoe Then, you need your schema to indicate that one of the isbn fields is man-\ndatory. That’s a good opportunity for me to tell you about JSON Schema\ncomposition.\nTheo What’s that?\nJoe It’s a way to combine schemas, similarly to how we combine logical conditions\nwith AND, OR, and NOT.\nTheo I’d like to see that.\nJoe Sure. How would you express the schema for the Books API response as a\ncomposition of three schemas: basicBookInfoSchema, the schema that you\nwrote where only title is required; mandatoryIsbn13, a schema where only\n--- Page 184 ---\n156 CHAPTER 7 Basic data validation\nisbn_13 is required; and mandatoryIsb10, a schema where only isbn_10 is\nrequired?\nTheo I think it should be basicBookInfoSchema AND (mandatoryIsbn13 OR\nmandatoryIsbn10).\nJoe Exactly! The only thing is that in JSON Schema, we use allOf instead of AND,\nand anyOf instead of OR.\nJoe shows Theo the result in listing 7.18 and an example of its usage in listing 7.19.\nListing7.18 Schema of an external API response\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n--- Page 185 ---\n7.4 Schema composition 157\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing7.19 Validating an external API response\nvar bookInfo = {\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n};\nvalidate(bookInfoSchema, bookInfo);\n// → true\nTheo I see why they call it allOf and anyOf. The first one means that data must con-\nform to all the schemas, and the second one means that data must conform to\nany of the schemas.\nJoe Yup.\n NOTE JSON Schema also supports oneOf for cases where data must be valid against\nexactly one schema.\nTheo Nice. With schema composition, JSON Schema seems to have more expressive\npower than what I was used to when representing data with classes.\nJoe That’s only the beginning. I’ll show you more data validation conditions that\ncan’t be expressed when data is represented with classes some other time.\n NOTE Advanced data validation is covered in chapter 12.\nTheo Something still bothers me, though. When data isn’t valid, you don’t know what\nwent wrong.\n--- Page 186 ---\n158 CHAPTER 7 Basic data validation\n7.5 Details about data validation failures\nJoe So far, we’ve treated JSON Schema validation as though it were binary: either a\npiece of data is valid or it isn’t.\nTheo Right...\nJoe But, in fact, when a piece of data is not valid, we can get details about the\nreason of the invalidity.\nTheo Like when a required field is missing, can we get the name of the missing field?\nJoe Yes. When a piece of data is not of the expected type, we can get information\nabout that also.\nTheo That sounds very useful!\nJoe Indeed. Let me show you how it works. Until now, we used a generic validate\nfunction, but when we deal with validation failures, we need to be more specific.\nTheo Why?\nJoe Because each data validator library has its own way of exposing the details of\nadata validation failure. For instance, in JavaScript Ajv, the errors from the\nlast data validation are stored as an array inside the validator instance.\nTheo Why an array?\nJoe Because there could be several failures. But let’s start with the case of a single\nfailure. Imagine we encounter a search book request where the title field is\nnamed myTitle instead of title. Take a look at this example. As you can see,\nwe first instantiate a validator instance.\nListing7.20 Accessing validation errors in Ajv\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nInstantiates a\nvar ajv = new Ajv(); validator instance\najv.validate(searchBooksRequestSchema, invalidSearchBooksRequest);\najv.errors\nDisplays the\nvalidation errors\n--- Page 187 ---\n7.5 Details about data validation failures 159\nTheo And what does the information inside the errors array look like?\nJoe Execute the code snippet. You’ll see.\nWhen Theo executes the code snippets from listing 7.20, he can hardly believe his eyes. He\nlooks at the details, finding the results hard to digest.\nListing7.21 Details for a single data validation failure in an array format\n[\n{\n\"instancePath\": \"\",\n\"schemaPath\": \"#/required\",\n\"keyword\": \"required\",\n\"params\": {\n\"missingProperty\":\"title\"\n},\n\"message\": \"must have required property 'title'\"\n}\n]\nTheo I find the contents of the errors array a bit hard to understand.\nJoe Me too. Fortunately, Ajv provides a errorsText utility function to convert the\nerrors array in a human readable format. See, for instance, what is returned\nwhen you call errorsText.\nListing7.22 Displaying the errors in human readable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title'\"\nTheo Let me see what happens when there are more than one validation failure in\nthe data.\nJoe By default, Ajv catches only one validation error.\nTIP By default, Ajv catches only the first validation failure.\nTheo I guess that’s for performance reasons. Once the validator encounters an\nerror, it doesn’t continue the data parsing.\nJoe Probably. Anyway, in order to catch more than one validation failure, you need\nto pass the allErrors options to the Ajv constructor. Check out this code.\nListing7.23 Catching multiple validation failures\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n--- Page 188 ---\n160 CHAPTER 7 Basic data validation\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nA request with\nthree failures\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [1, 2]\n}; Instantiates the Ajv constructor\nwith allErrors: true in order to\ncatch more than one failure\nvar ajv = new Ajv({allErrors: true});\najv.validate(searchBooksRequestSchema,\ninvalidSearchBooksRequest); Converts the\nerrors to a human\nreadable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title',\n// → data/fields/0 must be string,\n// → data/fields/1 must be string\"\nJoe We validate a search request with myTitle instead of title and numbers\ninstead of strings in the fields array. As you can see in the output of the code\nsnippet, three errors are returned.\nTheo Great! I think I have all that I need in order to add data validation to the\nboundaries of my system when Nancy asks me to make the Library Manage-\nment System into a web server.\nJoe Would you allow me to give you a small gift as a token of our friendship?\nTheo I’d be honored.\nJoe takes a small package out of his bag, wrapped in a light-green ribbon. He hands Theo\nthe package with a solemn gesture.\nWhen Theo undoes the ribbon, he discovers an elegant piece of paper decorated with\npretty little designs. In the center of the paper, Theo manages to read the inscription\n“JSON Schema cheat sheet.” He smiles while browsing the cheat sheet. It’s exactly what he\nneeds.\nListing7.24 JSON Schema cheat sheet\n{ At the root level,\ndata is an array.\n\"type\": \"array\",\n\"items\": { Each element of the\narray is a map.\n\"type\": \"object\",\nmyNumber \"properties\": {\nThe properties of\nis a number. \"myNumber\": {\"type\": \"number\"},\neach field in the map\n\"myString\": {\"type\": \"string\"},\nmyString is\n\"myEnum\": {\"enum\": [\"myVal\", \"yourVal\"]},\na string. myEnum is a\n\"myBool\": {\"type\": \"boolean\"}\nenumeration\nmyBool is a }, value with two\nboolean. \"required\": [\"myNumber\", \"myString\"], possibilities:\nThe mandatory fields in the map \"myVal\" and\nare myNumber and myString; \"yourVal\".\nother fields are optional.\n--- Page 189 ---\nSummary 161\n\"additionalProperties\": false\nWe don’t allow fields that\n}\nare not explicitly mentioned\n}\nin the schema.\nThen, Theo turns the paper over to find that the back is also filled with drawings. In the\ncenter of the paper, he reads the inscription, “An example of valid data.”\nListing7.25 An example of valid data\n[\n{\nThis map is valid\n\"myNumber\": 42,\nbecause all its\n\"myString\": \"Hello\",\nfields are valid.\n\"myEnum\": \"myVal\",\n\"myBool\": true\n},\n{\nThis map is valid\n\"myNumber\": 54,\nbecause it contains all\n\"myString\": \"Happy\"\nthe required fields.\n}\n]\nSummary\n DOP Principle #4 is to separate data schema and data representation.\n The boundaries of a system are defined to be the areas where the system\nexchanges data.\n Some examples of data validation at the boundaries of the system are validation\nof client requests and responses, and validation of data that comes from exter-\nnal sources.\n Data validation in DOP means checking whether a piece of data conforms to a\nschema.\n When a piece of data is not valid, we get information about the validation fail-\nures and send this information back to the client in a human readable format.\n When data at system boundaries is valid, it’s not critical to validate data again\ninside the system.\n JSON Schema is a language that allows us to separate data validation from data\nrepresentation.\n JSON Schema syntax is a bit verbose.\n The expressive power of JSON Schema is high.\n JSON Schemas are just maps and, as so, we are free to manipulate them like any\nother maps in our programs.\n We can store a schema definition in a variable and use this variable in another\nschema.\n In JSON Schema, map fields are optional by default.\n It’s good practice to validate data that comes from an external data source.\n--- Page 190 ---\n162 CHAPTER 7 Basic data validation\n It’s good practice to be strict regarding data that you send and to be flexible\nregarding data that you receive.\n Ajv is a JSON Schema library in JavaScript.\n By default, Ajv catches only the first validation failure.\n Advanced validation is covered in chapter 12.\n--- Page 191 ---\nAdvanced\nconcurrency control\nNo more deadlocks!\nThis chapter covers\n Atoms as an alternative to locks\n Managing a thread-safe counter and a thread-safe\nin-memory cache with atoms\n Managing the whole system state in a thread-safe\nway with atoms\nThe traditional way to manage concurrency in a multi-threaded environment\ninvolves lock mechanisms like mutexes. Lock mechanisms tend to increase the com-\nplexity of the system because it’s not trivial to make sure the system is free of dead-\nlocks. In DOP, we leverage the fact that data is immutable, and we use a lock-free\nmechanism, called an atom, to manage concurrency. Atoms are simpler to manage\nthan locks because they are lock-free. As a consequence, the usual complexity of\nlocks that are required to avoid deadlocks don’t apply to atoms.\n NOTE This chapter is mostly relevant to multi-threaded environments like Java,\nC#, Python, and Ruby. It is less relevant to single-threaded environments like Java-\nScript. The JavaScript code snippets in this chapter are written as though JavaScript\nwere multi-threaded.\n163\n--- Page 192 ---\n164 CHAPTER 8 Advanced concurrency control\n8.1 The complexity of locks\nThis Sunday afternoon, while riding his bike across the Golden Gate Bridge, Theo thinks\nabout the Klafim project with concern, not yet sure that betting on DOP was a good\nchoice. Suddenly, Theo realizes that he hasn’t yet scheduled the next session with Joe. He\ngets off his bike to call Joe. Bad luck, the line is busy.\nWhen Theo gets home, he tries to call Joe again, but once again the phone is busy. After\ndinner, Theo tries to call Joe one more time, with the same result—a busy signal. “Obvi-\nously, Joe is very busy today,” Theo tells himself. Exhausted by his 50-mile bike ride at an\naverage of 17 miles per hour, he falls asleep on the sofa. When Theo wakes up, he’s elated\nto see a text message from Joe, “See you Monday morning at 11 AM?” Theo answers with a\nthumbs up and prepares for another week of work.\nWhen Joe arrives at the office, Theo asks him why his phone was constantly busy the day\nbefore. Joe answers that he was about to ask Theo the same question. They look at each\nother, puzzled, and then simultaneously break into laughter as they realize what hap-\npened: in an amazing coincidence, they’d tried to phone each other at exactly the same\ntimes. They both say at once:\n“A deadlock!”\nThey both head for Theo’s office. When they get to Theo’s desk, Joe tells him that today’s\nsession is going to be about concurrency management in multi-threaded environments.\nJoe How do you usually manage concurrency in a multi-threaded environment?\nTheo I protect access to critical sections with a lock mechanism, a mutex, for instance.\nJoe When you say access, do you mean write access or also read access?\nTheo Both!\nJoe Why do you need to protect read access with a lock?\nTheo Because, without a lock protection, in the middle of a read, a write could hap-\npen in another thread. It would make my read logically inconsistent.\nJoe Another option would be to clone the data before processing it in a read.\nTheo Sometimes I would clone the data; but in many cases, when it’s large, it’s too\nexpensive to clone.\nTIP Cloning data to avoid read locks doesn’t scale.\nJoe In DOP, we don’t need to clone or to protect read access.\nTheo Because data is immutable?\nJoe Right. When data is immutable, even if a write happens in another thread\nduring a read, it won’t make the read inconsistent because the write never\nmutates the data that is read.\nTheo In a sense, a read always works on a data snapshot.\nJoe Exactly!\nTIP When data is immutable, a read is always safe.\nTheo But what about write access? Don’t you need to protect that with locks?\nJoe Nope.\n--- Page 193 ---\n8.2 Thread-safe counter with atoms 165\nTheo Why not?\nJoe We have a simpler mechanism—it’s called an atom.\nTheo I am glad to hear there is a something simpler than locks. I really struggle each\ntime I have to integrate locks into a multi-threaded system.\nJoe Me too! I remember a bug we had in production 10 years ago. We forgot to\nrelease a lock when an exception was thrown in a critical section. It caused a\nterrible deadlock.\nTheo Deadlocks are really hard to avoid. Last year, we had a deadlock issue when two\nlocks were not released in the proper order.\nJoe I have great news for you. With atoms, deadlocks never happen!\nTIP With atoms, deadlocks never happen.\nTheo That sounds great. Tell me more!\nTIP Atoms provide a way to manage concurrency without locks.\n8.2 Thread-safe counter with atoms\nJoe Let’s start with a simple case: a counter shared between threads.\nTheo What do you mean by a counter?\nJoe Imagine that we’d like to count the number of database accesses and write the\ntotal number of accesses to a log every minute.\nTheo OK.\nJoe Could you write JavaScript code for this multi-threaded counter using locks?\nTheo But JavaScript is single-threaded!\nJoe I know, but it’s just for the sake of illustration. Imagine that JavaScript were\nmulti-threaded and that it provided a Mutex object that you could lock and\nunlock.\nTheo It’s a bit awkward. I guess it would look like this.\nTheo goes to the whiteboard. He writes what he imagines to be JavaScript code for a multi-\nthreaded counter with locks.\nListing8.1 A thread-safe counter protected by a mutex\nvar mutex = new Mutex();\nvar counter = 0;\nfunction dbAccess() {\nmutex.lock();\ncounter = counter + 1;\nmutex.unlock();\n// access the database\n}\nfunction logCounter() {\nmutex.lock();\n--- Page 194 ---\n166 CHAPTER 8 Advanced concurrency control\nconsole.log('Number of database accesses: ' + counter);\nmutex.unlock();\n}\nJoe Excellent. Now, I am going to show you how to write the same code with atoms.\nAn atom provides three methods:\n get returns the current value of the atom.\n set overwrites the current value of the atom.\n swap receives a function and updates the value of the atom with the result\nof the function called on the current value of the atom.\nJoe unzips a pocket in his laptop case and takes out a piece of paper. He hands it to\nTheo. Theo is pleasantly surprised as the sheet of paper succinctly describes the methods\n(table 8.1).\nTable 8.1 The three methods of an atom\nMethod Description\nget Returns the current value\nset Overwrites the current value\nswap Updates the current value with a function\nTheo How would it look like to implement a thread-safe counter with an atom?\nJoe It’s quite simple, actually.\nJoe pulls out his laptop, fires it up, and begins to type. When he’s done, he turns the laptop\naround so that Theo can see the code to implement a thread-safe counter in an atom.\nListing8.2 A thread-safe counter stored in an atom\nvar counter = new Atom();\ncounter.set(0);\nfunction dbAccess() {\ncounter.swap(function(x) {\nThe argument x is the\nreturn x + 1;\ncurrent value of the atom,\n});\nsame as counter.get().\n// access the database\n}\nfunction logCounter() {\nconsole.log('Number of database accesses: ' + counter.get());\n}\nTheo Could you tell me what’s going on here?\nJoe Sure! First, we create an empty atom. Then, we initialize the value of the atom\nwith counter.set(0). In the logger thread, we read the current value of the\natom with counter.get().\nTheo And how do you increment the counter in the threads that access the database?\n--- Page 195 ---\n8.2 Thread-safe counter with atoms 167\nJoe We call swap with a function that receives x and returns x + 1.\nTheo I don’t understand how swap could be thread-safe without using any locks.\nJoe quickly goes to the whiteboard. He sketches the diagram in figure 8.1.\nTake snapshot\nCompute next state\nYes\nState changed?\nNo\nUpdate state\nFigure 8.1 High-level flow of swap\nJoe You see, swap computes the next value of the atom, and before modifying the\ncurrent value of the atom, it checks whether the value of the atom has changed\nduring the computation. If so, swap tries again, until no changes occur during\nthe computation.\nTheo Is swap easy to implement?\nJoe Let me show you the implementation of the Atom class and you’ll see.\nListing8.3 Implementation of the Atom class\nclass Atom {\nstate;\nconstructor() {}\nget() {\nreturn this.state;\n}\nset(state) {\nthis.state = state;\n}\nswap(f) {\nwhile(true) {\nvar stateSnapshot = this.state;\nvar nextState = f(stateSnapshot);\nif (!atomicCompareAndSet(this.state,\n--- Page 196 ---\n168 CHAPTER 8 Advanced concurrency control\nstateSnapshot,\nnextState)) {\nUses a special thread-safe comparison operation\ncontinue;\nas this.state might have changed in another\n}\nthread during execution of the function f.\nreturn nextState;\n}\n}\n}\nTheo comes closer to the whiteboard. He modifies Joe’s diagram a bit to make the flow of\nthe swap operation more detailed. The resulting diagram is in figure 8.2. Theo still has a\nfew questions, though.\nTake snapshot\nsnapshot = state\nCompute next state\nnextState = f(snapshot)\nCheck if state has changed\nstate == snapshot\nYes\nState changed?\nNo\nUpdate state\nstate = nextState\nFigure 8.2 Detailed flow of swap\nTheo What is atomicCompareAndSet?\nJoe It’s the core operation of an atom. atomicCompareAndSet atomically sets the\nstate to a new value if, and only if, the state equals the provided old value. It\nreturns true upon success and false upon failure.\nTheo How could it be atomic without using locks?\nJoe That’s a great question! In fact, atomicCompareAndSet is a compare-and-swap\noperation, provided by the language that relies on a functionality of the CPU\nitself. For example, in Java the java.util.concurrent.atomic package has\nan AtomicReference generic class that provides a compareAndSet() method.\n NOTE See http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html\nfor general information about compare-and-swap operations. Implementations for\nmulti-threaded languages appear in table 8.2.\n--- Page 197 ---\n8.2 Thread-safe counter with atoms 169\nTable 8.2 Implementation of an atomic compare and set in various languages\nLanguage Link\nJava http://mng.bz/mx0W\nJavaScript Not relevant (single-threaded language)\nRuby http://mng.bz/5KG8\nPython https://github.com/maxcountryman/atomos\nC# http://mng.bz/6Zzp\nTheo Apropos Java, how would the implementation of an atom look?\nJoe It’s quite the same, besides the fact that Atom has to use generics, and the inner\nstate has to be stored in an AtomicReference.\nJoe brings up a Java implementation of Atom on his laptop. Theo looks over the code.\nListing8.4 Implementation of the Atom class in Java\nclass Atom<ValueType> {\nprivate AtomicReference<ValueType> state;\npublic Atom() {}\nValueType get() {\nreturn this.state.get();\n}\nthis.state might have\nchanged in another thread\nvoid set(ValueType state) {\nduring the execution of f.\nthis.state.set(state);\n}\nValueType swap(UnaryOPerator<ValueType> f) {\nwhile(true) {\nValueType stateSnapshot = this.state.get();\nValueType nextState = f(stateSnapshot);\nif (!this.state.compareAndSet(stateSnapshot,\nnextState)) {\ncontinue;\n}\n}\nreturn nextState;\n}\n}\nTheo What about using an atom in Java?\nJoe Here, take a look. It’s quite simple.\n--- Page 198 ---\n170 CHAPTER 8 Advanced concurrency control\nListing8.5 Using an Atom in Java\nAtom<Integer> counter = new Atom<Integer>();\ncounter.set(0);\ncounter.swap(x -> x + 1);\ncounter.get();\nTheo takes a couple of minutes to meditate about this atom stuff and to digest what he’s\njust learned. Then, he asks Joe:\nTheo What if swap never succeeds? I mean, could the while loop inside the code of\nswap turn out to be an infinite loop?\nJoe No! By definition, when atomicCompareAndSet fails on a thread, it means that\nthe same atom was changed on another thread during the execution of swap.\nIn this race between threads, there is always a winner.\nTheo But isn’t it possible that some thread never succeeds because it always loses the\nrace against other threads?\nJoe In theory, yes, but I’ve never encountered such a situation. If you have thou-\nsands of threads that do nothing besides swapping an atom, it could happen I\nsuppose. But, in practice, once the atom is swapped, the threads do some real\nwork, for example, database access or I/O. This gives other threads the oppor-\ntunity to swap the atom successfully.\n NOTE In theory, atoms could create starvation in a system with thousands of threads\nthat do nothing beside swapping an atom. In practice, once an atom is swapped, the\nthreads do some real work (e.g., database access), which creates an opportunity for\nother threads to swap the atom successfully.\nTheo Interesting.... Indeed, atoms look much easier to manage than locks.\nJoe Now let me show you how to use atoms with composite data.\nTheo Why would that be different?\nJoe Usually, dealing with composite data is more difficult than dealing with primi-\ntive types.\nTheo When you sold me on DOP, you told me that we are able to manage data with\nthe same simplicity as we manage numbers.\nTIP In DOP, data is managed with the same simplicity as numbers.\nJoe That’s exactly what I am about to show you.\n8.3 Thread-safe cache with atoms\nJoe Are you familiar with the notion of in-memory cache?\nTheo You mean memoization?\n--- Page 199 ---\n8.3 Thread-safe cache with atoms 171\nJoe Kind of. Imagine that database queries don’t vary too much in your applica-\ntion. It makes sense in that case to store the results of previous queries in mem-\nory in order to improve the response time.\nTheo Yes, of course!\nJoe What data structure would you use to store the in-memory cache?\nTheo Probably a string map, where the keys are the queries, and the values are the\nresults from the database.\nTIP It’s quite common to represent an in-memory cache as a string map.\nJoe Excellent! Now can you write the code to cache database queries in a thread-\nsafe way using a lock?\nTheo Let me see: I’m going to use an immutable string map. Therefore, I don’t\nneed to protect read access with a lock. Only the cache update needs to be\nprotected.\nJoe You’re getting the hang of this!\nTheo The code should be something like this.\nListing8.6 Thread-safe cache with locks\nvar mutex = new Mutex();\nvar cache = {};\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache, query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\nmutex.lock();\ncache = _.set(cache, query, result);\nmutex.unlock();\nreturn result;\n}\nJoe Nice! Now, let me show you how to write the same code using an atom instead\nof a lock. Take a look at this code and let me know if it’s clear to you.\nListing8.7 Thread-safe cache with atoms\nvar cache = new Atom();\ncache.set({});\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache.get(), query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\ncache.swap(function(oldCache) {\n--- Page 200 ---\n172 CHAPTER 8 Advanced concurrency control\nreturn _.set(oldCache, query, result);\n});\nreturn result;\n}\nTheo I don’t understand the function you’re passing to the swap method.\nJoe The function passed to swap receives the current value of the cache, which is a\nstring map, and returns a new version of the string map with an additional key-\nvalue pair.\nTheo I see. But something bothers me with the performance of the swap method in\nthe case of a string map. How does the comparison work? I mean, comparing\ntwo string maps might take some time.\nJoe Not if you compare them by reference. As we discussed in the past, when data\nis immutable, it is safe to compare by reference, and it’s super fast.\nTIP When data is immutable, it is safe (and fast) to compare it by reference.\nTheo Cool. So atoms play well with immutable data.\nJoe Exactly!\n8.4 State management with atoms\nJoe Do you remember a couple of weeks ago when I showed you how we resolve\npotential conflicts between mutations? You told me that the code was not\nthread-safe.\nTheo Let me look again at the code.\nTheo takes a look at the code for the SystemData class that he wrote some time ago\n(repeated in listing 8.8). Without the validation logic, it makes the code easier to grasp.\nListing8.8 SystemData class from part 1\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nthis.systemData = SystemConsistency.reconcile(this.systemData,\nprevious,\nnext);\n}\n}\n--- Page 201 ---\n8.4 State management with atoms 173\nIt takes him a few minutes to remember how the commit method works. Suddenly, he has\nan Aha! moment.\nTheo This code is not thread-safe because the SystemConsistency.reconcile\ncode inside the commit method is not protected. Nothing prevents the two\nthreads from executing this code concurrently.\nJoe Right! Now, can you tell me how to make it thread-safe?\nTheo With locks?\nJoe Come on...\nTheo I was kidding, of course. We make the code thread-safe not with a lock but with\nan atom.\nJoe Nice joke!\nTheo Let me see. I’d need to store the system data inside an atom. The get and set\nmethod of SystemData would simply call the get and set methods of the\natom. How does this look?\nListing8.9 SystemData class with atom (without the commit method)\nclass SystemState {\nsystemData;\nconstructor() {\nthis.systemData = new Atom();\n}\nget() {\nreturn this.systemData.get();\n}\ncommit(prev, next) {\nthis.systemData.set(next);\n}\n}\nJoe Excellent. Now for the fun part. Implement the commit method by calling the\nswap method of the atom.\nTheo Instead of calling SystemConsistency.reconcile() directly, I need to wrap\nit into a call to swap. So, something like this?\nListing8.10 Implementation of SystemData.commit with atom\nSystemData.commit = function(previous, next) {\nthis.systemData.swap(function(current) {\nreturn SystemConsistency.reconcile(current,\nprevious,\nnext);\n});\n};",
        "sections_found": []
      },
      "accurate_page_range": "176-201"
    },
    {
      "text": "- 7.2 JSON Schema in a nutshell",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "raw_line": "- 7.2 JSON Schema in a nutshell (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 59,
      "chapter_info": {
        "page": 176,
        "title": "Basic data validation",
        "pattern_matched": "Chapter 7",
        "text_preview": "148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema"
      },
      "chapter_sections": {
        "start_page": 176,
        "end_page": 201,
        "content": "\n--- Page 176 ---\n148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema from listing 7.6.\nListing7.7 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe Give it a try, and you’ll see.\nIndeed! When Theo executes the code to validate the search request, it returns true.\nListing7.8 Validating the search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksRequest = {\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nvalidate(searchBooksRequestSchema, searchBooksRequest);\n// → true\nJoe Now, please try an invalid request.\nTheo Let me think about what kind of invalidity to try. I know, I’ll make a typo in the\ntitle field and call it tilte with the l before the t.\nAs expected, the code with the type returns false. Theo is not surprised, and Joe is smil-\ning from ear to ear.\nListing7.9 Validating an invalid search request\nvar invalidSearchBooksRequest = {\n\"tilte\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\n--- Page 177 ---\n7.3 Schema flexibility and strictness 149\nvalidate(searchBooksRequestSchema, invalidSearchBooksRequest);\n// → false\nTheo The syntax of JSON Schema is much more verbose than the syntax for declar-\ning the members in a class. Why is that so?\nJoe For two reasons. First, because JSON Schema is language independent, it can\nbe used in any programming language. As I told you, there are JSON Schema\nvalidators available in most programming languages.\nTheo I see.\nJoe Second, JSON Schema allows you to express validation conditions that are much\nharder, if not impossible, to express when data is represented with classes.\nTIP The expressive power of JSON Schema is high!\nTheo Now you have triggered my curiosity. Can you give me some examples?\nJoe In a moment, we’ll talk about schema composition. Someday I’ll show you\nsome examples of advanced validation.\n NOTE Advanced validation is covered in chapter 12.\nTheo What kind of advanced validation?\nJoe What I mean by advanced validation is, for instance, validating that a number\nfalls within a given range or validating that a string matches a regular expression.\nTheo Is there a way to get details about why the request is invalid?\nJoe Absolutely! I’ll show you later. For now, let me show you how to make sure the\nresponse the server sends back to the client is valid.\nTheo It sounds much more complicated than a search book request!\nJoe Why?\nTheo Because a search response is made of multiple book results, and in each book\nresult, some of the fields are optional!\n7.3 Schema flexibility and strictness\nJoe Can you give me an example of what a book search response would look like?\nTheo Take a look at this example. It’s a search response with information about two\nbooks: 7 Habits of Highly Effective People and The Power of Habit.\nListing7.10 An example of a search response\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432\n},\n--- Page 178 ---\n150 CHAPTER 7 Basic data validation\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn_13\": \"978-1982137274\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n]\n}\n]\nJoe It’s funny that you mention The Power of Habit. I’m reading this book in order\nto get rid of my habit of biting my nails. Anyway, what fields are required and\nwhat fields are optional in a book search response?\nTheo In book information, the title and available fields are required. The other\nfields are optional.\nJoe As I told you when we built the schema for the book search request, fields in a\nmap are optional by default. In order to make a field mandatory, we have to\ninclude it in the required array. I’d probably implement it with something\nlike this.\nListing7.11 Schema of a search response\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, map fields are optional by default.\nTheo I must admit that specifying a list of required fields is much simpler than hav-\ning to specify that a member in a class in nullable!\nJoe Agreed!\nTheo On the other hand, I find the nesting of the book information schema in the\nsearch response schema a bit hard to read.\n--- Page 179 ---\n7.3 Schema flexibility and strictness 151\nJoe Nothing prevents you from separating the book information schema from the\nsearch response schema.\nTheo How?\nJoe It’s just JSON, my friend. It means, you are free to manipulate the schema as\nany other map in your program. For instance, you could have the book infor-\nmation schema in a variable named bookInfoSchema and use it in the search\nbooks response schema. Let me refactor the schema to show you what I mean.\nListing7.12 Schema of a search response refactored\nvar bookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n};\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": bookInfoSchema\n};\nTheo Once again, I have to admit that JSON Schemas are more composable than\nclass definitions.\nTIP JSON Schemas are just maps. We are free to compose and manipulate them like\nany other map.\nJoe Let’s move on to validating data received from external data sources.\nTheo Is that different?\nJoe Not really, but I’ll take it as an opportunity to show you some other features of\nJSON Schema.\nTheo I’m curious to learn how data validation is used when we access data from the\ndatabase.\nJoe Each time we access data from the outside, it’s a good practice to validate it.\nCan you show me an example of how a database response for a search query\nwould look?\nTIP It’s a good practice to validate data that comes from an external data source.\n--- Page 180 ---\n152 CHAPTER 7 Basic data validation\nTheo When we query books from the database, we expect to receive an array of\nbooks with three fields: title, isbn, and available. The first two values should\nbe strings, and the third one should be a Boolean.\nJoe Are those fields optional or required?\nTheo What do you mean?\nJoe Could there be books for which some of the fields are not defined?\nTheo No.\nJoe In that case, the schema is quite simple. Would you like to try writing the\nschema for the database response?\nTheo Let me see. It’s an array of objects where each object has three properties, so\nsomething like this?\nListing7.13 Schema of a database response\n{\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n}\nJoe Well done, my friend! Now, I want to tell you about the additionalProperties\nfield in JSON Schema.\nTheo What’s that?\nJoe Take a look at this array.\nListing7.14 A book array with an additional property\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"dummy_property\": 42\n},\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn\": \"978-1982137274\",\n\"dummy_property\": 45\n}\n]\n--- Page 181 ---\n7.3 Schema flexibility and strictness 153\nJoe Is it a valid database response?\nTheo No. A database response should not have a dummy_property field. It should\nhave only the three required fields specified in the schema.\nJoe It might be surprising but, by default, fields not specified in the schema of an\nobject are allowed in JSON Schema. In order to disallow them, one has to set\nadditionalProperties to false like this.\nListing7.15 Disallowing properties not mentioned in the schema\nvar booksFromDBSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"additionalProperties\": false,\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, by default, fields not specified in the schema of a map are\nallowed.\nTheo Why is that?\nJoe The reason is that usually having additional fields in a map doesn’t cause\ntrouble. If your code doesn’t care about a field, it simply ignores it. But some-\ntimes we want to be as strict as possible, and we set additionalProperties\nto false.\nTheo What about the search request and response schema from the previous discus-\nsions? Should we set additionalProperties to false?\nJoe That’s an excellent question. I’d say it’s a matter of taste. Personally, I like to\nallow additional fields in requests and disallow them in responses.\nTheo What’s the advantage?\nJoe Well, the web server is responsible for the responses it sends to its clients. It\nmakes sense then to be as strict as possible. However, the requests are created\nby the clients, and I prefer to do my best to serve my clients even when they are\nnot as strict as they should be.\nTheo Naturally. “The client is always right.”\nJoe Actually, I prefer the way Jon Postel formulated his robustness principle: “Be\nconservative in what you send, be liberal in what you accept.”\nTIP It’s a good practice to be strict with the data that you send and to be flexible with\nthe data that you receive.\n--- Page 182 ---\n154 CHAPTER 7 Basic data validation\n7.4 Schema composition\nTheo What about validating data that comes from an external web service?\nJoe Can you give me an example?\nTheo In the near future, we’ll have to integrate with a service called Open Library\nBooks API that provides detailed information about books.\n NOTE For information on the Open Library Books API, see https://openlibrary\n.org/dev/docs/api/books.\nJoe Can you show me, for instance, the service response for Watchmen?\nTheo Sure. Here you go.\nTheo taps a few keys on his keyboard and brings up the response. Joe looks at the JSON for\na long time.\nListing7.16 An Open Library Books API response example\n{\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n}\nTheo asks himself, “What could be so special in this JSON?” While Joe is meditating about\nthis piece of JSON, Theo writes the JSON Schema for the Books API response. It doesn’t\nseem to be more complicated than any of the previous schemas. When Theo is done, he\nasks Joe to take a look at the schema.\nListing7.17 Schema of the Open Library Books API response\n{\n\"type\": \"object\",\n\"required\": [\"title\"],\n--- Page 183 ---\n7.4 Schema composition 155\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n}\nJoe Good job!\nTheo That wasn’t so hard. I really don’t see why you looked at this JSON response for\nsuch a long time.\nJoe Well, it has to do with the isbn_10 and isbn_13 fields. I assume that they’re\nnot both mandatory.\nTheo Right! That’s why I didn’t include them in the required field of my schema.\nJoe But one of them should always be there. Right?\nTheo Sometimes one of them and sometimes both of them, like for Watchmen. It\ndepends on the publication year of the book. Books published before 2007\nhave isbn_10, and books published after 2007 have isbn_13.\nJoe Oh, I see. And Watchmen has both because it was originally published in 1986\nbut published again after 2007.\nTheo Correct.\nJoe Then, you need your schema to indicate that one of the isbn fields is man-\ndatory. That’s a good opportunity for me to tell you about JSON Schema\ncomposition.\nTheo What’s that?\nJoe It’s a way to combine schemas, similarly to how we combine logical conditions\nwith AND, OR, and NOT.\nTheo I’d like to see that.\nJoe Sure. How would you express the schema for the Books API response as a\ncomposition of three schemas: basicBookInfoSchema, the schema that you\nwrote where only title is required; mandatoryIsbn13, a schema where only\n--- Page 184 ---\n156 CHAPTER 7 Basic data validation\nisbn_13 is required; and mandatoryIsb10, a schema where only isbn_10 is\nrequired?\nTheo I think it should be basicBookInfoSchema AND (mandatoryIsbn13 OR\nmandatoryIsbn10).\nJoe Exactly! The only thing is that in JSON Schema, we use allOf instead of AND,\nand anyOf instead of OR.\nJoe shows Theo the result in listing 7.18 and an example of its usage in listing 7.19.\nListing7.18 Schema of an external API response\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n--- Page 185 ---\n7.4 Schema composition 157\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing7.19 Validating an external API response\nvar bookInfo = {\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n};\nvalidate(bookInfoSchema, bookInfo);\n// → true\nTheo I see why they call it allOf and anyOf. The first one means that data must con-\nform to all the schemas, and the second one means that data must conform to\nany of the schemas.\nJoe Yup.\n NOTE JSON Schema also supports oneOf for cases where data must be valid against\nexactly one schema.\nTheo Nice. With schema composition, JSON Schema seems to have more expressive\npower than what I was used to when representing data with classes.\nJoe That’s only the beginning. I’ll show you more data validation conditions that\ncan’t be expressed when data is represented with classes some other time.\n NOTE Advanced data validation is covered in chapter 12.\nTheo Something still bothers me, though. When data isn’t valid, you don’t know what\nwent wrong.\n--- Page 186 ---\n158 CHAPTER 7 Basic data validation\n7.5 Details about data validation failures\nJoe So far, we’ve treated JSON Schema validation as though it were binary: either a\npiece of data is valid or it isn’t.\nTheo Right...\nJoe But, in fact, when a piece of data is not valid, we can get details about the\nreason of the invalidity.\nTheo Like when a required field is missing, can we get the name of the missing field?\nJoe Yes. When a piece of data is not of the expected type, we can get information\nabout that also.\nTheo That sounds very useful!\nJoe Indeed. Let me show you how it works. Until now, we used a generic validate\nfunction, but when we deal with validation failures, we need to be more specific.\nTheo Why?\nJoe Because each data validator library has its own way of exposing the details of\nadata validation failure. For instance, in JavaScript Ajv, the errors from the\nlast data validation are stored as an array inside the validator instance.\nTheo Why an array?\nJoe Because there could be several failures. But let’s start with the case of a single\nfailure. Imagine we encounter a search book request where the title field is\nnamed myTitle instead of title. Take a look at this example. As you can see,\nwe first instantiate a validator instance.\nListing7.20 Accessing validation errors in Ajv\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nInstantiates a\nvar ajv = new Ajv(); validator instance\najv.validate(searchBooksRequestSchema, invalidSearchBooksRequest);\najv.errors\nDisplays the\nvalidation errors\n--- Page 187 ---\n7.5 Details about data validation failures 159\nTheo And what does the information inside the errors array look like?\nJoe Execute the code snippet. You’ll see.\nWhen Theo executes the code snippets from listing 7.20, he can hardly believe his eyes. He\nlooks at the details, finding the results hard to digest.\nListing7.21 Details for a single data validation failure in an array format\n[\n{\n\"instancePath\": \"\",\n\"schemaPath\": \"#/required\",\n\"keyword\": \"required\",\n\"params\": {\n\"missingProperty\":\"title\"\n},\n\"message\": \"must have required property 'title'\"\n}\n]\nTheo I find the contents of the errors array a bit hard to understand.\nJoe Me too. Fortunately, Ajv provides a errorsText utility function to convert the\nerrors array in a human readable format. See, for instance, what is returned\nwhen you call errorsText.\nListing7.22 Displaying the errors in human readable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title'\"\nTheo Let me see what happens when there are more than one validation failure in\nthe data.\nJoe By default, Ajv catches only one validation error.\nTIP By default, Ajv catches only the first validation failure.\nTheo I guess that’s for performance reasons. Once the validator encounters an\nerror, it doesn’t continue the data parsing.\nJoe Probably. Anyway, in order to catch more than one validation failure, you need\nto pass the allErrors options to the Ajv constructor. Check out this code.\nListing7.23 Catching multiple validation failures\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n--- Page 188 ---\n160 CHAPTER 7 Basic data validation\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nA request with\nthree failures\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [1, 2]\n}; Instantiates the Ajv constructor\nwith allErrors: true in order to\ncatch more than one failure\nvar ajv = new Ajv({allErrors: true});\najv.validate(searchBooksRequestSchema,\ninvalidSearchBooksRequest); Converts the\nerrors to a human\nreadable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title',\n// → data/fields/0 must be string,\n// → data/fields/1 must be string\"\nJoe We validate a search request with myTitle instead of title and numbers\ninstead of strings in the fields array. As you can see in the output of the code\nsnippet, three errors are returned.\nTheo Great! I think I have all that I need in order to add data validation to the\nboundaries of my system when Nancy asks me to make the Library Manage-\nment System into a web server.\nJoe Would you allow me to give you a small gift as a token of our friendship?\nTheo I’d be honored.\nJoe takes a small package out of his bag, wrapped in a light-green ribbon. He hands Theo\nthe package with a solemn gesture.\nWhen Theo undoes the ribbon, he discovers an elegant piece of paper decorated with\npretty little designs. In the center of the paper, Theo manages to read the inscription\n“JSON Schema cheat sheet.” He smiles while browsing the cheat sheet. It’s exactly what he\nneeds.\nListing7.24 JSON Schema cheat sheet\n{ At the root level,\ndata is an array.\n\"type\": \"array\",\n\"items\": { Each element of the\narray is a map.\n\"type\": \"object\",\nmyNumber \"properties\": {\nThe properties of\nis a number. \"myNumber\": {\"type\": \"number\"},\neach field in the map\n\"myString\": {\"type\": \"string\"},\nmyString is\n\"myEnum\": {\"enum\": [\"myVal\", \"yourVal\"]},\na string. myEnum is a\n\"myBool\": {\"type\": \"boolean\"}\nenumeration\nmyBool is a }, value with two\nboolean. \"required\": [\"myNumber\", \"myString\"], possibilities:\nThe mandatory fields in the map \"myVal\" and\nare myNumber and myString; \"yourVal\".\nother fields are optional.\n--- Page 189 ---\nSummary 161\n\"additionalProperties\": false\nWe don’t allow fields that\n}\nare not explicitly mentioned\n}\nin the schema.\nThen, Theo turns the paper over to find that the back is also filled with drawings. In the\ncenter of the paper, he reads the inscription, “An example of valid data.”\nListing7.25 An example of valid data\n[\n{\nThis map is valid\n\"myNumber\": 42,\nbecause all its\n\"myString\": \"Hello\",\nfields are valid.\n\"myEnum\": \"myVal\",\n\"myBool\": true\n},\n{\nThis map is valid\n\"myNumber\": 54,\nbecause it contains all\n\"myString\": \"Happy\"\nthe required fields.\n}\n]\nSummary\n DOP Principle #4 is to separate data schema and data representation.\n The boundaries of a system are defined to be the areas where the system\nexchanges data.\n Some examples of data validation at the boundaries of the system are validation\nof client requests and responses, and validation of data that comes from exter-\nnal sources.\n Data validation in DOP means checking whether a piece of data conforms to a\nschema.\n When a piece of data is not valid, we get information about the validation fail-\nures and send this information back to the client in a human readable format.\n When data at system boundaries is valid, it’s not critical to validate data again\ninside the system.\n JSON Schema is a language that allows us to separate data validation from data\nrepresentation.\n JSON Schema syntax is a bit verbose.\n The expressive power of JSON Schema is high.\n JSON Schemas are just maps and, as so, we are free to manipulate them like any\nother maps in our programs.\n We can store a schema definition in a variable and use this variable in another\nschema.\n In JSON Schema, map fields are optional by default.\n It’s good practice to validate data that comes from an external data source.\n--- Page 190 ---\n162 CHAPTER 7 Basic data validation\n It’s good practice to be strict regarding data that you send and to be flexible\nregarding data that you receive.\n Ajv is a JSON Schema library in JavaScript.\n By default, Ajv catches only the first validation failure.\n Advanced validation is covered in chapter 12.\n--- Page 191 ---\nAdvanced\nconcurrency control\nNo more deadlocks!\nThis chapter covers\n Atoms as an alternative to locks\n Managing a thread-safe counter and a thread-safe\nin-memory cache with atoms\n Managing the whole system state in a thread-safe\nway with atoms\nThe traditional way to manage concurrency in a multi-threaded environment\ninvolves lock mechanisms like mutexes. Lock mechanisms tend to increase the com-\nplexity of the system because it’s not trivial to make sure the system is free of dead-\nlocks. In DOP, we leverage the fact that data is immutable, and we use a lock-free\nmechanism, called an atom, to manage concurrency. Atoms are simpler to manage\nthan locks because they are lock-free. As a consequence, the usual complexity of\nlocks that are required to avoid deadlocks don’t apply to atoms.\n NOTE This chapter is mostly relevant to multi-threaded environments like Java,\nC#, Python, and Ruby. It is less relevant to single-threaded environments like Java-\nScript. The JavaScript code snippets in this chapter are written as though JavaScript\nwere multi-threaded.\n163\n--- Page 192 ---\n164 CHAPTER 8 Advanced concurrency control\n8.1 The complexity of locks\nThis Sunday afternoon, while riding his bike across the Golden Gate Bridge, Theo thinks\nabout the Klafim project with concern, not yet sure that betting on DOP was a good\nchoice. Suddenly, Theo realizes that he hasn’t yet scheduled the next session with Joe. He\ngets off his bike to call Joe. Bad luck, the line is busy.\nWhen Theo gets home, he tries to call Joe again, but once again the phone is busy. After\ndinner, Theo tries to call Joe one more time, with the same result—a busy signal. “Obvi-\nously, Joe is very busy today,” Theo tells himself. Exhausted by his 50-mile bike ride at an\naverage of 17 miles per hour, he falls asleep on the sofa. When Theo wakes up, he’s elated\nto see a text message from Joe, “See you Monday morning at 11 AM?” Theo answers with a\nthumbs up and prepares for another week of work.\nWhen Joe arrives at the office, Theo asks him why his phone was constantly busy the day\nbefore. Joe answers that he was about to ask Theo the same question. They look at each\nother, puzzled, and then simultaneously break into laughter as they realize what hap-\npened: in an amazing coincidence, they’d tried to phone each other at exactly the same\ntimes. They both say at once:\n“A deadlock!”\nThey both head for Theo’s office. When they get to Theo’s desk, Joe tells him that today’s\nsession is going to be about concurrency management in multi-threaded environments.\nJoe How do you usually manage concurrency in a multi-threaded environment?\nTheo I protect access to critical sections with a lock mechanism, a mutex, for instance.\nJoe When you say access, do you mean write access or also read access?\nTheo Both!\nJoe Why do you need to protect read access with a lock?\nTheo Because, without a lock protection, in the middle of a read, a write could hap-\npen in another thread. It would make my read logically inconsistent.\nJoe Another option would be to clone the data before processing it in a read.\nTheo Sometimes I would clone the data; but in many cases, when it’s large, it’s too\nexpensive to clone.\nTIP Cloning data to avoid read locks doesn’t scale.\nJoe In DOP, we don’t need to clone or to protect read access.\nTheo Because data is immutable?\nJoe Right. When data is immutable, even if a write happens in another thread\nduring a read, it won’t make the read inconsistent because the write never\nmutates the data that is read.\nTheo In a sense, a read always works on a data snapshot.\nJoe Exactly!\nTIP When data is immutable, a read is always safe.\nTheo But what about write access? Don’t you need to protect that with locks?\nJoe Nope.\n--- Page 193 ---\n8.2 Thread-safe counter with atoms 165\nTheo Why not?\nJoe We have a simpler mechanism—it’s called an atom.\nTheo I am glad to hear there is a something simpler than locks. I really struggle each\ntime I have to integrate locks into a multi-threaded system.\nJoe Me too! I remember a bug we had in production 10 years ago. We forgot to\nrelease a lock when an exception was thrown in a critical section. It caused a\nterrible deadlock.\nTheo Deadlocks are really hard to avoid. Last year, we had a deadlock issue when two\nlocks were not released in the proper order.\nJoe I have great news for you. With atoms, deadlocks never happen!\nTIP With atoms, deadlocks never happen.\nTheo That sounds great. Tell me more!\nTIP Atoms provide a way to manage concurrency without locks.\n8.2 Thread-safe counter with atoms\nJoe Let’s start with a simple case: a counter shared between threads.\nTheo What do you mean by a counter?\nJoe Imagine that we’d like to count the number of database accesses and write the\ntotal number of accesses to a log every minute.\nTheo OK.\nJoe Could you write JavaScript code for this multi-threaded counter using locks?\nTheo But JavaScript is single-threaded!\nJoe I know, but it’s just for the sake of illustration. Imagine that JavaScript were\nmulti-threaded and that it provided a Mutex object that you could lock and\nunlock.\nTheo It’s a bit awkward. I guess it would look like this.\nTheo goes to the whiteboard. He writes what he imagines to be JavaScript code for a multi-\nthreaded counter with locks.\nListing8.1 A thread-safe counter protected by a mutex\nvar mutex = new Mutex();\nvar counter = 0;\nfunction dbAccess() {\nmutex.lock();\ncounter = counter + 1;\nmutex.unlock();\n// access the database\n}\nfunction logCounter() {\nmutex.lock();\n--- Page 194 ---\n166 CHAPTER 8 Advanced concurrency control\nconsole.log('Number of database accesses: ' + counter);\nmutex.unlock();\n}\nJoe Excellent. Now, I am going to show you how to write the same code with atoms.\nAn atom provides three methods:\n get returns the current value of the atom.\n set overwrites the current value of the atom.\n swap receives a function and updates the value of the atom with the result\nof the function called on the current value of the atom.\nJoe unzips a pocket in his laptop case and takes out a piece of paper. He hands it to\nTheo. Theo is pleasantly surprised as the sheet of paper succinctly describes the methods\n(table 8.1).\nTable 8.1 The three methods of an atom\nMethod Description\nget Returns the current value\nset Overwrites the current value\nswap Updates the current value with a function\nTheo How would it look like to implement a thread-safe counter with an atom?\nJoe It’s quite simple, actually.\nJoe pulls out his laptop, fires it up, and begins to type. When he’s done, he turns the laptop\naround so that Theo can see the code to implement a thread-safe counter in an atom.\nListing8.2 A thread-safe counter stored in an atom\nvar counter = new Atom();\ncounter.set(0);\nfunction dbAccess() {\ncounter.swap(function(x) {\nThe argument x is the\nreturn x + 1;\ncurrent value of the atom,\n});\nsame as counter.get().\n// access the database\n}\nfunction logCounter() {\nconsole.log('Number of database accesses: ' + counter.get());\n}\nTheo Could you tell me what’s going on here?\nJoe Sure! First, we create an empty atom. Then, we initialize the value of the atom\nwith counter.set(0). In the logger thread, we read the current value of the\natom with counter.get().\nTheo And how do you increment the counter in the threads that access the database?\n--- Page 195 ---\n8.2 Thread-safe counter with atoms 167\nJoe We call swap with a function that receives x and returns x + 1.\nTheo I don’t understand how swap could be thread-safe without using any locks.\nJoe quickly goes to the whiteboard. He sketches the diagram in figure 8.1.\nTake snapshot\nCompute next state\nYes\nState changed?\nNo\nUpdate state\nFigure 8.1 High-level flow of swap\nJoe You see, swap computes the next value of the atom, and before modifying the\ncurrent value of the atom, it checks whether the value of the atom has changed\nduring the computation. If so, swap tries again, until no changes occur during\nthe computation.\nTheo Is swap easy to implement?\nJoe Let me show you the implementation of the Atom class and you’ll see.\nListing8.3 Implementation of the Atom class\nclass Atom {\nstate;\nconstructor() {}\nget() {\nreturn this.state;\n}\nset(state) {\nthis.state = state;\n}\nswap(f) {\nwhile(true) {\nvar stateSnapshot = this.state;\nvar nextState = f(stateSnapshot);\nif (!atomicCompareAndSet(this.state,\n--- Page 196 ---\n168 CHAPTER 8 Advanced concurrency control\nstateSnapshot,\nnextState)) {\nUses a special thread-safe comparison operation\ncontinue;\nas this.state might have changed in another\n}\nthread during execution of the function f.\nreturn nextState;\n}\n}\n}\nTheo comes closer to the whiteboard. He modifies Joe’s diagram a bit to make the flow of\nthe swap operation more detailed. The resulting diagram is in figure 8.2. Theo still has a\nfew questions, though.\nTake snapshot\nsnapshot = state\nCompute next state\nnextState = f(snapshot)\nCheck if state has changed\nstate == snapshot\nYes\nState changed?\nNo\nUpdate state\nstate = nextState\nFigure 8.2 Detailed flow of swap\nTheo What is atomicCompareAndSet?\nJoe It’s the core operation of an atom. atomicCompareAndSet atomically sets the\nstate to a new value if, and only if, the state equals the provided old value. It\nreturns true upon success and false upon failure.\nTheo How could it be atomic without using locks?\nJoe That’s a great question! In fact, atomicCompareAndSet is a compare-and-swap\noperation, provided by the language that relies on a functionality of the CPU\nitself. For example, in Java the java.util.concurrent.atomic package has\nan AtomicReference generic class that provides a compareAndSet() method.\n NOTE See http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html\nfor general information about compare-and-swap operations. Implementations for\nmulti-threaded languages appear in table 8.2.\n--- Page 197 ---\n8.2 Thread-safe counter with atoms 169\nTable 8.2 Implementation of an atomic compare and set in various languages\nLanguage Link\nJava http://mng.bz/mx0W\nJavaScript Not relevant (single-threaded language)\nRuby http://mng.bz/5KG8\nPython https://github.com/maxcountryman/atomos\nC# http://mng.bz/6Zzp\nTheo Apropos Java, how would the implementation of an atom look?\nJoe It’s quite the same, besides the fact that Atom has to use generics, and the inner\nstate has to be stored in an AtomicReference.\nJoe brings up a Java implementation of Atom on his laptop. Theo looks over the code.\nListing8.4 Implementation of the Atom class in Java\nclass Atom<ValueType> {\nprivate AtomicReference<ValueType> state;\npublic Atom() {}\nValueType get() {\nreturn this.state.get();\n}\nthis.state might have\nchanged in another thread\nvoid set(ValueType state) {\nduring the execution of f.\nthis.state.set(state);\n}\nValueType swap(UnaryOPerator<ValueType> f) {\nwhile(true) {\nValueType stateSnapshot = this.state.get();\nValueType nextState = f(stateSnapshot);\nif (!this.state.compareAndSet(stateSnapshot,\nnextState)) {\ncontinue;\n}\n}\nreturn nextState;\n}\n}\nTheo What about using an atom in Java?\nJoe Here, take a look. It’s quite simple.\n--- Page 198 ---\n170 CHAPTER 8 Advanced concurrency control\nListing8.5 Using an Atom in Java\nAtom<Integer> counter = new Atom<Integer>();\ncounter.set(0);\ncounter.swap(x -> x + 1);\ncounter.get();\nTheo takes a couple of minutes to meditate about this atom stuff and to digest what he’s\njust learned. Then, he asks Joe:\nTheo What if swap never succeeds? I mean, could the while loop inside the code of\nswap turn out to be an infinite loop?\nJoe No! By definition, when atomicCompareAndSet fails on a thread, it means that\nthe same atom was changed on another thread during the execution of swap.\nIn this race between threads, there is always a winner.\nTheo But isn’t it possible that some thread never succeeds because it always loses the\nrace against other threads?\nJoe In theory, yes, but I’ve never encountered such a situation. If you have thou-\nsands of threads that do nothing besides swapping an atom, it could happen I\nsuppose. But, in practice, once the atom is swapped, the threads do some real\nwork, for example, database access or I/O. This gives other threads the oppor-\ntunity to swap the atom successfully.\n NOTE In theory, atoms could create starvation in a system with thousands of threads\nthat do nothing beside swapping an atom. In practice, once an atom is swapped, the\nthreads do some real work (e.g., database access), which creates an opportunity for\nother threads to swap the atom successfully.\nTheo Interesting.... Indeed, atoms look much easier to manage than locks.\nJoe Now let me show you how to use atoms with composite data.\nTheo Why would that be different?\nJoe Usually, dealing with composite data is more difficult than dealing with primi-\ntive types.\nTheo When you sold me on DOP, you told me that we are able to manage data with\nthe same simplicity as we manage numbers.\nTIP In DOP, data is managed with the same simplicity as numbers.\nJoe That’s exactly what I am about to show you.\n8.3 Thread-safe cache with atoms\nJoe Are you familiar with the notion of in-memory cache?\nTheo You mean memoization?\n--- Page 199 ---\n8.3 Thread-safe cache with atoms 171\nJoe Kind of. Imagine that database queries don’t vary too much in your applica-\ntion. It makes sense in that case to store the results of previous queries in mem-\nory in order to improve the response time.\nTheo Yes, of course!\nJoe What data structure would you use to store the in-memory cache?\nTheo Probably a string map, where the keys are the queries, and the values are the\nresults from the database.\nTIP It’s quite common to represent an in-memory cache as a string map.\nJoe Excellent! Now can you write the code to cache database queries in a thread-\nsafe way using a lock?\nTheo Let me see: I’m going to use an immutable string map. Therefore, I don’t\nneed to protect read access with a lock. Only the cache update needs to be\nprotected.\nJoe You’re getting the hang of this!\nTheo The code should be something like this.\nListing8.6 Thread-safe cache with locks\nvar mutex = new Mutex();\nvar cache = {};\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache, query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\nmutex.lock();\ncache = _.set(cache, query, result);\nmutex.unlock();\nreturn result;\n}\nJoe Nice! Now, let me show you how to write the same code using an atom instead\nof a lock. Take a look at this code and let me know if it’s clear to you.\nListing8.7 Thread-safe cache with atoms\nvar cache = new Atom();\ncache.set({});\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache.get(), query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\ncache.swap(function(oldCache) {\n--- Page 200 ---\n172 CHAPTER 8 Advanced concurrency control\nreturn _.set(oldCache, query, result);\n});\nreturn result;\n}\nTheo I don’t understand the function you’re passing to the swap method.\nJoe The function passed to swap receives the current value of the cache, which is a\nstring map, and returns a new version of the string map with an additional key-\nvalue pair.\nTheo I see. But something bothers me with the performance of the swap method in\nthe case of a string map. How does the comparison work? I mean, comparing\ntwo string maps might take some time.\nJoe Not if you compare them by reference. As we discussed in the past, when data\nis immutable, it is safe to compare by reference, and it’s super fast.\nTIP When data is immutable, it is safe (and fast) to compare it by reference.\nTheo Cool. So atoms play well with immutable data.\nJoe Exactly!\n8.4 State management with atoms\nJoe Do you remember a couple of weeks ago when I showed you how we resolve\npotential conflicts between mutations? You told me that the code was not\nthread-safe.\nTheo Let me look again at the code.\nTheo takes a look at the code for the SystemData class that he wrote some time ago\n(repeated in listing 8.8). Without the validation logic, it makes the code easier to grasp.\nListing8.8 SystemData class from part 1\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nthis.systemData = SystemConsistency.reconcile(this.systemData,\nprevious,\nnext);\n}\n}\n--- Page 201 ---\n8.4 State management with atoms 173\nIt takes him a few minutes to remember how the commit method works. Suddenly, he has\nan Aha! moment.\nTheo This code is not thread-safe because the SystemConsistency.reconcile\ncode inside the commit method is not protected. Nothing prevents the two\nthreads from executing this code concurrently.\nJoe Right! Now, can you tell me how to make it thread-safe?\nTheo With locks?\nJoe Come on...\nTheo I was kidding, of course. We make the code thread-safe not with a lock but with\nan atom.\nJoe Nice joke!\nTheo Let me see. I’d need to store the system data inside an atom. The get and set\nmethod of SystemData would simply call the get and set methods of the\natom. How does this look?\nListing8.9 SystemData class with atom (without the commit method)\nclass SystemState {\nsystemData;\nconstructor() {\nthis.systemData = new Atom();\n}\nget() {\nreturn this.systemData.get();\n}\ncommit(prev, next) {\nthis.systemData.set(next);\n}\n}\nJoe Excellent. Now for the fun part. Implement the commit method by calling the\nswap method of the atom.\nTheo Instead of calling SystemConsistency.reconcile() directly, I need to wrap\nit into a call to swap. So, something like this?\nListing8.10 Implementation of SystemData.commit with atom\nSystemData.commit = function(previous, next) {\nthis.systemData.swap(function(current) {\nreturn SystemConsistency.reconcile(current,\nprevious,\nnext);\n});\n};",
        "sections_found": []
      },
      "accurate_page_range": "176-201"
    },
    {
      "text": "- 7.3 Schema flexibility and strictness",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "raw_line": "- 7.3 Schema flexibility and strictness (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 60,
      "chapter_info": {
        "page": 176,
        "title": "Basic data validation",
        "pattern_matched": "Chapter 7",
        "text_preview": "148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema"
      },
      "chapter_sections": {
        "start_page": 176,
        "end_page": 201,
        "content": "\n--- Page 176 ---\n148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema from listing 7.6.\nListing7.7 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe Give it a try, and you’ll see.\nIndeed! When Theo executes the code to validate the search request, it returns true.\nListing7.8 Validating the search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksRequest = {\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nvalidate(searchBooksRequestSchema, searchBooksRequest);\n// → true\nJoe Now, please try an invalid request.\nTheo Let me think about what kind of invalidity to try. I know, I’ll make a typo in the\ntitle field and call it tilte with the l before the t.\nAs expected, the code with the type returns false. Theo is not surprised, and Joe is smil-\ning from ear to ear.\nListing7.9 Validating an invalid search request\nvar invalidSearchBooksRequest = {\n\"tilte\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\n--- Page 177 ---\n7.3 Schema flexibility and strictness 149\nvalidate(searchBooksRequestSchema, invalidSearchBooksRequest);\n// → false\nTheo The syntax of JSON Schema is much more verbose than the syntax for declar-\ning the members in a class. Why is that so?\nJoe For two reasons. First, because JSON Schema is language independent, it can\nbe used in any programming language. As I told you, there are JSON Schema\nvalidators available in most programming languages.\nTheo I see.\nJoe Second, JSON Schema allows you to express validation conditions that are much\nharder, if not impossible, to express when data is represented with classes.\nTIP The expressive power of JSON Schema is high!\nTheo Now you have triggered my curiosity. Can you give me some examples?\nJoe In a moment, we’ll talk about schema composition. Someday I’ll show you\nsome examples of advanced validation.\n NOTE Advanced validation is covered in chapter 12.\nTheo What kind of advanced validation?\nJoe What I mean by advanced validation is, for instance, validating that a number\nfalls within a given range or validating that a string matches a regular expression.\nTheo Is there a way to get details about why the request is invalid?\nJoe Absolutely! I’ll show you later. For now, let me show you how to make sure the\nresponse the server sends back to the client is valid.\nTheo It sounds much more complicated than a search book request!\nJoe Why?\nTheo Because a search response is made of multiple book results, and in each book\nresult, some of the fields are optional!\n7.3 Schema flexibility and strictness\nJoe Can you give me an example of what a book search response would look like?\nTheo Take a look at this example. It’s a search response with information about two\nbooks: 7 Habits of Highly Effective People and The Power of Habit.\nListing7.10 An example of a search response\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432\n},\n--- Page 178 ---\n150 CHAPTER 7 Basic data validation\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn_13\": \"978-1982137274\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n]\n}\n]\nJoe It’s funny that you mention The Power of Habit. I’m reading this book in order\nto get rid of my habit of biting my nails. Anyway, what fields are required and\nwhat fields are optional in a book search response?\nTheo In book information, the title and available fields are required. The other\nfields are optional.\nJoe As I told you when we built the schema for the book search request, fields in a\nmap are optional by default. In order to make a field mandatory, we have to\ninclude it in the required array. I’d probably implement it with something\nlike this.\nListing7.11 Schema of a search response\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, map fields are optional by default.\nTheo I must admit that specifying a list of required fields is much simpler than hav-\ning to specify that a member in a class in nullable!\nJoe Agreed!\nTheo On the other hand, I find the nesting of the book information schema in the\nsearch response schema a bit hard to read.\n--- Page 179 ---\n7.3 Schema flexibility and strictness 151\nJoe Nothing prevents you from separating the book information schema from the\nsearch response schema.\nTheo How?\nJoe It’s just JSON, my friend. It means, you are free to manipulate the schema as\nany other map in your program. For instance, you could have the book infor-\nmation schema in a variable named bookInfoSchema and use it in the search\nbooks response schema. Let me refactor the schema to show you what I mean.\nListing7.12 Schema of a search response refactored\nvar bookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n};\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": bookInfoSchema\n};\nTheo Once again, I have to admit that JSON Schemas are more composable than\nclass definitions.\nTIP JSON Schemas are just maps. We are free to compose and manipulate them like\nany other map.\nJoe Let’s move on to validating data received from external data sources.\nTheo Is that different?\nJoe Not really, but I’ll take it as an opportunity to show you some other features of\nJSON Schema.\nTheo I’m curious to learn how data validation is used when we access data from the\ndatabase.\nJoe Each time we access data from the outside, it’s a good practice to validate it.\nCan you show me an example of how a database response for a search query\nwould look?\nTIP It’s a good practice to validate data that comes from an external data source.\n--- Page 180 ---\n152 CHAPTER 7 Basic data validation\nTheo When we query books from the database, we expect to receive an array of\nbooks with three fields: title, isbn, and available. The first two values should\nbe strings, and the third one should be a Boolean.\nJoe Are those fields optional or required?\nTheo What do you mean?\nJoe Could there be books for which some of the fields are not defined?\nTheo No.\nJoe In that case, the schema is quite simple. Would you like to try writing the\nschema for the database response?\nTheo Let me see. It’s an array of objects where each object has three properties, so\nsomething like this?\nListing7.13 Schema of a database response\n{\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n}\nJoe Well done, my friend! Now, I want to tell you about the additionalProperties\nfield in JSON Schema.\nTheo What’s that?\nJoe Take a look at this array.\nListing7.14 A book array with an additional property\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"dummy_property\": 42\n},\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn\": \"978-1982137274\",\n\"dummy_property\": 45\n}\n]\n--- Page 181 ---\n7.3 Schema flexibility and strictness 153\nJoe Is it a valid database response?\nTheo No. A database response should not have a dummy_property field. It should\nhave only the three required fields specified in the schema.\nJoe It might be surprising but, by default, fields not specified in the schema of an\nobject are allowed in JSON Schema. In order to disallow them, one has to set\nadditionalProperties to false like this.\nListing7.15 Disallowing properties not mentioned in the schema\nvar booksFromDBSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"additionalProperties\": false,\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, by default, fields not specified in the schema of a map are\nallowed.\nTheo Why is that?\nJoe The reason is that usually having additional fields in a map doesn’t cause\ntrouble. If your code doesn’t care about a field, it simply ignores it. But some-\ntimes we want to be as strict as possible, and we set additionalProperties\nto false.\nTheo What about the search request and response schema from the previous discus-\nsions? Should we set additionalProperties to false?\nJoe That’s an excellent question. I’d say it’s a matter of taste. Personally, I like to\nallow additional fields in requests and disallow them in responses.\nTheo What’s the advantage?\nJoe Well, the web server is responsible for the responses it sends to its clients. It\nmakes sense then to be as strict as possible. However, the requests are created\nby the clients, and I prefer to do my best to serve my clients even when they are\nnot as strict as they should be.\nTheo Naturally. “The client is always right.”\nJoe Actually, I prefer the way Jon Postel formulated his robustness principle: “Be\nconservative in what you send, be liberal in what you accept.”\nTIP It’s a good practice to be strict with the data that you send and to be flexible with\nthe data that you receive.\n--- Page 182 ---\n154 CHAPTER 7 Basic data validation\n7.4 Schema composition\nTheo What about validating data that comes from an external web service?\nJoe Can you give me an example?\nTheo In the near future, we’ll have to integrate with a service called Open Library\nBooks API that provides detailed information about books.\n NOTE For information on the Open Library Books API, see https://openlibrary\n.org/dev/docs/api/books.\nJoe Can you show me, for instance, the service response for Watchmen?\nTheo Sure. Here you go.\nTheo taps a few keys on his keyboard and brings up the response. Joe looks at the JSON for\na long time.\nListing7.16 An Open Library Books API response example\n{\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n}\nTheo asks himself, “What could be so special in this JSON?” While Joe is meditating about\nthis piece of JSON, Theo writes the JSON Schema for the Books API response. It doesn’t\nseem to be more complicated than any of the previous schemas. When Theo is done, he\nasks Joe to take a look at the schema.\nListing7.17 Schema of the Open Library Books API response\n{\n\"type\": \"object\",\n\"required\": [\"title\"],\n--- Page 183 ---\n7.4 Schema composition 155\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n}\nJoe Good job!\nTheo That wasn’t so hard. I really don’t see why you looked at this JSON response for\nsuch a long time.\nJoe Well, it has to do with the isbn_10 and isbn_13 fields. I assume that they’re\nnot both mandatory.\nTheo Right! That’s why I didn’t include them in the required field of my schema.\nJoe But one of them should always be there. Right?\nTheo Sometimes one of them and sometimes both of them, like for Watchmen. It\ndepends on the publication year of the book. Books published before 2007\nhave isbn_10, and books published after 2007 have isbn_13.\nJoe Oh, I see. And Watchmen has both because it was originally published in 1986\nbut published again after 2007.\nTheo Correct.\nJoe Then, you need your schema to indicate that one of the isbn fields is man-\ndatory. That’s a good opportunity for me to tell you about JSON Schema\ncomposition.\nTheo What’s that?\nJoe It’s a way to combine schemas, similarly to how we combine logical conditions\nwith AND, OR, and NOT.\nTheo I’d like to see that.\nJoe Sure. How would you express the schema for the Books API response as a\ncomposition of three schemas: basicBookInfoSchema, the schema that you\nwrote where only title is required; mandatoryIsbn13, a schema where only\n--- Page 184 ---\n156 CHAPTER 7 Basic data validation\nisbn_13 is required; and mandatoryIsb10, a schema where only isbn_10 is\nrequired?\nTheo I think it should be basicBookInfoSchema AND (mandatoryIsbn13 OR\nmandatoryIsbn10).\nJoe Exactly! The only thing is that in JSON Schema, we use allOf instead of AND,\nand anyOf instead of OR.\nJoe shows Theo the result in listing 7.18 and an example of its usage in listing 7.19.\nListing7.18 Schema of an external API response\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n--- Page 185 ---\n7.4 Schema composition 157\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing7.19 Validating an external API response\nvar bookInfo = {\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n};\nvalidate(bookInfoSchema, bookInfo);\n// → true\nTheo I see why they call it allOf and anyOf. The first one means that data must con-\nform to all the schemas, and the second one means that data must conform to\nany of the schemas.\nJoe Yup.\n NOTE JSON Schema also supports oneOf for cases where data must be valid against\nexactly one schema.\nTheo Nice. With schema composition, JSON Schema seems to have more expressive\npower than what I was used to when representing data with classes.\nJoe That’s only the beginning. I’ll show you more data validation conditions that\ncan’t be expressed when data is represented with classes some other time.\n NOTE Advanced data validation is covered in chapter 12.\nTheo Something still bothers me, though. When data isn’t valid, you don’t know what\nwent wrong.\n--- Page 186 ---\n158 CHAPTER 7 Basic data validation\n7.5 Details about data validation failures\nJoe So far, we’ve treated JSON Schema validation as though it were binary: either a\npiece of data is valid or it isn’t.\nTheo Right...\nJoe But, in fact, when a piece of data is not valid, we can get details about the\nreason of the invalidity.\nTheo Like when a required field is missing, can we get the name of the missing field?\nJoe Yes. When a piece of data is not of the expected type, we can get information\nabout that also.\nTheo That sounds very useful!\nJoe Indeed. Let me show you how it works. Until now, we used a generic validate\nfunction, but when we deal with validation failures, we need to be more specific.\nTheo Why?\nJoe Because each data validator library has its own way of exposing the details of\nadata validation failure. For instance, in JavaScript Ajv, the errors from the\nlast data validation are stored as an array inside the validator instance.\nTheo Why an array?\nJoe Because there could be several failures. But let’s start with the case of a single\nfailure. Imagine we encounter a search book request where the title field is\nnamed myTitle instead of title. Take a look at this example. As you can see,\nwe first instantiate a validator instance.\nListing7.20 Accessing validation errors in Ajv\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nInstantiates a\nvar ajv = new Ajv(); validator instance\najv.validate(searchBooksRequestSchema, invalidSearchBooksRequest);\najv.errors\nDisplays the\nvalidation errors\n--- Page 187 ---\n7.5 Details about data validation failures 159\nTheo And what does the information inside the errors array look like?\nJoe Execute the code snippet. You’ll see.\nWhen Theo executes the code snippets from listing 7.20, he can hardly believe his eyes. He\nlooks at the details, finding the results hard to digest.\nListing7.21 Details for a single data validation failure in an array format\n[\n{\n\"instancePath\": \"\",\n\"schemaPath\": \"#/required\",\n\"keyword\": \"required\",\n\"params\": {\n\"missingProperty\":\"title\"\n},\n\"message\": \"must have required property 'title'\"\n}\n]\nTheo I find the contents of the errors array a bit hard to understand.\nJoe Me too. Fortunately, Ajv provides a errorsText utility function to convert the\nerrors array in a human readable format. See, for instance, what is returned\nwhen you call errorsText.\nListing7.22 Displaying the errors in human readable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title'\"\nTheo Let me see what happens when there are more than one validation failure in\nthe data.\nJoe By default, Ajv catches only one validation error.\nTIP By default, Ajv catches only the first validation failure.\nTheo I guess that’s for performance reasons. Once the validator encounters an\nerror, it doesn’t continue the data parsing.\nJoe Probably. Anyway, in order to catch more than one validation failure, you need\nto pass the allErrors options to the Ajv constructor. Check out this code.\nListing7.23 Catching multiple validation failures\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n--- Page 188 ---\n160 CHAPTER 7 Basic data validation\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nA request with\nthree failures\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [1, 2]\n}; Instantiates the Ajv constructor\nwith allErrors: true in order to\ncatch more than one failure\nvar ajv = new Ajv({allErrors: true});\najv.validate(searchBooksRequestSchema,\ninvalidSearchBooksRequest); Converts the\nerrors to a human\nreadable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title',\n// → data/fields/0 must be string,\n// → data/fields/1 must be string\"\nJoe We validate a search request with myTitle instead of title and numbers\ninstead of strings in the fields array. As you can see in the output of the code\nsnippet, three errors are returned.\nTheo Great! I think I have all that I need in order to add data validation to the\nboundaries of my system when Nancy asks me to make the Library Manage-\nment System into a web server.\nJoe Would you allow me to give you a small gift as a token of our friendship?\nTheo I’d be honored.\nJoe takes a small package out of his bag, wrapped in a light-green ribbon. He hands Theo\nthe package with a solemn gesture.\nWhen Theo undoes the ribbon, he discovers an elegant piece of paper decorated with\npretty little designs. In the center of the paper, Theo manages to read the inscription\n“JSON Schema cheat sheet.” He smiles while browsing the cheat sheet. It’s exactly what he\nneeds.\nListing7.24 JSON Schema cheat sheet\n{ At the root level,\ndata is an array.\n\"type\": \"array\",\n\"items\": { Each element of the\narray is a map.\n\"type\": \"object\",\nmyNumber \"properties\": {\nThe properties of\nis a number. \"myNumber\": {\"type\": \"number\"},\neach field in the map\n\"myString\": {\"type\": \"string\"},\nmyString is\n\"myEnum\": {\"enum\": [\"myVal\", \"yourVal\"]},\na string. myEnum is a\n\"myBool\": {\"type\": \"boolean\"}\nenumeration\nmyBool is a }, value with two\nboolean. \"required\": [\"myNumber\", \"myString\"], possibilities:\nThe mandatory fields in the map \"myVal\" and\nare myNumber and myString; \"yourVal\".\nother fields are optional.\n--- Page 189 ---\nSummary 161\n\"additionalProperties\": false\nWe don’t allow fields that\n}\nare not explicitly mentioned\n}\nin the schema.\nThen, Theo turns the paper over to find that the back is also filled with drawings. In the\ncenter of the paper, he reads the inscription, “An example of valid data.”\nListing7.25 An example of valid data\n[\n{\nThis map is valid\n\"myNumber\": 42,\nbecause all its\n\"myString\": \"Hello\",\nfields are valid.\n\"myEnum\": \"myVal\",\n\"myBool\": true\n},\n{\nThis map is valid\n\"myNumber\": 54,\nbecause it contains all\n\"myString\": \"Happy\"\nthe required fields.\n}\n]\nSummary\n DOP Principle #4 is to separate data schema and data representation.\n The boundaries of a system are defined to be the areas where the system\nexchanges data.\n Some examples of data validation at the boundaries of the system are validation\nof client requests and responses, and validation of data that comes from exter-\nnal sources.\n Data validation in DOP means checking whether a piece of data conforms to a\nschema.\n When a piece of data is not valid, we get information about the validation fail-\nures and send this information back to the client in a human readable format.\n When data at system boundaries is valid, it’s not critical to validate data again\ninside the system.\n JSON Schema is a language that allows us to separate data validation from data\nrepresentation.\n JSON Schema syntax is a bit verbose.\n The expressive power of JSON Schema is high.\n JSON Schemas are just maps and, as so, we are free to manipulate them like any\nother maps in our programs.\n We can store a schema definition in a variable and use this variable in another\nschema.\n In JSON Schema, map fields are optional by default.\n It’s good practice to validate data that comes from an external data source.\n--- Page 190 ---\n162 CHAPTER 7 Basic data validation\n It’s good practice to be strict regarding data that you send and to be flexible\nregarding data that you receive.\n Ajv is a JSON Schema library in JavaScript.\n By default, Ajv catches only the first validation failure.\n Advanced validation is covered in chapter 12.\n--- Page 191 ---\nAdvanced\nconcurrency control\nNo more deadlocks!\nThis chapter covers\n Atoms as an alternative to locks\n Managing a thread-safe counter and a thread-safe\nin-memory cache with atoms\n Managing the whole system state in a thread-safe\nway with atoms\nThe traditional way to manage concurrency in a multi-threaded environment\ninvolves lock mechanisms like mutexes. Lock mechanisms tend to increase the com-\nplexity of the system because it’s not trivial to make sure the system is free of dead-\nlocks. In DOP, we leverage the fact that data is immutable, and we use a lock-free\nmechanism, called an atom, to manage concurrency. Atoms are simpler to manage\nthan locks because they are lock-free. As a consequence, the usual complexity of\nlocks that are required to avoid deadlocks don’t apply to atoms.\n NOTE This chapter is mostly relevant to multi-threaded environments like Java,\nC#, Python, and Ruby. It is less relevant to single-threaded environments like Java-\nScript. The JavaScript code snippets in this chapter are written as though JavaScript\nwere multi-threaded.\n163\n--- Page 192 ---\n164 CHAPTER 8 Advanced concurrency control\n8.1 The complexity of locks\nThis Sunday afternoon, while riding his bike across the Golden Gate Bridge, Theo thinks\nabout the Klafim project with concern, not yet sure that betting on DOP was a good\nchoice. Suddenly, Theo realizes that he hasn’t yet scheduled the next session with Joe. He\ngets off his bike to call Joe. Bad luck, the line is busy.\nWhen Theo gets home, he tries to call Joe again, but once again the phone is busy. After\ndinner, Theo tries to call Joe one more time, with the same result—a busy signal. “Obvi-\nously, Joe is very busy today,” Theo tells himself. Exhausted by his 50-mile bike ride at an\naverage of 17 miles per hour, he falls asleep on the sofa. When Theo wakes up, he’s elated\nto see a text message from Joe, “See you Monday morning at 11 AM?” Theo answers with a\nthumbs up and prepares for another week of work.\nWhen Joe arrives at the office, Theo asks him why his phone was constantly busy the day\nbefore. Joe answers that he was about to ask Theo the same question. They look at each\nother, puzzled, and then simultaneously break into laughter as they realize what hap-\npened: in an amazing coincidence, they’d tried to phone each other at exactly the same\ntimes. They both say at once:\n“A deadlock!”\nThey both head for Theo’s office. When they get to Theo’s desk, Joe tells him that today’s\nsession is going to be about concurrency management in multi-threaded environments.\nJoe How do you usually manage concurrency in a multi-threaded environment?\nTheo I protect access to critical sections with a lock mechanism, a mutex, for instance.\nJoe When you say access, do you mean write access or also read access?\nTheo Both!\nJoe Why do you need to protect read access with a lock?\nTheo Because, without a lock protection, in the middle of a read, a write could hap-\npen in another thread. It would make my read logically inconsistent.\nJoe Another option would be to clone the data before processing it in a read.\nTheo Sometimes I would clone the data; but in many cases, when it’s large, it’s too\nexpensive to clone.\nTIP Cloning data to avoid read locks doesn’t scale.\nJoe In DOP, we don’t need to clone or to protect read access.\nTheo Because data is immutable?\nJoe Right. When data is immutable, even if a write happens in another thread\nduring a read, it won’t make the read inconsistent because the write never\nmutates the data that is read.\nTheo In a sense, a read always works on a data snapshot.\nJoe Exactly!\nTIP When data is immutable, a read is always safe.\nTheo But what about write access? Don’t you need to protect that with locks?\nJoe Nope.\n--- Page 193 ---\n8.2 Thread-safe counter with atoms 165\nTheo Why not?\nJoe We have a simpler mechanism—it’s called an atom.\nTheo I am glad to hear there is a something simpler than locks. I really struggle each\ntime I have to integrate locks into a multi-threaded system.\nJoe Me too! I remember a bug we had in production 10 years ago. We forgot to\nrelease a lock when an exception was thrown in a critical section. It caused a\nterrible deadlock.\nTheo Deadlocks are really hard to avoid. Last year, we had a deadlock issue when two\nlocks were not released in the proper order.\nJoe I have great news for you. With atoms, deadlocks never happen!\nTIP With atoms, deadlocks never happen.\nTheo That sounds great. Tell me more!\nTIP Atoms provide a way to manage concurrency without locks.\n8.2 Thread-safe counter with atoms\nJoe Let’s start with a simple case: a counter shared between threads.\nTheo What do you mean by a counter?\nJoe Imagine that we’d like to count the number of database accesses and write the\ntotal number of accesses to a log every minute.\nTheo OK.\nJoe Could you write JavaScript code for this multi-threaded counter using locks?\nTheo But JavaScript is single-threaded!\nJoe I know, but it’s just for the sake of illustration. Imagine that JavaScript were\nmulti-threaded and that it provided a Mutex object that you could lock and\nunlock.\nTheo It’s a bit awkward. I guess it would look like this.\nTheo goes to the whiteboard. He writes what he imagines to be JavaScript code for a multi-\nthreaded counter with locks.\nListing8.1 A thread-safe counter protected by a mutex\nvar mutex = new Mutex();\nvar counter = 0;\nfunction dbAccess() {\nmutex.lock();\ncounter = counter + 1;\nmutex.unlock();\n// access the database\n}\nfunction logCounter() {\nmutex.lock();\n--- Page 194 ---\n166 CHAPTER 8 Advanced concurrency control\nconsole.log('Number of database accesses: ' + counter);\nmutex.unlock();\n}\nJoe Excellent. Now, I am going to show you how to write the same code with atoms.\nAn atom provides three methods:\n get returns the current value of the atom.\n set overwrites the current value of the atom.\n swap receives a function and updates the value of the atom with the result\nof the function called on the current value of the atom.\nJoe unzips a pocket in his laptop case and takes out a piece of paper. He hands it to\nTheo. Theo is pleasantly surprised as the sheet of paper succinctly describes the methods\n(table 8.1).\nTable 8.1 The three methods of an atom\nMethod Description\nget Returns the current value\nset Overwrites the current value\nswap Updates the current value with a function\nTheo How would it look like to implement a thread-safe counter with an atom?\nJoe It’s quite simple, actually.\nJoe pulls out his laptop, fires it up, and begins to type. When he’s done, he turns the laptop\naround so that Theo can see the code to implement a thread-safe counter in an atom.\nListing8.2 A thread-safe counter stored in an atom\nvar counter = new Atom();\ncounter.set(0);\nfunction dbAccess() {\ncounter.swap(function(x) {\nThe argument x is the\nreturn x + 1;\ncurrent value of the atom,\n});\nsame as counter.get().\n// access the database\n}\nfunction logCounter() {\nconsole.log('Number of database accesses: ' + counter.get());\n}\nTheo Could you tell me what’s going on here?\nJoe Sure! First, we create an empty atom. Then, we initialize the value of the atom\nwith counter.set(0). In the logger thread, we read the current value of the\natom with counter.get().\nTheo And how do you increment the counter in the threads that access the database?\n--- Page 195 ---\n8.2 Thread-safe counter with atoms 167\nJoe We call swap with a function that receives x and returns x + 1.\nTheo I don’t understand how swap could be thread-safe without using any locks.\nJoe quickly goes to the whiteboard. He sketches the diagram in figure 8.1.\nTake snapshot\nCompute next state\nYes\nState changed?\nNo\nUpdate state\nFigure 8.1 High-level flow of swap\nJoe You see, swap computes the next value of the atom, and before modifying the\ncurrent value of the atom, it checks whether the value of the atom has changed\nduring the computation. If so, swap tries again, until no changes occur during\nthe computation.\nTheo Is swap easy to implement?\nJoe Let me show you the implementation of the Atom class and you’ll see.\nListing8.3 Implementation of the Atom class\nclass Atom {\nstate;\nconstructor() {}\nget() {\nreturn this.state;\n}\nset(state) {\nthis.state = state;\n}\nswap(f) {\nwhile(true) {\nvar stateSnapshot = this.state;\nvar nextState = f(stateSnapshot);\nif (!atomicCompareAndSet(this.state,\n--- Page 196 ---\n168 CHAPTER 8 Advanced concurrency control\nstateSnapshot,\nnextState)) {\nUses a special thread-safe comparison operation\ncontinue;\nas this.state might have changed in another\n}\nthread during execution of the function f.\nreturn nextState;\n}\n}\n}\nTheo comes closer to the whiteboard. He modifies Joe’s diagram a bit to make the flow of\nthe swap operation more detailed. The resulting diagram is in figure 8.2. Theo still has a\nfew questions, though.\nTake snapshot\nsnapshot = state\nCompute next state\nnextState = f(snapshot)\nCheck if state has changed\nstate == snapshot\nYes\nState changed?\nNo\nUpdate state\nstate = nextState\nFigure 8.2 Detailed flow of swap\nTheo What is atomicCompareAndSet?\nJoe It’s the core operation of an atom. atomicCompareAndSet atomically sets the\nstate to a new value if, and only if, the state equals the provided old value. It\nreturns true upon success and false upon failure.\nTheo How could it be atomic without using locks?\nJoe That’s a great question! In fact, atomicCompareAndSet is a compare-and-swap\noperation, provided by the language that relies on a functionality of the CPU\nitself. For example, in Java the java.util.concurrent.atomic package has\nan AtomicReference generic class that provides a compareAndSet() method.\n NOTE See http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html\nfor general information about compare-and-swap operations. Implementations for\nmulti-threaded languages appear in table 8.2.\n--- Page 197 ---\n8.2 Thread-safe counter with atoms 169\nTable 8.2 Implementation of an atomic compare and set in various languages\nLanguage Link\nJava http://mng.bz/mx0W\nJavaScript Not relevant (single-threaded language)\nRuby http://mng.bz/5KG8\nPython https://github.com/maxcountryman/atomos\nC# http://mng.bz/6Zzp\nTheo Apropos Java, how would the implementation of an atom look?\nJoe It’s quite the same, besides the fact that Atom has to use generics, and the inner\nstate has to be stored in an AtomicReference.\nJoe brings up a Java implementation of Atom on his laptop. Theo looks over the code.\nListing8.4 Implementation of the Atom class in Java\nclass Atom<ValueType> {\nprivate AtomicReference<ValueType> state;\npublic Atom() {}\nValueType get() {\nreturn this.state.get();\n}\nthis.state might have\nchanged in another thread\nvoid set(ValueType state) {\nduring the execution of f.\nthis.state.set(state);\n}\nValueType swap(UnaryOPerator<ValueType> f) {\nwhile(true) {\nValueType stateSnapshot = this.state.get();\nValueType nextState = f(stateSnapshot);\nif (!this.state.compareAndSet(stateSnapshot,\nnextState)) {\ncontinue;\n}\n}\nreturn nextState;\n}\n}\nTheo What about using an atom in Java?\nJoe Here, take a look. It’s quite simple.\n--- Page 198 ---\n170 CHAPTER 8 Advanced concurrency control\nListing8.5 Using an Atom in Java\nAtom<Integer> counter = new Atom<Integer>();\ncounter.set(0);\ncounter.swap(x -> x + 1);\ncounter.get();\nTheo takes a couple of minutes to meditate about this atom stuff and to digest what he’s\njust learned. Then, he asks Joe:\nTheo What if swap never succeeds? I mean, could the while loop inside the code of\nswap turn out to be an infinite loop?\nJoe No! By definition, when atomicCompareAndSet fails on a thread, it means that\nthe same atom was changed on another thread during the execution of swap.\nIn this race between threads, there is always a winner.\nTheo But isn’t it possible that some thread never succeeds because it always loses the\nrace against other threads?\nJoe In theory, yes, but I’ve never encountered such a situation. If you have thou-\nsands of threads that do nothing besides swapping an atom, it could happen I\nsuppose. But, in practice, once the atom is swapped, the threads do some real\nwork, for example, database access or I/O. This gives other threads the oppor-\ntunity to swap the atom successfully.\n NOTE In theory, atoms could create starvation in a system with thousands of threads\nthat do nothing beside swapping an atom. In practice, once an atom is swapped, the\nthreads do some real work (e.g., database access), which creates an opportunity for\nother threads to swap the atom successfully.\nTheo Interesting.... Indeed, atoms look much easier to manage than locks.\nJoe Now let me show you how to use atoms with composite data.\nTheo Why would that be different?\nJoe Usually, dealing with composite data is more difficult than dealing with primi-\ntive types.\nTheo When you sold me on DOP, you told me that we are able to manage data with\nthe same simplicity as we manage numbers.\nTIP In DOP, data is managed with the same simplicity as numbers.\nJoe That’s exactly what I am about to show you.\n8.3 Thread-safe cache with atoms\nJoe Are you familiar with the notion of in-memory cache?\nTheo You mean memoization?\n--- Page 199 ---\n8.3 Thread-safe cache with atoms 171\nJoe Kind of. Imagine that database queries don’t vary too much in your applica-\ntion. It makes sense in that case to store the results of previous queries in mem-\nory in order to improve the response time.\nTheo Yes, of course!\nJoe What data structure would you use to store the in-memory cache?\nTheo Probably a string map, where the keys are the queries, and the values are the\nresults from the database.\nTIP It’s quite common to represent an in-memory cache as a string map.\nJoe Excellent! Now can you write the code to cache database queries in a thread-\nsafe way using a lock?\nTheo Let me see: I’m going to use an immutable string map. Therefore, I don’t\nneed to protect read access with a lock. Only the cache update needs to be\nprotected.\nJoe You’re getting the hang of this!\nTheo The code should be something like this.\nListing8.6 Thread-safe cache with locks\nvar mutex = new Mutex();\nvar cache = {};\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache, query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\nmutex.lock();\ncache = _.set(cache, query, result);\nmutex.unlock();\nreturn result;\n}\nJoe Nice! Now, let me show you how to write the same code using an atom instead\nof a lock. Take a look at this code and let me know if it’s clear to you.\nListing8.7 Thread-safe cache with atoms\nvar cache = new Atom();\ncache.set({});\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache.get(), query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\ncache.swap(function(oldCache) {\n--- Page 200 ---\n172 CHAPTER 8 Advanced concurrency control\nreturn _.set(oldCache, query, result);\n});\nreturn result;\n}\nTheo I don’t understand the function you’re passing to the swap method.\nJoe The function passed to swap receives the current value of the cache, which is a\nstring map, and returns a new version of the string map with an additional key-\nvalue pair.\nTheo I see. But something bothers me with the performance of the swap method in\nthe case of a string map. How does the comparison work? I mean, comparing\ntwo string maps might take some time.\nJoe Not if you compare them by reference. As we discussed in the past, when data\nis immutable, it is safe to compare by reference, and it’s super fast.\nTIP When data is immutable, it is safe (and fast) to compare it by reference.\nTheo Cool. So atoms play well with immutable data.\nJoe Exactly!\n8.4 State management with atoms\nJoe Do you remember a couple of weeks ago when I showed you how we resolve\npotential conflicts between mutations? You told me that the code was not\nthread-safe.\nTheo Let me look again at the code.\nTheo takes a look at the code for the SystemData class that he wrote some time ago\n(repeated in listing 8.8). Without the validation logic, it makes the code easier to grasp.\nListing8.8 SystemData class from part 1\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nthis.systemData = SystemConsistency.reconcile(this.systemData,\nprevious,\nnext);\n}\n}\n--- Page 201 ---\n8.4 State management with atoms 173\nIt takes him a few minutes to remember how the commit method works. Suddenly, he has\nan Aha! moment.\nTheo This code is not thread-safe because the SystemConsistency.reconcile\ncode inside the commit method is not protected. Nothing prevents the two\nthreads from executing this code concurrently.\nJoe Right! Now, can you tell me how to make it thread-safe?\nTheo With locks?\nJoe Come on...\nTheo I was kidding, of course. We make the code thread-safe not with a lock but with\nan atom.\nJoe Nice joke!\nTheo Let me see. I’d need to store the system data inside an atom. The get and set\nmethod of SystemData would simply call the get and set methods of the\natom. How does this look?\nListing8.9 SystemData class with atom (without the commit method)\nclass SystemState {\nsystemData;\nconstructor() {\nthis.systemData = new Atom();\n}\nget() {\nreturn this.systemData.get();\n}\ncommit(prev, next) {\nthis.systemData.set(next);\n}\n}\nJoe Excellent. Now for the fun part. Implement the commit method by calling the\nswap method of the atom.\nTheo Instead of calling SystemConsistency.reconcile() directly, I need to wrap\nit into a call to swap. So, something like this?\nListing8.10 Implementation of SystemData.commit with atom\nSystemData.commit = function(previous, next) {\nthis.systemData.swap(function(current) {\nreturn SystemConsistency.reconcile(current,\nprevious,\nnext);\n});\n};",
        "sections_found": []
      },
      "accurate_page_range": "176-201"
    },
    {
      "text": "- 7.4 Schema composition",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "raw_line": "- 7.4 Schema composition (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 61,
      "chapter_info": {
        "page": 176,
        "title": "Basic data validation",
        "pattern_matched": "Chapter 7",
        "text_preview": "148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema"
      },
      "chapter_sections": {
        "start_page": 176,
        "end_page": 201,
        "content": "\n--- Page 176 ---\n148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema from listing 7.6.\nListing7.7 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe Give it a try, and you’ll see.\nIndeed! When Theo executes the code to validate the search request, it returns true.\nListing7.8 Validating the search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksRequest = {\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nvalidate(searchBooksRequestSchema, searchBooksRequest);\n// → true\nJoe Now, please try an invalid request.\nTheo Let me think about what kind of invalidity to try. I know, I’ll make a typo in the\ntitle field and call it tilte with the l before the t.\nAs expected, the code with the type returns false. Theo is not surprised, and Joe is smil-\ning from ear to ear.\nListing7.9 Validating an invalid search request\nvar invalidSearchBooksRequest = {\n\"tilte\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\n--- Page 177 ---\n7.3 Schema flexibility and strictness 149\nvalidate(searchBooksRequestSchema, invalidSearchBooksRequest);\n// → false\nTheo The syntax of JSON Schema is much more verbose than the syntax for declar-\ning the members in a class. Why is that so?\nJoe For two reasons. First, because JSON Schema is language independent, it can\nbe used in any programming language. As I told you, there are JSON Schema\nvalidators available in most programming languages.\nTheo I see.\nJoe Second, JSON Schema allows you to express validation conditions that are much\nharder, if not impossible, to express when data is represented with classes.\nTIP The expressive power of JSON Schema is high!\nTheo Now you have triggered my curiosity. Can you give me some examples?\nJoe In a moment, we’ll talk about schema composition. Someday I’ll show you\nsome examples of advanced validation.\n NOTE Advanced validation is covered in chapter 12.\nTheo What kind of advanced validation?\nJoe What I mean by advanced validation is, for instance, validating that a number\nfalls within a given range or validating that a string matches a regular expression.\nTheo Is there a way to get details about why the request is invalid?\nJoe Absolutely! I’ll show you later. For now, let me show you how to make sure the\nresponse the server sends back to the client is valid.\nTheo It sounds much more complicated than a search book request!\nJoe Why?\nTheo Because a search response is made of multiple book results, and in each book\nresult, some of the fields are optional!\n7.3 Schema flexibility and strictness\nJoe Can you give me an example of what a book search response would look like?\nTheo Take a look at this example. It’s a search response with information about two\nbooks: 7 Habits of Highly Effective People and The Power of Habit.\nListing7.10 An example of a search response\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432\n},\n--- Page 178 ---\n150 CHAPTER 7 Basic data validation\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn_13\": \"978-1982137274\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n]\n}\n]\nJoe It’s funny that you mention The Power of Habit. I’m reading this book in order\nto get rid of my habit of biting my nails. Anyway, what fields are required and\nwhat fields are optional in a book search response?\nTheo In book information, the title and available fields are required. The other\nfields are optional.\nJoe As I told you when we built the schema for the book search request, fields in a\nmap are optional by default. In order to make a field mandatory, we have to\ninclude it in the required array. I’d probably implement it with something\nlike this.\nListing7.11 Schema of a search response\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, map fields are optional by default.\nTheo I must admit that specifying a list of required fields is much simpler than hav-\ning to specify that a member in a class in nullable!\nJoe Agreed!\nTheo On the other hand, I find the nesting of the book information schema in the\nsearch response schema a bit hard to read.\n--- Page 179 ---\n7.3 Schema flexibility and strictness 151\nJoe Nothing prevents you from separating the book information schema from the\nsearch response schema.\nTheo How?\nJoe It’s just JSON, my friend. It means, you are free to manipulate the schema as\nany other map in your program. For instance, you could have the book infor-\nmation schema in a variable named bookInfoSchema and use it in the search\nbooks response schema. Let me refactor the schema to show you what I mean.\nListing7.12 Schema of a search response refactored\nvar bookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n};\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": bookInfoSchema\n};\nTheo Once again, I have to admit that JSON Schemas are more composable than\nclass definitions.\nTIP JSON Schemas are just maps. We are free to compose and manipulate them like\nany other map.\nJoe Let’s move on to validating data received from external data sources.\nTheo Is that different?\nJoe Not really, but I’ll take it as an opportunity to show you some other features of\nJSON Schema.\nTheo I’m curious to learn how data validation is used when we access data from the\ndatabase.\nJoe Each time we access data from the outside, it’s a good practice to validate it.\nCan you show me an example of how a database response for a search query\nwould look?\nTIP It’s a good practice to validate data that comes from an external data source.\n--- Page 180 ---\n152 CHAPTER 7 Basic data validation\nTheo When we query books from the database, we expect to receive an array of\nbooks with three fields: title, isbn, and available. The first two values should\nbe strings, and the third one should be a Boolean.\nJoe Are those fields optional or required?\nTheo What do you mean?\nJoe Could there be books for which some of the fields are not defined?\nTheo No.\nJoe In that case, the schema is quite simple. Would you like to try writing the\nschema for the database response?\nTheo Let me see. It’s an array of objects where each object has three properties, so\nsomething like this?\nListing7.13 Schema of a database response\n{\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n}\nJoe Well done, my friend! Now, I want to tell you about the additionalProperties\nfield in JSON Schema.\nTheo What’s that?\nJoe Take a look at this array.\nListing7.14 A book array with an additional property\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"dummy_property\": 42\n},\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn\": \"978-1982137274\",\n\"dummy_property\": 45\n}\n]\n--- Page 181 ---\n7.3 Schema flexibility and strictness 153\nJoe Is it a valid database response?\nTheo No. A database response should not have a dummy_property field. It should\nhave only the three required fields specified in the schema.\nJoe It might be surprising but, by default, fields not specified in the schema of an\nobject are allowed in JSON Schema. In order to disallow them, one has to set\nadditionalProperties to false like this.\nListing7.15 Disallowing properties not mentioned in the schema\nvar booksFromDBSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"additionalProperties\": false,\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, by default, fields not specified in the schema of a map are\nallowed.\nTheo Why is that?\nJoe The reason is that usually having additional fields in a map doesn’t cause\ntrouble. If your code doesn’t care about a field, it simply ignores it. But some-\ntimes we want to be as strict as possible, and we set additionalProperties\nto false.\nTheo What about the search request and response schema from the previous discus-\nsions? Should we set additionalProperties to false?\nJoe That’s an excellent question. I’d say it’s a matter of taste. Personally, I like to\nallow additional fields in requests and disallow them in responses.\nTheo What’s the advantage?\nJoe Well, the web server is responsible for the responses it sends to its clients. It\nmakes sense then to be as strict as possible. However, the requests are created\nby the clients, and I prefer to do my best to serve my clients even when they are\nnot as strict as they should be.\nTheo Naturally. “The client is always right.”\nJoe Actually, I prefer the way Jon Postel formulated his robustness principle: “Be\nconservative in what you send, be liberal in what you accept.”\nTIP It’s a good practice to be strict with the data that you send and to be flexible with\nthe data that you receive.\n--- Page 182 ---\n154 CHAPTER 7 Basic data validation\n7.4 Schema composition\nTheo What about validating data that comes from an external web service?\nJoe Can you give me an example?\nTheo In the near future, we’ll have to integrate with a service called Open Library\nBooks API that provides detailed information about books.\n NOTE For information on the Open Library Books API, see https://openlibrary\n.org/dev/docs/api/books.\nJoe Can you show me, for instance, the service response for Watchmen?\nTheo Sure. Here you go.\nTheo taps a few keys on his keyboard and brings up the response. Joe looks at the JSON for\na long time.\nListing7.16 An Open Library Books API response example\n{\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n}\nTheo asks himself, “What could be so special in this JSON?” While Joe is meditating about\nthis piece of JSON, Theo writes the JSON Schema for the Books API response. It doesn’t\nseem to be more complicated than any of the previous schemas. When Theo is done, he\nasks Joe to take a look at the schema.\nListing7.17 Schema of the Open Library Books API response\n{\n\"type\": \"object\",\n\"required\": [\"title\"],\n--- Page 183 ---\n7.4 Schema composition 155\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n}\nJoe Good job!\nTheo That wasn’t so hard. I really don’t see why you looked at this JSON response for\nsuch a long time.\nJoe Well, it has to do with the isbn_10 and isbn_13 fields. I assume that they’re\nnot both mandatory.\nTheo Right! That’s why I didn’t include them in the required field of my schema.\nJoe But one of them should always be there. Right?\nTheo Sometimes one of them and sometimes both of them, like for Watchmen. It\ndepends on the publication year of the book. Books published before 2007\nhave isbn_10, and books published after 2007 have isbn_13.\nJoe Oh, I see. And Watchmen has both because it was originally published in 1986\nbut published again after 2007.\nTheo Correct.\nJoe Then, you need your schema to indicate that one of the isbn fields is man-\ndatory. That’s a good opportunity for me to tell you about JSON Schema\ncomposition.\nTheo What’s that?\nJoe It’s a way to combine schemas, similarly to how we combine logical conditions\nwith AND, OR, and NOT.\nTheo I’d like to see that.\nJoe Sure. How would you express the schema for the Books API response as a\ncomposition of three schemas: basicBookInfoSchema, the schema that you\nwrote where only title is required; mandatoryIsbn13, a schema where only\n--- Page 184 ---\n156 CHAPTER 7 Basic data validation\nisbn_13 is required; and mandatoryIsb10, a schema where only isbn_10 is\nrequired?\nTheo I think it should be basicBookInfoSchema AND (mandatoryIsbn13 OR\nmandatoryIsbn10).\nJoe Exactly! The only thing is that in JSON Schema, we use allOf instead of AND,\nand anyOf instead of OR.\nJoe shows Theo the result in listing 7.18 and an example of its usage in listing 7.19.\nListing7.18 Schema of an external API response\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n--- Page 185 ---\n7.4 Schema composition 157\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing7.19 Validating an external API response\nvar bookInfo = {\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n};\nvalidate(bookInfoSchema, bookInfo);\n// → true\nTheo I see why they call it allOf and anyOf. The first one means that data must con-\nform to all the schemas, and the second one means that data must conform to\nany of the schemas.\nJoe Yup.\n NOTE JSON Schema also supports oneOf for cases where data must be valid against\nexactly one schema.\nTheo Nice. With schema composition, JSON Schema seems to have more expressive\npower than what I was used to when representing data with classes.\nJoe That’s only the beginning. I’ll show you more data validation conditions that\ncan’t be expressed when data is represented with classes some other time.\n NOTE Advanced data validation is covered in chapter 12.\nTheo Something still bothers me, though. When data isn’t valid, you don’t know what\nwent wrong.\n--- Page 186 ---\n158 CHAPTER 7 Basic data validation\n7.5 Details about data validation failures\nJoe So far, we’ve treated JSON Schema validation as though it were binary: either a\npiece of data is valid or it isn’t.\nTheo Right...\nJoe But, in fact, when a piece of data is not valid, we can get details about the\nreason of the invalidity.\nTheo Like when a required field is missing, can we get the name of the missing field?\nJoe Yes. When a piece of data is not of the expected type, we can get information\nabout that also.\nTheo That sounds very useful!\nJoe Indeed. Let me show you how it works. Until now, we used a generic validate\nfunction, but when we deal with validation failures, we need to be more specific.\nTheo Why?\nJoe Because each data validator library has its own way of exposing the details of\nadata validation failure. For instance, in JavaScript Ajv, the errors from the\nlast data validation are stored as an array inside the validator instance.\nTheo Why an array?\nJoe Because there could be several failures. But let’s start with the case of a single\nfailure. Imagine we encounter a search book request where the title field is\nnamed myTitle instead of title. Take a look at this example. As you can see,\nwe first instantiate a validator instance.\nListing7.20 Accessing validation errors in Ajv\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nInstantiates a\nvar ajv = new Ajv(); validator instance\najv.validate(searchBooksRequestSchema, invalidSearchBooksRequest);\najv.errors\nDisplays the\nvalidation errors\n--- Page 187 ---\n7.5 Details about data validation failures 159\nTheo And what does the information inside the errors array look like?\nJoe Execute the code snippet. You’ll see.\nWhen Theo executes the code snippets from listing 7.20, he can hardly believe his eyes. He\nlooks at the details, finding the results hard to digest.\nListing7.21 Details for a single data validation failure in an array format\n[\n{\n\"instancePath\": \"\",\n\"schemaPath\": \"#/required\",\n\"keyword\": \"required\",\n\"params\": {\n\"missingProperty\":\"title\"\n},\n\"message\": \"must have required property 'title'\"\n}\n]\nTheo I find the contents of the errors array a bit hard to understand.\nJoe Me too. Fortunately, Ajv provides a errorsText utility function to convert the\nerrors array in a human readable format. See, for instance, what is returned\nwhen you call errorsText.\nListing7.22 Displaying the errors in human readable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title'\"\nTheo Let me see what happens when there are more than one validation failure in\nthe data.\nJoe By default, Ajv catches only one validation error.\nTIP By default, Ajv catches only the first validation failure.\nTheo I guess that’s for performance reasons. Once the validator encounters an\nerror, it doesn’t continue the data parsing.\nJoe Probably. Anyway, in order to catch more than one validation failure, you need\nto pass the allErrors options to the Ajv constructor. Check out this code.\nListing7.23 Catching multiple validation failures\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n--- Page 188 ---\n160 CHAPTER 7 Basic data validation\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nA request with\nthree failures\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [1, 2]\n}; Instantiates the Ajv constructor\nwith allErrors: true in order to\ncatch more than one failure\nvar ajv = new Ajv({allErrors: true});\najv.validate(searchBooksRequestSchema,\ninvalidSearchBooksRequest); Converts the\nerrors to a human\nreadable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title',\n// → data/fields/0 must be string,\n// → data/fields/1 must be string\"\nJoe We validate a search request with myTitle instead of title and numbers\ninstead of strings in the fields array. As you can see in the output of the code\nsnippet, three errors are returned.\nTheo Great! I think I have all that I need in order to add data validation to the\nboundaries of my system when Nancy asks me to make the Library Manage-\nment System into a web server.\nJoe Would you allow me to give you a small gift as a token of our friendship?\nTheo I’d be honored.\nJoe takes a small package out of his bag, wrapped in a light-green ribbon. He hands Theo\nthe package with a solemn gesture.\nWhen Theo undoes the ribbon, he discovers an elegant piece of paper decorated with\npretty little designs. In the center of the paper, Theo manages to read the inscription\n“JSON Schema cheat sheet.” He smiles while browsing the cheat sheet. It’s exactly what he\nneeds.\nListing7.24 JSON Schema cheat sheet\n{ At the root level,\ndata is an array.\n\"type\": \"array\",\n\"items\": { Each element of the\narray is a map.\n\"type\": \"object\",\nmyNumber \"properties\": {\nThe properties of\nis a number. \"myNumber\": {\"type\": \"number\"},\neach field in the map\n\"myString\": {\"type\": \"string\"},\nmyString is\n\"myEnum\": {\"enum\": [\"myVal\", \"yourVal\"]},\na string. myEnum is a\n\"myBool\": {\"type\": \"boolean\"}\nenumeration\nmyBool is a }, value with two\nboolean. \"required\": [\"myNumber\", \"myString\"], possibilities:\nThe mandatory fields in the map \"myVal\" and\nare myNumber and myString; \"yourVal\".\nother fields are optional.\n--- Page 189 ---\nSummary 161\n\"additionalProperties\": false\nWe don’t allow fields that\n}\nare not explicitly mentioned\n}\nin the schema.\nThen, Theo turns the paper over to find that the back is also filled with drawings. In the\ncenter of the paper, he reads the inscription, “An example of valid data.”\nListing7.25 An example of valid data\n[\n{\nThis map is valid\n\"myNumber\": 42,\nbecause all its\n\"myString\": \"Hello\",\nfields are valid.\n\"myEnum\": \"myVal\",\n\"myBool\": true\n},\n{\nThis map is valid\n\"myNumber\": 54,\nbecause it contains all\n\"myString\": \"Happy\"\nthe required fields.\n}\n]\nSummary\n DOP Principle #4 is to separate data schema and data representation.\n The boundaries of a system are defined to be the areas where the system\nexchanges data.\n Some examples of data validation at the boundaries of the system are validation\nof client requests and responses, and validation of data that comes from exter-\nnal sources.\n Data validation in DOP means checking whether a piece of data conforms to a\nschema.\n When a piece of data is not valid, we get information about the validation fail-\nures and send this information back to the client in a human readable format.\n When data at system boundaries is valid, it’s not critical to validate data again\ninside the system.\n JSON Schema is a language that allows us to separate data validation from data\nrepresentation.\n JSON Schema syntax is a bit verbose.\n The expressive power of JSON Schema is high.\n JSON Schemas are just maps and, as so, we are free to manipulate them like any\nother maps in our programs.\n We can store a schema definition in a variable and use this variable in another\nschema.\n In JSON Schema, map fields are optional by default.\n It’s good practice to validate data that comes from an external data source.\n--- Page 190 ---\n162 CHAPTER 7 Basic data validation\n It’s good practice to be strict regarding data that you send and to be flexible\nregarding data that you receive.\n Ajv is a JSON Schema library in JavaScript.\n By default, Ajv catches only the first validation failure.\n Advanced validation is covered in chapter 12.\n--- Page 191 ---\nAdvanced\nconcurrency control\nNo more deadlocks!\nThis chapter covers\n Atoms as an alternative to locks\n Managing a thread-safe counter and a thread-safe\nin-memory cache with atoms\n Managing the whole system state in a thread-safe\nway with atoms\nThe traditional way to manage concurrency in a multi-threaded environment\ninvolves lock mechanisms like mutexes. Lock mechanisms tend to increase the com-\nplexity of the system because it’s not trivial to make sure the system is free of dead-\nlocks. In DOP, we leverage the fact that data is immutable, and we use a lock-free\nmechanism, called an atom, to manage concurrency. Atoms are simpler to manage\nthan locks because they are lock-free. As a consequence, the usual complexity of\nlocks that are required to avoid deadlocks don’t apply to atoms.\n NOTE This chapter is mostly relevant to multi-threaded environments like Java,\nC#, Python, and Ruby. It is less relevant to single-threaded environments like Java-\nScript. The JavaScript code snippets in this chapter are written as though JavaScript\nwere multi-threaded.\n163\n--- Page 192 ---\n164 CHAPTER 8 Advanced concurrency control\n8.1 The complexity of locks\nThis Sunday afternoon, while riding his bike across the Golden Gate Bridge, Theo thinks\nabout the Klafim project with concern, not yet sure that betting on DOP was a good\nchoice. Suddenly, Theo realizes that he hasn’t yet scheduled the next session with Joe. He\ngets off his bike to call Joe. Bad luck, the line is busy.\nWhen Theo gets home, he tries to call Joe again, but once again the phone is busy. After\ndinner, Theo tries to call Joe one more time, with the same result—a busy signal. “Obvi-\nously, Joe is very busy today,” Theo tells himself. Exhausted by his 50-mile bike ride at an\naverage of 17 miles per hour, he falls asleep on the sofa. When Theo wakes up, he’s elated\nto see a text message from Joe, “See you Monday morning at 11 AM?” Theo answers with a\nthumbs up and prepares for another week of work.\nWhen Joe arrives at the office, Theo asks him why his phone was constantly busy the day\nbefore. Joe answers that he was about to ask Theo the same question. They look at each\nother, puzzled, and then simultaneously break into laughter as they realize what hap-\npened: in an amazing coincidence, they’d tried to phone each other at exactly the same\ntimes. They both say at once:\n“A deadlock!”\nThey both head for Theo’s office. When they get to Theo’s desk, Joe tells him that today’s\nsession is going to be about concurrency management in multi-threaded environments.\nJoe How do you usually manage concurrency in a multi-threaded environment?\nTheo I protect access to critical sections with a lock mechanism, a mutex, for instance.\nJoe When you say access, do you mean write access or also read access?\nTheo Both!\nJoe Why do you need to protect read access with a lock?\nTheo Because, without a lock protection, in the middle of a read, a write could hap-\npen in another thread. It would make my read logically inconsistent.\nJoe Another option would be to clone the data before processing it in a read.\nTheo Sometimes I would clone the data; but in many cases, when it’s large, it’s too\nexpensive to clone.\nTIP Cloning data to avoid read locks doesn’t scale.\nJoe In DOP, we don’t need to clone or to protect read access.\nTheo Because data is immutable?\nJoe Right. When data is immutable, even if a write happens in another thread\nduring a read, it won’t make the read inconsistent because the write never\nmutates the data that is read.\nTheo In a sense, a read always works on a data snapshot.\nJoe Exactly!\nTIP When data is immutable, a read is always safe.\nTheo But what about write access? Don’t you need to protect that with locks?\nJoe Nope.\n--- Page 193 ---\n8.2 Thread-safe counter with atoms 165\nTheo Why not?\nJoe We have a simpler mechanism—it’s called an atom.\nTheo I am glad to hear there is a something simpler than locks. I really struggle each\ntime I have to integrate locks into a multi-threaded system.\nJoe Me too! I remember a bug we had in production 10 years ago. We forgot to\nrelease a lock when an exception was thrown in a critical section. It caused a\nterrible deadlock.\nTheo Deadlocks are really hard to avoid. Last year, we had a deadlock issue when two\nlocks were not released in the proper order.\nJoe I have great news for you. With atoms, deadlocks never happen!\nTIP With atoms, deadlocks never happen.\nTheo That sounds great. Tell me more!\nTIP Atoms provide a way to manage concurrency without locks.\n8.2 Thread-safe counter with atoms\nJoe Let’s start with a simple case: a counter shared between threads.\nTheo What do you mean by a counter?\nJoe Imagine that we’d like to count the number of database accesses and write the\ntotal number of accesses to a log every minute.\nTheo OK.\nJoe Could you write JavaScript code for this multi-threaded counter using locks?\nTheo But JavaScript is single-threaded!\nJoe I know, but it’s just for the sake of illustration. Imagine that JavaScript were\nmulti-threaded and that it provided a Mutex object that you could lock and\nunlock.\nTheo It’s a bit awkward. I guess it would look like this.\nTheo goes to the whiteboard. He writes what he imagines to be JavaScript code for a multi-\nthreaded counter with locks.\nListing8.1 A thread-safe counter protected by a mutex\nvar mutex = new Mutex();\nvar counter = 0;\nfunction dbAccess() {\nmutex.lock();\ncounter = counter + 1;\nmutex.unlock();\n// access the database\n}\nfunction logCounter() {\nmutex.lock();\n--- Page 194 ---\n166 CHAPTER 8 Advanced concurrency control\nconsole.log('Number of database accesses: ' + counter);\nmutex.unlock();\n}\nJoe Excellent. Now, I am going to show you how to write the same code with atoms.\nAn atom provides three methods:\n get returns the current value of the atom.\n set overwrites the current value of the atom.\n swap receives a function and updates the value of the atom with the result\nof the function called on the current value of the atom.\nJoe unzips a pocket in his laptop case and takes out a piece of paper. He hands it to\nTheo. Theo is pleasantly surprised as the sheet of paper succinctly describes the methods\n(table 8.1).\nTable 8.1 The three methods of an atom\nMethod Description\nget Returns the current value\nset Overwrites the current value\nswap Updates the current value with a function\nTheo How would it look like to implement a thread-safe counter with an atom?\nJoe It’s quite simple, actually.\nJoe pulls out his laptop, fires it up, and begins to type. When he’s done, he turns the laptop\naround so that Theo can see the code to implement a thread-safe counter in an atom.\nListing8.2 A thread-safe counter stored in an atom\nvar counter = new Atom();\ncounter.set(0);\nfunction dbAccess() {\ncounter.swap(function(x) {\nThe argument x is the\nreturn x + 1;\ncurrent value of the atom,\n});\nsame as counter.get().\n// access the database\n}\nfunction logCounter() {\nconsole.log('Number of database accesses: ' + counter.get());\n}\nTheo Could you tell me what’s going on here?\nJoe Sure! First, we create an empty atom. Then, we initialize the value of the atom\nwith counter.set(0). In the logger thread, we read the current value of the\natom with counter.get().\nTheo And how do you increment the counter in the threads that access the database?\n--- Page 195 ---\n8.2 Thread-safe counter with atoms 167\nJoe We call swap with a function that receives x and returns x + 1.\nTheo I don’t understand how swap could be thread-safe without using any locks.\nJoe quickly goes to the whiteboard. He sketches the diagram in figure 8.1.\nTake snapshot\nCompute next state\nYes\nState changed?\nNo\nUpdate state\nFigure 8.1 High-level flow of swap\nJoe You see, swap computes the next value of the atom, and before modifying the\ncurrent value of the atom, it checks whether the value of the atom has changed\nduring the computation. If so, swap tries again, until no changes occur during\nthe computation.\nTheo Is swap easy to implement?\nJoe Let me show you the implementation of the Atom class and you’ll see.\nListing8.3 Implementation of the Atom class\nclass Atom {\nstate;\nconstructor() {}\nget() {\nreturn this.state;\n}\nset(state) {\nthis.state = state;\n}\nswap(f) {\nwhile(true) {\nvar stateSnapshot = this.state;\nvar nextState = f(stateSnapshot);\nif (!atomicCompareAndSet(this.state,\n--- Page 196 ---\n168 CHAPTER 8 Advanced concurrency control\nstateSnapshot,\nnextState)) {\nUses a special thread-safe comparison operation\ncontinue;\nas this.state might have changed in another\n}\nthread during execution of the function f.\nreturn nextState;\n}\n}\n}\nTheo comes closer to the whiteboard. He modifies Joe’s diagram a bit to make the flow of\nthe swap operation more detailed. The resulting diagram is in figure 8.2. Theo still has a\nfew questions, though.\nTake snapshot\nsnapshot = state\nCompute next state\nnextState = f(snapshot)\nCheck if state has changed\nstate == snapshot\nYes\nState changed?\nNo\nUpdate state\nstate = nextState\nFigure 8.2 Detailed flow of swap\nTheo What is atomicCompareAndSet?\nJoe It’s the core operation of an atom. atomicCompareAndSet atomically sets the\nstate to a new value if, and only if, the state equals the provided old value. It\nreturns true upon success and false upon failure.\nTheo How could it be atomic without using locks?\nJoe That’s a great question! In fact, atomicCompareAndSet is a compare-and-swap\noperation, provided by the language that relies on a functionality of the CPU\nitself. For example, in Java the java.util.concurrent.atomic package has\nan AtomicReference generic class that provides a compareAndSet() method.\n NOTE See http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html\nfor general information about compare-and-swap operations. Implementations for\nmulti-threaded languages appear in table 8.2.\n--- Page 197 ---\n8.2 Thread-safe counter with atoms 169\nTable 8.2 Implementation of an atomic compare and set in various languages\nLanguage Link\nJava http://mng.bz/mx0W\nJavaScript Not relevant (single-threaded language)\nRuby http://mng.bz/5KG8\nPython https://github.com/maxcountryman/atomos\nC# http://mng.bz/6Zzp\nTheo Apropos Java, how would the implementation of an atom look?\nJoe It’s quite the same, besides the fact that Atom has to use generics, and the inner\nstate has to be stored in an AtomicReference.\nJoe brings up a Java implementation of Atom on his laptop. Theo looks over the code.\nListing8.4 Implementation of the Atom class in Java\nclass Atom<ValueType> {\nprivate AtomicReference<ValueType> state;\npublic Atom() {}\nValueType get() {\nreturn this.state.get();\n}\nthis.state might have\nchanged in another thread\nvoid set(ValueType state) {\nduring the execution of f.\nthis.state.set(state);\n}\nValueType swap(UnaryOPerator<ValueType> f) {\nwhile(true) {\nValueType stateSnapshot = this.state.get();\nValueType nextState = f(stateSnapshot);\nif (!this.state.compareAndSet(stateSnapshot,\nnextState)) {\ncontinue;\n}\n}\nreturn nextState;\n}\n}\nTheo What about using an atom in Java?\nJoe Here, take a look. It’s quite simple.\n--- Page 198 ---\n170 CHAPTER 8 Advanced concurrency control\nListing8.5 Using an Atom in Java\nAtom<Integer> counter = new Atom<Integer>();\ncounter.set(0);\ncounter.swap(x -> x + 1);\ncounter.get();\nTheo takes a couple of minutes to meditate about this atom stuff and to digest what he’s\njust learned. Then, he asks Joe:\nTheo What if swap never succeeds? I mean, could the while loop inside the code of\nswap turn out to be an infinite loop?\nJoe No! By definition, when atomicCompareAndSet fails on a thread, it means that\nthe same atom was changed on another thread during the execution of swap.\nIn this race between threads, there is always a winner.\nTheo But isn’t it possible that some thread never succeeds because it always loses the\nrace against other threads?\nJoe In theory, yes, but I’ve never encountered such a situation. If you have thou-\nsands of threads that do nothing besides swapping an atom, it could happen I\nsuppose. But, in practice, once the atom is swapped, the threads do some real\nwork, for example, database access or I/O. This gives other threads the oppor-\ntunity to swap the atom successfully.\n NOTE In theory, atoms could create starvation in a system with thousands of threads\nthat do nothing beside swapping an atom. In practice, once an atom is swapped, the\nthreads do some real work (e.g., database access), which creates an opportunity for\nother threads to swap the atom successfully.\nTheo Interesting.... Indeed, atoms look much easier to manage than locks.\nJoe Now let me show you how to use atoms with composite data.\nTheo Why would that be different?\nJoe Usually, dealing with composite data is more difficult than dealing with primi-\ntive types.\nTheo When you sold me on DOP, you told me that we are able to manage data with\nthe same simplicity as we manage numbers.\nTIP In DOP, data is managed with the same simplicity as numbers.\nJoe That’s exactly what I am about to show you.\n8.3 Thread-safe cache with atoms\nJoe Are you familiar with the notion of in-memory cache?\nTheo You mean memoization?\n--- Page 199 ---\n8.3 Thread-safe cache with atoms 171\nJoe Kind of. Imagine that database queries don’t vary too much in your applica-\ntion. It makes sense in that case to store the results of previous queries in mem-\nory in order to improve the response time.\nTheo Yes, of course!\nJoe What data structure would you use to store the in-memory cache?\nTheo Probably a string map, where the keys are the queries, and the values are the\nresults from the database.\nTIP It’s quite common to represent an in-memory cache as a string map.\nJoe Excellent! Now can you write the code to cache database queries in a thread-\nsafe way using a lock?\nTheo Let me see: I’m going to use an immutable string map. Therefore, I don’t\nneed to protect read access with a lock. Only the cache update needs to be\nprotected.\nJoe You’re getting the hang of this!\nTheo The code should be something like this.\nListing8.6 Thread-safe cache with locks\nvar mutex = new Mutex();\nvar cache = {};\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache, query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\nmutex.lock();\ncache = _.set(cache, query, result);\nmutex.unlock();\nreturn result;\n}\nJoe Nice! Now, let me show you how to write the same code using an atom instead\nof a lock. Take a look at this code and let me know if it’s clear to you.\nListing8.7 Thread-safe cache with atoms\nvar cache = new Atom();\ncache.set({});\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache.get(), query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\ncache.swap(function(oldCache) {\n--- Page 200 ---\n172 CHAPTER 8 Advanced concurrency control\nreturn _.set(oldCache, query, result);\n});\nreturn result;\n}\nTheo I don’t understand the function you’re passing to the swap method.\nJoe The function passed to swap receives the current value of the cache, which is a\nstring map, and returns a new version of the string map with an additional key-\nvalue pair.\nTheo I see. But something bothers me with the performance of the swap method in\nthe case of a string map. How does the comparison work? I mean, comparing\ntwo string maps might take some time.\nJoe Not if you compare them by reference. As we discussed in the past, when data\nis immutable, it is safe to compare by reference, and it’s super fast.\nTIP When data is immutable, it is safe (and fast) to compare it by reference.\nTheo Cool. So atoms play well with immutable data.\nJoe Exactly!\n8.4 State management with atoms\nJoe Do you remember a couple of weeks ago when I showed you how we resolve\npotential conflicts between mutations? You told me that the code was not\nthread-safe.\nTheo Let me look again at the code.\nTheo takes a look at the code for the SystemData class that he wrote some time ago\n(repeated in listing 8.8). Without the validation logic, it makes the code easier to grasp.\nListing8.8 SystemData class from part 1\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nthis.systemData = SystemConsistency.reconcile(this.systemData,\nprevious,\nnext);\n}\n}\n--- Page 201 ---\n8.4 State management with atoms 173\nIt takes him a few minutes to remember how the commit method works. Suddenly, he has\nan Aha! moment.\nTheo This code is not thread-safe because the SystemConsistency.reconcile\ncode inside the commit method is not protected. Nothing prevents the two\nthreads from executing this code concurrently.\nJoe Right! Now, can you tell me how to make it thread-safe?\nTheo With locks?\nJoe Come on...\nTheo I was kidding, of course. We make the code thread-safe not with a lock but with\nan atom.\nJoe Nice joke!\nTheo Let me see. I’d need to store the system data inside an atom. The get and set\nmethod of SystemData would simply call the get and set methods of the\natom. How does this look?\nListing8.9 SystemData class with atom (without the commit method)\nclass SystemState {\nsystemData;\nconstructor() {\nthis.systemData = new Atom();\n}\nget() {\nreturn this.systemData.get();\n}\ncommit(prev, next) {\nthis.systemData.set(next);\n}\n}\nJoe Excellent. Now for the fun part. Implement the commit method by calling the\nswap method of the atom.\nTheo Instead of calling SystemConsistency.reconcile() directly, I need to wrap\nit into a call to swap. So, something like this?\nListing8.10 Implementation of SystemData.commit with atom\nSystemData.commit = function(previous, next) {\nthis.systemData.swap(function(current) {\nreturn SystemConsistency.reconcile(current,\nprevious,\nnext);\n});\n};",
        "sections_found": []
      },
      "accurate_page_range": "176-201"
    },
    {
      "text": "- 7.5 Details about data validation failures",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "raw_line": "- 7.5 Details about data validation failures (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 62,
      "chapter_info": {
        "page": 176,
        "title": "Basic data validation",
        "pattern_matched": "Chapter 7",
        "text_preview": "148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema"
      },
      "chapter_sections": {
        "start_page": 176,
        "end_page": 201,
        "content": "\n--- Page 176 ---\n148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema from listing 7.6.\nListing7.7 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe Give it a try, and you’ll see.\nIndeed! When Theo executes the code to validate the search request, it returns true.\nListing7.8 Validating the search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksRequest = {\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nvalidate(searchBooksRequestSchema, searchBooksRequest);\n// → true\nJoe Now, please try an invalid request.\nTheo Let me think about what kind of invalidity to try. I know, I’ll make a typo in the\ntitle field and call it tilte with the l before the t.\nAs expected, the code with the type returns false. Theo is not surprised, and Joe is smil-\ning from ear to ear.\nListing7.9 Validating an invalid search request\nvar invalidSearchBooksRequest = {\n\"tilte\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\n--- Page 177 ---\n7.3 Schema flexibility and strictness 149\nvalidate(searchBooksRequestSchema, invalidSearchBooksRequest);\n// → false\nTheo The syntax of JSON Schema is much more verbose than the syntax for declar-\ning the members in a class. Why is that so?\nJoe For two reasons. First, because JSON Schema is language independent, it can\nbe used in any programming language. As I told you, there are JSON Schema\nvalidators available in most programming languages.\nTheo I see.\nJoe Second, JSON Schema allows you to express validation conditions that are much\nharder, if not impossible, to express when data is represented with classes.\nTIP The expressive power of JSON Schema is high!\nTheo Now you have triggered my curiosity. Can you give me some examples?\nJoe In a moment, we’ll talk about schema composition. Someday I’ll show you\nsome examples of advanced validation.\n NOTE Advanced validation is covered in chapter 12.\nTheo What kind of advanced validation?\nJoe What I mean by advanced validation is, for instance, validating that a number\nfalls within a given range or validating that a string matches a regular expression.\nTheo Is there a way to get details about why the request is invalid?\nJoe Absolutely! I’ll show you later. For now, let me show you how to make sure the\nresponse the server sends back to the client is valid.\nTheo It sounds much more complicated than a search book request!\nJoe Why?\nTheo Because a search response is made of multiple book results, and in each book\nresult, some of the fields are optional!\n7.3 Schema flexibility and strictness\nJoe Can you give me an example of what a book search response would look like?\nTheo Take a look at this example. It’s a search response with information about two\nbooks: 7 Habits of Highly Effective People and The Power of Habit.\nListing7.10 An example of a search response\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432\n},\n--- Page 178 ---\n150 CHAPTER 7 Basic data validation\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn_13\": \"978-1982137274\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n]\n}\n]\nJoe It’s funny that you mention The Power of Habit. I’m reading this book in order\nto get rid of my habit of biting my nails. Anyway, what fields are required and\nwhat fields are optional in a book search response?\nTheo In book information, the title and available fields are required. The other\nfields are optional.\nJoe As I told you when we built the schema for the book search request, fields in a\nmap are optional by default. In order to make a field mandatory, we have to\ninclude it in the required array. I’d probably implement it with something\nlike this.\nListing7.11 Schema of a search response\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, map fields are optional by default.\nTheo I must admit that specifying a list of required fields is much simpler than hav-\ning to specify that a member in a class in nullable!\nJoe Agreed!\nTheo On the other hand, I find the nesting of the book information schema in the\nsearch response schema a bit hard to read.\n--- Page 179 ---\n7.3 Schema flexibility and strictness 151\nJoe Nothing prevents you from separating the book information schema from the\nsearch response schema.\nTheo How?\nJoe It’s just JSON, my friend. It means, you are free to manipulate the schema as\nany other map in your program. For instance, you could have the book infor-\nmation schema in a variable named bookInfoSchema and use it in the search\nbooks response schema. Let me refactor the schema to show you what I mean.\nListing7.12 Schema of a search response refactored\nvar bookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n};\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": bookInfoSchema\n};\nTheo Once again, I have to admit that JSON Schemas are more composable than\nclass definitions.\nTIP JSON Schemas are just maps. We are free to compose and manipulate them like\nany other map.\nJoe Let’s move on to validating data received from external data sources.\nTheo Is that different?\nJoe Not really, but I’ll take it as an opportunity to show you some other features of\nJSON Schema.\nTheo I’m curious to learn how data validation is used when we access data from the\ndatabase.\nJoe Each time we access data from the outside, it’s a good practice to validate it.\nCan you show me an example of how a database response for a search query\nwould look?\nTIP It’s a good practice to validate data that comes from an external data source.\n--- Page 180 ---\n152 CHAPTER 7 Basic data validation\nTheo When we query books from the database, we expect to receive an array of\nbooks with three fields: title, isbn, and available. The first two values should\nbe strings, and the third one should be a Boolean.\nJoe Are those fields optional or required?\nTheo What do you mean?\nJoe Could there be books for which some of the fields are not defined?\nTheo No.\nJoe In that case, the schema is quite simple. Would you like to try writing the\nschema for the database response?\nTheo Let me see. It’s an array of objects where each object has three properties, so\nsomething like this?\nListing7.13 Schema of a database response\n{\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n}\nJoe Well done, my friend! Now, I want to tell you about the additionalProperties\nfield in JSON Schema.\nTheo What’s that?\nJoe Take a look at this array.\nListing7.14 A book array with an additional property\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"dummy_property\": 42\n},\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn\": \"978-1982137274\",\n\"dummy_property\": 45\n}\n]\n--- Page 181 ---\n7.3 Schema flexibility and strictness 153\nJoe Is it a valid database response?\nTheo No. A database response should not have a dummy_property field. It should\nhave only the three required fields specified in the schema.\nJoe It might be surprising but, by default, fields not specified in the schema of an\nobject are allowed in JSON Schema. In order to disallow them, one has to set\nadditionalProperties to false like this.\nListing7.15 Disallowing properties not mentioned in the schema\nvar booksFromDBSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"additionalProperties\": false,\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, by default, fields not specified in the schema of a map are\nallowed.\nTheo Why is that?\nJoe The reason is that usually having additional fields in a map doesn’t cause\ntrouble. If your code doesn’t care about a field, it simply ignores it. But some-\ntimes we want to be as strict as possible, and we set additionalProperties\nto false.\nTheo What about the search request and response schema from the previous discus-\nsions? Should we set additionalProperties to false?\nJoe That’s an excellent question. I’d say it’s a matter of taste. Personally, I like to\nallow additional fields in requests and disallow them in responses.\nTheo What’s the advantage?\nJoe Well, the web server is responsible for the responses it sends to its clients. It\nmakes sense then to be as strict as possible. However, the requests are created\nby the clients, and I prefer to do my best to serve my clients even when they are\nnot as strict as they should be.\nTheo Naturally. “The client is always right.”\nJoe Actually, I prefer the way Jon Postel formulated his robustness principle: “Be\nconservative in what you send, be liberal in what you accept.”\nTIP It’s a good practice to be strict with the data that you send and to be flexible with\nthe data that you receive.\n--- Page 182 ---\n154 CHAPTER 7 Basic data validation\n7.4 Schema composition\nTheo What about validating data that comes from an external web service?\nJoe Can you give me an example?\nTheo In the near future, we’ll have to integrate with a service called Open Library\nBooks API that provides detailed information about books.\n NOTE For information on the Open Library Books API, see https://openlibrary\n.org/dev/docs/api/books.\nJoe Can you show me, for instance, the service response for Watchmen?\nTheo Sure. Here you go.\nTheo taps a few keys on his keyboard and brings up the response. Joe looks at the JSON for\na long time.\nListing7.16 An Open Library Books API response example\n{\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n}\nTheo asks himself, “What could be so special in this JSON?” While Joe is meditating about\nthis piece of JSON, Theo writes the JSON Schema for the Books API response. It doesn’t\nseem to be more complicated than any of the previous schemas. When Theo is done, he\nasks Joe to take a look at the schema.\nListing7.17 Schema of the Open Library Books API response\n{\n\"type\": \"object\",\n\"required\": [\"title\"],\n--- Page 183 ---\n7.4 Schema composition 155\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n}\nJoe Good job!\nTheo That wasn’t so hard. I really don’t see why you looked at this JSON response for\nsuch a long time.\nJoe Well, it has to do with the isbn_10 and isbn_13 fields. I assume that they’re\nnot both mandatory.\nTheo Right! That’s why I didn’t include them in the required field of my schema.\nJoe But one of them should always be there. Right?\nTheo Sometimes one of them and sometimes both of them, like for Watchmen. It\ndepends on the publication year of the book. Books published before 2007\nhave isbn_10, and books published after 2007 have isbn_13.\nJoe Oh, I see. And Watchmen has both because it was originally published in 1986\nbut published again after 2007.\nTheo Correct.\nJoe Then, you need your schema to indicate that one of the isbn fields is man-\ndatory. That’s a good opportunity for me to tell you about JSON Schema\ncomposition.\nTheo What’s that?\nJoe It’s a way to combine schemas, similarly to how we combine logical conditions\nwith AND, OR, and NOT.\nTheo I’d like to see that.\nJoe Sure. How would you express the schema for the Books API response as a\ncomposition of three schemas: basicBookInfoSchema, the schema that you\nwrote where only title is required; mandatoryIsbn13, a schema where only\n--- Page 184 ---\n156 CHAPTER 7 Basic data validation\nisbn_13 is required; and mandatoryIsb10, a schema where only isbn_10 is\nrequired?\nTheo I think it should be basicBookInfoSchema AND (mandatoryIsbn13 OR\nmandatoryIsbn10).\nJoe Exactly! The only thing is that in JSON Schema, we use allOf instead of AND,\nand anyOf instead of OR.\nJoe shows Theo the result in listing 7.18 and an example of its usage in listing 7.19.\nListing7.18 Schema of an external API response\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n--- Page 185 ---\n7.4 Schema composition 157\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing7.19 Validating an external API response\nvar bookInfo = {\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n};\nvalidate(bookInfoSchema, bookInfo);\n// → true\nTheo I see why they call it allOf and anyOf. The first one means that data must con-\nform to all the schemas, and the second one means that data must conform to\nany of the schemas.\nJoe Yup.\n NOTE JSON Schema also supports oneOf for cases where data must be valid against\nexactly one schema.\nTheo Nice. With schema composition, JSON Schema seems to have more expressive\npower than what I was used to when representing data with classes.\nJoe That’s only the beginning. I’ll show you more data validation conditions that\ncan’t be expressed when data is represented with classes some other time.\n NOTE Advanced data validation is covered in chapter 12.\nTheo Something still bothers me, though. When data isn’t valid, you don’t know what\nwent wrong.\n--- Page 186 ---\n158 CHAPTER 7 Basic data validation\n7.5 Details about data validation failures\nJoe So far, we’ve treated JSON Schema validation as though it were binary: either a\npiece of data is valid or it isn’t.\nTheo Right...\nJoe But, in fact, when a piece of data is not valid, we can get details about the\nreason of the invalidity.\nTheo Like when a required field is missing, can we get the name of the missing field?\nJoe Yes. When a piece of data is not of the expected type, we can get information\nabout that also.\nTheo That sounds very useful!\nJoe Indeed. Let me show you how it works. Until now, we used a generic validate\nfunction, but when we deal with validation failures, we need to be more specific.\nTheo Why?\nJoe Because each data validator library has its own way of exposing the details of\nadata validation failure. For instance, in JavaScript Ajv, the errors from the\nlast data validation are stored as an array inside the validator instance.\nTheo Why an array?\nJoe Because there could be several failures. But let’s start with the case of a single\nfailure. Imagine we encounter a search book request where the title field is\nnamed myTitle instead of title. Take a look at this example. As you can see,\nwe first instantiate a validator instance.\nListing7.20 Accessing validation errors in Ajv\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nInstantiates a\nvar ajv = new Ajv(); validator instance\najv.validate(searchBooksRequestSchema, invalidSearchBooksRequest);\najv.errors\nDisplays the\nvalidation errors\n--- Page 187 ---\n7.5 Details about data validation failures 159\nTheo And what does the information inside the errors array look like?\nJoe Execute the code snippet. You’ll see.\nWhen Theo executes the code snippets from listing 7.20, he can hardly believe his eyes. He\nlooks at the details, finding the results hard to digest.\nListing7.21 Details for a single data validation failure in an array format\n[\n{\n\"instancePath\": \"\",\n\"schemaPath\": \"#/required\",\n\"keyword\": \"required\",\n\"params\": {\n\"missingProperty\":\"title\"\n},\n\"message\": \"must have required property 'title'\"\n}\n]\nTheo I find the contents of the errors array a bit hard to understand.\nJoe Me too. Fortunately, Ajv provides a errorsText utility function to convert the\nerrors array in a human readable format. See, for instance, what is returned\nwhen you call errorsText.\nListing7.22 Displaying the errors in human readable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title'\"\nTheo Let me see what happens when there are more than one validation failure in\nthe data.\nJoe By default, Ajv catches only one validation error.\nTIP By default, Ajv catches only the first validation failure.\nTheo I guess that’s for performance reasons. Once the validator encounters an\nerror, it doesn’t continue the data parsing.\nJoe Probably. Anyway, in order to catch more than one validation failure, you need\nto pass the allErrors options to the Ajv constructor. Check out this code.\nListing7.23 Catching multiple validation failures\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n--- Page 188 ---\n160 CHAPTER 7 Basic data validation\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nA request with\nthree failures\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [1, 2]\n}; Instantiates the Ajv constructor\nwith allErrors: true in order to\ncatch more than one failure\nvar ajv = new Ajv({allErrors: true});\najv.validate(searchBooksRequestSchema,\ninvalidSearchBooksRequest); Converts the\nerrors to a human\nreadable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title',\n// → data/fields/0 must be string,\n// → data/fields/1 must be string\"\nJoe We validate a search request with myTitle instead of title and numbers\ninstead of strings in the fields array. As you can see in the output of the code\nsnippet, three errors are returned.\nTheo Great! I think I have all that I need in order to add data validation to the\nboundaries of my system when Nancy asks me to make the Library Manage-\nment System into a web server.\nJoe Would you allow me to give you a small gift as a token of our friendship?\nTheo I’d be honored.\nJoe takes a small package out of his bag, wrapped in a light-green ribbon. He hands Theo\nthe package with a solemn gesture.\nWhen Theo undoes the ribbon, he discovers an elegant piece of paper decorated with\npretty little designs. In the center of the paper, Theo manages to read the inscription\n“JSON Schema cheat sheet.” He smiles while browsing the cheat sheet. It’s exactly what he\nneeds.\nListing7.24 JSON Schema cheat sheet\n{ At the root level,\ndata is an array.\n\"type\": \"array\",\n\"items\": { Each element of the\narray is a map.\n\"type\": \"object\",\nmyNumber \"properties\": {\nThe properties of\nis a number. \"myNumber\": {\"type\": \"number\"},\neach field in the map\n\"myString\": {\"type\": \"string\"},\nmyString is\n\"myEnum\": {\"enum\": [\"myVal\", \"yourVal\"]},\na string. myEnum is a\n\"myBool\": {\"type\": \"boolean\"}\nenumeration\nmyBool is a }, value with two\nboolean. \"required\": [\"myNumber\", \"myString\"], possibilities:\nThe mandatory fields in the map \"myVal\" and\nare myNumber and myString; \"yourVal\".\nother fields are optional.\n--- Page 189 ---\nSummary 161\n\"additionalProperties\": false\nWe don’t allow fields that\n}\nare not explicitly mentioned\n}\nin the schema.\nThen, Theo turns the paper over to find that the back is also filled with drawings. In the\ncenter of the paper, he reads the inscription, “An example of valid data.”\nListing7.25 An example of valid data\n[\n{\nThis map is valid\n\"myNumber\": 42,\nbecause all its\n\"myString\": \"Hello\",\nfields are valid.\n\"myEnum\": \"myVal\",\n\"myBool\": true\n},\n{\nThis map is valid\n\"myNumber\": 54,\nbecause it contains all\n\"myString\": \"Happy\"\nthe required fields.\n}\n]\nSummary\n DOP Principle #4 is to separate data schema and data representation.\n The boundaries of a system are defined to be the areas where the system\nexchanges data.\n Some examples of data validation at the boundaries of the system are validation\nof client requests and responses, and validation of data that comes from exter-\nnal sources.\n Data validation in DOP means checking whether a piece of data conforms to a\nschema.\n When a piece of data is not valid, we get information about the validation fail-\nures and send this information back to the client in a human readable format.\n When data at system boundaries is valid, it’s not critical to validate data again\ninside the system.\n JSON Schema is a language that allows us to separate data validation from data\nrepresentation.\n JSON Schema syntax is a bit verbose.\n The expressive power of JSON Schema is high.\n JSON Schemas are just maps and, as so, we are free to manipulate them like any\nother maps in our programs.\n We can store a schema definition in a variable and use this variable in another\nschema.\n In JSON Schema, map fields are optional by default.\n It’s good practice to validate data that comes from an external data source.\n--- Page 190 ---\n162 CHAPTER 7 Basic data validation\n It’s good practice to be strict regarding data that you send and to be flexible\nregarding data that you receive.\n Ajv is a JSON Schema library in JavaScript.\n By default, Ajv catches only the first validation failure.\n Advanced validation is covered in chapter 12.\n--- Page 191 ---\nAdvanced\nconcurrency control\nNo more deadlocks!\nThis chapter covers\n Atoms as an alternative to locks\n Managing a thread-safe counter and a thread-safe\nin-memory cache with atoms\n Managing the whole system state in a thread-safe\nway with atoms\nThe traditional way to manage concurrency in a multi-threaded environment\ninvolves lock mechanisms like mutexes. Lock mechanisms tend to increase the com-\nplexity of the system because it’s not trivial to make sure the system is free of dead-\nlocks. In DOP, we leverage the fact that data is immutable, and we use a lock-free\nmechanism, called an atom, to manage concurrency. Atoms are simpler to manage\nthan locks because they are lock-free. As a consequence, the usual complexity of\nlocks that are required to avoid deadlocks don’t apply to atoms.\n NOTE This chapter is mostly relevant to multi-threaded environments like Java,\nC#, Python, and Ruby. It is less relevant to single-threaded environments like Java-\nScript. The JavaScript code snippets in this chapter are written as though JavaScript\nwere multi-threaded.\n163\n--- Page 192 ---\n164 CHAPTER 8 Advanced concurrency control\n8.1 The complexity of locks\nThis Sunday afternoon, while riding his bike across the Golden Gate Bridge, Theo thinks\nabout the Klafim project with concern, not yet sure that betting on DOP was a good\nchoice. Suddenly, Theo realizes that he hasn’t yet scheduled the next session with Joe. He\ngets off his bike to call Joe. Bad luck, the line is busy.\nWhen Theo gets home, he tries to call Joe again, but once again the phone is busy. After\ndinner, Theo tries to call Joe one more time, with the same result—a busy signal. “Obvi-\nously, Joe is very busy today,” Theo tells himself. Exhausted by his 50-mile bike ride at an\naverage of 17 miles per hour, he falls asleep on the sofa. When Theo wakes up, he’s elated\nto see a text message from Joe, “See you Monday morning at 11 AM?” Theo answers with a\nthumbs up and prepares for another week of work.\nWhen Joe arrives at the office, Theo asks him why his phone was constantly busy the day\nbefore. Joe answers that he was about to ask Theo the same question. They look at each\nother, puzzled, and then simultaneously break into laughter as they realize what hap-\npened: in an amazing coincidence, they’d tried to phone each other at exactly the same\ntimes. They both say at once:\n“A deadlock!”\nThey both head for Theo’s office. When they get to Theo’s desk, Joe tells him that today’s\nsession is going to be about concurrency management in multi-threaded environments.\nJoe How do you usually manage concurrency in a multi-threaded environment?\nTheo I protect access to critical sections with a lock mechanism, a mutex, for instance.\nJoe When you say access, do you mean write access or also read access?\nTheo Both!\nJoe Why do you need to protect read access with a lock?\nTheo Because, without a lock protection, in the middle of a read, a write could hap-\npen in another thread. It would make my read logically inconsistent.\nJoe Another option would be to clone the data before processing it in a read.\nTheo Sometimes I would clone the data; but in many cases, when it’s large, it’s too\nexpensive to clone.\nTIP Cloning data to avoid read locks doesn’t scale.\nJoe In DOP, we don’t need to clone or to protect read access.\nTheo Because data is immutable?\nJoe Right. When data is immutable, even if a write happens in another thread\nduring a read, it won’t make the read inconsistent because the write never\nmutates the data that is read.\nTheo In a sense, a read always works on a data snapshot.\nJoe Exactly!\nTIP When data is immutable, a read is always safe.\nTheo But what about write access? Don’t you need to protect that with locks?\nJoe Nope.\n--- Page 193 ---\n8.2 Thread-safe counter with atoms 165\nTheo Why not?\nJoe We have a simpler mechanism—it’s called an atom.\nTheo I am glad to hear there is a something simpler than locks. I really struggle each\ntime I have to integrate locks into a multi-threaded system.\nJoe Me too! I remember a bug we had in production 10 years ago. We forgot to\nrelease a lock when an exception was thrown in a critical section. It caused a\nterrible deadlock.\nTheo Deadlocks are really hard to avoid. Last year, we had a deadlock issue when two\nlocks were not released in the proper order.\nJoe I have great news for you. With atoms, deadlocks never happen!\nTIP With atoms, deadlocks never happen.\nTheo That sounds great. Tell me more!\nTIP Atoms provide a way to manage concurrency without locks.\n8.2 Thread-safe counter with atoms\nJoe Let’s start with a simple case: a counter shared between threads.\nTheo What do you mean by a counter?\nJoe Imagine that we’d like to count the number of database accesses and write the\ntotal number of accesses to a log every minute.\nTheo OK.\nJoe Could you write JavaScript code for this multi-threaded counter using locks?\nTheo But JavaScript is single-threaded!\nJoe I know, but it’s just for the sake of illustration. Imagine that JavaScript were\nmulti-threaded and that it provided a Mutex object that you could lock and\nunlock.\nTheo It’s a bit awkward. I guess it would look like this.\nTheo goes to the whiteboard. He writes what he imagines to be JavaScript code for a multi-\nthreaded counter with locks.\nListing8.1 A thread-safe counter protected by a mutex\nvar mutex = new Mutex();\nvar counter = 0;\nfunction dbAccess() {\nmutex.lock();\ncounter = counter + 1;\nmutex.unlock();\n// access the database\n}\nfunction logCounter() {\nmutex.lock();\n--- Page 194 ---\n166 CHAPTER 8 Advanced concurrency control\nconsole.log('Number of database accesses: ' + counter);\nmutex.unlock();\n}\nJoe Excellent. Now, I am going to show you how to write the same code with atoms.\nAn atom provides three methods:\n get returns the current value of the atom.\n set overwrites the current value of the atom.\n swap receives a function and updates the value of the atom with the result\nof the function called on the current value of the atom.\nJoe unzips a pocket in his laptop case and takes out a piece of paper. He hands it to\nTheo. Theo is pleasantly surprised as the sheet of paper succinctly describes the methods\n(table 8.1).\nTable 8.1 The three methods of an atom\nMethod Description\nget Returns the current value\nset Overwrites the current value\nswap Updates the current value with a function\nTheo How would it look like to implement a thread-safe counter with an atom?\nJoe It’s quite simple, actually.\nJoe pulls out his laptop, fires it up, and begins to type. When he’s done, he turns the laptop\naround so that Theo can see the code to implement a thread-safe counter in an atom.\nListing8.2 A thread-safe counter stored in an atom\nvar counter = new Atom();\ncounter.set(0);\nfunction dbAccess() {\ncounter.swap(function(x) {\nThe argument x is the\nreturn x + 1;\ncurrent value of the atom,\n});\nsame as counter.get().\n// access the database\n}\nfunction logCounter() {\nconsole.log('Number of database accesses: ' + counter.get());\n}\nTheo Could you tell me what’s going on here?\nJoe Sure! First, we create an empty atom. Then, we initialize the value of the atom\nwith counter.set(0). In the logger thread, we read the current value of the\natom with counter.get().\nTheo And how do you increment the counter in the threads that access the database?\n--- Page 195 ---\n8.2 Thread-safe counter with atoms 167\nJoe We call swap with a function that receives x and returns x + 1.\nTheo I don’t understand how swap could be thread-safe without using any locks.\nJoe quickly goes to the whiteboard. He sketches the diagram in figure 8.1.\nTake snapshot\nCompute next state\nYes\nState changed?\nNo\nUpdate state\nFigure 8.1 High-level flow of swap\nJoe You see, swap computes the next value of the atom, and before modifying the\ncurrent value of the atom, it checks whether the value of the atom has changed\nduring the computation. If so, swap tries again, until no changes occur during\nthe computation.\nTheo Is swap easy to implement?\nJoe Let me show you the implementation of the Atom class and you’ll see.\nListing8.3 Implementation of the Atom class\nclass Atom {\nstate;\nconstructor() {}\nget() {\nreturn this.state;\n}\nset(state) {\nthis.state = state;\n}\nswap(f) {\nwhile(true) {\nvar stateSnapshot = this.state;\nvar nextState = f(stateSnapshot);\nif (!atomicCompareAndSet(this.state,\n--- Page 196 ---\n168 CHAPTER 8 Advanced concurrency control\nstateSnapshot,\nnextState)) {\nUses a special thread-safe comparison operation\ncontinue;\nas this.state might have changed in another\n}\nthread during execution of the function f.\nreturn nextState;\n}\n}\n}\nTheo comes closer to the whiteboard. He modifies Joe’s diagram a bit to make the flow of\nthe swap operation more detailed. The resulting diagram is in figure 8.2. Theo still has a\nfew questions, though.\nTake snapshot\nsnapshot = state\nCompute next state\nnextState = f(snapshot)\nCheck if state has changed\nstate == snapshot\nYes\nState changed?\nNo\nUpdate state\nstate = nextState\nFigure 8.2 Detailed flow of swap\nTheo What is atomicCompareAndSet?\nJoe It’s the core operation of an atom. atomicCompareAndSet atomically sets the\nstate to a new value if, and only if, the state equals the provided old value. It\nreturns true upon success and false upon failure.\nTheo How could it be atomic without using locks?\nJoe That’s a great question! In fact, atomicCompareAndSet is a compare-and-swap\noperation, provided by the language that relies on a functionality of the CPU\nitself. For example, in Java the java.util.concurrent.atomic package has\nan AtomicReference generic class that provides a compareAndSet() method.\n NOTE See http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html\nfor general information about compare-and-swap operations. Implementations for\nmulti-threaded languages appear in table 8.2.\n--- Page 197 ---\n8.2 Thread-safe counter with atoms 169\nTable 8.2 Implementation of an atomic compare and set in various languages\nLanguage Link\nJava http://mng.bz/mx0W\nJavaScript Not relevant (single-threaded language)\nRuby http://mng.bz/5KG8\nPython https://github.com/maxcountryman/atomos\nC# http://mng.bz/6Zzp\nTheo Apropos Java, how would the implementation of an atom look?\nJoe It’s quite the same, besides the fact that Atom has to use generics, and the inner\nstate has to be stored in an AtomicReference.\nJoe brings up a Java implementation of Atom on his laptop. Theo looks over the code.\nListing8.4 Implementation of the Atom class in Java\nclass Atom<ValueType> {\nprivate AtomicReference<ValueType> state;\npublic Atom() {}\nValueType get() {\nreturn this.state.get();\n}\nthis.state might have\nchanged in another thread\nvoid set(ValueType state) {\nduring the execution of f.\nthis.state.set(state);\n}\nValueType swap(UnaryOPerator<ValueType> f) {\nwhile(true) {\nValueType stateSnapshot = this.state.get();\nValueType nextState = f(stateSnapshot);\nif (!this.state.compareAndSet(stateSnapshot,\nnextState)) {\ncontinue;\n}\n}\nreturn nextState;\n}\n}\nTheo What about using an atom in Java?\nJoe Here, take a look. It’s quite simple.\n--- Page 198 ---\n170 CHAPTER 8 Advanced concurrency control\nListing8.5 Using an Atom in Java\nAtom<Integer> counter = new Atom<Integer>();\ncounter.set(0);\ncounter.swap(x -> x + 1);\ncounter.get();\nTheo takes a couple of minutes to meditate about this atom stuff and to digest what he’s\njust learned. Then, he asks Joe:\nTheo What if swap never succeeds? I mean, could the while loop inside the code of\nswap turn out to be an infinite loop?\nJoe No! By definition, when atomicCompareAndSet fails on a thread, it means that\nthe same atom was changed on another thread during the execution of swap.\nIn this race between threads, there is always a winner.\nTheo But isn’t it possible that some thread never succeeds because it always loses the\nrace against other threads?\nJoe In theory, yes, but I’ve never encountered such a situation. If you have thou-\nsands of threads that do nothing besides swapping an atom, it could happen I\nsuppose. But, in practice, once the atom is swapped, the threads do some real\nwork, for example, database access or I/O. This gives other threads the oppor-\ntunity to swap the atom successfully.\n NOTE In theory, atoms could create starvation in a system with thousands of threads\nthat do nothing beside swapping an atom. In practice, once an atom is swapped, the\nthreads do some real work (e.g., database access), which creates an opportunity for\nother threads to swap the atom successfully.\nTheo Interesting.... Indeed, atoms look much easier to manage than locks.\nJoe Now let me show you how to use atoms with composite data.\nTheo Why would that be different?\nJoe Usually, dealing with composite data is more difficult than dealing with primi-\ntive types.\nTheo When you sold me on DOP, you told me that we are able to manage data with\nthe same simplicity as we manage numbers.\nTIP In DOP, data is managed with the same simplicity as numbers.\nJoe That’s exactly what I am about to show you.\n8.3 Thread-safe cache with atoms\nJoe Are you familiar with the notion of in-memory cache?\nTheo You mean memoization?\n--- Page 199 ---\n8.3 Thread-safe cache with atoms 171\nJoe Kind of. Imagine that database queries don’t vary too much in your applica-\ntion. It makes sense in that case to store the results of previous queries in mem-\nory in order to improve the response time.\nTheo Yes, of course!\nJoe What data structure would you use to store the in-memory cache?\nTheo Probably a string map, where the keys are the queries, and the values are the\nresults from the database.\nTIP It’s quite common to represent an in-memory cache as a string map.\nJoe Excellent! Now can you write the code to cache database queries in a thread-\nsafe way using a lock?\nTheo Let me see: I’m going to use an immutable string map. Therefore, I don’t\nneed to protect read access with a lock. Only the cache update needs to be\nprotected.\nJoe You’re getting the hang of this!\nTheo The code should be something like this.\nListing8.6 Thread-safe cache with locks\nvar mutex = new Mutex();\nvar cache = {};\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache, query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\nmutex.lock();\ncache = _.set(cache, query, result);\nmutex.unlock();\nreturn result;\n}\nJoe Nice! Now, let me show you how to write the same code using an atom instead\nof a lock. Take a look at this code and let me know if it’s clear to you.\nListing8.7 Thread-safe cache with atoms\nvar cache = new Atom();\ncache.set({});\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache.get(), query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\ncache.swap(function(oldCache) {\n--- Page 200 ---\n172 CHAPTER 8 Advanced concurrency control\nreturn _.set(oldCache, query, result);\n});\nreturn result;\n}\nTheo I don’t understand the function you’re passing to the swap method.\nJoe The function passed to swap receives the current value of the cache, which is a\nstring map, and returns a new version of the string map with an additional key-\nvalue pair.\nTheo I see. But something bothers me with the performance of the swap method in\nthe case of a string map. How does the comparison work? I mean, comparing\ntwo string maps might take some time.\nJoe Not if you compare them by reference. As we discussed in the past, when data\nis immutable, it is safe to compare by reference, and it’s super fast.\nTIP When data is immutable, it is safe (and fast) to compare it by reference.\nTheo Cool. So atoms play well with immutable data.\nJoe Exactly!\n8.4 State management with atoms\nJoe Do you remember a couple of weeks ago when I showed you how we resolve\npotential conflicts between mutations? You told me that the code was not\nthread-safe.\nTheo Let me look again at the code.\nTheo takes a look at the code for the SystemData class that he wrote some time ago\n(repeated in listing 8.8). Without the validation logic, it makes the code easier to grasp.\nListing8.8 SystemData class from part 1\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nthis.systemData = SystemConsistency.reconcile(this.systemData,\nprevious,\nnext);\n}\n}\n--- Page 201 ---\n8.4 State management with atoms 173\nIt takes him a few minutes to remember how the commit method works. Suddenly, he has\nan Aha! moment.\nTheo This code is not thread-safe because the SystemConsistency.reconcile\ncode inside the commit method is not protected. Nothing prevents the two\nthreads from executing this code concurrently.\nJoe Right! Now, can you tell me how to make it thread-safe?\nTheo With locks?\nJoe Come on...\nTheo I was kidding, of course. We make the code thread-safe not with a lock but with\nan atom.\nJoe Nice joke!\nTheo Let me see. I’d need to store the system data inside an atom. The get and set\nmethod of SystemData would simply call the get and set methods of the\natom. How does this look?\nListing8.9 SystemData class with atom (without the commit method)\nclass SystemState {\nsystemData;\nconstructor() {\nthis.systemData = new Atom();\n}\nget() {\nreturn this.systemData.get();\n}\ncommit(prev, next) {\nthis.systemData.set(next);\n}\n}\nJoe Excellent. Now for the fun part. Implement the commit method by calling the\nswap method of the atom.\nTheo Instead of calling SystemConsistency.reconcile() directly, I need to wrap\nit into a call to swap. So, something like this?\nListing8.10 Implementation of SystemData.commit with atom\nSystemData.commit = function(previous, next) {\nthis.systemData.swap(function(current) {\nreturn SystemConsistency.reconcile(current,\nprevious,\nnext);\n});\n};",
        "sections_found": []
      },
      "accurate_page_range": "176-201"
    },
    {
      "text": "- Summary",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "raw_line": "- Summary (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 63,
      "chapter_info": {
        "page": 176,
        "title": "Basic data validation",
        "pattern_matched": "Chapter 7",
        "text_preview": "148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema"
      },
      "chapter_sections": {
        "start_page": 176,
        "end_page": 201,
        "content": "\n--- Page 176 ---\n148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema from listing 7.6.\nListing7.7 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe Give it a try, and you’ll see.\nIndeed! When Theo executes the code to validate the search request, it returns true.\nListing7.8 Validating the search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksRequest = {\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nvalidate(searchBooksRequestSchema, searchBooksRequest);\n// → true\nJoe Now, please try an invalid request.\nTheo Let me think about what kind of invalidity to try. I know, I’ll make a typo in the\ntitle field and call it tilte with the l before the t.\nAs expected, the code with the type returns false. Theo is not surprised, and Joe is smil-\ning from ear to ear.\nListing7.9 Validating an invalid search request\nvar invalidSearchBooksRequest = {\n\"tilte\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\n--- Page 177 ---\n7.3 Schema flexibility and strictness 149\nvalidate(searchBooksRequestSchema, invalidSearchBooksRequest);\n// → false\nTheo The syntax of JSON Schema is much more verbose than the syntax for declar-\ning the members in a class. Why is that so?\nJoe For two reasons. First, because JSON Schema is language independent, it can\nbe used in any programming language. As I told you, there are JSON Schema\nvalidators available in most programming languages.\nTheo I see.\nJoe Second, JSON Schema allows you to express validation conditions that are much\nharder, if not impossible, to express when data is represented with classes.\nTIP The expressive power of JSON Schema is high!\nTheo Now you have triggered my curiosity. Can you give me some examples?\nJoe In a moment, we’ll talk about schema composition. Someday I’ll show you\nsome examples of advanced validation.\n NOTE Advanced validation is covered in chapter 12.\nTheo What kind of advanced validation?\nJoe What I mean by advanced validation is, for instance, validating that a number\nfalls within a given range or validating that a string matches a regular expression.\nTheo Is there a way to get details about why the request is invalid?\nJoe Absolutely! I’ll show you later. For now, let me show you how to make sure the\nresponse the server sends back to the client is valid.\nTheo It sounds much more complicated than a search book request!\nJoe Why?\nTheo Because a search response is made of multiple book results, and in each book\nresult, some of the fields are optional!\n7.3 Schema flexibility and strictness\nJoe Can you give me an example of what a book search response would look like?\nTheo Take a look at this example. It’s a search response with information about two\nbooks: 7 Habits of Highly Effective People and The Power of Habit.\nListing7.10 An example of a search response\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432\n},\n--- Page 178 ---\n150 CHAPTER 7 Basic data validation\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn_13\": \"978-1982137274\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n]\n}\n]\nJoe It’s funny that you mention The Power of Habit. I’m reading this book in order\nto get rid of my habit of biting my nails. Anyway, what fields are required and\nwhat fields are optional in a book search response?\nTheo In book information, the title and available fields are required. The other\nfields are optional.\nJoe As I told you when we built the schema for the book search request, fields in a\nmap are optional by default. In order to make a field mandatory, we have to\ninclude it in the required array. I’d probably implement it with something\nlike this.\nListing7.11 Schema of a search response\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, map fields are optional by default.\nTheo I must admit that specifying a list of required fields is much simpler than hav-\ning to specify that a member in a class in nullable!\nJoe Agreed!\nTheo On the other hand, I find the nesting of the book information schema in the\nsearch response schema a bit hard to read.\n--- Page 179 ---\n7.3 Schema flexibility and strictness 151\nJoe Nothing prevents you from separating the book information schema from the\nsearch response schema.\nTheo How?\nJoe It’s just JSON, my friend. It means, you are free to manipulate the schema as\nany other map in your program. For instance, you could have the book infor-\nmation schema in a variable named bookInfoSchema and use it in the search\nbooks response schema. Let me refactor the schema to show you what I mean.\nListing7.12 Schema of a search response refactored\nvar bookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"subtitle\": {\"type\": \"string\"},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"isbn_13\": {\"type\": \"string\"}\n}\n};\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": bookInfoSchema\n};\nTheo Once again, I have to admit that JSON Schemas are more composable than\nclass definitions.\nTIP JSON Schemas are just maps. We are free to compose and manipulate them like\nany other map.\nJoe Let’s move on to validating data received from external data sources.\nTheo Is that different?\nJoe Not really, but I’ll take it as an opportunity to show you some other features of\nJSON Schema.\nTheo I’m curious to learn how data validation is used when we access data from the\ndatabase.\nJoe Each time we access data from the outside, it’s a good practice to validate it.\nCan you show me an example of how a database response for a search query\nwould look?\nTIP It’s a good practice to validate data that comes from an external data source.\n--- Page 180 ---\n152 CHAPTER 7 Basic data validation\nTheo When we query books from the database, we expect to receive an array of\nbooks with three fields: title, isbn, and available. The first two values should\nbe strings, and the third one should be a Boolean.\nJoe Are those fields optional or required?\nTheo What do you mean?\nJoe Could there be books for which some of the fields are not defined?\nTheo No.\nJoe In that case, the schema is quite simple. Would you like to try writing the\nschema for the database response?\nTheo Let me see. It’s an array of objects where each object has three properties, so\nsomething like this?\nListing7.13 Schema of a database response\n{\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n}\nJoe Well done, my friend! Now, I want to tell you about the additionalProperties\nfield in JSON Schema.\nTheo What’s that?\nJoe Take a look at this array.\nListing7.14 A book array with an additional property\n[\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true,\n\"isbn\": \"978-0812981605\",\n\"dummy_property\": 42\n},\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn\": \"978-1982137274\",\n\"dummy_property\": 45\n}\n]\n--- Page 181 ---\n7.3 Schema flexibility and strictness 153\nJoe Is it a valid database response?\nTheo No. A database response should not have a dummy_property field. It should\nhave only the three required fields specified in the schema.\nJoe It might be surprising but, by default, fields not specified in the schema of an\nobject are allowed in JSON Schema. In order to disallow them, one has to set\nadditionalProperties to false like this.\nListing7.15 Disallowing properties not mentioned in the schema\nvar booksFromDBSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"additionalProperties\": false,\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"isbn\": {\"type\": \"string\"}\n}\n}\n};\nTIP In JSON Schema, by default, fields not specified in the schema of a map are\nallowed.\nTheo Why is that?\nJoe The reason is that usually having additional fields in a map doesn’t cause\ntrouble. If your code doesn’t care about a field, it simply ignores it. But some-\ntimes we want to be as strict as possible, and we set additionalProperties\nto false.\nTheo What about the search request and response schema from the previous discus-\nsions? Should we set additionalProperties to false?\nJoe That’s an excellent question. I’d say it’s a matter of taste. Personally, I like to\nallow additional fields in requests and disallow them in responses.\nTheo What’s the advantage?\nJoe Well, the web server is responsible for the responses it sends to its clients. It\nmakes sense then to be as strict as possible. However, the requests are created\nby the clients, and I prefer to do my best to serve my clients even when they are\nnot as strict as they should be.\nTheo Naturally. “The client is always right.”\nJoe Actually, I prefer the way Jon Postel formulated his robustness principle: “Be\nconservative in what you send, be liberal in what you accept.”\nTIP It’s a good practice to be strict with the data that you send and to be flexible with\nthe data that you receive.\n--- Page 182 ---\n154 CHAPTER 7 Basic data validation\n7.4 Schema composition\nTheo What about validating data that comes from an external web service?\nJoe Can you give me an example?\nTheo In the near future, we’ll have to integrate with a service called Open Library\nBooks API that provides detailed information about books.\n NOTE For information on the Open Library Books API, see https://openlibrary\n.org/dev/docs/api/books.\nJoe Can you show me, for instance, the service response for Watchmen?\nTheo Sure. Here you go.\nTheo taps a few keys on his keyboard and brings up the response. Joe looks at the JSON for\na long time.\nListing7.16 An Open Library Books API response example\n{\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n}\nTheo asks himself, “What could be so special in this JSON?” While Joe is meditating about\nthis piece of JSON, Theo writes the JSON Schema for the Books API response. It doesn’t\nseem to be more complicated than any of the previous schemas. When Theo is done, he\nasks Joe to take a look at the schema.\nListing7.17 Schema of the Open Library Books API response\n{\n\"type\": \"object\",\n\"required\": [\"title\"],\n--- Page 183 ---\n7.4 Schema composition 155\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n}\nJoe Good job!\nTheo That wasn’t so hard. I really don’t see why you looked at this JSON response for\nsuch a long time.\nJoe Well, it has to do with the isbn_10 and isbn_13 fields. I assume that they’re\nnot both mandatory.\nTheo Right! That’s why I didn’t include them in the required field of my schema.\nJoe But one of them should always be there. Right?\nTheo Sometimes one of them and sometimes both of them, like for Watchmen. It\ndepends on the publication year of the book. Books published before 2007\nhave isbn_10, and books published after 2007 have isbn_13.\nJoe Oh, I see. And Watchmen has both because it was originally published in 1986\nbut published again after 2007.\nTheo Correct.\nJoe Then, you need your schema to indicate that one of the isbn fields is man-\ndatory. That’s a good opportunity for me to tell you about JSON Schema\ncomposition.\nTheo What’s that?\nJoe It’s a way to combine schemas, similarly to how we combine logical conditions\nwith AND, OR, and NOT.\nTheo I’d like to see that.\nJoe Sure. How would you express the schema for the Books API response as a\ncomposition of three schemas: basicBookInfoSchema, the schema that you\nwrote where only title is required; mandatoryIsbn13, a schema where only\n--- Page 184 ---\n156 CHAPTER 7 Basic data validation\nisbn_13 is required; and mandatoryIsb10, a schema where only isbn_10 is\nrequired?\nTheo I think it should be basicBookInfoSchema AND (mandatoryIsbn13 OR\nmandatoryIsbn10).\nJoe Exactly! The only thing is that in JSON Schema, we use allOf instead of AND,\nand anyOf instead of OR.\nJoe shows Theo the result in listing 7.18 and an example of its usage in listing 7.19.\nListing7.18 Schema of an external API response\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n--- Page 185 ---\n7.4 Schema composition 157\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing7.19 Validating an external API response\nvar bookInfo = {\n\"publishers\": [\n\"DC Comics\"\n],\n\"number_of_pages\": 334,\n\"weight\": \"1.4 pounds\",\n\"physical_format\": \"Paperback\",\n\"subjects\": [\n\"Graphic Novels\",\n\"Comics & Graphic Novels\",\n\"Fiction\",\n\"Fantastic fiction\"\n],\n\"isbn_13\": [\n\"9780930289232\"\n],\n\"title\": \"Watchmen\",\n\"isbn_10\": [\n\"0930289234\"\n],\n\"publish_date\": \"April 1, 1995\",\n\"physical_dimensions\": \"10.1 x 6.6 x 0.8 inches\"\n};\nvalidate(bookInfoSchema, bookInfo);\n// → true\nTheo I see why they call it allOf and anyOf. The first one means that data must con-\nform to all the schemas, and the second one means that data must conform to\nany of the schemas.\nJoe Yup.\n NOTE JSON Schema also supports oneOf for cases where data must be valid against\nexactly one schema.\nTheo Nice. With schema composition, JSON Schema seems to have more expressive\npower than what I was used to when representing data with classes.\nJoe That’s only the beginning. I’ll show you more data validation conditions that\ncan’t be expressed when data is represented with classes some other time.\n NOTE Advanced data validation is covered in chapter 12.\nTheo Something still bothers me, though. When data isn’t valid, you don’t know what\nwent wrong.\n--- Page 186 ---\n158 CHAPTER 7 Basic data validation\n7.5 Details about data validation failures\nJoe So far, we’ve treated JSON Schema validation as though it were binary: either a\npiece of data is valid or it isn’t.\nTheo Right...\nJoe But, in fact, when a piece of data is not valid, we can get details about the\nreason of the invalidity.\nTheo Like when a required field is missing, can we get the name of the missing field?\nJoe Yes. When a piece of data is not of the expected type, we can get information\nabout that also.\nTheo That sounds very useful!\nJoe Indeed. Let me show you how it works. Until now, we used a generic validate\nfunction, but when we deal with validation failures, we need to be more specific.\nTheo Why?\nJoe Because each data validator library has its own way of exposing the details of\nadata validation failure. For instance, in JavaScript Ajv, the errors from the\nlast data validation are stored as an array inside the validator instance.\nTheo Why an array?\nJoe Because there could be several failures. But let’s start with the case of a single\nfailure. Imagine we encounter a search book request where the title field is\nnamed myTitle instead of title. Take a look at this example. As you can see,\nwe first instantiate a validator instance.\nListing7.20 Accessing validation errors in Ajv\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n};\nInstantiates a\nvar ajv = new Ajv(); validator instance\najv.validate(searchBooksRequestSchema, invalidSearchBooksRequest);\najv.errors\nDisplays the\nvalidation errors\n--- Page 187 ---\n7.5 Details about data validation failures 159\nTheo And what does the information inside the errors array look like?\nJoe Execute the code snippet. You’ll see.\nWhen Theo executes the code snippets from listing 7.20, he can hardly believe his eyes. He\nlooks at the details, finding the results hard to digest.\nListing7.21 Details for a single data validation failure in an array format\n[\n{\n\"instancePath\": \"\",\n\"schemaPath\": \"#/required\",\n\"keyword\": \"required\",\n\"params\": {\n\"missingProperty\":\"title\"\n},\n\"message\": \"must have required property 'title'\"\n}\n]\nTheo I find the contents of the errors array a bit hard to understand.\nJoe Me too. Fortunately, Ajv provides a errorsText utility function to convert the\nerrors array in a human readable format. See, for instance, what is returned\nwhen you call errorsText.\nListing7.22 Displaying the errors in human readable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title'\"\nTheo Let me see what happens when there are more than one validation failure in\nthe data.\nJoe By default, Ajv catches only one validation error.\nTIP By default, Ajv catches only the first validation failure.\nTheo I guess that’s for performance reasons. Once the validator encounters an\nerror, it doesn’t continue the data parsing.\nJoe Probably. Anyway, in order to catch more than one validation failure, you need\nto pass the allErrors options to the Ajv constructor. Check out this code.\nListing7.23 Catching multiple validation failures\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n--- Page 188 ---\n160 CHAPTER 7 Basic data validation\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nA request with\nthree failures\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [1, 2]\n}; Instantiates the Ajv constructor\nwith allErrors: true in order to\ncatch more than one failure\nvar ajv = new Ajv({allErrors: true});\najv.validate(searchBooksRequestSchema,\ninvalidSearchBooksRequest); Converts the\nerrors to a human\nreadable format\najv.errorsText(ajv.errors);\n// → \"data must have required property 'title',\n// → data/fields/0 must be string,\n// → data/fields/1 must be string\"\nJoe We validate a search request with myTitle instead of title and numbers\ninstead of strings in the fields array. As you can see in the output of the code\nsnippet, three errors are returned.\nTheo Great! I think I have all that I need in order to add data validation to the\nboundaries of my system when Nancy asks me to make the Library Manage-\nment System into a web server.\nJoe Would you allow me to give you a small gift as a token of our friendship?\nTheo I’d be honored.\nJoe takes a small package out of his bag, wrapped in a light-green ribbon. He hands Theo\nthe package with a solemn gesture.\nWhen Theo undoes the ribbon, he discovers an elegant piece of paper decorated with\npretty little designs. In the center of the paper, Theo manages to read the inscription\n“JSON Schema cheat sheet.” He smiles while browsing the cheat sheet. It’s exactly what he\nneeds.\nListing7.24 JSON Schema cheat sheet\n{ At the root level,\ndata is an array.\n\"type\": \"array\",\n\"items\": { Each element of the\narray is a map.\n\"type\": \"object\",\nmyNumber \"properties\": {\nThe properties of\nis a number. \"myNumber\": {\"type\": \"number\"},\neach field in the map\n\"myString\": {\"type\": \"string\"},\nmyString is\n\"myEnum\": {\"enum\": [\"myVal\", \"yourVal\"]},\na string. myEnum is a\n\"myBool\": {\"type\": \"boolean\"}\nenumeration\nmyBool is a }, value with two\nboolean. \"required\": [\"myNumber\", \"myString\"], possibilities:\nThe mandatory fields in the map \"myVal\" and\nare myNumber and myString; \"yourVal\".\nother fields are optional.\n--- Page 189 ---\nSummary 161\n\"additionalProperties\": false\nWe don’t allow fields that\n}\nare not explicitly mentioned\n}\nin the schema.\nThen, Theo turns the paper over to find that the back is also filled with drawings. In the\ncenter of the paper, he reads the inscription, “An example of valid data.”\nListing7.25 An example of valid data\n[\n{\nThis map is valid\n\"myNumber\": 42,\nbecause all its\n\"myString\": \"Hello\",\nfields are valid.\n\"myEnum\": \"myVal\",\n\"myBool\": true\n},\n{\nThis map is valid\n\"myNumber\": 54,\nbecause it contains all\n\"myString\": \"Happy\"\nthe required fields.\n}\n]\nSummary\n DOP Principle #4 is to separate data schema and data representation.\n The boundaries of a system are defined to be the areas where the system\nexchanges data.\n Some examples of data validation at the boundaries of the system are validation\nof client requests and responses, and validation of data that comes from exter-\nnal sources.\n Data validation in DOP means checking whether a piece of data conforms to a\nschema.\n When a piece of data is not valid, we get information about the validation fail-\nures and send this information back to the client in a human readable format.\n When data at system boundaries is valid, it’s not critical to validate data again\ninside the system.\n JSON Schema is a language that allows us to separate data validation from data\nrepresentation.\n JSON Schema syntax is a bit verbose.\n The expressive power of JSON Schema is high.\n JSON Schemas are just maps and, as so, we are free to manipulate them like any\nother maps in our programs.\n We can store a schema definition in a variable and use this variable in another\nschema.\n In JSON Schema, map fields are optional by default.\n It’s good practice to validate data that comes from an external data source.\n--- Page 190 ---\n162 CHAPTER 7 Basic data validation\n It’s good practice to be strict regarding data that you send and to be flexible\nregarding data that you receive.\n Ajv is a JSON Schema library in JavaScript.\n By default, Ajv catches only the first validation failure.\n Advanced validation is covered in chapter 12.\n--- Page 191 ---\nAdvanced\nconcurrency control\nNo more deadlocks!\nThis chapter covers\n Atoms as an alternative to locks\n Managing a thread-safe counter and a thread-safe\nin-memory cache with atoms\n Managing the whole system state in a thread-safe\nway with atoms\nThe traditional way to manage concurrency in a multi-threaded environment\ninvolves lock mechanisms like mutexes. Lock mechanisms tend to increase the com-\nplexity of the system because it’s not trivial to make sure the system is free of dead-\nlocks. In DOP, we leverage the fact that data is immutable, and we use a lock-free\nmechanism, called an atom, to manage concurrency. Atoms are simpler to manage\nthan locks because they are lock-free. As a consequence, the usual complexity of\nlocks that are required to avoid deadlocks don’t apply to atoms.\n NOTE This chapter is mostly relevant to multi-threaded environments like Java,\nC#, Python, and Ruby. It is less relevant to single-threaded environments like Java-\nScript. The JavaScript code snippets in this chapter are written as though JavaScript\nwere multi-threaded.\n163\n--- Page 192 ---\n164 CHAPTER 8 Advanced concurrency control\n8.1 The complexity of locks\nThis Sunday afternoon, while riding his bike across the Golden Gate Bridge, Theo thinks\nabout the Klafim project with concern, not yet sure that betting on DOP was a good\nchoice. Suddenly, Theo realizes that he hasn’t yet scheduled the next session with Joe. He\ngets off his bike to call Joe. Bad luck, the line is busy.\nWhen Theo gets home, he tries to call Joe again, but once again the phone is busy. After\ndinner, Theo tries to call Joe one more time, with the same result—a busy signal. “Obvi-\nously, Joe is very busy today,” Theo tells himself. Exhausted by his 50-mile bike ride at an\naverage of 17 miles per hour, he falls asleep on the sofa. When Theo wakes up, he’s elated\nto see a text message from Joe, “See you Monday morning at 11 AM?” Theo answers with a\nthumbs up and prepares for another week of work.\nWhen Joe arrives at the office, Theo asks him why his phone was constantly busy the day\nbefore. Joe answers that he was about to ask Theo the same question. They look at each\nother, puzzled, and then simultaneously break into laughter as they realize what hap-\npened: in an amazing coincidence, they’d tried to phone each other at exactly the same\ntimes. They both say at once:\n“A deadlock!”\nThey both head for Theo’s office. When they get to Theo’s desk, Joe tells him that today’s\nsession is going to be about concurrency management in multi-threaded environments.\nJoe How do you usually manage concurrency in a multi-threaded environment?\nTheo I protect access to critical sections with a lock mechanism, a mutex, for instance.\nJoe When you say access, do you mean write access or also read access?\nTheo Both!\nJoe Why do you need to protect read access with a lock?\nTheo Because, without a lock protection, in the middle of a read, a write could hap-\npen in another thread. It would make my read logically inconsistent.\nJoe Another option would be to clone the data before processing it in a read.\nTheo Sometimes I would clone the data; but in many cases, when it’s large, it’s too\nexpensive to clone.\nTIP Cloning data to avoid read locks doesn’t scale.\nJoe In DOP, we don’t need to clone or to protect read access.\nTheo Because data is immutable?\nJoe Right. When data is immutable, even if a write happens in another thread\nduring a read, it won’t make the read inconsistent because the write never\nmutates the data that is read.\nTheo In a sense, a read always works on a data snapshot.\nJoe Exactly!\nTIP When data is immutable, a read is always safe.\nTheo But what about write access? Don’t you need to protect that with locks?\nJoe Nope.\n--- Page 193 ---\n8.2 Thread-safe counter with atoms 165\nTheo Why not?\nJoe We have a simpler mechanism—it’s called an atom.\nTheo I am glad to hear there is a something simpler than locks. I really struggle each\ntime I have to integrate locks into a multi-threaded system.\nJoe Me too! I remember a bug we had in production 10 years ago. We forgot to\nrelease a lock when an exception was thrown in a critical section. It caused a\nterrible deadlock.\nTheo Deadlocks are really hard to avoid. Last year, we had a deadlock issue when two\nlocks were not released in the proper order.\nJoe I have great news for you. With atoms, deadlocks never happen!\nTIP With atoms, deadlocks never happen.\nTheo That sounds great. Tell me more!\nTIP Atoms provide a way to manage concurrency without locks.\n8.2 Thread-safe counter with atoms\nJoe Let’s start with a simple case: a counter shared between threads.\nTheo What do you mean by a counter?\nJoe Imagine that we’d like to count the number of database accesses and write the\ntotal number of accesses to a log every minute.\nTheo OK.\nJoe Could you write JavaScript code for this multi-threaded counter using locks?\nTheo But JavaScript is single-threaded!\nJoe I know, but it’s just for the sake of illustration. Imagine that JavaScript were\nmulti-threaded and that it provided a Mutex object that you could lock and\nunlock.\nTheo It’s a bit awkward. I guess it would look like this.\nTheo goes to the whiteboard. He writes what he imagines to be JavaScript code for a multi-\nthreaded counter with locks.\nListing8.1 A thread-safe counter protected by a mutex\nvar mutex = new Mutex();\nvar counter = 0;\nfunction dbAccess() {\nmutex.lock();\ncounter = counter + 1;\nmutex.unlock();\n// access the database\n}\nfunction logCounter() {\nmutex.lock();\n--- Page 194 ---\n166 CHAPTER 8 Advanced concurrency control\nconsole.log('Number of database accesses: ' + counter);\nmutex.unlock();\n}\nJoe Excellent. Now, I am going to show you how to write the same code with atoms.\nAn atom provides three methods:\n get returns the current value of the atom.\n set overwrites the current value of the atom.\n swap receives a function and updates the value of the atom with the result\nof the function called on the current value of the atom.\nJoe unzips a pocket in his laptop case and takes out a piece of paper. He hands it to\nTheo. Theo is pleasantly surprised as the sheet of paper succinctly describes the methods\n(table 8.1).\nTable 8.1 The three methods of an atom\nMethod Description\nget Returns the current value\nset Overwrites the current value\nswap Updates the current value with a function\nTheo How would it look like to implement a thread-safe counter with an atom?\nJoe It’s quite simple, actually.\nJoe pulls out his laptop, fires it up, and begins to type. When he’s done, he turns the laptop\naround so that Theo can see the code to implement a thread-safe counter in an atom.\nListing8.2 A thread-safe counter stored in an atom\nvar counter = new Atom();\ncounter.set(0);\nfunction dbAccess() {\ncounter.swap(function(x) {\nThe argument x is the\nreturn x + 1;\ncurrent value of the atom,\n});\nsame as counter.get().\n// access the database\n}\nfunction logCounter() {\nconsole.log('Number of database accesses: ' + counter.get());\n}\nTheo Could you tell me what’s going on here?\nJoe Sure! First, we create an empty atom. Then, we initialize the value of the atom\nwith counter.set(0). In the logger thread, we read the current value of the\natom with counter.get().\nTheo And how do you increment the counter in the threads that access the database?\n--- Page 195 ---\n8.2 Thread-safe counter with atoms 167\nJoe We call swap with a function that receives x and returns x + 1.\nTheo I don’t understand how swap could be thread-safe without using any locks.\nJoe quickly goes to the whiteboard. He sketches the diagram in figure 8.1.\nTake snapshot\nCompute next state\nYes\nState changed?\nNo\nUpdate state\nFigure 8.1 High-level flow of swap\nJoe You see, swap computes the next value of the atom, and before modifying the\ncurrent value of the atom, it checks whether the value of the atom has changed\nduring the computation. If so, swap tries again, until no changes occur during\nthe computation.\nTheo Is swap easy to implement?\nJoe Let me show you the implementation of the Atom class and you’ll see.\nListing8.3 Implementation of the Atom class\nclass Atom {\nstate;\nconstructor() {}\nget() {\nreturn this.state;\n}\nset(state) {\nthis.state = state;\n}\nswap(f) {\nwhile(true) {\nvar stateSnapshot = this.state;\nvar nextState = f(stateSnapshot);\nif (!atomicCompareAndSet(this.state,\n--- Page 196 ---\n168 CHAPTER 8 Advanced concurrency control\nstateSnapshot,\nnextState)) {\nUses a special thread-safe comparison operation\ncontinue;\nas this.state might have changed in another\n}\nthread during execution of the function f.\nreturn nextState;\n}\n}\n}\nTheo comes closer to the whiteboard. He modifies Joe’s diagram a bit to make the flow of\nthe swap operation more detailed. The resulting diagram is in figure 8.2. Theo still has a\nfew questions, though.\nTake snapshot\nsnapshot = state\nCompute next state\nnextState = f(snapshot)\nCheck if state has changed\nstate == snapshot\nYes\nState changed?\nNo\nUpdate state\nstate = nextState\nFigure 8.2 Detailed flow of swap\nTheo What is atomicCompareAndSet?\nJoe It’s the core operation of an atom. atomicCompareAndSet atomically sets the\nstate to a new value if, and only if, the state equals the provided old value. It\nreturns true upon success and false upon failure.\nTheo How could it be atomic without using locks?\nJoe That’s a great question! In fact, atomicCompareAndSet is a compare-and-swap\noperation, provided by the language that relies on a functionality of the CPU\nitself. For example, in Java the java.util.concurrent.atomic package has\nan AtomicReference generic class that provides a compareAndSet() method.\n NOTE See http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html\nfor general information about compare-and-swap operations. Implementations for\nmulti-threaded languages appear in table 8.2.\n--- Page 197 ---\n8.2 Thread-safe counter with atoms 169\nTable 8.2 Implementation of an atomic compare and set in various languages\nLanguage Link\nJava http://mng.bz/mx0W\nJavaScript Not relevant (single-threaded language)\nRuby http://mng.bz/5KG8\nPython https://github.com/maxcountryman/atomos\nC# http://mng.bz/6Zzp\nTheo Apropos Java, how would the implementation of an atom look?\nJoe It’s quite the same, besides the fact that Atom has to use generics, and the inner\nstate has to be stored in an AtomicReference.\nJoe brings up a Java implementation of Atom on his laptop. Theo looks over the code.\nListing8.4 Implementation of the Atom class in Java\nclass Atom<ValueType> {\nprivate AtomicReference<ValueType> state;\npublic Atom() {}\nValueType get() {\nreturn this.state.get();\n}\nthis.state might have\nchanged in another thread\nvoid set(ValueType state) {\nduring the execution of f.\nthis.state.set(state);\n}\nValueType swap(UnaryOPerator<ValueType> f) {\nwhile(true) {\nValueType stateSnapshot = this.state.get();\nValueType nextState = f(stateSnapshot);\nif (!this.state.compareAndSet(stateSnapshot,\nnextState)) {\ncontinue;\n}\n}\nreturn nextState;\n}\n}\nTheo What about using an atom in Java?\nJoe Here, take a look. It’s quite simple.\n--- Page 198 ---\n170 CHAPTER 8 Advanced concurrency control\nListing8.5 Using an Atom in Java\nAtom<Integer> counter = new Atom<Integer>();\ncounter.set(0);\ncounter.swap(x -> x + 1);\ncounter.get();\nTheo takes a couple of minutes to meditate about this atom stuff and to digest what he’s\njust learned. Then, he asks Joe:\nTheo What if swap never succeeds? I mean, could the while loop inside the code of\nswap turn out to be an infinite loop?\nJoe No! By definition, when atomicCompareAndSet fails on a thread, it means that\nthe same atom was changed on another thread during the execution of swap.\nIn this race between threads, there is always a winner.\nTheo But isn’t it possible that some thread never succeeds because it always loses the\nrace against other threads?\nJoe In theory, yes, but I’ve never encountered such a situation. If you have thou-\nsands of threads that do nothing besides swapping an atom, it could happen I\nsuppose. But, in practice, once the atom is swapped, the threads do some real\nwork, for example, database access or I/O. This gives other threads the oppor-\ntunity to swap the atom successfully.\n NOTE In theory, atoms could create starvation in a system with thousands of threads\nthat do nothing beside swapping an atom. In practice, once an atom is swapped, the\nthreads do some real work (e.g., database access), which creates an opportunity for\nother threads to swap the atom successfully.\nTheo Interesting.... Indeed, atoms look much easier to manage than locks.\nJoe Now let me show you how to use atoms with composite data.\nTheo Why would that be different?\nJoe Usually, dealing with composite data is more difficult than dealing with primi-\ntive types.\nTheo When you sold me on DOP, you told me that we are able to manage data with\nthe same simplicity as we manage numbers.\nTIP In DOP, data is managed with the same simplicity as numbers.\nJoe That’s exactly what I am about to show you.\n8.3 Thread-safe cache with atoms\nJoe Are you familiar with the notion of in-memory cache?\nTheo You mean memoization?\n--- Page 199 ---\n8.3 Thread-safe cache with atoms 171\nJoe Kind of. Imagine that database queries don’t vary too much in your applica-\ntion. It makes sense in that case to store the results of previous queries in mem-\nory in order to improve the response time.\nTheo Yes, of course!\nJoe What data structure would you use to store the in-memory cache?\nTheo Probably a string map, where the keys are the queries, and the values are the\nresults from the database.\nTIP It’s quite common to represent an in-memory cache as a string map.\nJoe Excellent! Now can you write the code to cache database queries in a thread-\nsafe way using a lock?\nTheo Let me see: I’m going to use an immutable string map. Therefore, I don’t\nneed to protect read access with a lock. Only the cache update needs to be\nprotected.\nJoe You’re getting the hang of this!\nTheo The code should be something like this.\nListing8.6 Thread-safe cache with locks\nvar mutex = new Mutex();\nvar cache = {};\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache, query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\nmutex.lock();\ncache = _.set(cache, query, result);\nmutex.unlock();\nreturn result;\n}\nJoe Nice! Now, let me show you how to write the same code using an atom instead\nof a lock. Take a look at this code and let me know if it’s clear to you.\nListing8.7 Thread-safe cache with atoms\nvar cache = new Atom();\ncache.set({});\nfunction dbAccessCached(query) {\nvar resultFromCache = _.get(cache.get(), query);\nif (resultFromCache != nil) {\nreturn resultFromCache;\n}\nvar result = dbAccess(query);\ncache.swap(function(oldCache) {\n--- Page 200 ---\n172 CHAPTER 8 Advanced concurrency control\nreturn _.set(oldCache, query, result);\n});\nreturn result;\n}\nTheo I don’t understand the function you’re passing to the swap method.\nJoe The function passed to swap receives the current value of the cache, which is a\nstring map, and returns a new version of the string map with an additional key-\nvalue pair.\nTheo I see. But something bothers me with the performance of the swap method in\nthe case of a string map. How does the comparison work? I mean, comparing\ntwo string maps might take some time.\nJoe Not if you compare them by reference. As we discussed in the past, when data\nis immutable, it is safe to compare by reference, and it’s super fast.\nTIP When data is immutable, it is safe (and fast) to compare it by reference.\nTheo Cool. So atoms play well with immutable data.\nJoe Exactly!\n8.4 State management with atoms\nJoe Do you remember a couple of weeks ago when I showed you how we resolve\npotential conflicts between mutations? You told me that the code was not\nthread-safe.\nTheo Let me look again at the code.\nTheo takes a look at the code for the SystemData class that he wrote some time ago\n(repeated in listing 8.8). Without the validation logic, it makes the code easier to grasp.\nListing8.8 SystemData class from part 1\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nthis.systemData = SystemConsistency.reconcile(this.systemData,\nprevious,\nnext);\n}\n}\n--- Page 201 ---\n8.4 State management with atoms 173\nIt takes him a few minutes to remember how the commit method works. Suddenly, he has\nan Aha! moment.\nTheo This code is not thread-safe because the SystemConsistency.reconcile\ncode inside the commit method is not protected. Nothing prevents the two\nthreads from executing this code concurrently.\nJoe Right! Now, can you tell me how to make it thread-safe?\nTheo With locks?\nJoe Come on...\nTheo I was kidding, of course. We make the code thread-safe not with a lock but with\nan atom.\nJoe Nice joke!\nTheo Let me see. I’d need to store the system data inside an atom. The get and set\nmethod of SystemData would simply call the get and set methods of the\natom. How does this look?\nListing8.9 SystemData class with atom (without the commit method)\nclass SystemState {\nsystemData;\nconstructor() {\nthis.systemData = new Atom();\n}\nget() {\nreturn this.systemData.get();\n}\ncommit(prev, next) {\nthis.systemData.set(next);\n}\n}\nJoe Excellent. Now for the fun part. Implement the commit method by calling the\nswap method of the atom.\nTheo Instead of calling SystemConsistency.reconcile() directly, I need to wrap\nit into a call to swap. So, something like this?\nListing8.10 Implementation of SystemData.commit with atom\nSystemData.commit = function(previous, next) {\nthis.systemData.swap(function(current) {\nreturn SystemConsistency.reconcile(current,\nprevious,\nnext);\n});\n};",
        "sections_found": []
      },
      "accurate_page_range": "176-201"
    }
  ]
}