{
  "chapter": "1",
  "title": "Complexity of object-oriented programming",
  "page_info": {
    "page": 32,
    "title": "Complexity of object-oriented programming",
    "pattern_matched": "Chapter 1",
    "text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased "
  },
  "leaf_nodes": [
    {
      "text": "- 1.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "raw_line": "- 1.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 2,
      "chapter_info": {
        "page": 32,
        "title": "Complexity of object-oriented programming",
        "pattern_matched": "Chapter 1",
        "text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased "
      },
      "chapter_sections": {
        "start_page": 32,
        "end_page": 55,
        "content": "\n--- Page 32 ---\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, and their new project were introduced in the opener for part 1.\nTake a moment to read the opener if you missed it.\nTheo gets back to the office with Nancy’s napkin in his pocket and a lot of anxiety in his\nheart because he knows he has committed to a tough deadline. But he had no choice! Last\nweek, Monica, his boss, told him quite clearly that he had to close the deal with Nancy no\nmatter what.\nAlbatross, where Theo works, is a software consulting company with customers all over\nthe world. It originally had lots of customers among startups. Over the last year, however,\nmany projects were badly managed, and the Startup department lost the trust of its cus-\ntomers. That’s why management moved Theo from the Enterprise department to the\nStartup department as a Senior Tech lead. His job is to close deals and to deliver on time.\n1.1.1 The design phase\nBefore rushing to his laptop to code the system, Theo grabs a sheet of paper, much big-\nger than a napkin, and starts to draw a UML class diagram of the system that will imple-\nment the Klafim prototype. Theo is an object-oriented programmer. For him, there is no\nquestion—every business entity is represented by an object, and every object is made\nfrom a class.\nThe requirements for the Klafim prototype\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There can be several copies of a book.\n A book belongs to a physical library.\nTheo spends some time thinking about the organization of the system. He identifies the\nmain classes for the Klafim Global Library Management System.\n--- Page 33 ---\n1.1 OOP design: Classic or classical? 5\nThe main classes of the library management system\n Library—The central part of the system design.\n Book—A book.\n BookItem—A book can have multiple copies, and each copy is considered as\na book item.\n BookLending—When a book is lent, a book lending object is created.\n Member—A member of the library.\n Librarian—A librarian.\n User—A base class for Librarian and Member.\n Catalog—Contains a list of books.\n Author—A book author.\nThat was the easy part. Now comes the difficult part: the relations between the classes.\nAfter two hours or so, Theo comes up with a first draft of a design for the Global Library\nManagement System. It looks like the diagram in figure 1.1.\n NOTE The design presented here doesn’t pretend to be the smartest OOP design:\nexperienced OOP developers would probably use a couple of design patterns to sug-\ngest a much better design. This design is meant to be naive and by no means covers all\nthe features of the system. It serves two purposes:\n For Theo, the developer, it is rich enough to start coding.\n For me, the author of the book, it is rich enough to illustrate the complexity of a\ntypical OOP system.\nTheo feels proud of himself and of the design diagram he just produced. He definitely\ndeserves a cup of coffee!\nNear the coffee machine, Theo meets Dave, a junior software developer who joined\nAlbatross a couple of weeks ago. Theo and Dave appreciate each other, as Dave’s curiosity\nleads him to ask challenging questions. Meetings near the coffee machine often turn into\ninteresting discussions about programming.\nTheo Hey Dave! How’s it going?\nDave Today? Not great. I’m trying to fix a bug in my code! I can’t understand why\nthe state of my objects always changes. I’ll figure it out though, I’m sure. How’s\nyour day going?\nTheo I just finished the design of a system for a new customer.\nDave Cool! Would it be OK for me to see it? I’m trying to improve my design skills.\nTheo Sure! I have the diagram on my desk. We can take a look now if you like.\n--- Page 34 ---\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool\nid : String block() : Bool\nfullName: String unblock() : Bool\nreturnBook(bookLending: BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\n*\nC User\nC BookItem\nid : String\nid : String\nemail : String\nlibId: String\npassword : String\ncheckout(member: Member) : BookLending\nlogin() : Bool\nC BookLending\nid : String\nlendingDate : date *\ndueDate : date\nisLate() : Bool\nreturnBook() : Bool\nFigure 1.1 A class diagram for Klafim’s Global Library Management System\n1.1.2 UML 101\nLatte in hand, Dave follows Theo to his desk. Theo proudly shows Dave his piece of art: the\nUML diagram for the Library Management System (figure 1.1). Dave seems really excited.\nDave Wow! Such a detailed class diagram.\nTheo Yeah. I’m pretty happy with it.\n--- Page 35 ---\n1.1 OOP design: Classic or classical? 7\nDave The thing is that I can never remember the meaning of the different arrows.\nTheo There are four types of arrows in my class diagram: composition, association,\ninheritance, and usage.\nDave What’s the difference between composition and association?\n NOTE Don’t worry if you’re not familiar with OOP jargon. We’re going to leave it\naside in the next chapter.\nTheo It’s all about whether the objects can live without each other. With composi-\ntion, when one object dies, the other one dies too. While in an association rela-\ntion, each object has an independent life.\nTIP In a composition relation, when one object dies, the other one also dies. While\nin an association relation, each object has an independent life cycle.\nIn the class diagram, there are two kinds of composition symbolized by an arrow with\na plain diamond at one edge and an optional star at the other edge. Figure 1.2 shows\nthe relation between:\n A Library that owns a Catalog—A one-to-one composition. If a Library object\ndies, then its Catalog object dies with it.\n A Library that owns many Members—A one-to-many composition. If a Library\nobject dies, then all its Member objects die with it.\nC Library\nname : String * C Member\naddress : String\nFigure 1.2 The two kinds of\nC Catalog composition: one-to-one and\none-to-many. In both cases,\nList<Book> search(searchCriteria, queryStr) when an object dies, the\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\ncomposed object dies with it.\nTIP A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\nDave Do you have association relations in your diagram?\nTheo Take a look at the arrow between Book and Author. It has an empty diamond\nand a star at both edges, so it’s a many-to-many association relation.\nA book can be written by multiple authors, and an author can write multiple books.\nMoreover, Book and Author objects can live independently. The relation between\nbooks and authors is a many-to-many association (figure 1.3).\n--- Page 36 ---\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the Librarian::blockMember method. It calls\nMember::block.\nTIP Dashed arrows indicate usage relations (figure 1.4), for instance, when a class\nuses a method of another class.\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember(member: Member)\nC Member\nBool isBlocked()\nBool block()\nBool unblock()\nBool returnBook(bookLending: BookLending) Figure 1.4 Usage relation: a class\nBookLending checkout(bookItem: BookItem) uses a method of another class.\nDave I see. And I guess a plain arrow with an empty triangle, like the one between\nMember and User, represents inheritance.\nTheo Absolutely!\nTIP Plain arrows with empty triangles represent class inheritance (figure 1.5), where\nthe arrow points towards the superclass.\n--- Page 37 ---\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasure. Want to see how it all fits together?\nDave What class should we look at first?\nTheo I think we should start with Library.\nTHE LIBRARY CLASS\nThe Library is the root class of the library system. Figure 1.6 shows the system structure.\nCC Library\nname : String\naddress : String\n*\nC Member\nC Catalog\nBool isBlocked()\nList<Book> search(searchCriteria, queryStr) Bool block()\nBookItem addBookItem(librarian: Librarian, Bool unblock()\nbookItem: BookItem) Bool returnBook(bookLending: BookLending)\nBookLending checkout(bookItem: BookItem)\n*\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember\n(member: Member)\nFigure 1.6 The Library class\n--- Page 38 ---\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC Member C Librarian\nisBlocked() : Bool blockMember(member: Member) : Bool\nblock() : Bool unblockMember(member: Member) : Bool\nunblock() : Bool addBookItem(bookItem: BookItem) : BookItem\nreturnBook(bookLending : BookLending) : Bool : Member) :\ncheckout(bookItem: BookItem) : BookLending\nCC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.7 Librarian and Member derive from User.\nThe User class represents a user of the library:\n In terms of data members, it sticks to the bare minimum: it has an id, email,\nand password (with no security and encryption for now).\n In terms of code, it can log in via login.\nThe Member class represents a member of the library:\n It inherits from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Check out a book via checkout.\n– Return a book via returnBook.\n– Block itself via block.\n– Unblock itself via unblock.\n– Answer if it is blocked via isBlocked.\n It owns multiple BookLending objects.\n It uses BookItem in order to implement checkout.\n--- Page 39 ---\n1.1 OOP design: Classic or classical? 11\nThe Librarian class represents a librarian:\n It derives from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Block and unblock a Member.\n– List the member’s book lendings via getBookLendings.\n– Add book items to the library via addBookItem.\n It uses Member to implement blockMember, unblockMember, and getBook-\nLendings.\n It uses BookItem to implement checkout.\n It uses BookLending to implement getBookLendings.\nTHE CATALOG CLASS\nThe Catalog class is responsible for the management of the books. Figure 1.8 shows\nthe relation among the Catalog, Librarian, and Book classes. In terms of code, a\nCatalog object can\n Search books via search.\n Add book items to the library via addBookItem.\nC Catalog\nList<Book> search(searchCriteria, queryStr)\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\nC Librarian *\nC Book\nBool blockMember(member: Member)\nBool unblockMember(member: Member) id : String\nBookItem addBookItem(bookItem: BookItem) title : String\nList<BookLending> getBookLendingsOfMember (member: Member)\nFigure 1.8 The Catalog class\nA Catalog object uses Librarian in order to implement addBookItem. In terms of\ndata, a Catalog owns multiple Book objects.\nTHE BOOK CLASS\nFigure 1.9 presents the Book class. In terms of data, a Book object\n Should have as its bare minimum an id and a title.\n Is associated with multiple Author objects (a book might have multiple authors).\n Owns multiple BookItem objects, one for each copy of the book.\n--- Page 40 ---\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare minimum data for members: an id and a libId (for its\nphysical library ID).\n Owns multiple BookLending objects, one for each time the book is lent.\nIn terms of code, a BookItem object can be checked out via checkout.\n1.1.4 The implementation phase\nAfter this detailed investigation of Theo’s diagrams, Dave lets it sink in as he slowly sips his\ncoffee. He then expresses his admiration to Theo.\nDave Wow! That’s amazing!\nTheo Thank you.\nDave I didn’t realize people were really spending the time to write down their design\nin such detail before coding.\nTheo I always do that. It saves me lot of time during the coding phase.\nDave When will you start coding?\nTheo When I finish my latte.\nTheo grabs his coffee mug and notices that his hot latte has become an iced latte. He was\nso excited to show his class diagram to Dave that he forgot to drink it!\n--- Page 41 ---\n1.2 Sources of complexity 13\n1.2 Sources of complexity\nWhile Theo is getting himself another cup of coffee (a cappuccino this time), I\nwould like to challenge his design. It might look beautiful and clear on the paper,\nbut I claim that this design makes the system hard to understand. It’s not that Theo\npicked the wrong classes or that he misunderstood the relations among the classes.\nIt goes much deeper:\n It’s about the programming paradigm he chose to implement the system.\n It’s about the object-oriented paradigm.\n It’s about the tendency of OOP to increase the complexity of a system.\nTIP OOP has a tendency to create complex systems.\nThroughout this book, the type of complexity I refer to is that which makes systems\nhard to understand as defined in the paper, “Out of the Tar Pit,” by Ben Moseley\nand Peter Marks (2006), available at http://mng.bz/enzq. It has nothing to do with\nthe type of complexity that deals with the amount of resources consumed by a pro-\ngram. Similarly, when I refer to simplicity, I mean not complex (in other words, easy\nto understand).\nKeep in mind that complexity and simplicity (like hard and easy) are not absolute\nbut relative concepts. We can compare the complexity of two systems and determine\nwhether system A is more complex (or simpler) than system B.\n NOTE Complexity in the context of this book means hard to understand.\nAs mentioned in the introduction of this chapter, there are many ways in OOP to\nalleviate complexity. The purpose of this book is not be critical of OOP, but rather\nto present a programming paradigm called data-oriented programming (DOP) that\ntends to build systems that are less complex. In fact, the DOP paradigm is compati-\nble with OOP.\nIf one chooses to build an OOP system that adheres to DOP principles, the system\nwill be less complex. According to DOP, the main sources of complexity in Theo’s sys-\ntem (and of many traditional OOP systems) are that\n Code and data are mixed.\n Objects are mutable.\n Data is locked in objects as members.\n Code is locked into classes as methods.\nThis analysis is similar to what functional programming (FP) thinks about traditional\nOOP. However, as we will see throughout the book, the data approach that DOP takes\nin order to reduce system complexity differs from the FP approach. In appendix A, we\nillustrate how to apply DOP principles both in OOP and in FP styles.\nTIP DOP is compatible both with OOP and FP.\n--- Page 42 ---\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Extra thinking is needed when reading code.\nObjects are mutable. Explicit synchronization is required on multi-threaded environments.\nData is locked in objects. Data serialization is not trivial.\nCode is locked in classes. Class hierarchies are complex.\n1.2.1 Many relations between classes\nOne way to assess the complexity of a class diagram is to look only at the entities and\ntheir relations, ignoring members and methods, as in figure 1.10. When we design a\nsystem, we have to define the relations between different pieces of code and data.\nThat’s unavoidable.\nC Library\nC Catalog\n* *\nC Book C Librarian\n*\n*\nC Member\n*\nC Author\nC BookItem C User\nFigure 1.10 A class\ndiagram overview for\nC BookLending * Klafim’s Library\nManagement System\nTIP In OOP, code and data are mixed together in classes: data as members and code as\nmethods.\n--- Page 43 ---\n1.2 Sources of complexity 15\nFrom a system analysis perspective, the fact that code and data are mixed together\nmakes the system complex in the sense that entities tend to be involved in many rela-\ntions. In figure 1.11, we take a closer look at the Member class. Member is involved in five\nrelations: two data relations and three code relations.\n Data relations:\n– Library has many Members.\n– Member has many BookLendings.\n Code relations:\n– Member extends User.\n– Librarian uses Member.\n– Member uses BookItem.\nC Librarian\nC Library * C Member\n*\nC User C BookLending C BookItem Figure 1.11 The class Member is\ninvolved in five relations.\nImagine for a moment that we were able, somehow, to split the Member class into two\nseparate entities:\n MemberCode for the code\n MemberData for the data\nInstead of a Member class with five relations, we would have the diagram shown in fig-\nure 1.12 with:\n A MemberCode entity and three relations.\n A MemberData entity and two relations.\nC Library C Librarian\n*\nC MemberData C MemberCode\n*\nC BookLending C User C BookItem Figure 1.12 A class diagram where Member\nis split into code and data entities\n--- Page 44 ---\n16 CHAPTER 1 Complexity of object-orientedprogramming\nThe class diagram where Member is split into MemberCode and MemberData is made of\ntwo independent parts. Each part is easier to understand than the original diagram.\nLet’s split every class of our original class diagram into code and data entities.\nFigure 1.13 shows the resulting diagram. Now the system is made of two indepen-\ndent parts:\n A part that involves only data entities.\n A part that involves only code entities.\nC LibraryData * C LibrarianData C CatalogCode\n*\nC MemberData C CatalogData C LibrarianCode\n*\nC BookData C MemberCode C BookLendingCode C BookItemCode\n*\n* *\nC BookItemData C AuthorData C UserCode C BookItem\n*\nC BookLendingData\nFigure 1.13 A class diagram where every class is split into code and data entities\nTIP A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\nThe resulting system, made up of two independent subsystems, is easier to understand\nthan the original system. The fact that the two subsystems are independent means that\neach subsystem can be understood separately and in any order. The resulting system\nnot simpler by accident; it is a logical consequence of separating code from data.\nTIP A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n1.2.2 Unpredictable code behavior\nYou might be a bit tired after the system-level analysis that we presented in the previ-\nous section. Let’s get refreshed and look at some code.\nTake a look at the code in listing 1.1, where we get the blocked status of a member\nand display it twice. If I tell you that when I called displayBlockedStatusTwice, the\nprogram displayed true on the first console.log call, can you tell me what the pro-\ngram displayed on the second console.log call?\n--- Page 45 ---\n1.2 Sources of complexity 17\nListing1.1 Really simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nvar isBlocked = this.isBlocked;\nconsole.log(isBlocked);\nconsole.log(isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\n“Of course, it displayed true again,” you say. And you are right!\nNow, take a look at a slightly different pseudocode as shown in listing 1.2. Here we\ndisplay, twice, the blocked status of a member without assigning a variable. Same ques-\ntion as before: if I tell you that when I called displayBlockedStatusTwice, the pro-\ngram displayed true on the first console.log call, can you tell me what the program\ndisplayed on the second console.log call?\nListing1.2 Apparently simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nconsole.log(this.isBlocked);\nconsole.log(this.isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\nThe correct answer is...in a single-threaded environment, it displays true, while in a\nmulti-threaded environment, it’s unpredictable. Indeed, in a multi-threaded environ-\nment between the two console.log calls, there could be a context switch that changes\nthe state of the object (e.g., a librarian unblocked the member). In fact, with a slight\nmodification, the same kind of code unpredictability could occur even in a single-\nthreaded environment like JavaScript, when data is modified via asynchronous code\n(see the section about Principle #3 in appendix A). The difference between the two\ncode snippets is that\n In the first listing (listing 1.1), we access a Boolean value twice , which is a prim-\nitive value.\n In the second listing (listing 1.2), we access a member of an object twice.\nTIP When data is mutable, code is unpredictable.\n--- Page 46 ---\n18 CHAPTER 1 Complexity of object-orientedprogramming\nThis unpredictable behavior of the second listing is one of the annoying conse-\nquences of OOP. Unlike primitive types, which are usually immutable, object mem-\nbers are mutable. One way to solve this problem in OOP is to protect sensitive code\nwith concurrency safety mechanisms like mutexes, but that introduces issues like a\nperformance hit and a risk of deadlocks.\nWe will see later in the book that DOP treats every piece of data in the same way:\nboth primitive types and collection types are immutable values. This value treatment for\nall citizens brings serenity to DOP developers’ minds, and more brain cells are avail-\nable to handle the interesting pieces of the applications they build.\nTIP Data immutability brings serenity to DOP developers’ minds.\n1.2.3 Not trivial data serialization\nTheo is really tired, and he falls asleep at his desk. He’s having dream. In his dream, Nancy\nasks him to make Klafim’s Library Management System accessible via a REST API using\nJSON as a transport layer. Theo has to implement a /search endpoint that receives a\nquery in JSON format and returns the results in JSON format. Listing 1.3 shows an input\nexample of the /search endpoint, and listing 1.4 shows an output example of the /search\nendpoint.\nListing1.3 A JSON input of the /search endpoint\n{\n\"searchCriteria\": \"author\",\n\"query\": \"albert\"\n}\nListing1.4 A JSON output of the /search endpoint\n[\n{\n\"title\": \"The world as I see it\",\n\"authors\": [\n{\n\"fullName\": \"Albert Einstein\"\n}\n]\n},\n{\n\"title\": \"The Stranger\",\n\"authors\": [\n{\n\"fullName\": \"Albert Camus\"\n}\n]\n}\n]\n--- Page 47 ---\n1.2 Sources of complexity 19\nTheo would probably implement the /search endpoint by creating three classes simi-\nlarly to what is shown in the following list and in figure 1.14. (Not surprisingly, every-\nthing in OOP has to be wrapped in a class. Right?)\n SearchController is responsible for handling the query.\n SearchQuery converts the JSON query string into data.\n SearchResult converts the search result data into a JSON string.\nC SearchController\nString handle(searchQuery: String)\nC SearchQuery\nC SearchResult\nC Catalog\nsearchCriteria: String\nSearchResult(books: List<Book>)\nList<Book> search(searchCriteria, queryStr) query: String\nString toJSON()\nSearchQuery(jsonString: String)\n* *\nC Book\nid : String\ntitle : String\nFigure 1.14 The class diagram for SearchController\nThe SearchController (see figure 1.14) would have a single handle method with the\nfollowing flow:\n Creates a SearchQuery object from the JSON query string.\n Retrieves searchCriteria and queryStr from the SearchQuery object.\n Calls the search method of the catalog:Catalog with searchCriteria and\nqueryStr and receives books:List<Book>.\n Creates a SearchResult object with books.\n Converts the SearchResult object to a JSON string.\nWhat about other endpoints, for instance, those allowing librarians to add book items\nthrough /add-book-item? Theo would have to repeat the exact same process and cre-\nate three classes:\n AddBookItemController to handle the query\n BookItemQuery to convert the JSON query string into data\n BookItemResult to convert the search result data into a JSON string\nThe code that deals with JSON deserialization that Theo wrote previously in Search-\nQuery would have to be rewritten in BookItemQuery. Same thing for the code that\ndeals with JSON serialization he wrote previously in SearchResult; it would have to be\nrewritten in BookItemResult.\n--- Page 48 ---\n20 CHAPTER 1 Complexity of object-orientedprogramming\nThe bad news is that Theo would have to repeat the same process for every end-\npoint of the system. Each time he encounters a new kind of JSON input or output,\nhe would have to create a new class and write code. Theo’s dream is turning into a\nnightmare!\nSuddenly, his phone rings, next to where he was resting his head on the desk. As Theo\nwakes up, he realizes that Nancy never asked for JSON. It was all a dream...a really bad\ndream!\nTIP In OOP, data serialization is difficult.\nIt’s quite frustrating that handling JSON serialization and deserialization in OOP\nrequires the addition of so many classes and writing so much code—again and again!\nThe frustration grows when you consider that serializing a search query, a book item\nquery, or any query is quite similar. It comes down to\n Going over data fields.\n Concatenating the name of the data fields and the value of the data fields, sepa-\nrated by a comma.\nWhy is such a simple thing so hard to achieve in OOP? In OOP, data has to follow a\nrigid shape defined in classes, which means that data is locked in members. There is\nno simple way to access data generically.\nTIP In OOP, data is locked in classes as members.\nWe will refine later what we mean by generic access to the data, and we will see how\nDOP provides a generic way to handle JSON serialization and deserialization. Until\nthen, you will have to continue suffering. But at least you are starting to become aware\nof this suffering, and you know that it is avoidable.\n NOTE Most OOP programming languages alleviate a bit of the difficulty involved\nin the conversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n1.2.4 Complex class hierarchies\nOne way to avoid writing the same code twice in OOP involves class inheritance. Indeed,\nwhen every requirement of the system is known up front, you design your class hier-\narchy is such a way that classes with common behavior derive from a base class.\nFigure 1.15 shows an example of this pattern that focuses on the part of our class\ndiagram that deals with members and librarians. Both Librarians and Members need\nthe ability to log in, and they inherit this ability from the User class.\nSo far, so good, but when new requirements are introduced after the system is imple-\nmented, it’s a completely different story. Fast forward to Monday, March 29th, at 11:00 AM,\nwhere two days are left before the deadline (Wednesday at midnight).\n--- Page 49 ---\n1.2 Sources of complexity 21\nC Librarian\nblockMember(member: Member) : Bool\nunblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String Figure 1.15 The part of the\npassword : String class diagram that deals with\nlogin() : Bool members and librarians\nNancy calls Theo with an urgent request. Theo is not sure if it’s a dream or reality. He\npinches himself and he can feel the jolt. It’s definitely reality!\nNancy How is the project doing?\nTheo Fine, Nancy. We’re on schedule to meet the deadline. We’re running our last\nround of regression tests now.\nNancy Fantastic! It means we have time for adding a tiny feature to the system, right?\nTheo Depends what you mean by “tiny.”\nNancy We need to add VIP members to the system.\nTheo What do you mean by VIP members?\nNancy VIP members are allowed to add book items to the library by themselves.\nTheo Hmm...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nI’ll ask you the same question Nancy asked Theo: why is adding VIP members to our\nsystem not a tiny task? After all, Theo has already written the code that allows librari-\nans to add book items to the library (it’s in Librarian::addBookItem). What prevents\nhim from reusing this code for VIP members? The reason is that, in OOP, the code is\nlocked into classes as methods.\nTIP In OOP, code is locked into classes.\nVIP members are members that are allowed to add book items to the library by them-\nselves. Theo decomposes the customer requirements into two pieces:\n--- Page 50 ---\n22 CHAPTER 1 Complexity of object-orientedprogramming\n VIP members are library members.\n VIP members are allowed to add book items to the library by themselves.\nTheo then decides that he needs a new class, VIPMember. For the first requirement\n(VIP members are library members), it seems reasonable to make VIPMember derive\nfrom Member. However, handling the second requirement (VIP members are allowed\nto add book items) is more complex. He cannot make a VIPMember derive from\nLibrarian because the relation between VIPMember and Librarian is not linear:\n On one hand, VIP members are like librarians in that they are allowed to add\nbook items.\n On the other hand, VIP members are not like librarians in that they are not\nallowed to block members or list the books lent to a member.\nThe problem is that the code that adds book items is locked in the Librarian class.\nThere is no way for the VIPMember class to use this code.\nFigure 1.16 shows one possible solution that makes the code of Librarian::add-\nBookItem available to both Librarian and VIPMember classes. Here are the changes to\nthe previous class diagram:\n A base class UserWithBookItemRight extends User.\n addBookItem moves from Librarian to UserWithBookItemRight.\n Both VIPMember and Librarian extend UserWithBookItemRight.\nC Librarian\nblockMember(member: Member) : Bool C VIPMember\nunblockMember(member: Member) : Bool\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nCC UserWithBookItemRight\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool addBookItem(bookItem: BookItem) : BookItem\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.16 A class diagram for a system with VIP members\nIt wasn’t easy, but Theo manages to handle the change on time, thanks to an all nighter\ncoding on his laptop. He was even able to add new tests to the system and run the regres-\nsion tests again. However, he was so excited that he didn’t pay attention to the diamond\n--- Page 51 ---\n1.2 Sources of complexity 23\nproblem VIPMember introduced in his class diagram due to multiple inheritance: VIPMember\nextends both Member and UserWithBookItemRight, which both extend User.\nWednesday, March 31, at 10:00 AM (14 hours before the deadline), Theo calls Nancy to\ntell her the good news.\nTheo We were able to add VIP members to the system on time, Nancy.\nNancy Fantastic! I told you it was a tiny feature.\nTheo Yeah, well...\nNancy Look, I was going to call you anyway. I just finished a meeting with my business\npartner, and we realized that we need another tiny feature before the launch.\nWill you be able to handle it before the deadline?\nTheo Again, it depends what you mean by “tiny.”\nNancy We need to add Super members to the system.\nTheo What do you mean by Super members?\nNancy Super members are allowed to list the books lent to other members.\nTheo Err...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nAs with VIP members, adding Super members to the system requires changes to Theo’s\nclass hierarchy. Figure 1.17 shows the solution Theo has in mind.\nC Librarian\nC VIPMember C SuperMember\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC UserWithBlockMemberRight\nCC UserWithBookItemRight\nblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\nunblockMember(member: Member) : Bool\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.17 A class diagram for a system with Super and VIP members\nThe addition of Super members has made the system really complex. Theo suddenly\nnotices that he has three diamonds in his class diagram—not gemstones but three “Deadly\n--- Page 52 ---\n24 CHAPTER 1 Complexity of object-orientedprogramming\nDiamonds of Death” as OOP developers sometimes name the ambiguity that arises when a\nclass D inherits from two classes B and C, where both inherit from class A!\nHe tries to avoid the diamonds by transforming the User class into an interface and\nusing the composition over inheritance design pattern. But with the stress of the deadline\nlooming, he isn’t able to use all of his brain cells. In fact, the system has become so com-\nplex, he’s unable to deliver the system by the deadline. Theo tells himself that he should\nhave used composition instead of class inheritance. But, it’s too late now.\nTIP In OOP, prefer composition over class inheritance.\nAt 10:00 PM, two hours before the deadline, Theo calls Nancy to explain the situation.\nTheo Look Nancy, we really did our best, but we won’t be able to add Super mem-\nbers to the system before the deadline.\nNancy No worries, my business partner and I decided to omit this feature for now.\nWe’ll add it later.\nWith mixed feelings of anger and relief, Theo stops pacing around his office. He realizes\nhe will be spending tonight in his own bed, rather than plowing away on his computer at\nthe office. That should make his wife happy.\nTheo I guess that means we’re ready for the launch tomorrow morning.\nNancy Yes. We’ll offer this new product for a month or so, and if we get good market\ntraction, we’ll move forward with a bigger project.\nTheo Cool. Let’s be in touch in a month then. Good luck on the launch!\nSummary\n Complexity in the context of this book means hard to understand.\n We use the terms code and behavior interchangeably.\n DOP stands for data-oriented programming.\n OOP stands for object-oriented programming.\n FP stands for functional programming.\n In a composition relation, when one object dies, the other one also dies.\n A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\n In an association relation, each object has an independent life cycle.\n A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\n Dashed arrows indicate a usage relation; for instance, when a class uses a method\nof another class.\n Plain arrows with empty triangles represent class inheritance, where the arrow\npoints towards the superclass.\n The design presented in this chapter doesn’t pretend to be the smartest OOP\ndesign. Experienced OOP developers would probably use a couple of design\npatterns and suggest a much better diagram.\n--- Page 53 ---\nSummary 25\n Traditional OOP systems tend to increase system complexity, in the sense that\nOOP systems are hard to understand.\n In traditional OOP, code and data are mixed together in classes: data as mem-\nbers and code as methods.\n In traditional OOP, data is mutable.\n The root cause of the increase in complexity is related to the mixing of code\nand data together into objects.\n When code and data are mixed, classes tend to be involved in many relations.\n When objects are mutable, extra thinking is required in order to understand\nhow the code behaves.\n When objects are mutable, explicit synchronization mechanisms are required\non multi-threaded environments.\n When data is locked in objects, data serialization is not trivial.\n When code is locked in classes, class hierarchies tend to be complex.\n A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\n A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n When data is mutable, code is unpredictable.\n A strategic use of design patterns can help mitigate complexity in traditional\nOOP to some degree.\n Data immutability brings serenity to DOP developers’ minds.\n Most OOP programming languages alleviate slightly the difficulty involved the\nconversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n In traditional OOP, data serialization is difficult.\n In traditional OOP, data is locked in classes as members.\n In traditional OOP, code is locked into classes.\n DOP reduces complexity by rethinking data.\n DOP is compatible both with OOP and FP.\n--- Page 54 ---\nSeparation between\ncode and data\nA whole new world\nThis chapter covers\n The benefits of separating code from data\n Designing a system where code and data are\nseparate\n Implementing a system that respects the\nseparation between code and data\nThe first insight of DOP is that we can decrease the complexity of our systems by\nseparating code from data. Indeed, when code is separated from data, our systems\nare made of two main pieces that can be thought about separately: data entities and\ncode modules. This chapter is a deep dive in the first principle of DOP (summa-\nrized in figure 2.1).\nPRINCIPLE #1 Separate code from data such that the code resides in functions,\nwhose behavior doesn’t depend on data that is somehow encapsulated in the func-\ntion’s context.\n26\n--- Page 55 ---\n2.1 The two parts of a DOP system 27\nStateless (static)\nFunctions\nData asfirst argument\nCode modules\nUsage\nRelations\nNo inheritance\nSeparate code from data\nOnly members\nData entities No code\nAssociation\nRelations\nComposition\nFigure 2.1 DOP principle #1 summarized: Separate code from data.\nIn this chapter, we’ll illustrate the separation between code and data in the context of\nKlafim’s Library Management System that we introduced in chapter 1. We’ll also unveil\nthe benefits that this separation brings to the system:\n The system is simple. It is easy to understand.\n The system is flexible and extensible. Quite often, it requires no design changes to\nadapt to changing requirements.\nThis chapter focuses on the design of the code in a system where code and data are\nseparate. In the next chapter, we’ll focus on the design of the data. As we progress in\nthe book, we’ll discover other benefits of separating code from data.\n2.1 The two parts of a DOP system\nWhile Theo is driving home after delivering the prototype, he asks himself whether the\nKlafim project was a success or not. Sure, he was able to satisfy the customer, but it was\nmore luck than brains. He wouldn’t have made it on time if Nancy had decided to keep\nthe Super members feature. Why was it so complicated to add tiny features to the system?\nWhy was the system he built so complex? He thought there should be a way to build more\nflexible systems!\nThe next morning, Theo asks on Hacker News and on Reddit for ways to reduce system\ncomplexity and build flexible systems. Some folks mention using different programming\nlanguages, while others talk about advanced design patterns. Finally, Theo’s attention gets\ncaptured by a comment from a user named Joe. He mentions data-oriented programming and\nclaims that its main goal is to reduce system complexity. Theo has never heard this term\nbefore. Out of curiosity, he decides to contact Joe by email. What a coincidence! Joe lives\nin San Francisco too. Theo invites him to a meeting in his office.\nJoe is a 40-year-old developer. He was a Java developer for nearly a decade before adopt-\ning Clojure around 7 years ago. When Theo tells Joe about the Library Management System",
        "sections_found": []
      },
      "accurate_page_range": "32-55"
    },
    {
      "text": "- 1.1.0 Introduction (사용자 추가)",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "raw_line": "- 1.1.0 Introduction (사용자 추가) (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 3,
      "chapter_info": {
        "page": 32,
        "title": "Complexity of object-oriented programming",
        "pattern_matched": "Chapter 1",
        "text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased "
      },
      "chapter_sections": {
        "start_page": 32,
        "end_page": 55,
        "content": "\n--- Page 32 ---\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, and their new project were introduced in the opener for part 1.\nTake a moment to read the opener if you missed it.\nTheo gets back to the office with Nancy’s napkin in his pocket and a lot of anxiety in his\nheart because he knows he has committed to a tough deadline. But he had no choice! Last\nweek, Monica, his boss, told him quite clearly that he had to close the deal with Nancy no\nmatter what.\nAlbatross, where Theo works, is a software consulting company with customers all over\nthe world. It originally had lots of customers among startups. Over the last year, however,\nmany projects were badly managed, and the Startup department lost the trust of its cus-\ntomers. That’s why management moved Theo from the Enterprise department to the\nStartup department as a Senior Tech lead. His job is to close deals and to deliver on time.\n1.1.1 The design phase\nBefore rushing to his laptop to code the system, Theo grabs a sheet of paper, much big-\nger than a napkin, and starts to draw a UML class diagram of the system that will imple-\nment the Klafim prototype. Theo is an object-oriented programmer. For him, there is no\nquestion—every business entity is represented by an object, and every object is made\nfrom a class.\nThe requirements for the Klafim prototype\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There can be several copies of a book.\n A book belongs to a physical library.\nTheo spends some time thinking about the organization of the system. He identifies the\nmain classes for the Klafim Global Library Management System.\n--- Page 33 ---\n1.1 OOP design: Classic or classical? 5\nThe main classes of the library management system\n Library—The central part of the system design.\n Book—A book.\n BookItem—A book can have multiple copies, and each copy is considered as\na book item.\n BookLending—When a book is lent, a book lending object is created.\n Member—A member of the library.\n Librarian—A librarian.\n User—A base class for Librarian and Member.\n Catalog—Contains a list of books.\n Author—A book author.\nThat was the easy part. Now comes the difficult part: the relations between the classes.\nAfter two hours or so, Theo comes up with a first draft of a design for the Global Library\nManagement System. It looks like the diagram in figure 1.1.\n NOTE The design presented here doesn’t pretend to be the smartest OOP design:\nexperienced OOP developers would probably use a couple of design patterns to sug-\ngest a much better design. This design is meant to be naive and by no means covers all\nthe features of the system. It serves two purposes:\n For Theo, the developer, it is rich enough to start coding.\n For me, the author of the book, it is rich enough to illustrate the complexity of a\ntypical OOP system.\nTheo feels proud of himself and of the design diagram he just produced. He definitely\ndeserves a cup of coffee!\nNear the coffee machine, Theo meets Dave, a junior software developer who joined\nAlbatross a couple of weeks ago. Theo and Dave appreciate each other, as Dave’s curiosity\nleads him to ask challenging questions. Meetings near the coffee machine often turn into\ninteresting discussions about programming.\nTheo Hey Dave! How’s it going?\nDave Today? Not great. I’m trying to fix a bug in my code! I can’t understand why\nthe state of my objects always changes. I’ll figure it out though, I’m sure. How’s\nyour day going?\nTheo I just finished the design of a system for a new customer.\nDave Cool! Would it be OK for me to see it? I’m trying to improve my design skills.\nTheo Sure! I have the diagram on my desk. We can take a look now if you like.\n--- Page 34 ---\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool\nid : String block() : Bool\nfullName: String unblock() : Bool\nreturnBook(bookLending: BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\n*\nC User\nC BookItem\nid : String\nid : String\nemail : String\nlibId: String\npassword : String\ncheckout(member: Member) : BookLending\nlogin() : Bool\nC BookLending\nid : String\nlendingDate : date *\ndueDate : date\nisLate() : Bool\nreturnBook() : Bool\nFigure 1.1 A class diagram for Klafim’s Global Library Management System\n1.1.2 UML 101\nLatte in hand, Dave follows Theo to his desk. Theo proudly shows Dave his piece of art: the\nUML diagram for the Library Management System (figure 1.1). Dave seems really excited.\nDave Wow! Such a detailed class diagram.\nTheo Yeah. I’m pretty happy with it.\n--- Page 35 ---\n1.1 OOP design: Classic or classical? 7\nDave The thing is that I can never remember the meaning of the different arrows.\nTheo There are four types of arrows in my class diagram: composition, association,\ninheritance, and usage.\nDave What’s the difference between composition and association?\n NOTE Don’t worry if you’re not familiar with OOP jargon. We’re going to leave it\naside in the next chapter.\nTheo It’s all about whether the objects can live without each other. With composi-\ntion, when one object dies, the other one dies too. While in an association rela-\ntion, each object has an independent life.\nTIP In a composition relation, when one object dies, the other one also dies. While\nin an association relation, each object has an independent life cycle.\nIn the class diagram, there are two kinds of composition symbolized by an arrow with\na plain diamond at one edge and an optional star at the other edge. Figure 1.2 shows\nthe relation between:\n A Library that owns a Catalog—A one-to-one composition. If a Library object\ndies, then its Catalog object dies with it.\n A Library that owns many Members—A one-to-many composition. If a Library\nobject dies, then all its Member objects die with it.\nC Library\nname : String * C Member\naddress : String\nFigure 1.2 The two kinds of\nC Catalog composition: one-to-one and\none-to-many. In both cases,\nList<Book> search(searchCriteria, queryStr) when an object dies, the\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\ncomposed object dies with it.\nTIP A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\nDave Do you have association relations in your diagram?\nTheo Take a look at the arrow between Book and Author. It has an empty diamond\nand a star at both edges, so it’s a many-to-many association relation.\nA book can be written by multiple authors, and an author can write multiple books.\nMoreover, Book and Author objects can live independently. The relation between\nbooks and authors is a many-to-many association (figure 1.3).\n--- Page 36 ---\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the Librarian::blockMember method. It calls\nMember::block.\nTIP Dashed arrows indicate usage relations (figure 1.4), for instance, when a class\nuses a method of another class.\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember(member: Member)\nC Member\nBool isBlocked()\nBool block()\nBool unblock()\nBool returnBook(bookLending: BookLending) Figure 1.4 Usage relation: a class\nBookLending checkout(bookItem: BookItem) uses a method of another class.\nDave I see. And I guess a plain arrow with an empty triangle, like the one between\nMember and User, represents inheritance.\nTheo Absolutely!\nTIP Plain arrows with empty triangles represent class inheritance (figure 1.5), where\nthe arrow points towards the superclass.\n--- Page 37 ---\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasure. Want to see how it all fits together?\nDave What class should we look at first?\nTheo I think we should start with Library.\nTHE LIBRARY CLASS\nThe Library is the root class of the library system. Figure 1.6 shows the system structure.\nCC Library\nname : String\naddress : String\n*\nC Member\nC Catalog\nBool isBlocked()\nList<Book> search(searchCriteria, queryStr) Bool block()\nBookItem addBookItem(librarian: Librarian, Bool unblock()\nbookItem: BookItem) Bool returnBook(bookLending: BookLending)\nBookLending checkout(bookItem: BookItem)\n*\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember\n(member: Member)\nFigure 1.6 The Library class\n--- Page 38 ---\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC Member C Librarian\nisBlocked() : Bool blockMember(member: Member) : Bool\nblock() : Bool unblockMember(member: Member) : Bool\nunblock() : Bool addBookItem(bookItem: BookItem) : BookItem\nreturnBook(bookLending : BookLending) : Bool : Member) :\ncheckout(bookItem: BookItem) : BookLending\nCC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.7 Librarian and Member derive from User.\nThe User class represents a user of the library:\n In terms of data members, it sticks to the bare minimum: it has an id, email,\nand password (with no security and encryption for now).\n In terms of code, it can log in via login.\nThe Member class represents a member of the library:\n It inherits from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Check out a book via checkout.\n– Return a book via returnBook.\n– Block itself via block.\n– Unblock itself via unblock.\n– Answer if it is blocked via isBlocked.\n It owns multiple BookLending objects.\n It uses BookItem in order to implement checkout.\n--- Page 39 ---\n1.1 OOP design: Classic or classical? 11\nThe Librarian class represents a librarian:\n It derives from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Block and unblock a Member.\n– List the member’s book lendings via getBookLendings.\n– Add book items to the library via addBookItem.\n It uses Member to implement blockMember, unblockMember, and getBook-\nLendings.\n It uses BookItem to implement checkout.\n It uses BookLending to implement getBookLendings.\nTHE CATALOG CLASS\nThe Catalog class is responsible for the management of the books. Figure 1.8 shows\nthe relation among the Catalog, Librarian, and Book classes. In terms of code, a\nCatalog object can\n Search books via search.\n Add book items to the library via addBookItem.\nC Catalog\nList<Book> search(searchCriteria, queryStr)\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\nC Librarian *\nC Book\nBool blockMember(member: Member)\nBool unblockMember(member: Member) id : String\nBookItem addBookItem(bookItem: BookItem) title : String\nList<BookLending> getBookLendingsOfMember (member: Member)\nFigure 1.8 The Catalog class\nA Catalog object uses Librarian in order to implement addBookItem. In terms of\ndata, a Catalog owns multiple Book objects.\nTHE BOOK CLASS\nFigure 1.9 presents the Book class. In terms of data, a Book object\n Should have as its bare minimum an id and a title.\n Is associated with multiple Author objects (a book might have multiple authors).\n Owns multiple BookItem objects, one for each copy of the book.\n--- Page 40 ---\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare minimum data for members: an id and a libId (for its\nphysical library ID).\n Owns multiple BookLending objects, one for each time the book is lent.\nIn terms of code, a BookItem object can be checked out via checkout.\n1.1.4 The implementation phase\nAfter this detailed investigation of Theo’s diagrams, Dave lets it sink in as he slowly sips his\ncoffee. He then expresses his admiration to Theo.\nDave Wow! That’s amazing!\nTheo Thank you.\nDave I didn’t realize people were really spending the time to write down their design\nin such detail before coding.\nTheo I always do that. It saves me lot of time during the coding phase.\nDave When will you start coding?\nTheo When I finish my latte.\nTheo grabs his coffee mug and notices that his hot latte has become an iced latte. He was\nso excited to show his class diagram to Dave that he forgot to drink it!\n--- Page 41 ---\n1.2 Sources of complexity 13\n1.2 Sources of complexity\nWhile Theo is getting himself another cup of coffee (a cappuccino this time), I\nwould like to challenge his design. It might look beautiful and clear on the paper,\nbut I claim that this design makes the system hard to understand. It’s not that Theo\npicked the wrong classes or that he misunderstood the relations among the classes.\nIt goes much deeper:\n It’s about the programming paradigm he chose to implement the system.\n It’s about the object-oriented paradigm.\n It’s about the tendency of OOP to increase the complexity of a system.\nTIP OOP has a tendency to create complex systems.\nThroughout this book, the type of complexity I refer to is that which makes systems\nhard to understand as defined in the paper, “Out of the Tar Pit,” by Ben Moseley\nand Peter Marks (2006), available at http://mng.bz/enzq. It has nothing to do with\nthe type of complexity that deals with the amount of resources consumed by a pro-\ngram. Similarly, when I refer to simplicity, I mean not complex (in other words, easy\nto understand).\nKeep in mind that complexity and simplicity (like hard and easy) are not absolute\nbut relative concepts. We can compare the complexity of two systems and determine\nwhether system A is more complex (or simpler) than system B.\n NOTE Complexity in the context of this book means hard to understand.\nAs mentioned in the introduction of this chapter, there are many ways in OOP to\nalleviate complexity. The purpose of this book is not be critical of OOP, but rather\nto present a programming paradigm called data-oriented programming (DOP) that\ntends to build systems that are less complex. In fact, the DOP paradigm is compati-\nble with OOP.\nIf one chooses to build an OOP system that adheres to DOP principles, the system\nwill be less complex. According to DOP, the main sources of complexity in Theo’s sys-\ntem (and of many traditional OOP systems) are that\n Code and data are mixed.\n Objects are mutable.\n Data is locked in objects as members.\n Code is locked into classes as methods.\nThis analysis is similar to what functional programming (FP) thinks about traditional\nOOP. However, as we will see throughout the book, the data approach that DOP takes\nin order to reduce system complexity differs from the FP approach. In appendix A, we\nillustrate how to apply DOP principles both in OOP and in FP styles.\nTIP DOP is compatible both with OOP and FP.\n--- Page 42 ---\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Extra thinking is needed when reading code.\nObjects are mutable. Explicit synchronization is required on multi-threaded environments.\nData is locked in objects. Data serialization is not trivial.\nCode is locked in classes. Class hierarchies are complex.\n1.2.1 Many relations between classes\nOne way to assess the complexity of a class diagram is to look only at the entities and\ntheir relations, ignoring members and methods, as in figure 1.10. When we design a\nsystem, we have to define the relations between different pieces of code and data.\nThat’s unavoidable.\nC Library\nC Catalog\n* *\nC Book C Librarian\n*\n*\nC Member\n*\nC Author\nC BookItem C User\nFigure 1.10 A class\ndiagram overview for\nC BookLending * Klafim’s Library\nManagement System\nTIP In OOP, code and data are mixed together in classes: data as members and code as\nmethods.\n--- Page 43 ---\n1.2 Sources of complexity 15\nFrom a system analysis perspective, the fact that code and data are mixed together\nmakes the system complex in the sense that entities tend to be involved in many rela-\ntions. In figure 1.11, we take a closer look at the Member class. Member is involved in five\nrelations: two data relations and three code relations.\n Data relations:\n– Library has many Members.\n– Member has many BookLendings.\n Code relations:\n– Member extends User.\n– Librarian uses Member.\n– Member uses BookItem.\nC Librarian\nC Library * C Member\n*\nC User C BookLending C BookItem Figure 1.11 The class Member is\ninvolved in five relations.\nImagine for a moment that we were able, somehow, to split the Member class into two\nseparate entities:\n MemberCode for the code\n MemberData for the data\nInstead of a Member class with five relations, we would have the diagram shown in fig-\nure 1.12 with:\n A MemberCode entity and three relations.\n A MemberData entity and two relations.\nC Library C Librarian\n*\nC MemberData C MemberCode\n*\nC BookLending C User C BookItem Figure 1.12 A class diagram where Member\nis split into code and data entities\n--- Page 44 ---\n16 CHAPTER 1 Complexity of object-orientedprogramming\nThe class diagram where Member is split into MemberCode and MemberData is made of\ntwo independent parts. Each part is easier to understand than the original diagram.\nLet’s split every class of our original class diagram into code and data entities.\nFigure 1.13 shows the resulting diagram. Now the system is made of two indepen-\ndent parts:\n A part that involves only data entities.\n A part that involves only code entities.\nC LibraryData * C LibrarianData C CatalogCode\n*\nC MemberData C CatalogData C LibrarianCode\n*\nC BookData C MemberCode C BookLendingCode C BookItemCode\n*\n* *\nC BookItemData C AuthorData C UserCode C BookItem\n*\nC BookLendingData\nFigure 1.13 A class diagram where every class is split into code and data entities\nTIP A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\nThe resulting system, made up of two independent subsystems, is easier to understand\nthan the original system. The fact that the two subsystems are independent means that\neach subsystem can be understood separately and in any order. The resulting system\nnot simpler by accident; it is a logical consequence of separating code from data.\nTIP A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n1.2.2 Unpredictable code behavior\nYou might be a bit tired after the system-level analysis that we presented in the previ-\nous section. Let’s get refreshed and look at some code.\nTake a look at the code in listing 1.1, where we get the blocked status of a member\nand display it twice. If I tell you that when I called displayBlockedStatusTwice, the\nprogram displayed true on the first console.log call, can you tell me what the pro-\ngram displayed on the second console.log call?\n--- Page 45 ---\n1.2 Sources of complexity 17\nListing1.1 Really simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nvar isBlocked = this.isBlocked;\nconsole.log(isBlocked);\nconsole.log(isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\n“Of course, it displayed true again,” you say. And you are right!\nNow, take a look at a slightly different pseudocode as shown in listing 1.2. Here we\ndisplay, twice, the blocked status of a member without assigning a variable. Same ques-\ntion as before: if I tell you that when I called displayBlockedStatusTwice, the pro-\ngram displayed true on the first console.log call, can you tell me what the program\ndisplayed on the second console.log call?\nListing1.2 Apparently simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nconsole.log(this.isBlocked);\nconsole.log(this.isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\nThe correct answer is...in a single-threaded environment, it displays true, while in a\nmulti-threaded environment, it’s unpredictable. Indeed, in a multi-threaded environ-\nment between the two console.log calls, there could be a context switch that changes\nthe state of the object (e.g., a librarian unblocked the member). In fact, with a slight\nmodification, the same kind of code unpredictability could occur even in a single-\nthreaded environment like JavaScript, when data is modified via asynchronous code\n(see the section about Principle #3 in appendix A). The difference between the two\ncode snippets is that\n In the first listing (listing 1.1), we access a Boolean value twice , which is a prim-\nitive value.\n In the second listing (listing 1.2), we access a member of an object twice.\nTIP When data is mutable, code is unpredictable.\n--- Page 46 ---\n18 CHAPTER 1 Complexity of object-orientedprogramming\nThis unpredictable behavior of the second listing is one of the annoying conse-\nquences of OOP. Unlike primitive types, which are usually immutable, object mem-\nbers are mutable. One way to solve this problem in OOP is to protect sensitive code\nwith concurrency safety mechanisms like mutexes, but that introduces issues like a\nperformance hit and a risk of deadlocks.\nWe will see later in the book that DOP treats every piece of data in the same way:\nboth primitive types and collection types are immutable values. This value treatment for\nall citizens brings serenity to DOP developers’ minds, and more brain cells are avail-\nable to handle the interesting pieces of the applications they build.\nTIP Data immutability brings serenity to DOP developers’ minds.\n1.2.3 Not trivial data serialization\nTheo is really tired, and he falls asleep at his desk. He’s having dream. In his dream, Nancy\nasks him to make Klafim’s Library Management System accessible via a REST API using\nJSON as a transport layer. Theo has to implement a /search endpoint that receives a\nquery in JSON format and returns the results in JSON format. Listing 1.3 shows an input\nexample of the /search endpoint, and listing 1.4 shows an output example of the /search\nendpoint.\nListing1.3 A JSON input of the /search endpoint\n{\n\"searchCriteria\": \"author\",\n\"query\": \"albert\"\n}\nListing1.4 A JSON output of the /search endpoint\n[\n{\n\"title\": \"The world as I see it\",\n\"authors\": [\n{\n\"fullName\": \"Albert Einstein\"\n}\n]\n},\n{\n\"title\": \"The Stranger\",\n\"authors\": [\n{\n\"fullName\": \"Albert Camus\"\n}\n]\n}\n]\n--- Page 47 ---\n1.2 Sources of complexity 19\nTheo would probably implement the /search endpoint by creating three classes simi-\nlarly to what is shown in the following list and in figure 1.14. (Not surprisingly, every-\nthing in OOP has to be wrapped in a class. Right?)\n SearchController is responsible for handling the query.\n SearchQuery converts the JSON query string into data.\n SearchResult converts the search result data into a JSON string.\nC SearchController\nString handle(searchQuery: String)\nC SearchQuery\nC SearchResult\nC Catalog\nsearchCriteria: String\nSearchResult(books: List<Book>)\nList<Book> search(searchCriteria, queryStr) query: String\nString toJSON()\nSearchQuery(jsonString: String)\n* *\nC Book\nid : String\ntitle : String\nFigure 1.14 The class diagram for SearchController\nThe SearchController (see figure 1.14) would have a single handle method with the\nfollowing flow:\n Creates a SearchQuery object from the JSON query string.\n Retrieves searchCriteria and queryStr from the SearchQuery object.\n Calls the search method of the catalog:Catalog with searchCriteria and\nqueryStr and receives books:List<Book>.\n Creates a SearchResult object with books.\n Converts the SearchResult object to a JSON string.\nWhat about other endpoints, for instance, those allowing librarians to add book items\nthrough /add-book-item? Theo would have to repeat the exact same process and cre-\nate three classes:\n AddBookItemController to handle the query\n BookItemQuery to convert the JSON query string into data\n BookItemResult to convert the search result data into a JSON string\nThe code that deals with JSON deserialization that Theo wrote previously in Search-\nQuery would have to be rewritten in BookItemQuery. Same thing for the code that\ndeals with JSON serialization he wrote previously in SearchResult; it would have to be\nrewritten in BookItemResult.\n--- Page 48 ---\n20 CHAPTER 1 Complexity of object-orientedprogramming\nThe bad news is that Theo would have to repeat the same process for every end-\npoint of the system. Each time he encounters a new kind of JSON input or output,\nhe would have to create a new class and write code. Theo’s dream is turning into a\nnightmare!\nSuddenly, his phone rings, next to where he was resting his head on the desk. As Theo\nwakes up, he realizes that Nancy never asked for JSON. It was all a dream...a really bad\ndream!\nTIP In OOP, data serialization is difficult.\nIt’s quite frustrating that handling JSON serialization and deserialization in OOP\nrequires the addition of so many classes and writing so much code—again and again!\nThe frustration grows when you consider that serializing a search query, a book item\nquery, or any query is quite similar. It comes down to\n Going over data fields.\n Concatenating the name of the data fields and the value of the data fields, sepa-\nrated by a comma.\nWhy is such a simple thing so hard to achieve in OOP? In OOP, data has to follow a\nrigid shape defined in classes, which means that data is locked in members. There is\nno simple way to access data generically.\nTIP In OOP, data is locked in classes as members.\nWe will refine later what we mean by generic access to the data, and we will see how\nDOP provides a generic way to handle JSON serialization and deserialization. Until\nthen, you will have to continue suffering. But at least you are starting to become aware\nof this suffering, and you know that it is avoidable.\n NOTE Most OOP programming languages alleviate a bit of the difficulty involved\nin the conversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n1.2.4 Complex class hierarchies\nOne way to avoid writing the same code twice in OOP involves class inheritance. Indeed,\nwhen every requirement of the system is known up front, you design your class hier-\narchy is such a way that classes with common behavior derive from a base class.\nFigure 1.15 shows an example of this pattern that focuses on the part of our class\ndiagram that deals with members and librarians. Both Librarians and Members need\nthe ability to log in, and they inherit this ability from the User class.\nSo far, so good, but when new requirements are introduced after the system is imple-\nmented, it’s a completely different story. Fast forward to Monday, March 29th, at 11:00 AM,\nwhere two days are left before the deadline (Wednesday at midnight).\n--- Page 49 ---\n1.2 Sources of complexity 21\nC Librarian\nblockMember(member: Member) : Bool\nunblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String Figure 1.15 The part of the\npassword : String class diagram that deals with\nlogin() : Bool members and librarians\nNancy calls Theo with an urgent request. Theo is not sure if it’s a dream or reality. He\npinches himself and he can feel the jolt. It’s definitely reality!\nNancy How is the project doing?\nTheo Fine, Nancy. We’re on schedule to meet the deadline. We’re running our last\nround of regression tests now.\nNancy Fantastic! It means we have time for adding a tiny feature to the system, right?\nTheo Depends what you mean by “tiny.”\nNancy We need to add VIP members to the system.\nTheo What do you mean by VIP members?\nNancy VIP members are allowed to add book items to the library by themselves.\nTheo Hmm...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nI’ll ask you the same question Nancy asked Theo: why is adding VIP members to our\nsystem not a tiny task? After all, Theo has already written the code that allows librari-\nans to add book items to the library (it’s in Librarian::addBookItem). What prevents\nhim from reusing this code for VIP members? The reason is that, in OOP, the code is\nlocked into classes as methods.\nTIP In OOP, code is locked into classes.\nVIP members are members that are allowed to add book items to the library by them-\nselves. Theo decomposes the customer requirements into two pieces:\n--- Page 50 ---\n22 CHAPTER 1 Complexity of object-orientedprogramming\n VIP members are library members.\n VIP members are allowed to add book items to the library by themselves.\nTheo then decides that he needs a new class, VIPMember. For the first requirement\n(VIP members are library members), it seems reasonable to make VIPMember derive\nfrom Member. However, handling the second requirement (VIP members are allowed\nto add book items) is more complex. He cannot make a VIPMember derive from\nLibrarian because the relation between VIPMember and Librarian is not linear:\n On one hand, VIP members are like librarians in that they are allowed to add\nbook items.\n On the other hand, VIP members are not like librarians in that they are not\nallowed to block members or list the books lent to a member.\nThe problem is that the code that adds book items is locked in the Librarian class.\nThere is no way for the VIPMember class to use this code.\nFigure 1.16 shows one possible solution that makes the code of Librarian::add-\nBookItem available to both Librarian and VIPMember classes. Here are the changes to\nthe previous class diagram:\n A base class UserWithBookItemRight extends User.\n addBookItem moves from Librarian to UserWithBookItemRight.\n Both VIPMember and Librarian extend UserWithBookItemRight.\nC Librarian\nblockMember(member: Member) : Bool C VIPMember\nunblockMember(member: Member) : Bool\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nCC UserWithBookItemRight\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool addBookItem(bookItem: BookItem) : BookItem\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.16 A class diagram for a system with VIP members\nIt wasn’t easy, but Theo manages to handle the change on time, thanks to an all nighter\ncoding on his laptop. He was even able to add new tests to the system and run the regres-\nsion tests again. However, he was so excited that he didn’t pay attention to the diamond\n--- Page 51 ---\n1.2 Sources of complexity 23\nproblem VIPMember introduced in his class diagram due to multiple inheritance: VIPMember\nextends both Member and UserWithBookItemRight, which both extend User.\nWednesday, March 31, at 10:00 AM (14 hours before the deadline), Theo calls Nancy to\ntell her the good news.\nTheo We were able to add VIP members to the system on time, Nancy.\nNancy Fantastic! I told you it was a tiny feature.\nTheo Yeah, well...\nNancy Look, I was going to call you anyway. I just finished a meeting with my business\npartner, and we realized that we need another tiny feature before the launch.\nWill you be able to handle it before the deadline?\nTheo Again, it depends what you mean by “tiny.”\nNancy We need to add Super members to the system.\nTheo What do you mean by Super members?\nNancy Super members are allowed to list the books lent to other members.\nTheo Err...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nAs with VIP members, adding Super members to the system requires changes to Theo’s\nclass hierarchy. Figure 1.17 shows the solution Theo has in mind.\nC Librarian\nC VIPMember C SuperMember\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC UserWithBlockMemberRight\nCC UserWithBookItemRight\nblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\nunblockMember(member: Member) : Bool\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.17 A class diagram for a system with Super and VIP members\nThe addition of Super members has made the system really complex. Theo suddenly\nnotices that he has three diamonds in his class diagram—not gemstones but three “Deadly\n--- Page 52 ---\n24 CHAPTER 1 Complexity of object-orientedprogramming\nDiamonds of Death” as OOP developers sometimes name the ambiguity that arises when a\nclass D inherits from two classes B and C, where both inherit from class A!\nHe tries to avoid the diamonds by transforming the User class into an interface and\nusing the composition over inheritance design pattern. But with the stress of the deadline\nlooming, he isn’t able to use all of his brain cells. In fact, the system has become so com-\nplex, he’s unable to deliver the system by the deadline. Theo tells himself that he should\nhave used composition instead of class inheritance. But, it’s too late now.\nTIP In OOP, prefer composition over class inheritance.\nAt 10:00 PM, two hours before the deadline, Theo calls Nancy to explain the situation.\nTheo Look Nancy, we really did our best, but we won’t be able to add Super mem-\nbers to the system before the deadline.\nNancy No worries, my business partner and I decided to omit this feature for now.\nWe’ll add it later.\nWith mixed feelings of anger and relief, Theo stops pacing around his office. He realizes\nhe will be spending tonight in his own bed, rather than plowing away on his computer at\nthe office. That should make his wife happy.\nTheo I guess that means we’re ready for the launch tomorrow morning.\nNancy Yes. We’ll offer this new product for a month or so, and if we get good market\ntraction, we’ll move forward with a bigger project.\nTheo Cool. Let’s be in touch in a month then. Good luck on the launch!\nSummary\n Complexity in the context of this book means hard to understand.\n We use the terms code and behavior interchangeably.\n DOP stands for data-oriented programming.\n OOP stands for object-oriented programming.\n FP stands for functional programming.\n In a composition relation, when one object dies, the other one also dies.\n A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\n In an association relation, each object has an independent life cycle.\n A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\n Dashed arrows indicate a usage relation; for instance, when a class uses a method\nof another class.\n Plain arrows with empty triangles represent class inheritance, where the arrow\npoints towards the superclass.\n The design presented in this chapter doesn’t pretend to be the smartest OOP\ndesign. Experienced OOP developers would probably use a couple of design\npatterns and suggest a much better diagram.\n--- Page 53 ---\nSummary 25\n Traditional OOP systems tend to increase system complexity, in the sense that\nOOP systems are hard to understand.\n In traditional OOP, code and data are mixed together in classes: data as mem-\nbers and code as methods.\n In traditional OOP, data is mutable.\n The root cause of the increase in complexity is related to the mixing of code\nand data together into objects.\n When code and data are mixed, classes tend to be involved in many relations.\n When objects are mutable, extra thinking is required in order to understand\nhow the code behaves.\n When objects are mutable, explicit synchronization mechanisms are required\non multi-threaded environments.\n When data is locked in objects, data serialization is not trivial.\n When code is locked in classes, class hierarchies tend to be complex.\n A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\n A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n When data is mutable, code is unpredictable.\n A strategic use of design patterns can help mitigate complexity in traditional\nOOP to some degree.\n Data immutability brings serenity to DOP developers’ minds.\n Most OOP programming languages alleviate slightly the difficulty involved the\nconversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n In traditional OOP, data serialization is difficult.\n In traditional OOP, data is locked in classes as members.\n In traditional OOP, code is locked into classes.\n DOP reduces complexity by rethinking data.\n DOP is compatible both with OOP and FP.\n--- Page 54 ---\nSeparation between\ncode and data\nA whole new world\nThis chapter covers\n The benefits of separating code from data\n Designing a system where code and data are\nseparate\n Implementing a system that respects the\nseparation between code and data\nThe first insight of DOP is that we can decrease the complexity of our systems by\nseparating code from data. Indeed, when code is separated from data, our systems\nare made of two main pieces that can be thought about separately: data entities and\ncode modules. This chapter is a deep dive in the first principle of DOP (summa-\nrized in figure 2.1).\nPRINCIPLE #1 Separate code from data such that the code resides in functions,\nwhose behavior doesn’t depend on data that is somehow encapsulated in the func-\ntion’s context.\n26\n--- Page 55 ---\n2.1 The two parts of a DOP system 27\nStateless (static)\nFunctions\nData asfirst argument\nCode modules\nUsage\nRelations\nNo inheritance\nSeparate code from data\nOnly members\nData entities No code\nAssociation\nRelations\nComposition\nFigure 2.1 DOP principle #1 summarized: Separate code from data.\nIn this chapter, we’ll illustrate the separation between code and data in the context of\nKlafim’s Library Management System that we introduced in chapter 1. We’ll also unveil\nthe benefits that this separation brings to the system:\n The system is simple. It is easy to understand.\n The system is flexible and extensible. Quite often, it requires no design changes to\nadapt to changing requirements.\nThis chapter focuses on the design of the code in a system where code and data are\nseparate. In the next chapter, we’ll focus on the design of the data. As we progress in\nthe book, we’ll discover other benefits of separating code from data.\n2.1 The two parts of a DOP system\nWhile Theo is driving home after delivering the prototype, he asks himself whether the\nKlafim project was a success or not. Sure, he was able to satisfy the customer, but it was\nmore luck than brains. He wouldn’t have made it on time if Nancy had decided to keep\nthe Super members feature. Why was it so complicated to add tiny features to the system?\nWhy was the system he built so complex? He thought there should be a way to build more\nflexible systems!\nThe next morning, Theo asks on Hacker News and on Reddit for ways to reduce system\ncomplexity and build flexible systems. Some folks mention using different programming\nlanguages, while others talk about advanced design patterns. Finally, Theo’s attention gets\ncaptured by a comment from a user named Joe. He mentions data-oriented programming and\nclaims that its main goal is to reduce system complexity. Theo has never heard this term\nbefore. Out of curiosity, he decides to contact Joe by email. What a coincidence! Joe lives\nin San Francisco too. Theo invites him to a meeting in his office.\nJoe is a 40-year-old developer. He was a Java developer for nearly a decade before adopt-\ning Clojure around 7 years ago. When Theo tells Joe about the Library Management System",
        "sections_found": []
      },
      "accurate_page_range": "32-55"
    },
    {
      "text": "- 1.1.1 The design phase",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "raw_line": "- 1.1.1 The design phase (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 4,
      "chapter_info": {
        "page": 32,
        "title": "Complexity of object-oriented programming",
        "pattern_matched": "Chapter 1",
        "text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased "
      },
      "chapter_sections": {
        "start_page": 32,
        "end_page": 55,
        "content": "\n--- Page 32 ---\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, and their new project were introduced in the opener for part 1.\nTake a moment to read the opener if you missed it.\nTheo gets back to the office with Nancy’s napkin in his pocket and a lot of anxiety in his\nheart because he knows he has committed to a tough deadline. But he had no choice! Last\nweek, Monica, his boss, told him quite clearly that he had to close the deal with Nancy no\nmatter what.\nAlbatross, where Theo works, is a software consulting company with customers all over\nthe world. It originally had lots of customers among startups. Over the last year, however,\nmany projects were badly managed, and the Startup department lost the trust of its cus-\ntomers. That’s why management moved Theo from the Enterprise department to the\nStartup department as a Senior Tech lead. His job is to close deals and to deliver on time.\n1.1.1 The design phase\nBefore rushing to his laptop to code the system, Theo grabs a sheet of paper, much big-\nger than a napkin, and starts to draw a UML class diagram of the system that will imple-\nment the Klafim prototype. Theo is an object-oriented programmer. For him, there is no\nquestion—every business entity is represented by an object, and every object is made\nfrom a class.\nThe requirements for the Klafim prototype\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There can be several copies of a book.\n A book belongs to a physical library.\nTheo spends some time thinking about the organization of the system. He identifies the\nmain classes for the Klafim Global Library Management System.\n--- Page 33 ---\n1.1 OOP design: Classic or classical? 5\nThe main classes of the library management system\n Library—The central part of the system design.\n Book—A book.\n BookItem—A book can have multiple copies, and each copy is considered as\na book item.\n BookLending—When a book is lent, a book lending object is created.\n Member—A member of the library.\n Librarian—A librarian.\n User—A base class for Librarian and Member.\n Catalog—Contains a list of books.\n Author—A book author.\nThat was the easy part. Now comes the difficult part: the relations between the classes.\nAfter two hours or so, Theo comes up with a first draft of a design for the Global Library\nManagement System. It looks like the diagram in figure 1.1.\n NOTE The design presented here doesn’t pretend to be the smartest OOP design:\nexperienced OOP developers would probably use a couple of design patterns to sug-\ngest a much better design. This design is meant to be naive and by no means covers all\nthe features of the system. It serves two purposes:\n For Theo, the developer, it is rich enough to start coding.\n For me, the author of the book, it is rich enough to illustrate the complexity of a\ntypical OOP system.\nTheo feels proud of himself and of the design diagram he just produced. He definitely\ndeserves a cup of coffee!\nNear the coffee machine, Theo meets Dave, a junior software developer who joined\nAlbatross a couple of weeks ago. Theo and Dave appreciate each other, as Dave’s curiosity\nleads him to ask challenging questions. Meetings near the coffee machine often turn into\ninteresting discussions about programming.\nTheo Hey Dave! How’s it going?\nDave Today? Not great. I’m trying to fix a bug in my code! I can’t understand why\nthe state of my objects always changes. I’ll figure it out though, I’m sure. How’s\nyour day going?\nTheo I just finished the design of a system for a new customer.\nDave Cool! Would it be OK for me to see it? I’m trying to improve my design skills.\nTheo Sure! I have the diagram on my desk. We can take a look now if you like.\n--- Page 34 ---\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool\nid : String block() : Bool\nfullName: String unblock() : Bool\nreturnBook(bookLending: BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\n*\nC User\nC BookItem\nid : String\nid : String\nemail : String\nlibId: String\npassword : String\ncheckout(member: Member) : BookLending\nlogin() : Bool\nC BookLending\nid : String\nlendingDate : date *\ndueDate : date\nisLate() : Bool\nreturnBook() : Bool\nFigure 1.1 A class diagram for Klafim’s Global Library Management System\n1.1.2 UML 101\nLatte in hand, Dave follows Theo to his desk. Theo proudly shows Dave his piece of art: the\nUML diagram for the Library Management System (figure 1.1). Dave seems really excited.\nDave Wow! Such a detailed class diagram.\nTheo Yeah. I’m pretty happy with it.\n--- Page 35 ---\n1.1 OOP design: Classic or classical? 7\nDave The thing is that I can never remember the meaning of the different arrows.\nTheo There are four types of arrows in my class diagram: composition, association,\ninheritance, and usage.\nDave What’s the difference between composition and association?\n NOTE Don’t worry if you’re not familiar with OOP jargon. We’re going to leave it\naside in the next chapter.\nTheo It’s all about whether the objects can live without each other. With composi-\ntion, when one object dies, the other one dies too. While in an association rela-\ntion, each object has an independent life.\nTIP In a composition relation, when one object dies, the other one also dies. While\nin an association relation, each object has an independent life cycle.\nIn the class diagram, there are two kinds of composition symbolized by an arrow with\na plain diamond at one edge and an optional star at the other edge. Figure 1.2 shows\nthe relation between:\n A Library that owns a Catalog—A one-to-one composition. If a Library object\ndies, then its Catalog object dies with it.\n A Library that owns many Members—A one-to-many composition. If a Library\nobject dies, then all its Member objects die with it.\nC Library\nname : String * C Member\naddress : String\nFigure 1.2 The two kinds of\nC Catalog composition: one-to-one and\none-to-many. In both cases,\nList<Book> search(searchCriteria, queryStr) when an object dies, the\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\ncomposed object dies with it.\nTIP A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\nDave Do you have association relations in your diagram?\nTheo Take a look at the arrow between Book and Author. It has an empty diamond\nand a star at both edges, so it’s a many-to-many association relation.\nA book can be written by multiple authors, and an author can write multiple books.\nMoreover, Book and Author objects can live independently. The relation between\nbooks and authors is a many-to-many association (figure 1.3).\n--- Page 36 ---\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the Librarian::blockMember method. It calls\nMember::block.\nTIP Dashed arrows indicate usage relations (figure 1.4), for instance, when a class\nuses a method of another class.\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember(member: Member)\nC Member\nBool isBlocked()\nBool block()\nBool unblock()\nBool returnBook(bookLending: BookLending) Figure 1.4 Usage relation: a class\nBookLending checkout(bookItem: BookItem) uses a method of another class.\nDave I see. And I guess a plain arrow with an empty triangle, like the one between\nMember and User, represents inheritance.\nTheo Absolutely!\nTIP Plain arrows with empty triangles represent class inheritance (figure 1.5), where\nthe arrow points towards the superclass.\n--- Page 37 ---\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasure. Want to see how it all fits together?\nDave What class should we look at first?\nTheo I think we should start with Library.\nTHE LIBRARY CLASS\nThe Library is the root class of the library system. Figure 1.6 shows the system structure.\nCC Library\nname : String\naddress : String\n*\nC Member\nC Catalog\nBool isBlocked()\nList<Book> search(searchCriteria, queryStr) Bool block()\nBookItem addBookItem(librarian: Librarian, Bool unblock()\nbookItem: BookItem) Bool returnBook(bookLending: BookLending)\nBookLending checkout(bookItem: BookItem)\n*\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember\n(member: Member)\nFigure 1.6 The Library class\n--- Page 38 ---\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC Member C Librarian\nisBlocked() : Bool blockMember(member: Member) : Bool\nblock() : Bool unblockMember(member: Member) : Bool\nunblock() : Bool addBookItem(bookItem: BookItem) : BookItem\nreturnBook(bookLending : BookLending) : Bool : Member) :\ncheckout(bookItem: BookItem) : BookLending\nCC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.7 Librarian and Member derive from User.\nThe User class represents a user of the library:\n In terms of data members, it sticks to the bare minimum: it has an id, email,\nand password (with no security and encryption for now).\n In terms of code, it can log in via login.\nThe Member class represents a member of the library:\n It inherits from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Check out a book via checkout.\n– Return a book via returnBook.\n– Block itself via block.\n– Unblock itself via unblock.\n– Answer if it is blocked via isBlocked.\n It owns multiple BookLending objects.\n It uses BookItem in order to implement checkout.\n--- Page 39 ---\n1.1 OOP design: Classic or classical? 11\nThe Librarian class represents a librarian:\n It derives from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Block and unblock a Member.\n– List the member’s book lendings via getBookLendings.\n– Add book items to the library via addBookItem.\n It uses Member to implement blockMember, unblockMember, and getBook-\nLendings.\n It uses BookItem to implement checkout.\n It uses BookLending to implement getBookLendings.\nTHE CATALOG CLASS\nThe Catalog class is responsible for the management of the books. Figure 1.8 shows\nthe relation among the Catalog, Librarian, and Book classes. In terms of code, a\nCatalog object can\n Search books via search.\n Add book items to the library via addBookItem.\nC Catalog\nList<Book> search(searchCriteria, queryStr)\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\nC Librarian *\nC Book\nBool blockMember(member: Member)\nBool unblockMember(member: Member) id : String\nBookItem addBookItem(bookItem: BookItem) title : String\nList<BookLending> getBookLendingsOfMember (member: Member)\nFigure 1.8 The Catalog class\nA Catalog object uses Librarian in order to implement addBookItem. In terms of\ndata, a Catalog owns multiple Book objects.\nTHE BOOK CLASS\nFigure 1.9 presents the Book class. In terms of data, a Book object\n Should have as its bare minimum an id and a title.\n Is associated with multiple Author objects (a book might have multiple authors).\n Owns multiple BookItem objects, one for each copy of the book.\n--- Page 40 ---\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare minimum data for members: an id and a libId (for its\nphysical library ID).\n Owns multiple BookLending objects, one for each time the book is lent.\nIn terms of code, a BookItem object can be checked out via checkout.\n1.1.4 The implementation phase\nAfter this detailed investigation of Theo’s diagrams, Dave lets it sink in as he slowly sips his\ncoffee. He then expresses his admiration to Theo.\nDave Wow! That’s amazing!\nTheo Thank you.\nDave I didn’t realize people were really spending the time to write down their design\nin such detail before coding.\nTheo I always do that. It saves me lot of time during the coding phase.\nDave When will you start coding?\nTheo When I finish my latte.\nTheo grabs his coffee mug and notices that his hot latte has become an iced latte. He was\nso excited to show his class diagram to Dave that he forgot to drink it!\n--- Page 41 ---\n1.2 Sources of complexity 13\n1.2 Sources of complexity\nWhile Theo is getting himself another cup of coffee (a cappuccino this time), I\nwould like to challenge his design. It might look beautiful and clear on the paper,\nbut I claim that this design makes the system hard to understand. It’s not that Theo\npicked the wrong classes or that he misunderstood the relations among the classes.\nIt goes much deeper:\n It’s about the programming paradigm he chose to implement the system.\n It’s about the object-oriented paradigm.\n It’s about the tendency of OOP to increase the complexity of a system.\nTIP OOP has a tendency to create complex systems.\nThroughout this book, the type of complexity I refer to is that which makes systems\nhard to understand as defined in the paper, “Out of the Tar Pit,” by Ben Moseley\nand Peter Marks (2006), available at http://mng.bz/enzq. It has nothing to do with\nthe type of complexity that deals with the amount of resources consumed by a pro-\ngram. Similarly, when I refer to simplicity, I mean not complex (in other words, easy\nto understand).\nKeep in mind that complexity and simplicity (like hard and easy) are not absolute\nbut relative concepts. We can compare the complexity of two systems and determine\nwhether system A is more complex (or simpler) than system B.\n NOTE Complexity in the context of this book means hard to understand.\nAs mentioned in the introduction of this chapter, there are many ways in OOP to\nalleviate complexity. The purpose of this book is not be critical of OOP, but rather\nto present a programming paradigm called data-oriented programming (DOP) that\ntends to build systems that are less complex. In fact, the DOP paradigm is compati-\nble with OOP.\nIf one chooses to build an OOP system that adheres to DOP principles, the system\nwill be less complex. According to DOP, the main sources of complexity in Theo’s sys-\ntem (and of many traditional OOP systems) are that\n Code and data are mixed.\n Objects are mutable.\n Data is locked in objects as members.\n Code is locked into classes as methods.\nThis analysis is similar to what functional programming (FP) thinks about traditional\nOOP. However, as we will see throughout the book, the data approach that DOP takes\nin order to reduce system complexity differs from the FP approach. In appendix A, we\nillustrate how to apply DOP principles both in OOP and in FP styles.\nTIP DOP is compatible both with OOP and FP.\n--- Page 42 ---\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Extra thinking is needed when reading code.\nObjects are mutable. Explicit synchronization is required on multi-threaded environments.\nData is locked in objects. Data serialization is not trivial.\nCode is locked in classes. Class hierarchies are complex.\n1.2.1 Many relations between classes\nOne way to assess the complexity of a class diagram is to look only at the entities and\ntheir relations, ignoring members and methods, as in figure 1.10. When we design a\nsystem, we have to define the relations between different pieces of code and data.\nThat’s unavoidable.\nC Library\nC Catalog\n* *\nC Book C Librarian\n*\n*\nC Member\n*\nC Author\nC BookItem C User\nFigure 1.10 A class\ndiagram overview for\nC BookLending * Klafim’s Library\nManagement System\nTIP In OOP, code and data are mixed together in classes: data as members and code as\nmethods.\n--- Page 43 ---\n1.2 Sources of complexity 15\nFrom a system analysis perspective, the fact that code and data are mixed together\nmakes the system complex in the sense that entities tend to be involved in many rela-\ntions. In figure 1.11, we take a closer look at the Member class. Member is involved in five\nrelations: two data relations and three code relations.\n Data relations:\n– Library has many Members.\n– Member has many BookLendings.\n Code relations:\n– Member extends User.\n– Librarian uses Member.\n– Member uses BookItem.\nC Librarian\nC Library * C Member\n*\nC User C BookLending C BookItem Figure 1.11 The class Member is\ninvolved in five relations.\nImagine for a moment that we were able, somehow, to split the Member class into two\nseparate entities:\n MemberCode for the code\n MemberData for the data\nInstead of a Member class with five relations, we would have the diagram shown in fig-\nure 1.12 with:\n A MemberCode entity and three relations.\n A MemberData entity and two relations.\nC Library C Librarian\n*\nC MemberData C MemberCode\n*\nC BookLending C User C BookItem Figure 1.12 A class diagram where Member\nis split into code and data entities\n--- Page 44 ---\n16 CHAPTER 1 Complexity of object-orientedprogramming\nThe class diagram where Member is split into MemberCode and MemberData is made of\ntwo independent parts. Each part is easier to understand than the original diagram.\nLet’s split every class of our original class diagram into code and data entities.\nFigure 1.13 shows the resulting diagram. Now the system is made of two indepen-\ndent parts:\n A part that involves only data entities.\n A part that involves only code entities.\nC LibraryData * C LibrarianData C CatalogCode\n*\nC MemberData C CatalogData C LibrarianCode\n*\nC BookData C MemberCode C BookLendingCode C BookItemCode\n*\n* *\nC BookItemData C AuthorData C UserCode C BookItem\n*\nC BookLendingData\nFigure 1.13 A class diagram where every class is split into code and data entities\nTIP A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\nThe resulting system, made up of two independent subsystems, is easier to understand\nthan the original system. The fact that the two subsystems are independent means that\neach subsystem can be understood separately and in any order. The resulting system\nnot simpler by accident; it is a logical consequence of separating code from data.\nTIP A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n1.2.2 Unpredictable code behavior\nYou might be a bit tired after the system-level analysis that we presented in the previ-\nous section. Let’s get refreshed and look at some code.\nTake a look at the code in listing 1.1, where we get the blocked status of a member\nand display it twice. If I tell you that when I called displayBlockedStatusTwice, the\nprogram displayed true on the first console.log call, can you tell me what the pro-\ngram displayed on the second console.log call?\n--- Page 45 ---\n1.2 Sources of complexity 17\nListing1.1 Really simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nvar isBlocked = this.isBlocked;\nconsole.log(isBlocked);\nconsole.log(isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\n“Of course, it displayed true again,” you say. And you are right!\nNow, take a look at a slightly different pseudocode as shown in listing 1.2. Here we\ndisplay, twice, the blocked status of a member without assigning a variable. Same ques-\ntion as before: if I tell you that when I called displayBlockedStatusTwice, the pro-\ngram displayed true on the first console.log call, can you tell me what the program\ndisplayed on the second console.log call?\nListing1.2 Apparently simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nconsole.log(this.isBlocked);\nconsole.log(this.isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\nThe correct answer is...in a single-threaded environment, it displays true, while in a\nmulti-threaded environment, it’s unpredictable. Indeed, in a multi-threaded environ-\nment between the two console.log calls, there could be a context switch that changes\nthe state of the object (e.g., a librarian unblocked the member). In fact, with a slight\nmodification, the same kind of code unpredictability could occur even in a single-\nthreaded environment like JavaScript, when data is modified via asynchronous code\n(see the section about Principle #3 in appendix A). The difference between the two\ncode snippets is that\n In the first listing (listing 1.1), we access a Boolean value twice , which is a prim-\nitive value.\n In the second listing (listing 1.2), we access a member of an object twice.\nTIP When data is mutable, code is unpredictable.\n--- Page 46 ---\n18 CHAPTER 1 Complexity of object-orientedprogramming\nThis unpredictable behavior of the second listing is one of the annoying conse-\nquences of OOP. Unlike primitive types, which are usually immutable, object mem-\nbers are mutable. One way to solve this problem in OOP is to protect sensitive code\nwith concurrency safety mechanisms like mutexes, but that introduces issues like a\nperformance hit and a risk of deadlocks.\nWe will see later in the book that DOP treats every piece of data in the same way:\nboth primitive types and collection types are immutable values. This value treatment for\nall citizens brings serenity to DOP developers’ minds, and more brain cells are avail-\nable to handle the interesting pieces of the applications they build.\nTIP Data immutability brings serenity to DOP developers’ minds.\n1.2.3 Not trivial data serialization\nTheo is really tired, and he falls asleep at his desk. He’s having dream. In his dream, Nancy\nasks him to make Klafim’s Library Management System accessible via a REST API using\nJSON as a transport layer. Theo has to implement a /search endpoint that receives a\nquery in JSON format and returns the results in JSON format. Listing 1.3 shows an input\nexample of the /search endpoint, and listing 1.4 shows an output example of the /search\nendpoint.\nListing1.3 A JSON input of the /search endpoint\n{\n\"searchCriteria\": \"author\",\n\"query\": \"albert\"\n}\nListing1.4 A JSON output of the /search endpoint\n[\n{\n\"title\": \"The world as I see it\",\n\"authors\": [\n{\n\"fullName\": \"Albert Einstein\"\n}\n]\n},\n{\n\"title\": \"The Stranger\",\n\"authors\": [\n{\n\"fullName\": \"Albert Camus\"\n}\n]\n}\n]\n--- Page 47 ---\n1.2 Sources of complexity 19\nTheo would probably implement the /search endpoint by creating three classes simi-\nlarly to what is shown in the following list and in figure 1.14. (Not surprisingly, every-\nthing in OOP has to be wrapped in a class. Right?)\n SearchController is responsible for handling the query.\n SearchQuery converts the JSON query string into data.\n SearchResult converts the search result data into a JSON string.\nC SearchController\nString handle(searchQuery: String)\nC SearchQuery\nC SearchResult\nC Catalog\nsearchCriteria: String\nSearchResult(books: List<Book>)\nList<Book> search(searchCriteria, queryStr) query: String\nString toJSON()\nSearchQuery(jsonString: String)\n* *\nC Book\nid : String\ntitle : String\nFigure 1.14 The class diagram for SearchController\nThe SearchController (see figure 1.14) would have a single handle method with the\nfollowing flow:\n Creates a SearchQuery object from the JSON query string.\n Retrieves searchCriteria and queryStr from the SearchQuery object.\n Calls the search method of the catalog:Catalog with searchCriteria and\nqueryStr and receives books:List<Book>.\n Creates a SearchResult object with books.\n Converts the SearchResult object to a JSON string.\nWhat about other endpoints, for instance, those allowing librarians to add book items\nthrough /add-book-item? Theo would have to repeat the exact same process and cre-\nate three classes:\n AddBookItemController to handle the query\n BookItemQuery to convert the JSON query string into data\n BookItemResult to convert the search result data into a JSON string\nThe code that deals with JSON deserialization that Theo wrote previously in Search-\nQuery would have to be rewritten in BookItemQuery. Same thing for the code that\ndeals with JSON serialization he wrote previously in SearchResult; it would have to be\nrewritten in BookItemResult.\n--- Page 48 ---\n20 CHAPTER 1 Complexity of object-orientedprogramming\nThe bad news is that Theo would have to repeat the same process for every end-\npoint of the system. Each time he encounters a new kind of JSON input or output,\nhe would have to create a new class and write code. Theo’s dream is turning into a\nnightmare!\nSuddenly, his phone rings, next to where he was resting his head on the desk. As Theo\nwakes up, he realizes that Nancy never asked for JSON. It was all a dream...a really bad\ndream!\nTIP In OOP, data serialization is difficult.\nIt’s quite frustrating that handling JSON serialization and deserialization in OOP\nrequires the addition of so many classes and writing so much code—again and again!\nThe frustration grows when you consider that serializing a search query, a book item\nquery, or any query is quite similar. It comes down to\n Going over data fields.\n Concatenating the name of the data fields and the value of the data fields, sepa-\nrated by a comma.\nWhy is such a simple thing so hard to achieve in OOP? In OOP, data has to follow a\nrigid shape defined in classes, which means that data is locked in members. There is\nno simple way to access data generically.\nTIP In OOP, data is locked in classes as members.\nWe will refine later what we mean by generic access to the data, and we will see how\nDOP provides a generic way to handle JSON serialization and deserialization. Until\nthen, you will have to continue suffering. But at least you are starting to become aware\nof this suffering, and you know that it is avoidable.\n NOTE Most OOP programming languages alleviate a bit of the difficulty involved\nin the conversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n1.2.4 Complex class hierarchies\nOne way to avoid writing the same code twice in OOP involves class inheritance. Indeed,\nwhen every requirement of the system is known up front, you design your class hier-\narchy is such a way that classes with common behavior derive from a base class.\nFigure 1.15 shows an example of this pattern that focuses on the part of our class\ndiagram that deals with members and librarians. Both Librarians and Members need\nthe ability to log in, and they inherit this ability from the User class.\nSo far, so good, but when new requirements are introduced after the system is imple-\nmented, it’s a completely different story. Fast forward to Monday, March 29th, at 11:00 AM,\nwhere two days are left before the deadline (Wednesday at midnight).\n--- Page 49 ---\n1.2 Sources of complexity 21\nC Librarian\nblockMember(member: Member) : Bool\nunblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String Figure 1.15 The part of the\npassword : String class diagram that deals with\nlogin() : Bool members and librarians\nNancy calls Theo with an urgent request. Theo is not sure if it’s a dream or reality. He\npinches himself and he can feel the jolt. It’s definitely reality!\nNancy How is the project doing?\nTheo Fine, Nancy. We’re on schedule to meet the deadline. We’re running our last\nround of regression tests now.\nNancy Fantastic! It means we have time for adding a tiny feature to the system, right?\nTheo Depends what you mean by “tiny.”\nNancy We need to add VIP members to the system.\nTheo What do you mean by VIP members?\nNancy VIP members are allowed to add book items to the library by themselves.\nTheo Hmm...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nI’ll ask you the same question Nancy asked Theo: why is adding VIP members to our\nsystem not a tiny task? After all, Theo has already written the code that allows librari-\nans to add book items to the library (it’s in Librarian::addBookItem). What prevents\nhim from reusing this code for VIP members? The reason is that, in OOP, the code is\nlocked into classes as methods.\nTIP In OOP, code is locked into classes.\nVIP members are members that are allowed to add book items to the library by them-\nselves. Theo decomposes the customer requirements into two pieces:\n--- Page 50 ---\n22 CHAPTER 1 Complexity of object-orientedprogramming\n VIP members are library members.\n VIP members are allowed to add book items to the library by themselves.\nTheo then decides that he needs a new class, VIPMember. For the first requirement\n(VIP members are library members), it seems reasonable to make VIPMember derive\nfrom Member. However, handling the second requirement (VIP members are allowed\nto add book items) is more complex. He cannot make a VIPMember derive from\nLibrarian because the relation between VIPMember and Librarian is not linear:\n On one hand, VIP members are like librarians in that they are allowed to add\nbook items.\n On the other hand, VIP members are not like librarians in that they are not\nallowed to block members or list the books lent to a member.\nThe problem is that the code that adds book items is locked in the Librarian class.\nThere is no way for the VIPMember class to use this code.\nFigure 1.16 shows one possible solution that makes the code of Librarian::add-\nBookItem available to both Librarian and VIPMember classes. Here are the changes to\nthe previous class diagram:\n A base class UserWithBookItemRight extends User.\n addBookItem moves from Librarian to UserWithBookItemRight.\n Both VIPMember and Librarian extend UserWithBookItemRight.\nC Librarian\nblockMember(member: Member) : Bool C VIPMember\nunblockMember(member: Member) : Bool\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nCC UserWithBookItemRight\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool addBookItem(bookItem: BookItem) : BookItem\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.16 A class diagram for a system with VIP members\nIt wasn’t easy, but Theo manages to handle the change on time, thanks to an all nighter\ncoding on his laptop. He was even able to add new tests to the system and run the regres-\nsion tests again. However, he was so excited that he didn’t pay attention to the diamond\n--- Page 51 ---\n1.2 Sources of complexity 23\nproblem VIPMember introduced in his class diagram due to multiple inheritance: VIPMember\nextends both Member and UserWithBookItemRight, which both extend User.\nWednesday, March 31, at 10:00 AM (14 hours before the deadline), Theo calls Nancy to\ntell her the good news.\nTheo We were able to add VIP members to the system on time, Nancy.\nNancy Fantastic! I told you it was a tiny feature.\nTheo Yeah, well...\nNancy Look, I was going to call you anyway. I just finished a meeting with my business\npartner, and we realized that we need another tiny feature before the launch.\nWill you be able to handle it before the deadline?\nTheo Again, it depends what you mean by “tiny.”\nNancy We need to add Super members to the system.\nTheo What do you mean by Super members?\nNancy Super members are allowed to list the books lent to other members.\nTheo Err...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nAs with VIP members, adding Super members to the system requires changes to Theo’s\nclass hierarchy. Figure 1.17 shows the solution Theo has in mind.\nC Librarian\nC VIPMember C SuperMember\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC UserWithBlockMemberRight\nCC UserWithBookItemRight\nblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\nunblockMember(member: Member) : Bool\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.17 A class diagram for a system with Super and VIP members\nThe addition of Super members has made the system really complex. Theo suddenly\nnotices that he has three diamonds in his class diagram—not gemstones but three “Deadly\n--- Page 52 ---\n24 CHAPTER 1 Complexity of object-orientedprogramming\nDiamonds of Death” as OOP developers sometimes name the ambiguity that arises when a\nclass D inherits from two classes B and C, where both inherit from class A!\nHe tries to avoid the diamonds by transforming the User class into an interface and\nusing the composition over inheritance design pattern. But with the stress of the deadline\nlooming, he isn’t able to use all of his brain cells. In fact, the system has become so com-\nplex, he’s unable to deliver the system by the deadline. Theo tells himself that he should\nhave used composition instead of class inheritance. But, it’s too late now.\nTIP In OOP, prefer composition over class inheritance.\nAt 10:00 PM, two hours before the deadline, Theo calls Nancy to explain the situation.\nTheo Look Nancy, we really did our best, but we won’t be able to add Super mem-\nbers to the system before the deadline.\nNancy No worries, my business partner and I decided to omit this feature for now.\nWe’ll add it later.\nWith mixed feelings of anger and relief, Theo stops pacing around his office. He realizes\nhe will be spending tonight in his own bed, rather than plowing away on his computer at\nthe office. That should make his wife happy.\nTheo I guess that means we’re ready for the launch tomorrow morning.\nNancy Yes. We’ll offer this new product for a month or so, and if we get good market\ntraction, we’ll move forward with a bigger project.\nTheo Cool. Let’s be in touch in a month then. Good luck on the launch!\nSummary\n Complexity in the context of this book means hard to understand.\n We use the terms code and behavior interchangeably.\n DOP stands for data-oriented programming.\n OOP stands for object-oriented programming.\n FP stands for functional programming.\n In a composition relation, when one object dies, the other one also dies.\n A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\n In an association relation, each object has an independent life cycle.\n A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\n Dashed arrows indicate a usage relation; for instance, when a class uses a method\nof another class.\n Plain arrows with empty triangles represent class inheritance, where the arrow\npoints towards the superclass.\n The design presented in this chapter doesn’t pretend to be the smartest OOP\ndesign. Experienced OOP developers would probably use a couple of design\npatterns and suggest a much better diagram.\n--- Page 53 ---\nSummary 25\n Traditional OOP systems tend to increase system complexity, in the sense that\nOOP systems are hard to understand.\n In traditional OOP, code and data are mixed together in classes: data as mem-\nbers and code as methods.\n In traditional OOP, data is mutable.\n The root cause of the increase in complexity is related to the mixing of code\nand data together into objects.\n When code and data are mixed, classes tend to be involved in many relations.\n When objects are mutable, extra thinking is required in order to understand\nhow the code behaves.\n When objects are mutable, explicit synchronization mechanisms are required\non multi-threaded environments.\n When data is locked in objects, data serialization is not trivial.\n When code is locked in classes, class hierarchies tend to be complex.\n A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\n A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n When data is mutable, code is unpredictable.\n A strategic use of design patterns can help mitigate complexity in traditional\nOOP to some degree.\n Data immutability brings serenity to DOP developers’ minds.\n Most OOP programming languages alleviate slightly the difficulty involved the\nconversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n In traditional OOP, data serialization is difficult.\n In traditional OOP, data is locked in classes as members.\n In traditional OOP, code is locked into classes.\n DOP reduces complexity by rethinking data.\n DOP is compatible both with OOP and FP.\n--- Page 54 ---\nSeparation between\ncode and data\nA whole new world\nThis chapter covers\n The benefits of separating code from data\n Designing a system where code and data are\nseparate\n Implementing a system that respects the\nseparation between code and data\nThe first insight of DOP is that we can decrease the complexity of our systems by\nseparating code from data. Indeed, when code is separated from data, our systems\nare made of two main pieces that can be thought about separately: data entities and\ncode modules. This chapter is a deep dive in the first principle of DOP (summa-\nrized in figure 2.1).\nPRINCIPLE #1 Separate code from data such that the code resides in functions,\nwhose behavior doesn’t depend on data that is somehow encapsulated in the func-\ntion’s context.\n26\n--- Page 55 ---\n2.1 The two parts of a DOP system 27\nStateless (static)\nFunctions\nData asfirst argument\nCode modules\nUsage\nRelations\nNo inheritance\nSeparate code from data\nOnly members\nData entities No code\nAssociation\nRelations\nComposition\nFigure 2.1 DOP principle #1 summarized: Separate code from data.\nIn this chapter, we’ll illustrate the separation between code and data in the context of\nKlafim’s Library Management System that we introduced in chapter 1. We’ll also unveil\nthe benefits that this separation brings to the system:\n The system is simple. It is easy to understand.\n The system is flexible and extensible. Quite often, it requires no design changes to\nadapt to changing requirements.\nThis chapter focuses on the design of the code in a system where code and data are\nseparate. In the next chapter, we’ll focus on the design of the data. As we progress in\nthe book, we’ll discover other benefits of separating code from data.\n2.1 The two parts of a DOP system\nWhile Theo is driving home after delivering the prototype, he asks himself whether the\nKlafim project was a success or not. Sure, he was able to satisfy the customer, but it was\nmore luck than brains. He wouldn’t have made it on time if Nancy had decided to keep\nthe Super members feature. Why was it so complicated to add tiny features to the system?\nWhy was the system he built so complex? He thought there should be a way to build more\nflexible systems!\nThe next morning, Theo asks on Hacker News and on Reddit for ways to reduce system\ncomplexity and build flexible systems. Some folks mention using different programming\nlanguages, while others talk about advanced design patterns. Finally, Theo’s attention gets\ncaptured by a comment from a user named Joe. He mentions data-oriented programming and\nclaims that its main goal is to reduce system complexity. Theo has never heard this term\nbefore. Out of curiosity, he decides to contact Joe by email. What a coincidence! Joe lives\nin San Francisco too. Theo invites him to a meeting in his office.\nJoe is a 40-year-old developer. He was a Java developer for nearly a decade before adopt-\ning Clojure around 7 years ago. When Theo tells Joe about the Library Management System",
        "sections_found": []
      },
      "accurate_page_range": "32-55"
    },
    {
      "text": "- 1.1.2 UML 101",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "raw_line": "- 1.1.2 UML 101 (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 5,
      "chapter_info": {
        "page": 32,
        "title": "Complexity of object-oriented programming",
        "pattern_matched": "Chapter 1",
        "text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased "
      },
      "chapter_sections": {
        "start_page": 32,
        "end_page": 55,
        "content": "\n--- Page 32 ---\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, and their new project were introduced in the opener for part 1.\nTake a moment to read the opener if you missed it.\nTheo gets back to the office with Nancy’s napkin in his pocket and a lot of anxiety in his\nheart because he knows he has committed to a tough deadline. But he had no choice! Last\nweek, Monica, his boss, told him quite clearly that he had to close the deal with Nancy no\nmatter what.\nAlbatross, where Theo works, is a software consulting company with customers all over\nthe world. It originally had lots of customers among startups. Over the last year, however,\nmany projects were badly managed, and the Startup department lost the trust of its cus-\ntomers. That’s why management moved Theo from the Enterprise department to the\nStartup department as a Senior Tech lead. His job is to close deals and to deliver on time.\n1.1.1 The design phase\nBefore rushing to his laptop to code the system, Theo grabs a sheet of paper, much big-\nger than a napkin, and starts to draw a UML class diagram of the system that will imple-\nment the Klafim prototype. Theo is an object-oriented programmer. For him, there is no\nquestion—every business entity is represented by an object, and every object is made\nfrom a class.\nThe requirements for the Klafim prototype\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There can be several copies of a book.\n A book belongs to a physical library.\nTheo spends some time thinking about the organization of the system. He identifies the\nmain classes for the Klafim Global Library Management System.\n--- Page 33 ---\n1.1 OOP design: Classic or classical? 5\nThe main classes of the library management system\n Library—The central part of the system design.\n Book—A book.\n BookItem—A book can have multiple copies, and each copy is considered as\na book item.\n BookLending—When a book is lent, a book lending object is created.\n Member—A member of the library.\n Librarian—A librarian.\n User—A base class for Librarian and Member.\n Catalog—Contains a list of books.\n Author—A book author.\nThat was the easy part. Now comes the difficult part: the relations between the classes.\nAfter two hours or so, Theo comes up with a first draft of a design for the Global Library\nManagement System. It looks like the diagram in figure 1.1.\n NOTE The design presented here doesn’t pretend to be the smartest OOP design:\nexperienced OOP developers would probably use a couple of design patterns to sug-\ngest a much better design. This design is meant to be naive and by no means covers all\nthe features of the system. It serves two purposes:\n For Theo, the developer, it is rich enough to start coding.\n For me, the author of the book, it is rich enough to illustrate the complexity of a\ntypical OOP system.\nTheo feels proud of himself and of the design diagram he just produced. He definitely\ndeserves a cup of coffee!\nNear the coffee machine, Theo meets Dave, a junior software developer who joined\nAlbatross a couple of weeks ago. Theo and Dave appreciate each other, as Dave’s curiosity\nleads him to ask challenging questions. Meetings near the coffee machine often turn into\ninteresting discussions about programming.\nTheo Hey Dave! How’s it going?\nDave Today? Not great. I’m trying to fix a bug in my code! I can’t understand why\nthe state of my objects always changes. I’ll figure it out though, I’m sure. How’s\nyour day going?\nTheo I just finished the design of a system for a new customer.\nDave Cool! Would it be OK for me to see it? I’m trying to improve my design skills.\nTheo Sure! I have the diagram on my desk. We can take a look now if you like.\n--- Page 34 ---\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool\nid : String block() : Bool\nfullName: String unblock() : Bool\nreturnBook(bookLending: BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\n*\nC User\nC BookItem\nid : String\nid : String\nemail : String\nlibId: String\npassword : String\ncheckout(member: Member) : BookLending\nlogin() : Bool\nC BookLending\nid : String\nlendingDate : date *\ndueDate : date\nisLate() : Bool\nreturnBook() : Bool\nFigure 1.1 A class diagram for Klafim’s Global Library Management System\n1.1.2 UML 101\nLatte in hand, Dave follows Theo to his desk. Theo proudly shows Dave his piece of art: the\nUML diagram for the Library Management System (figure 1.1). Dave seems really excited.\nDave Wow! Such a detailed class diagram.\nTheo Yeah. I’m pretty happy with it.\n--- Page 35 ---\n1.1 OOP design: Classic or classical? 7\nDave The thing is that I can never remember the meaning of the different arrows.\nTheo There are four types of arrows in my class diagram: composition, association,\ninheritance, and usage.\nDave What’s the difference between composition and association?\n NOTE Don’t worry if you’re not familiar with OOP jargon. We’re going to leave it\naside in the next chapter.\nTheo It’s all about whether the objects can live without each other. With composi-\ntion, when one object dies, the other one dies too. While in an association rela-\ntion, each object has an independent life.\nTIP In a composition relation, when one object dies, the other one also dies. While\nin an association relation, each object has an independent life cycle.\nIn the class diagram, there are two kinds of composition symbolized by an arrow with\na plain diamond at one edge and an optional star at the other edge. Figure 1.2 shows\nthe relation between:\n A Library that owns a Catalog—A one-to-one composition. If a Library object\ndies, then its Catalog object dies with it.\n A Library that owns many Members—A one-to-many composition. If a Library\nobject dies, then all its Member objects die with it.\nC Library\nname : String * C Member\naddress : String\nFigure 1.2 The two kinds of\nC Catalog composition: one-to-one and\none-to-many. In both cases,\nList<Book> search(searchCriteria, queryStr) when an object dies, the\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\ncomposed object dies with it.\nTIP A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\nDave Do you have association relations in your diagram?\nTheo Take a look at the arrow between Book and Author. It has an empty diamond\nand a star at both edges, so it’s a many-to-many association relation.\nA book can be written by multiple authors, and an author can write multiple books.\nMoreover, Book and Author objects can live independently. The relation between\nbooks and authors is a many-to-many association (figure 1.3).\n--- Page 36 ---\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the Librarian::blockMember method. It calls\nMember::block.\nTIP Dashed arrows indicate usage relations (figure 1.4), for instance, when a class\nuses a method of another class.\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember(member: Member)\nC Member\nBool isBlocked()\nBool block()\nBool unblock()\nBool returnBook(bookLending: BookLending) Figure 1.4 Usage relation: a class\nBookLending checkout(bookItem: BookItem) uses a method of another class.\nDave I see. And I guess a plain arrow with an empty triangle, like the one between\nMember and User, represents inheritance.\nTheo Absolutely!\nTIP Plain arrows with empty triangles represent class inheritance (figure 1.5), where\nthe arrow points towards the superclass.\n--- Page 37 ---\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasure. Want to see how it all fits together?\nDave What class should we look at first?\nTheo I think we should start with Library.\nTHE LIBRARY CLASS\nThe Library is the root class of the library system. Figure 1.6 shows the system structure.\nCC Library\nname : String\naddress : String\n*\nC Member\nC Catalog\nBool isBlocked()\nList<Book> search(searchCriteria, queryStr) Bool block()\nBookItem addBookItem(librarian: Librarian, Bool unblock()\nbookItem: BookItem) Bool returnBook(bookLending: BookLending)\nBookLending checkout(bookItem: BookItem)\n*\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember\n(member: Member)\nFigure 1.6 The Library class\n--- Page 38 ---\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC Member C Librarian\nisBlocked() : Bool blockMember(member: Member) : Bool\nblock() : Bool unblockMember(member: Member) : Bool\nunblock() : Bool addBookItem(bookItem: BookItem) : BookItem\nreturnBook(bookLending : BookLending) : Bool : Member) :\ncheckout(bookItem: BookItem) : BookLending\nCC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.7 Librarian and Member derive from User.\nThe User class represents a user of the library:\n In terms of data members, it sticks to the bare minimum: it has an id, email,\nand password (with no security and encryption for now).\n In terms of code, it can log in via login.\nThe Member class represents a member of the library:\n It inherits from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Check out a book via checkout.\n– Return a book via returnBook.\n– Block itself via block.\n– Unblock itself via unblock.\n– Answer if it is blocked via isBlocked.\n It owns multiple BookLending objects.\n It uses BookItem in order to implement checkout.\n--- Page 39 ---\n1.1 OOP design: Classic or classical? 11\nThe Librarian class represents a librarian:\n It derives from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Block and unblock a Member.\n– List the member’s book lendings via getBookLendings.\n– Add book items to the library via addBookItem.\n It uses Member to implement blockMember, unblockMember, and getBook-\nLendings.\n It uses BookItem to implement checkout.\n It uses BookLending to implement getBookLendings.\nTHE CATALOG CLASS\nThe Catalog class is responsible for the management of the books. Figure 1.8 shows\nthe relation among the Catalog, Librarian, and Book classes. In terms of code, a\nCatalog object can\n Search books via search.\n Add book items to the library via addBookItem.\nC Catalog\nList<Book> search(searchCriteria, queryStr)\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\nC Librarian *\nC Book\nBool blockMember(member: Member)\nBool unblockMember(member: Member) id : String\nBookItem addBookItem(bookItem: BookItem) title : String\nList<BookLending> getBookLendingsOfMember (member: Member)\nFigure 1.8 The Catalog class\nA Catalog object uses Librarian in order to implement addBookItem. In terms of\ndata, a Catalog owns multiple Book objects.\nTHE BOOK CLASS\nFigure 1.9 presents the Book class. In terms of data, a Book object\n Should have as its bare minimum an id and a title.\n Is associated with multiple Author objects (a book might have multiple authors).\n Owns multiple BookItem objects, one for each copy of the book.\n--- Page 40 ---\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare minimum data for members: an id and a libId (for its\nphysical library ID).\n Owns multiple BookLending objects, one for each time the book is lent.\nIn terms of code, a BookItem object can be checked out via checkout.\n1.1.4 The implementation phase\nAfter this detailed investigation of Theo’s diagrams, Dave lets it sink in as he slowly sips his\ncoffee. He then expresses his admiration to Theo.\nDave Wow! That’s amazing!\nTheo Thank you.\nDave I didn’t realize people were really spending the time to write down their design\nin such detail before coding.\nTheo I always do that. It saves me lot of time during the coding phase.\nDave When will you start coding?\nTheo When I finish my latte.\nTheo grabs his coffee mug and notices that his hot latte has become an iced latte. He was\nso excited to show his class diagram to Dave that he forgot to drink it!\n--- Page 41 ---\n1.2 Sources of complexity 13\n1.2 Sources of complexity\nWhile Theo is getting himself another cup of coffee (a cappuccino this time), I\nwould like to challenge his design. It might look beautiful and clear on the paper,\nbut I claim that this design makes the system hard to understand. It’s not that Theo\npicked the wrong classes or that he misunderstood the relations among the classes.\nIt goes much deeper:\n It’s about the programming paradigm he chose to implement the system.\n It’s about the object-oriented paradigm.\n It’s about the tendency of OOP to increase the complexity of a system.\nTIP OOP has a tendency to create complex systems.\nThroughout this book, the type of complexity I refer to is that which makes systems\nhard to understand as defined in the paper, “Out of the Tar Pit,” by Ben Moseley\nand Peter Marks (2006), available at http://mng.bz/enzq. It has nothing to do with\nthe type of complexity that deals with the amount of resources consumed by a pro-\ngram. Similarly, when I refer to simplicity, I mean not complex (in other words, easy\nto understand).\nKeep in mind that complexity and simplicity (like hard and easy) are not absolute\nbut relative concepts. We can compare the complexity of two systems and determine\nwhether system A is more complex (or simpler) than system B.\n NOTE Complexity in the context of this book means hard to understand.\nAs mentioned in the introduction of this chapter, there are many ways in OOP to\nalleviate complexity. The purpose of this book is not be critical of OOP, but rather\nto present a programming paradigm called data-oriented programming (DOP) that\ntends to build systems that are less complex. In fact, the DOP paradigm is compati-\nble with OOP.\nIf one chooses to build an OOP system that adheres to DOP principles, the system\nwill be less complex. According to DOP, the main sources of complexity in Theo’s sys-\ntem (and of many traditional OOP systems) are that\n Code and data are mixed.\n Objects are mutable.\n Data is locked in objects as members.\n Code is locked into classes as methods.\nThis analysis is similar to what functional programming (FP) thinks about traditional\nOOP. However, as we will see throughout the book, the data approach that DOP takes\nin order to reduce system complexity differs from the FP approach. In appendix A, we\nillustrate how to apply DOP principles both in OOP and in FP styles.\nTIP DOP is compatible both with OOP and FP.\n--- Page 42 ---\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Extra thinking is needed when reading code.\nObjects are mutable. Explicit synchronization is required on multi-threaded environments.\nData is locked in objects. Data serialization is not trivial.\nCode is locked in classes. Class hierarchies are complex.\n1.2.1 Many relations between classes\nOne way to assess the complexity of a class diagram is to look only at the entities and\ntheir relations, ignoring members and methods, as in figure 1.10. When we design a\nsystem, we have to define the relations between different pieces of code and data.\nThat’s unavoidable.\nC Library\nC Catalog\n* *\nC Book C Librarian\n*\n*\nC Member\n*\nC Author\nC BookItem C User\nFigure 1.10 A class\ndiagram overview for\nC BookLending * Klafim’s Library\nManagement System\nTIP In OOP, code and data are mixed together in classes: data as members and code as\nmethods.\n--- Page 43 ---\n1.2 Sources of complexity 15\nFrom a system analysis perspective, the fact that code and data are mixed together\nmakes the system complex in the sense that entities tend to be involved in many rela-\ntions. In figure 1.11, we take a closer look at the Member class. Member is involved in five\nrelations: two data relations and three code relations.\n Data relations:\n– Library has many Members.\n– Member has many BookLendings.\n Code relations:\n– Member extends User.\n– Librarian uses Member.\n– Member uses BookItem.\nC Librarian\nC Library * C Member\n*\nC User C BookLending C BookItem Figure 1.11 The class Member is\ninvolved in five relations.\nImagine for a moment that we were able, somehow, to split the Member class into two\nseparate entities:\n MemberCode for the code\n MemberData for the data\nInstead of a Member class with five relations, we would have the diagram shown in fig-\nure 1.12 with:\n A MemberCode entity and three relations.\n A MemberData entity and two relations.\nC Library C Librarian\n*\nC MemberData C MemberCode\n*\nC BookLending C User C BookItem Figure 1.12 A class diagram where Member\nis split into code and data entities\n--- Page 44 ---\n16 CHAPTER 1 Complexity of object-orientedprogramming\nThe class diagram where Member is split into MemberCode and MemberData is made of\ntwo independent parts. Each part is easier to understand than the original diagram.\nLet’s split every class of our original class diagram into code and data entities.\nFigure 1.13 shows the resulting diagram. Now the system is made of two indepen-\ndent parts:\n A part that involves only data entities.\n A part that involves only code entities.\nC LibraryData * C LibrarianData C CatalogCode\n*\nC MemberData C CatalogData C LibrarianCode\n*\nC BookData C MemberCode C BookLendingCode C BookItemCode\n*\n* *\nC BookItemData C AuthorData C UserCode C BookItem\n*\nC BookLendingData\nFigure 1.13 A class diagram where every class is split into code and data entities\nTIP A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\nThe resulting system, made up of two independent subsystems, is easier to understand\nthan the original system. The fact that the two subsystems are independent means that\neach subsystem can be understood separately and in any order. The resulting system\nnot simpler by accident; it is a logical consequence of separating code from data.\nTIP A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n1.2.2 Unpredictable code behavior\nYou might be a bit tired after the system-level analysis that we presented in the previ-\nous section. Let’s get refreshed and look at some code.\nTake a look at the code in listing 1.1, where we get the blocked status of a member\nand display it twice. If I tell you that when I called displayBlockedStatusTwice, the\nprogram displayed true on the first console.log call, can you tell me what the pro-\ngram displayed on the second console.log call?\n--- Page 45 ---\n1.2 Sources of complexity 17\nListing1.1 Really simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nvar isBlocked = this.isBlocked;\nconsole.log(isBlocked);\nconsole.log(isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\n“Of course, it displayed true again,” you say. And you are right!\nNow, take a look at a slightly different pseudocode as shown in listing 1.2. Here we\ndisplay, twice, the blocked status of a member without assigning a variable. Same ques-\ntion as before: if I tell you that when I called displayBlockedStatusTwice, the pro-\ngram displayed true on the first console.log call, can you tell me what the program\ndisplayed on the second console.log call?\nListing1.2 Apparently simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nconsole.log(this.isBlocked);\nconsole.log(this.isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\nThe correct answer is...in a single-threaded environment, it displays true, while in a\nmulti-threaded environment, it’s unpredictable. Indeed, in a multi-threaded environ-\nment between the two console.log calls, there could be a context switch that changes\nthe state of the object (e.g., a librarian unblocked the member). In fact, with a slight\nmodification, the same kind of code unpredictability could occur even in a single-\nthreaded environment like JavaScript, when data is modified via asynchronous code\n(see the section about Principle #3 in appendix A). The difference between the two\ncode snippets is that\n In the first listing (listing 1.1), we access a Boolean value twice , which is a prim-\nitive value.\n In the second listing (listing 1.2), we access a member of an object twice.\nTIP When data is mutable, code is unpredictable.\n--- Page 46 ---\n18 CHAPTER 1 Complexity of object-orientedprogramming\nThis unpredictable behavior of the second listing is one of the annoying conse-\nquences of OOP. Unlike primitive types, which are usually immutable, object mem-\nbers are mutable. One way to solve this problem in OOP is to protect sensitive code\nwith concurrency safety mechanisms like mutexes, but that introduces issues like a\nperformance hit and a risk of deadlocks.\nWe will see later in the book that DOP treats every piece of data in the same way:\nboth primitive types and collection types are immutable values. This value treatment for\nall citizens brings serenity to DOP developers’ minds, and more brain cells are avail-\nable to handle the interesting pieces of the applications they build.\nTIP Data immutability brings serenity to DOP developers’ minds.\n1.2.3 Not trivial data serialization\nTheo is really tired, and he falls asleep at his desk. He’s having dream. In his dream, Nancy\nasks him to make Klafim’s Library Management System accessible via a REST API using\nJSON as a transport layer. Theo has to implement a /search endpoint that receives a\nquery in JSON format and returns the results in JSON format. Listing 1.3 shows an input\nexample of the /search endpoint, and listing 1.4 shows an output example of the /search\nendpoint.\nListing1.3 A JSON input of the /search endpoint\n{\n\"searchCriteria\": \"author\",\n\"query\": \"albert\"\n}\nListing1.4 A JSON output of the /search endpoint\n[\n{\n\"title\": \"The world as I see it\",\n\"authors\": [\n{\n\"fullName\": \"Albert Einstein\"\n}\n]\n},\n{\n\"title\": \"The Stranger\",\n\"authors\": [\n{\n\"fullName\": \"Albert Camus\"\n}\n]\n}\n]\n--- Page 47 ---\n1.2 Sources of complexity 19\nTheo would probably implement the /search endpoint by creating three classes simi-\nlarly to what is shown in the following list and in figure 1.14. (Not surprisingly, every-\nthing in OOP has to be wrapped in a class. Right?)\n SearchController is responsible for handling the query.\n SearchQuery converts the JSON query string into data.\n SearchResult converts the search result data into a JSON string.\nC SearchController\nString handle(searchQuery: String)\nC SearchQuery\nC SearchResult\nC Catalog\nsearchCriteria: String\nSearchResult(books: List<Book>)\nList<Book> search(searchCriteria, queryStr) query: String\nString toJSON()\nSearchQuery(jsonString: String)\n* *\nC Book\nid : String\ntitle : String\nFigure 1.14 The class diagram for SearchController\nThe SearchController (see figure 1.14) would have a single handle method with the\nfollowing flow:\n Creates a SearchQuery object from the JSON query string.\n Retrieves searchCriteria and queryStr from the SearchQuery object.\n Calls the search method of the catalog:Catalog with searchCriteria and\nqueryStr and receives books:List<Book>.\n Creates a SearchResult object with books.\n Converts the SearchResult object to a JSON string.\nWhat about other endpoints, for instance, those allowing librarians to add book items\nthrough /add-book-item? Theo would have to repeat the exact same process and cre-\nate three classes:\n AddBookItemController to handle the query\n BookItemQuery to convert the JSON query string into data\n BookItemResult to convert the search result data into a JSON string\nThe code that deals with JSON deserialization that Theo wrote previously in Search-\nQuery would have to be rewritten in BookItemQuery. Same thing for the code that\ndeals with JSON serialization he wrote previously in SearchResult; it would have to be\nrewritten in BookItemResult.\n--- Page 48 ---\n20 CHAPTER 1 Complexity of object-orientedprogramming\nThe bad news is that Theo would have to repeat the same process for every end-\npoint of the system. Each time he encounters a new kind of JSON input or output,\nhe would have to create a new class and write code. Theo’s dream is turning into a\nnightmare!\nSuddenly, his phone rings, next to where he was resting his head on the desk. As Theo\nwakes up, he realizes that Nancy never asked for JSON. It was all a dream...a really bad\ndream!\nTIP In OOP, data serialization is difficult.\nIt’s quite frustrating that handling JSON serialization and deserialization in OOP\nrequires the addition of so many classes and writing so much code—again and again!\nThe frustration grows when you consider that serializing a search query, a book item\nquery, or any query is quite similar. It comes down to\n Going over data fields.\n Concatenating the name of the data fields and the value of the data fields, sepa-\nrated by a comma.\nWhy is such a simple thing so hard to achieve in OOP? In OOP, data has to follow a\nrigid shape defined in classes, which means that data is locked in members. There is\nno simple way to access data generically.\nTIP In OOP, data is locked in classes as members.\nWe will refine later what we mean by generic access to the data, and we will see how\nDOP provides a generic way to handle JSON serialization and deserialization. Until\nthen, you will have to continue suffering. But at least you are starting to become aware\nof this suffering, and you know that it is avoidable.\n NOTE Most OOP programming languages alleviate a bit of the difficulty involved\nin the conversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n1.2.4 Complex class hierarchies\nOne way to avoid writing the same code twice in OOP involves class inheritance. Indeed,\nwhen every requirement of the system is known up front, you design your class hier-\narchy is such a way that classes with common behavior derive from a base class.\nFigure 1.15 shows an example of this pattern that focuses on the part of our class\ndiagram that deals with members and librarians. Both Librarians and Members need\nthe ability to log in, and they inherit this ability from the User class.\nSo far, so good, but when new requirements are introduced after the system is imple-\nmented, it’s a completely different story. Fast forward to Monday, March 29th, at 11:00 AM,\nwhere two days are left before the deadline (Wednesday at midnight).\n--- Page 49 ---\n1.2 Sources of complexity 21\nC Librarian\nblockMember(member: Member) : Bool\nunblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String Figure 1.15 The part of the\npassword : String class diagram that deals with\nlogin() : Bool members and librarians\nNancy calls Theo with an urgent request. Theo is not sure if it’s a dream or reality. He\npinches himself and he can feel the jolt. It’s definitely reality!\nNancy How is the project doing?\nTheo Fine, Nancy. We’re on schedule to meet the deadline. We’re running our last\nround of regression tests now.\nNancy Fantastic! It means we have time for adding a tiny feature to the system, right?\nTheo Depends what you mean by “tiny.”\nNancy We need to add VIP members to the system.\nTheo What do you mean by VIP members?\nNancy VIP members are allowed to add book items to the library by themselves.\nTheo Hmm...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nI’ll ask you the same question Nancy asked Theo: why is adding VIP members to our\nsystem not a tiny task? After all, Theo has already written the code that allows librari-\nans to add book items to the library (it’s in Librarian::addBookItem). What prevents\nhim from reusing this code for VIP members? The reason is that, in OOP, the code is\nlocked into classes as methods.\nTIP In OOP, code is locked into classes.\nVIP members are members that are allowed to add book items to the library by them-\nselves. Theo decomposes the customer requirements into two pieces:\n--- Page 50 ---\n22 CHAPTER 1 Complexity of object-orientedprogramming\n VIP members are library members.\n VIP members are allowed to add book items to the library by themselves.\nTheo then decides that he needs a new class, VIPMember. For the first requirement\n(VIP members are library members), it seems reasonable to make VIPMember derive\nfrom Member. However, handling the second requirement (VIP members are allowed\nto add book items) is more complex. He cannot make a VIPMember derive from\nLibrarian because the relation between VIPMember and Librarian is not linear:\n On one hand, VIP members are like librarians in that they are allowed to add\nbook items.\n On the other hand, VIP members are not like librarians in that they are not\nallowed to block members or list the books lent to a member.\nThe problem is that the code that adds book items is locked in the Librarian class.\nThere is no way for the VIPMember class to use this code.\nFigure 1.16 shows one possible solution that makes the code of Librarian::add-\nBookItem available to both Librarian and VIPMember classes. Here are the changes to\nthe previous class diagram:\n A base class UserWithBookItemRight extends User.\n addBookItem moves from Librarian to UserWithBookItemRight.\n Both VIPMember and Librarian extend UserWithBookItemRight.\nC Librarian\nblockMember(member: Member) : Bool C VIPMember\nunblockMember(member: Member) : Bool\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nCC UserWithBookItemRight\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool addBookItem(bookItem: BookItem) : BookItem\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.16 A class diagram for a system with VIP members\nIt wasn’t easy, but Theo manages to handle the change on time, thanks to an all nighter\ncoding on his laptop. He was even able to add new tests to the system and run the regres-\nsion tests again. However, he was so excited that he didn’t pay attention to the diamond\n--- Page 51 ---\n1.2 Sources of complexity 23\nproblem VIPMember introduced in his class diagram due to multiple inheritance: VIPMember\nextends both Member and UserWithBookItemRight, which both extend User.\nWednesday, March 31, at 10:00 AM (14 hours before the deadline), Theo calls Nancy to\ntell her the good news.\nTheo We were able to add VIP members to the system on time, Nancy.\nNancy Fantastic! I told you it was a tiny feature.\nTheo Yeah, well...\nNancy Look, I was going to call you anyway. I just finished a meeting with my business\npartner, and we realized that we need another tiny feature before the launch.\nWill you be able to handle it before the deadline?\nTheo Again, it depends what you mean by “tiny.”\nNancy We need to add Super members to the system.\nTheo What do you mean by Super members?\nNancy Super members are allowed to list the books lent to other members.\nTheo Err...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nAs with VIP members, adding Super members to the system requires changes to Theo’s\nclass hierarchy. Figure 1.17 shows the solution Theo has in mind.\nC Librarian\nC VIPMember C SuperMember\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC UserWithBlockMemberRight\nCC UserWithBookItemRight\nblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\nunblockMember(member: Member) : Bool\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.17 A class diagram for a system with Super and VIP members\nThe addition of Super members has made the system really complex. Theo suddenly\nnotices that he has three diamonds in his class diagram—not gemstones but three “Deadly\n--- Page 52 ---\n24 CHAPTER 1 Complexity of object-orientedprogramming\nDiamonds of Death” as OOP developers sometimes name the ambiguity that arises when a\nclass D inherits from two classes B and C, where both inherit from class A!\nHe tries to avoid the diamonds by transforming the User class into an interface and\nusing the composition over inheritance design pattern. But with the stress of the deadline\nlooming, he isn’t able to use all of his brain cells. In fact, the system has become so com-\nplex, he’s unable to deliver the system by the deadline. Theo tells himself that he should\nhave used composition instead of class inheritance. But, it’s too late now.\nTIP In OOP, prefer composition over class inheritance.\nAt 10:00 PM, two hours before the deadline, Theo calls Nancy to explain the situation.\nTheo Look Nancy, we really did our best, but we won’t be able to add Super mem-\nbers to the system before the deadline.\nNancy No worries, my business partner and I decided to omit this feature for now.\nWe’ll add it later.\nWith mixed feelings of anger and relief, Theo stops pacing around his office. He realizes\nhe will be spending tonight in his own bed, rather than plowing away on his computer at\nthe office. That should make his wife happy.\nTheo I guess that means we’re ready for the launch tomorrow morning.\nNancy Yes. We’ll offer this new product for a month or so, and if we get good market\ntraction, we’ll move forward with a bigger project.\nTheo Cool. Let’s be in touch in a month then. Good luck on the launch!\nSummary\n Complexity in the context of this book means hard to understand.\n We use the terms code and behavior interchangeably.\n DOP stands for data-oriented programming.\n OOP stands for object-oriented programming.\n FP stands for functional programming.\n In a composition relation, when one object dies, the other one also dies.\n A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\n In an association relation, each object has an independent life cycle.\n A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\n Dashed arrows indicate a usage relation; for instance, when a class uses a method\nof another class.\n Plain arrows with empty triangles represent class inheritance, where the arrow\npoints towards the superclass.\n The design presented in this chapter doesn’t pretend to be the smartest OOP\ndesign. Experienced OOP developers would probably use a couple of design\npatterns and suggest a much better diagram.\n--- Page 53 ---\nSummary 25\n Traditional OOP systems tend to increase system complexity, in the sense that\nOOP systems are hard to understand.\n In traditional OOP, code and data are mixed together in classes: data as mem-\nbers and code as methods.\n In traditional OOP, data is mutable.\n The root cause of the increase in complexity is related to the mixing of code\nand data together into objects.\n When code and data are mixed, classes tend to be involved in many relations.\n When objects are mutable, extra thinking is required in order to understand\nhow the code behaves.\n When objects are mutable, explicit synchronization mechanisms are required\non multi-threaded environments.\n When data is locked in objects, data serialization is not trivial.\n When code is locked in classes, class hierarchies tend to be complex.\n A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\n A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n When data is mutable, code is unpredictable.\n A strategic use of design patterns can help mitigate complexity in traditional\nOOP to some degree.\n Data immutability brings serenity to DOP developers’ minds.\n Most OOP programming languages alleviate slightly the difficulty involved the\nconversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n In traditional OOP, data serialization is difficult.\n In traditional OOP, data is locked in classes as members.\n In traditional OOP, code is locked into classes.\n DOP reduces complexity by rethinking data.\n DOP is compatible both with OOP and FP.\n--- Page 54 ---\nSeparation between\ncode and data\nA whole new world\nThis chapter covers\n The benefits of separating code from data\n Designing a system where code and data are\nseparate\n Implementing a system that respects the\nseparation between code and data\nThe first insight of DOP is that we can decrease the complexity of our systems by\nseparating code from data. Indeed, when code is separated from data, our systems\nare made of two main pieces that can be thought about separately: data entities and\ncode modules. This chapter is a deep dive in the first principle of DOP (summa-\nrized in figure 2.1).\nPRINCIPLE #1 Separate code from data such that the code resides in functions,\nwhose behavior doesn’t depend on data that is somehow encapsulated in the func-\ntion’s context.\n26\n--- Page 55 ---\n2.1 The two parts of a DOP system 27\nStateless (static)\nFunctions\nData asfirst argument\nCode modules\nUsage\nRelations\nNo inheritance\nSeparate code from data\nOnly members\nData entities No code\nAssociation\nRelations\nComposition\nFigure 2.1 DOP principle #1 summarized: Separate code from data.\nIn this chapter, we’ll illustrate the separation between code and data in the context of\nKlafim’s Library Management System that we introduced in chapter 1. We’ll also unveil\nthe benefits that this separation brings to the system:\n The system is simple. It is easy to understand.\n The system is flexible and extensible. Quite often, it requires no design changes to\nadapt to changing requirements.\nThis chapter focuses on the design of the code in a system where code and data are\nseparate. In the next chapter, we’ll focus on the design of the data. As we progress in\nthe book, we’ll discover other benefits of separating code from data.\n2.1 The two parts of a DOP system\nWhile Theo is driving home after delivering the prototype, he asks himself whether the\nKlafim project was a success or not. Sure, he was able to satisfy the customer, but it was\nmore luck than brains. He wouldn’t have made it on time if Nancy had decided to keep\nthe Super members feature. Why was it so complicated to add tiny features to the system?\nWhy was the system he built so complex? He thought there should be a way to build more\nflexible systems!\nThe next morning, Theo asks on Hacker News and on Reddit for ways to reduce system\ncomplexity and build flexible systems. Some folks mention using different programming\nlanguages, while others talk about advanced design patterns. Finally, Theo’s attention gets\ncaptured by a comment from a user named Joe. He mentions data-oriented programming and\nclaims that its main goal is to reduce system complexity. Theo has never heard this term\nbefore. Out of curiosity, he decides to contact Joe by email. What a coincidence! Joe lives\nin San Francisco too. Theo invites him to a meeting in his office.\nJoe is a 40-year-old developer. He was a Java developer for nearly a decade before adopt-\ning Clojure around 7 years ago. When Theo tells Joe about the Library Management System",
        "sections_found": []
      },
      "accurate_page_range": "32-55"
    },
    {
      "text": "- 1.1.3 Explaining each piece of the class diagram",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "raw_line": "- 1.1.3 Explaining each piece of the class diagram (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 6,
      "chapter_info": {
        "page": 32,
        "title": "Complexity of object-oriented programming",
        "pattern_matched": "Chapter 1",
        "text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased "
      },
      "chapter_sections": {
        "start_page": 32,
        "end_page": 55,
        "content": "\n--- Page 32 ---\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, and their new project were introduced in the opener for part 1.\nTake a moment to read the opener if you missed it.\nTheo gets back to the office with Nancy’s napkin in his pocket and a lot of anxiety in his\nheart because he knows he has committed to a tough deadline. But he had no choice! Last\nweek, Monica, his boss, told him quite clearly that he had to close the deal with Nancy no\nmatter what.\nAlbatross, where Theo works, is a software consulting company with customers all over\nthe world. It originally had lots of customers among startups. Over the last year, however,\nmany projects were badly managed, and the Startup department lost the trust of its cus-\ntomers. That’s why management moved Theo from the Enterprise department to the\nStartup department as a Senior Tech lead. His job is to close deals and to deliver on time.\n1.1.1 The design phase\nBefore rushing to his laptop to code the system, Theo grabs a sheet of paper, much big-\nger than a napkin, and starts to draw a UML class diagram of the system that will imple-\nment the Klafim prototype. Theo is an object-oriented programmer. For him, there is no\nquestion—every business entity is represented by an object, and every object is made\nfrom a class.\nThe requirements for the Klafim prototype\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There can be several copies of a book.\n A book belongs to a physical library.\nTheo spends some time thinking about the organization of the system. He identifies the\nmain classes for the Klafim Global Library Management System.\n--- Page 33 ---\n1.1 OOP design: Classic or classical? 5\nThe main classes of the library management system\n Library—The central part of the system design.\n Book—A book.\n BookItem—A book can have multiple copies, and each copy is considered as\na book item.\n BookLending—When a book is lent, a book lending object is created.\n Member—A member of the library.\n Librarian—A librarian.\n User—A base class for Librarian and Member.\n Catalog—Contains a list of books.\n Author—A book author.\nThat was the easy part. Now comes the difficult part: the relations between the classes.\nAfter two hours or so, Theo comes up with a first draft of a design for the Global Library\nManagement System. It looks like the diagram in figure 1.1.\n NOTE The design presented here doesn’t pretend to be the smartest OOP design:\nexperienced OOP developers would probably use a couple of design patterns to sug-\ngest a much better design. This design is meant to be naive and by no means covers all\nthe features of the system. It serves two purposes:\n For Theo, the developer, it is rich enough to start coding.\n For me, the author of the book, it is rich enough to illustrate the complexity of a\ntypical OOP system.\nTheo feels proud of himself and of the design diagram he just produced. He definitely\ndeserves a cup of coffee!\nNear the coffee machine, Theo meets Dave, a junior software developer who joined\nAlbatross a couple of weeks ago. Theo and Dave appreciate each other, as Dave’s curiosity\nleads him to ask challenging questions. Meetings near the coffee machine often turn into\ninteresting discussions about programming.\nTheo Hey Dave! How’s it going?\nDave Today? Not great. I’m trying to fix a bug in my code! I can’t understand why\nthe state of my objects always changes. I’ll figure it out though, I’m sure. How’s\nyour day going?\nTheo I just finished the design of a system for a new customer.\nDave Cool! Would it be OK for me to see it? I’m trying to improve my design skills.\nTheo Sure! I have the diagram on my desk. We can take a look now if you like.\n--- Page 34 ---\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool\nid : String block() : Bool\nfullName: String unblock() : Bool\nreturnBook(bookLending: BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\n*\nC User\nC BookItem\nid : String\nid : String\nemail : String\nlibId: String\npassword : String\ncheckout(member: Member) : BookLending\nlogin() : Bool\nC BookLending\nid : String\nlendingDate : date *\ndueDate : date\nisLate() : Bool\nreturnBook() : Bool\nFigure 1.1 A class diagram for Klafim’s Global Library Management System\n1.1.2 UML 101\nLatte in hand, Dave follows Theo to his desk. Theo proudly shows Dave his piece of art: the\nUML diagram for the Library Management System (figure 1.1). Dave seems really excited.\nDave Wow! Such a detailed class diagram.\nTheo Yeah. I’m pretty happy with it.\n--- Page 35 ---\n1.1 OOP design: Classic or classical? 7\nDave The thing is that I can never remember the meaning of the different arrows.\nTheo There are four types of arrows in my class diagram: composition, association,\ninheritance, and usage.\nDave What’s the difference between composition and association?\n NOTE Don’t worry if you’re not familiar with OOP jargon. We’re going to leave it\naside in the next chapter.\nTheo It’s all about whether the objects can live without each other. With composi-\ntion, when one object dies, the other one dies too. While in an association rela-\ntion, each object has an independent life.\nTIP In a composition relation, when one object dies, the other one also dies. While\nin an association relation, each object has an independent life cycle.\nIn the class diagram, there are two kinds of composition symbolized by an arrow with\na plain diamond at one edge and an optional star at the other edge. Figure 1.2 shows\nthe relation between:\n A Library that owns a Catalog—A one-to-one composition. If a Library object\ndies, then its Catalog object dies with it.\n A Library that owns many Members—A one-to-many composition. If a Library\nobject dies, then all its Member objects die with it.\nC Library\nname : String * C Member\naddress : String\nFigure 1.2 The two kinds of\nC Catalog composition: one-to-one and\none-to-many. In both cases,\nList<Book> search(searchCriteria, queryStr) when an object dies, the\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\ncomposed object dies with it.\nTIP A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\nDave Do you have association relations in your diagram?\nTheo Take a look at the arrow between Book and Author. It has an empty diamond\nand a star at both edges, so it’s a many-to-many association relation.\nA book can be written by multiple authors, and an author can write multiple books.\nMoreover, Book and Author objects can live independently. The relation between\nbooks and authors is a many-to-many association (figure 1.3).\n--- Page 36 ---\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the Librarian::blockMember method. It calls\nMember::block.\nTIP Dashed arrows indicate usage relations (figure 1.4), for instance, when a class\nuses a method of another class.\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember(member: Member)\nC Member\nBool isBlocked()\nBool block()\nBool unblock()\nBool returnBook(bookLending: BookLending) Figure 1.4 Usage relation: a class\nBookLending checkout(bookItem: BookItem) uses a method of another class.\nDave I see. And I guess a plain arrow with an empty triangle, like the one between\nMember and User, represents inheritance.\nTheo Absolutely!\nTIP Plain arrows with empty triangles represent class inheritance (figure 1.5), where\nthe arrow points towards the superclass.\n--- Page 37 ---\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasure. Want to see how it all fits together?\nDave What class should we look at first?\nTheo I think we should start with Library.\nTHE LIBRARY CLASS\nThe Library is the root class of the library system. Figure 1.6 shows the system structure.\nCC Library\nname : String\naddress : String\n*\nC Member\nC Catalog\nBool isBlocked()\nList<Book> search(searchCriteria, queryStr) Bool block()\nBookItem addBookItem(librarian: Librarian, Bool unblock()\nbookItem: BookItem) Bool returnBook(bookLending: BookLending)\nBookLending checkout(bookItem: BookItem)\n*\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember\n(member: Member)\nFigure 1.6 The Library class\n--- Page 38 ---\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC Member C Librarian\nisBlocked() : Bool blockMember(member: Member) : Bool\nblock() : Bool unblockMember(member: Member) : Bool\nunblock() : Bool addBookItem(bookItem: BookItem) : BookItem\nreturnBook(bookLending : BookLending) : Bool : Member) :\ncheckout(bookItem: BookItem) : BookLending\nCC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.7 Librarian and Member derive from User.\nThe User class represents a user of the library:\n In terms of data members, it sticks to the bare minimum: it has an id, email,\nand password (with no security and encryption for now).\n In terms of code, it can log in via login.\nThe Member class represents a member of the library:\n It inherits from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Check out a book via checkout.\n– Return a book via returnBook.\n– Block itself via block.\n– Unblock itself via unblock.\n– Answer if it is blocked via isBlocked.\n It owns multiple BookLending objects.\n It uses BookItem in order to implement checkout.\n--- Page 39 ---\n1.1 OOP design: Classic or classical? 11\nThe Librarian class represents a librarian:\n It derives from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Block and unblock a Member.\n– List the member’s book lendings via getBookLendings.\n– Add book items to the library via addBookItem.\n It uses Member to implement blockMember, unblockMember, and getBook-\nLendings.\n It uses BookItem to implement checkout.\n It uses BookLending to implement getBookLendings.\nTHE CATALOG CLASS\nThe Catalog class is responsible for the management of the books. Figure 1.8 shows\nthe relation among the Catalog, Librarian, and Book classes. In terms of code, a\nCatalog object can\n Search books via search.\n Add book items to the library via addBookItem.\nC Catalog\nList<Book> search(searchCriteria, queryStr)\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\nC Librarian *\nC Book\nBool blockMember(member: Member)\nBool unblockMember(member: Member) id : String\nBookItem addBookItem(bookItem: BookItem) title : String\nList<BookLending> getBookLendingsOfMember (member: Member)\nFigure 1.8 The Catalog class\nA Catalog object uses Librarian in order to implement addBookItem. In terms of\ndata, a Catalog owns multiple Book objects.\nTHE BOOK CLASS\nFigure 1.9 presents the Book class. In terms of data, a Book object\n Should have as its bare minimum an id and a title.\n Is associated with multiple Author objects (a book might have multiple authors).\n Owns multiple BookItem objects, one for each copy of the book.\n--- Page 40 ---\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare minimum data for members: an id and a libId (for its\nphysical library ID).\n Owns multiple BookLending objects, one for each time the book is lent.\nIn terms of code, a BookItem object can be checked out via checkout.\n1.1.4 The implementation phase\nAfter this detailed investigation of Theo’s diagrams, Dave lets it sink in as he slowly sips his\ncoffee. He then expresses his admiration to Theo.\nDave Wow! That’s amazing!\nTheo Thank you.\nDave I didn’t realize people were really spending the time to write down their design\nin such detail before coding.\nTheo I always do that. It saves me lot of time during the coding phase.\nDave When will you start coding?\nTheo When I finish my latte.\nTheo grabs his coffee mug and notices that his hot latte has become an iced latte. He was\nso excited to show his class diagram to Dave that he forgot to drink it!\n--- Page 41 ---\n1.2 Sources of complexity 13\n1.2 Sources of complexity\nWhile Theo is getting himself another cup of coffee (a cappuccino this time), I\nwould like to challenge his design. It might look beautiful and clear on the paper,\nbut I claim that this design makes the system hard to understand. It’s not that Theo\npicked the wrong classes or that he misunderstood the relations among the classes.\nIt goes much deeper:\n It’s about the programming paradigm he chose to implement the system.\n It’s about the object-oriented paradigm.\n It’s about the tendency of OOP to increase the complexity of a system.\nTIP OOP has a tendency to create complex systems.\nThroughout this book, the type of complexity I refer to is that which makes systems\nhard to understand as defined in the paper, “Out of the Tar Pit,” by Ben Moseley\nand Peter Marks (2006), available at http://mng.bz/enzq. It has nothing to do with\nthe type of complexity that deals with the amount of resources consumed by a pro-\ngram. Similarly, when I refer to simplicity, I mean not complex (in other words, easy\nto understand).\nKeep in mind that complexity and simplicity (like hard and easy) are not absolute\nbut relative concepts. We can compare the complexity of two systems and determine\nwhether system A is more complex (or simpler) than system B.\n NOTE Complexity in the context of this book means hard to understand.\nAs mentioned in the introduction of this chapter, there are many ways in OOP to\nalleviate complexity. The purpose of this book is not be critical of OOP, but rather\nto present a programming paradigm called data-oriented programming (DOP) that\ntends to build systems that are less complex. In fact, the DOP paradigm is compati-\nble with OOP.\nIf one chooses to build an OOP system that adheres to DOP principles, the system\nwill be less complex. According to DOP, the main sources of complexity in Theo’s sys-\ntem (and of many traditional OOP systems) are that\n Code and data are mixed.\n Objects are mutable.\n Data is locked in objects as members.\n Code is locked into classes as methods.\nThis analysis is similar to what functional programming (FP) thinks about traditional\nOOP. However, as we will see throughout the book, the data approach that DOP takes\nin order to reduce system complexity differs from the FP approach. In appendix A, we\nillustrate how to apply DOP principles both in OOP and in FP styles.\nTIP DOP is compatible both with OOP and FP.\n--- Page 42 ---\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Extra thinking is needed when reading code.\nObjects are mutable. Explicit synchronization is required on multi-threaded environments.\nData is locked in objects. Data serialization is not trivial.\nCode is locked in classes. Class hierarchies are complex.\n1.2.1 Many relations between classes\nOne way to assess the complexity of a class diagram is to look only at the entities and\ntheir relations, ignoring members and methods, as in figure 1.10. When we design a\nsystem, we have to define the relations between different pieces of code and data.\nThat’s unavoidable.\nC Library\nC Catalog\n* *\nC Book C Librarian\n*\n*\nC Member\n*\nC Author\nC BookItem C User\nFigure 1.10 A class\ndiagram overview for\nC BookLending * Klafim’s Library\nManagement System\nTIP In OOP, code and data are mixed together in classes: data as members and code as\nmethods.\n--- Page 43 ---\n1.2 Sources of complexity 15\nFrom a system analysis perspective, the fact that code and data are mixed together\nmakes the system complex in the sense that entities tend to be involved in many rela-\ntions. In figure 1.11, we take a closer look at the Member class. Member is involved in five\nrelations: two data relations and three code relations.\n Data relations:\n– Library has many Members.\n– Member has many BookLendings.\n Code relations:\n– Member extends User.\n– Librarian uses Member.\n– Member uses BookItem.\nC Librarian\nC Library * C Member\n*\nC User C BookLending C BookItem Figure 1.11 The class Member is\ninvolved in five relations.\nImagine for a moment that we were able, somehow, to split the Member class into two\nseparate entities:\n MemberCode for the code\n MemberData for the data\nInstead of a Member class with five relations, we would have the diagram shown in fig-\nure 1.12 with:\n A MemberCode entity and three relations.\n A MemberData entity and two relations.\nC Library C Librarian\n*\nC MemberData C MemberCode\n*\nC BookLending C User C BookItem Figure 1.12 A class diagram where Member\nis split into code and data entities\n--- Page 44 ---\n16 CHAPTER 1 Complexity of object-orientedprogramming\nThe class diagram where Member is split into MemberCode and MemberData is made of\ntwo independent parts. Each part is easier to understand than the original diagram.\nLet’s split every class of our original class diagram into code and data entities.\nFigure 1.13 shows the resulting diagram. Now the system is made of two indepen-\ndent parts:\n A part that involves only data entities.\n A part that involves only code entities.\nC LibraryData * C LibrarianData C CatalogCode\n*\nC MemberData C CatalogData C LibrarianCode\n*\nC BookData C MemberCode C BookLendingCode C BookItemCode\n*\n* *\nC BookItemData C AuthorData C UserCode C BookItem\n*\nC BookLendingData\nFigure 1.13 A class diagram where every class is split into code and data entities\nTIP A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\nThe resulting system, made up of two independent subsystems, is easier to understand\nthan the original system. The fact that the two subsystems are independent means that\neach subsystem can be understood separately and in any order. The resulting system\nnot simpler by accident; it is a logical consequence of separating code from data.\nTIP A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n1.2.2 Unpredictable code behavior\nYou might be a bit tired after the system-level analysis that we presented in the previ-\nous section. Let’s get refreshed and look at some code.\nTake a look at the code in listing 1.1, where we get the blocked status of a member\nand display it twice. If I tell you that when I called displayBlockedStatusTwice, the\nprogram displayed true on the first console.log call, can you tell me what the pro-\ngram displayed on the second console.log call?\n--- Page 45 ---\n1.2 Sources of complexity 17\nListing1.1 Really simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nvar isBlocked = this.isBlocked;\nconsole.log(isBlocked);\nconsole.log(isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\n“Of course, it displayed true again,” you say. And you are right!\nNow, take a look at a slightly different pseudocode as shown in listing 1.2. Here we\ndisplay, twice, the blocked status of a member without assigning a variable. Same ques-\ntion as before: if I tell you that when I called displayBlockedStatusTwice, the pro-\ngram displayed true on the first console.log call, can you tell me what the program\ndisplayed on the second console.log call?\nListing1.2 Apparently simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nconsole.log(this.isBlocked);\nconsole.log(this.isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\nThe correct answer is...in a single-threaded environment, it displays true, while in a\nmulti-threaded environment, it’s unpredictable. Indeed, in a multi-threaded environ-\nment between the two console.log calls, there could be a context switch that changes\nthe state of the object (e.g., a librarian unblocked the member). In fact, with a slight\nmodification, the same kind of code unpredictability could occur even in a single-\nthreaded environment like JavaScript, when data is modified via asynchronous code\n(see the section about Principle #3 in appendix A). The difference between the two\ncode snippets is that\n In the first listing (listing 1.1), we access a Boolean value twice , which is a prim-\nitive value.\n In the second listing (listing 1.2), we access a member of an object twice.\nTIP When data is mutable, code is unpredictable.\n--- Page 46 ---\n18 CHAPTER 1 Complexity of object-orientedprogramming\nThis unpredictable behavior of the second listing is one of the annoying conse-\nquences of OOP. Unlike primitive types, which are usually immutable, object mem-\nbers are mutable. One way to solve this problem in OOP is to protect sensitive code\nwith concurrency safety mechanisms like mutexes, but that introduces issues like a\nperformance hit and a risk of deadlocks.\nWe will see later in the book that DOP treats every piece of data in the same way:\nboth primitive types and collection types are immutable values. This value treatment for\nall citizens brings serenity to DOP developers’ minds, and more brain cells are avail-\nable to handle the interesting pieces of the applications they build.\nTIP Data immutability brings serenity to DOP developers’ minds.\n1.2.3 Not trivial data serialization\nTheo is really tired, and he falls asleep at his desk. He’s having dream. In his dream, Nancy\nasks him to make Klafim’s Library Management System accessible via a REST API using\nJSON as a transport layer. Theo has to implement a /search endpoint that receives a\nquery in JSON format and returns the results in JSON format. Listing 1.3 shows an input\nexample of the /search endpoint, and listing 1.4 shows an output example of the /search\nendpoint.\nListing1.3 A JSON input of the /search endpoint\n{\n\"searchCriteria\": \"author\",\n\"query\": \"albert\"\n}\nListing1.4 A JSON output of the /search endpoint\n[\n{\n\"title\": \"The world as I see it\",\n\"authors\": [\n{\n\"fullName\": \"Albert Einstein\"\n}\n]\n},\n{\n\"title\": \"The Stranger\",\n\"authors\": [\n{\n\"fullName\": \"Albert Camus\"\n}\n]\n}\n]\n--- Page 47 ---\n1.2 Sources of complexity 19\nTheo would probably implement the /search endpoint by creating three classes simi-\nlarly to what is shown in the following list and in figure 1.14. (Not surprisingly, every-\nthing in OOP has to be wrapped in a class. Right?)\n SearchController is responsible for handling the query.\n SearchQuery converts the JSON query string into data.\n SearchResult converts the search result data into a JSON string.\nC SearchController\nString handle(searchQuery: String)\nC SearchQuery\nC SearchResult\nC Catalog\nsearchCriteria: String\nSearchResult(books: List<Book>)\nList<Book> search(searchCriteria, queryStr) query: String\nString toJSON()\nSearchQuery(jsonString: String)\n* *\nC Book\nid : String\ntitle : String\nFigure 1.14 The class diagram for SearchController\nThe SearchController (see figure 1.14) would have a single handle method with the\nfollowing flow:\n Creates a SearchQuery object from the JSON query string.\n Retrieves searchCriteria and queryStr from the SearchQuery object.\n Calls the search method of the catalog:Catalog with searchCriteria and\nqueryStr and receives books:List<Book>.\n Creates a SearchResult object with books.\n Converts the SearchResult object to a JSON string.\nWhat about other endpoints, for instance, those allowing librarians to add book items\nthrough /add-book-item? Theo would have to repeat the exact same process and cre-\nate three classes:\n AddBookItemController to handle the query\n BookItemQuery to convert the JSON query string into data\n BookItemResult to convert the search result data into a JSON string\nThe code that deals with JSON deserialization that Theo wrote previously in Search-\nQuery would have to be rewritten in BookItemQuery. Same thing for the code that\ndeals with JSON serialization he wrote previously in SearchResult; it would have to be\nrewritten in BookItemResult.\n--- Page 48 ---\n20 CHAPTER 1 Complexity of object-orientedprogramming\nThe bad news is that Theo would have to repeat the same process for every end-\npoint of the system. Each time he encounters a new kind of JSON input or output,\nhe would have to create a new class and write code. Theo’s dream is turning into a\nnightmare!\nSuddenly, his phone rings, next to where he was resting his head on the desk. As Theo\nwakes up, he realizes that Nancy never asked for JSON. It was all a dream...a really bad\ndream!\nTIP In OOP, data serialization is difficult.\nIt’s quite frustrating that handling JSON serialization and deserialization in OOP\nrequires the addition of so many classes and writing so much code—again and again!\nThe frustration grows when you consider that serializing a search query, a book item\nquery, or any query is quite similar. It comes down to\n Going over data fields.\n Concatenating the name of the data fields and the value of the data fields, sepa-\nrated by a comma.\nWhy is such a simple thing so hard to achieve in OOP? In OOP, data has to follow a\nrigid shape defined in classes, which means that data is locked in members. There is\nno simple way to access data generically.\nTIP In OOP, data is locked in classes as members.\nWe will refine later what we mean by generic access to the data, and we will see how\nDOP provides a generic way to handle JSON serialization and deserialization. Until\nthen, you will have to continue suffering. But at least you are starting to become aware\nof this suffering, and you know that it is avoidable.\n NOTE Most OOP programming languages alleviate a bit of the difficulty involved\nin the conversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n1.2.4 Complex class hierarchies\nOne way to avoid writing the same code twice in OOP involves class inheritance. Indeed,\nwhen every requirement of the system is known up front, you design your class hier-\narchy is such a way that classes with common behavior derive from a base class.\nFigure 1.15 shows an example of this pattern that focuses on the part of our class\ndiagram that deals with members and librarians. Both Librarians and Members need\nthe ability to log in, and they inherit this ability from the User class.\nSo far, so good, but when new requirements are introduced after the system is imple-\nmented, it’s a completely different story. Fast forward to Monday, March 29th, at 11:00 AM,\nwhere two days are left before the deadline (Wednesday at midnight).\n--- Page 49 ---\n1.2 Sources of complexity 21\nC Librarian\nblockMember(member: Member) : Bool\nunblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String Figure 1.15 The part of the\npassword : String class diagram that deals with\nlogin() : Bool members and librarians\nNancy calls Theo with an urgent request. Theo is not sure if it’s a dream or reality. He\npinches himself and he can feel the jolt. It’s definitely reality!\nNancy How is the project doing?\nTheo Fine, Nancy. We’re on schedule to meet the deadline. We’re running our last\nround of regression tests now.\nNancy Fantastic! It means we have time for adding a tiny feature to the system, right?\nTheo Depends what you mean by “tiny.”\nNancy We need to add VIP members to the system.\nTheo What do you mean by VIP members?\nNancy VIP members are allowed to add book items to the library by themselves.\nTheo Hmm...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nI’ll ask you the same question Nancy asked Theo: why is adding VIP members to our\nsystem not a tiny task? After all, Theo has already written the code that allows librari-\nans to add book items to the library (it’s in Librarian::addBookItem). What prevents\nhim from reusing this code for VIP members? The reason is that, in OOP, the code is\nlocked into classes as methods.\nTIP In OOP, code is locked into classes.\nVIP members are members that are allowed to add book items to the library by them-\nselves. Theo decomposes the customer requirements into two pieces:\n--- Page 50 ---\n22 CHAPTER 1 Complexity of object-orientedprogramming\n VIP members are library members.\n VIP members are allowed to add book items to the library by themselves.\nTheo then decides that he needs a new class, VIPMember. For the first requirement\n(VIP members are library members), it seems reasonable to make VIPMember derive\nfrom Member. However, handling the second requirement (VIP members are allowed\nto add book items) is more complex. He cannot make a VIPMember derive from\nLibrarian because the relation between VIPMember and Librarian is not linear:\n On one hand, VIP members are like librarians in that they are allowed to add\nbook items.\n On the other hand, VIP members are not like librarians in that they are not\nallowed to block members or list the books lent to a member.\nThe problem is that the code that adds book items is locked in the Librarian class.\nThere is no way for the VIPMember class to use this code.\nFigure 1.16 shows one possible solution that makes the code of Librarian::add-\nBookItem available to both Librarian and VIPMember classes. Here are the changes to\nthe previous class diagram:\n A base class UserWithBookItemRight extends User.\n addBookItem moves from Librarian to UserWithBookItemRight.\n Both VIPMember and Librarian extend UserWithBookItemRight.\nC Librarian\nblockMember(member: Member) : Bool C VIPMember\nunblockMember(member: Member) : Bool\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nCC UserWithBookItemRight\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool addBookItem(bookItem: BookItem) : BookItem\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.16 A class diagram for a system with VIP members\nIt wasn’t easy, but Theo manages to handle the change on time, thanks to an all nighter\ncoding on his laptop. He was even able to add new tests to the system and run the regres-\nsion tests again. However, he was so excited that he didn’t pay attention to the diamond\n--- Page 51 ---\n1.2 Sources of complexity 23\nproblem VIPMember introduced in his class diagram due to multiple inheritance: VIPMember\nextends both Member and UserWithBookItemRight, which both extend User.\nWednesday, March 31, at 10:00 AM (14 hours before the deadline), Theo calls Nancy to\ntell her the good news.\nTheo We were able to add VIP members to the system on time, Nancy.\nNancy Fantastic! I told you it was a tiny feature.\nTheo Yeah, well...\nNancy Look, I was going to call you anyway. I just finished a meeting with my business\npartner, and we realized that we need another tiny feature before the launch.\nWill you be able to handle it before the deadline?\nTheo Again, it depends what you mean by “tiny.”\nNancy We need to add Super members to the system.\nTheo What do you mean by Super members?\nNancy Super members are allowed to list the books lent to other members.\nTheo Err...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nAs with VIP members, adding Super members to the system requires changes to Theo’s\nclass hierarchy. Figure 1.17 shows the solution Theo has in mind.\nC Librarian\nC VIPMember C SuperMember\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC UserWithBlockMemberRight\nCC UserWithBookItemRight\nblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\nunblockMember(member: Member) : Bool\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.17 A class diagram for a system with Super and VIP members\nThe addition of Super members has made the system really complex. Theo suddenly\nnotices that he has three diamonds in his class diagram—not gemstones but three “Deadly\n--- Page 52 ---\n24 CHAPTER 1 Complexity of object-orientedprogramming\nDiamonds of Death” as OOP developers sometimes name the ambiguity that arises when a\nclass D inherits from two classes B and C, where both inherit from class A!\nHe tries to avoid the diamonds by transforming the User class into an interface and\nusing the composition over inheritance design pattern. But with the stress of the deadline\nlooming, he isn’t able to use all of his brain cells. In fact, the system has become so com-\nplex, he’s unable to deliver the system by the deadline. Theo tells himself that he should\nhave used composition instead of class inheritance. But, it’s too late now.\nTIP In OOP, prefer composition over class inheritance.\nAt 10:00 PM, two hours before the deadline, Theo calls Nancy to explain the situation.\nTheo Look Nancy, we really did our best, but we won’t be able to add Super mem-\nbers to the system before the deadline.\nNancy No worries, my business partner and I decided to omit this feature for now.\nWe’ll add it later.\nWith mixed feelings of anger and relief, Theo stops pacing around his office. He realizes\nhe will be spending tonight in his own bed, rather than plowing away on his computer at\nthe office. That should make his wife happy.\nTheo I guess that means we’re ready for the launch tomorrow morning.\nNancy Yes. We’ll offer this new product for a month or so, and if we get good market\ntraction, we’ll move forward with a bigger project.\nTheo Cool. Let’s be in touch in a month then. Good luck on the launch!\nSummary\n Complexity in the context of this book means hard to understand.\n We use the terms code and behavior interchangeably.\n DOP stands for data-oriented programming.\n OOP stands for object-oriented programming.\n FP stands for functional programming.\n In a composition relation, when one object dies, the other one also dies.\n A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\n In an association relation, each object has an independent life cycle.\n A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\n Dashed arrows indicate a usage relation; for instance, when a class uses a method\nof another class.\n Plain arrows with empty triangles represent class inheritance, where the arrow\npoints towards the superclass.\n The design presented in this chapter doesn’t pretend to be the smartest OOP\ndesign. Experienced OOP developers would probably use a couple of design\npatterns and suggest a much better diagram.\n--- Page 53 ---\nSummary 25\n Traditional OOP systems tend to increase system complexity, in the sense that\nOOP systems are hard to understand.\n In traditional OOP, code and data are mixed together in classes: data as mem-\nbers and code as methods.\n In traditional OOP, data is mutable.\n The root cause of the increase in complexity is related to the mixing of code\nand data together into objects.\n When code and data are mixed, classes tend to be involved in many relations.\n When objects are mutable, extra thinking is required in order to understand\nhow the code behaves.\n When objects are mutable, explicit synchronization mechanisms are required\non multi-threaded environments.\n When data is locked in objects, data serialization is not trivial.\n When code is locked in classes, class hierarchies tend to be complex.\n A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\n A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n When data is mutable, code is unpredictable.\n A strategic use of design patterns can help mitigate complexity in traditional\nOOP to some degree.\n Data immutability brings serenity to DOP developers’ minds.\n Most OOP programming languages alleviate slightly the difficulty involved the\nconversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n In traditional OOP, data serialization is difficult.\n In traditional OOP, data is locked in classes as members.\n In traditional OOP, code is locked into classes.\n DOP reduces complexity by rethinking data.\n DOP is compatible both with OOP and FP.\n--- Page 54 ---\nSeparation between\ncode and data\nA whole new world\nThis chapter covers\n The benefits of separating code from data\n Designing a system where code and data are\nseparate\n Implementing a system that respects the\nseparation between code and data\nThe first insight of DOP is that we can decrease the complexity of our systems by\nseparating code from data. Indeed, when code is separated from data, our systems\nare made of two main pieces that can be thought about separately: data entities and\ncode modules. This chapter is a deep dive in the first principle of DOP (summa-\nrized in figure 2.1).\nPRINCIPLE #1 Separate code from data such that the code resides in functions,\nwhose behavior doesn’t depend on data that is somehow encapsulated in the func-\ntion’s context.\n26\n--- Page 55 ---\n2.1 The two parts of a DOP system 27\nStateless (static)\nFunctions\nData asfirst argument\nCode modules\nUsage\nRelations\nNo inheritance\nSeparate code from data\nOnly members\nData entities No code\nAssociation\nRelations\nComposition\nFigure 2.1 DOP principle #1 summarized: Separate code from data.\nIn this chapter, we’ll illustrate the separation between code and data in the context of\nKlafim’s Library Management System that we introduced in chapter 1. We’ll also unveil\nthe benefits that this separation brings to the system:\n The system is simple. It is easy to understand.\n The system is flexible and extensible. Quite often, it requires no design changes to\nadapt to changing requirements.\nThis chapter focuses on the design of the code in a system where code and data are\nseparate. In the next chapter, we’ll focus on the design of the data. As we progress in\nthe book, we’ll discover other benefits of separating code from data.\n2.1 The two parts of a DOP system\nWhile Theo is driving home after delivering the prototype, he asks himself whether the\nKlafim project was a success or not. Sure, he was able to satisfy the customer, but it was\nmore luck than brains. He wouldn’t have made it on time if Nancy had decided to keep\nthe Super members feature. Why was it so complicated to add tiny features to the system?\nWhy was the system he built so complex? He thought there should be a way to build more\nflexible systems!\nThe next morning, Theo asks on Hacker News and on Reddit for ways to reduce system\ncomplexity and build flexible systems. Some folks mention using different programming\nlanguages, while others talk about advanced design patterns. Finally, Theo’s attention gets\ncaptured by a comment from a user named Joe. He mentions data-oriented programming and\nclaims that its main goal is to reduce system complexity. Theo has never heard this term\nbefore. Out of curiosity, he decides to contact Joe by email. What a coincidence! Joe lives\nin San Francisco too. Theo invites him to a meeting in his office.\nJoe is a 40-year-old developer. He was a Java developer for nearly a decade before adopt-\ning Clojure around 7 years ago. When Theo tells Joe about the Library Management System",
        "sections_found": []
      },
      "accurate_page_range": "32-55"
    },
    {
      "text": "- 1.1.4 The implementation phase",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "raw_line": "- 1.1.4 The implementation phase (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 7,
      "chapter_info": {
        "page": 32,
        "title": "Complexity of object-oriented programming",
        "pattern_matched": "Chapter 1",
        "text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased "
      },
      "chapter_sections": {
        "start_page": 32,
        "end_page": 55,
        "content": "\n--- Page 32 ---\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, and their new project were introduced in the opener for part 1.\nTake a moment to read the opener if you missed it.\nTheo gets back to the office with Nancy’s napkin in his pocket and a lot of anxiety in his\nheart because he knows he has committed to a tough deadline. But he had no choice! Last\nweek, Monica, his boss, told him quite clearly that he had to close the deal with Nancy no\nmatter what.\nAlbatross, where Theo works, is a software consulting company with customers all over\nthe world. It originally had lots of customers among startups. Over the last year, however,\nmany projects were badly managed, and the Startup department lost the trust of its cus-\ntomers. That’s why management moved Theo from the Enterprise department to the\nStartup department as a Senior Tech lead. His job is to close deals and to deliver on time.\n1.1.1 The design phase\nBefore rushing to his laptop to code the system, Theo grabs a sheet of paper, much big-\nger than a napkin, and starts to draw a UML class diagram of the system that will imple-\nment the Klafim prototype. Theo is an object-oriented programmer. For him, there is no\nquestion—every business entity is represented by an object, and every object is made\nfrom a class.\nThe requirements for the Klafim prototype\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There can be several copies of a book.\n A book belongs to a physical library.\nTheo spends some time thinking about the organization of the system. He identifies the\nmain classes for the Klafim Global Library Management System.\n--- Page 33 ---\n1.1 OOP design: Classic or classical? 5\nThe main classes of the library management system\n Library—The central part of the system design.\n Book—A book.\n BookItem—A book can have multiple copies, and each copy is considered as\na book item.\n BookLending—When a book is lent, a book lending object is created.\n Member—A member of the library.\n Librarian—A librarian.\n User—A base class for Librarian and Member.\n Catalog—Contains a list of books.\n Author—A book author.\nThat was the easy part. Now comes the difficult part: the relations between the classes.\nAfter two hours or so, Theo comes up with a first draft of a design for the Global Library\nManagement System. It looks like the diagram in figure 1.1.\n NOTE The design presented here doesn’t pretend to be the smartest OOP design:\nexperienced OOP developers would probably use a couple of design patterns to sug-\ngest a much better design. This design is meant to be naive and by no means covers all\nthe features of the system. It serves two purposes:\n For Theo, the developer, it is rich enough to start coding.\n For me, the author of the book, it is rich enough to illustrate the complexity of a\ntypical OOP system.\nTheo feels proud of himself and of the design diagram he just produced. He definitely\ndeserves a cup of coffee!\nNear the coffee machine, Theo meets Dave, a junior software developer who joined\nAlbatross a couple of weeks ago. Theo and Dave appreciate each other, as Dave’s curiosity\nleads him to ask challenging questions. Meetings near the coffee machine often turn into\ninteresting discussions about programming.\nTheo Hey Dave! How’s it going?\nDave Today? Not great. I’m trying to fix a bug in my code! I can’t understand why\nthe state of my objects always changes. I’ll figure it out though, I’m sure. How’s\nyour day going?\nTheo I just finished the design of a system for a new customer.\nDave Cool! Would it be OK for me to see it? I’m trying to improve my design skills.\nTheo Sure! I have the diagram on my desk. We can take a look now if you like.\n--- Page 34 ---\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool\nid : String block() : Bool\nfullName: String unblock() : Bool\nreturnBook(bookLending: BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\n*\nC User\nC BookItem\nid : String\nid : String\nemail : String\nlibId: String\npassword : String\ncheckout(member: Member) : BookLending\nlogin() : Bool\nC BookLending\nid : String\nlendingDate : date *\ndueDate : date\nisLate() : Bool\nreturnBook() : Bool\nFigure 1.1 A class diagram for Klafim’s Global Library Management System\n1.1.2 UML 101\nLatte in hand, Dave follows Theo to his desk. Theo proudly shows Dave his piece of art: the\nUML diagram for the Library Management System (figure 1.1). Dave seems really excited.\nDave Wow! Such a detailed class diagram.\nTheo Yeah. I’m pretty happy with it.\n--- Page 35 ---\n1.1 OOP design: Classic or classical? 7\nDave The thing is that I can never remember the meaning of the different arrows.\nTheo There are four types of arrows in my class diagram: composition, association,\ninheritance, and usage.\nDave What’s the difference between composition and association?\n NOTE Don’t worry if you’re not familiar with OOP jargon. We’re going to leave it\naside in the next chapter.\nTheo It’s all about whether the objects can live without each other. With composi-\ntion, when one object dies, the other one dies too. While in an association rela-\ntion, each object has an independent life.\nTIP In a composition relation, when one object dies, the other one also dies. While\nin an association relation, each object has an independent life cycle.\nIn the class diagram, there are two kinds of composition symbolized by an arrow with\na plain diamond at one edge and an optional star at the other edge. Figure 1.2 shows\nthe relation between:\n A Library that owns a Catalog—A one-to-one composition. If a Library object\ndies, then its Catalog object dies with it.\n A Library that owns many Members—A one-to-many composition. If a Library\nobject dies, then all its Member objects die with it.\nC Library\nname : String * C Member\naddress : String\nFigure 1.2 The two kinds of\nC Catalog composition: one-to-one and\none-to-many. In both cases,\nList<Book> search(searchCriteria, queryStr) when an object dies, the\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\ncomposed object dies with it.\nTIP A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\nDave Do you have association relations in your diagram?\nTheo Take a look at the arrow between Book and Author. It has an empty diamond\nand a star at both edges, so it’s a many-to-many association relation.\nA book can be written by multiple authors, and an author can write multiple books.\nMoreover, Book and Author objects can live independently. The relation between\nbooks and authors is a many-to-many association (figure 1.3).\n--- Page 36 ---\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the Librarian::blockMember method. It calls\nMember::block.\nTIP Dashed arrows indicate usage relations (figure 1.4), for instance, when a class\nuses a method of another class.\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember(member: Member)\nC Member\nBool isBlocked()\nBool block()\nBool unblock()\nBool returnBook(bookLending: BookLending) Figure 1.4 Usage relation: a class\nBookLending checkout(bookItem: BookItem) uses a method of another class.\nDave I see. And I guess a plain arrow with an empty triangle, like the one between\nMember and User, represents inheritance.\nTheo Absolutely!\nTIP Plain arrows with empty triangles represent class inheritance (figure 1.5), where\nthe arrow points towards the superclass.\n--- Page 37 ---\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasure. Want to see how it all fits together?\nDave What class should we look at first?\nTheo I think we should start with Library.\nTHE LIBRARY CLASS\nThe Library is the root class of the library system. Figure 1.6 shows the system structure.\nCC Library\nname : String\naddress : String\n*\nC Member\nC Catalog\nBool isBlocked()\nList<Book> search(searchCriteria, queryStr) Bool block()\nBookItem addBookItem(librarian: Librarian, Bool unblock()\nbookItem: BookItem) Bool returnBook(bookLending: BookLending)\nBookLending checkout(bookItem: BookItem)\n*\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember\n(member: Member)\nFigure 1.6 The Library class\n--- Page 38 ---\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC Member C Librarian\nisBlocked() : Bool blockMember(member: Member) : Bool\nblock() : Bool unblockMember(member: Member) : Bool\nunblock() : Bool addBookItem(bookItem: BookItem) : BookItem\nreturnBook(bookLending : BookLending) : Bool : Member) :\ncheckout(bookItem: BookItem) : BookLending\nCC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.7 Librarian and Member derive from User.\nThe User class represents a user of the library:\n In terms of data members, it sticks to the bare minimum: it has an id, email,\nand password (with no security and encryption for now).\n In terms of code, it can log in via login.\nThe Member class represents a member of the library:\n It inherits from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Check out a book via checkout.\n– Return a book via returnBook.\n– Block itself via block.\n– Unblock itself via unblock.\n– Answer if it is blocked via isBlocked.\n It owns multiple BookLending objects.\n It uses BookItem in order to implement checkout.\n--- Page 39 ---\n1.1 OOP design: Classic or classical? 11\nThe Librarian class represents a librarian:\n It derives from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Block and unblock a Member.\n– List the member’s book lendings via getBookLendings.\n– Add book items to the library via addBookItem.\n It uses Member to implement blockMember, unblockMember, and getBook-\nLendings.\n It uses BookItem to implement checkout.\n It uses BookLending to implement getBookLendings.\nTHE CATALOG CLASS\nThe Catalog class is responsible for the management of the books. Figure 1.8 shows\nthe relation among the Catalog, Librarian, and Book classes. In terms of code, a\nCatalog object can\n Search books via search.\n Add book items to the library via addBookItem.\nC Catalog\nList<Book> search(searchCriteria, queryStr)\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\nC Librarian *\nC Book\nBool blockMember(member: Member)\nBool unblockMember(member: Member) id : String\nBookItem addBookItem(bookItem: BookItem) title : String\nList<BookLending> getBookLendingsOfMember (member: Member)\nFigure 1.8 The Catalog class\nA Catalog object uses Librarian in order to implement addBookItem. In terms of\ndata, a Catalog owns multiple Book objects.\nTHE BOOK CLASS\nFigure 1.9 presents the Book class. In terms of data, a Book object\n Should have as its bare minimum an id and a title.\n Is associated with multiple Author objects (a book might have multiple authors).\n Owns multiple BookItem objects, one for each copy of the book.\n--- Page 40 ---\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare minimum data for members: an id and a libId (for its\nphysical library ID).\n Owns multiple BookLending objects, one for each time the book is lent.\nIn terms of code, a BookItem object can be checked out via checkout.\n1.1.4 The implementation phase\nAfter this detailed investigation of Theo’s diagrams, Dave lets it sink in as he slowly sips his\ncoffee. He then expresses his admiration to Theo.\nDave Wow! That’s amazing!\nTheo Thank you.\nDave I didn’t realize people were really spending the time to write down their design\nin such detail before coding.\nTheo I always do that. It saves me lot of time during the coding phase.\nDave When will you start coding?\nTheo When I finish my latte.\nTheo grabs his coffee mug and notices that his hot latte has become an iced latte. He was\nso excited to show his class diagram to Dave that he forgot to drink it!\n--- Page 41 ---\n1.2 Sources of complexity 13\n1.2 Sources of complexity\nWhile Theo is getting himself another cup of coffee (a cappuccino this time), I\nwould like to challenge his design. It might look beautiful and clear on the paper,\nbut I claim that this design makes the system hard to understand. It’s not that Theo\npicked the wrong classes or that he misunderstood the relations among the classes.\nIt goes much deeper:\n It’s about the programming paradigm he chose to implement the system.\n It’s about the object-oriented paradigm.\n It’s about the tendency of OOP to increase the complexity of a system.\nTIP OOP has a tendency to create complex systems.\nThroughout this book, the type of complexity I refer to is that which makes systems\nhard to understand as defined in the paper, “Out of the Tar Pit,” by Ben Moseley\nand Peter Marks (2006), available at http://mng.bz/enzq. It has nothing to do with\nthe type of complexity that deals with the amount of resources consumed by a pro-\ngram. Similarly, when I refer to simplicity, I mean not complex (in other words, easy\nto understand).\nKeep in mind that complexity and simplicity (like hard and easy) are not absolute\nbut relative concepts. We can compare the complexity of two systems and determine\nwhether system A is more complex (or simpler) than system B.\n NOTE Complexity in the context of this book means hard to understand.\nAs mentioned in the introduction of this chapter, there are many ways in OOP to\nalleviate complexity. The purpose of this book is not be critical of OOP, but rather\nto present a programming paradigm called data-oriented programming (DOP) that\ntends to build systems that are less complex. In fact, the DOP paradigm is compati-\nble with OOP.\nIf one chooses to build an OOP system that adheres to DOP principles, the system\nwill be less complex. According to DOP, the main sources of complexity in Theo’s sys-\ntem (and of many traditional OOP systems) are that\n Code and data are mixed.\n Objects are mutable.\n Data is locked in objects as members.\n Code is locked into classes as methods.\nThis analysis is similar to what functional programming (FP) thinks about traditional\nOOP. However, as we will see throughout the book, the data approach that DOP takes\nin order to reduce system complexity differs from the FP approach. In appendix A, we\nillustrate how to apply DOP principles both in OOP and in FP styles.\nTIP DOP is compatible both with OOP and FP.\n--- Page 42 ---\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Extra thinking is needed when reading code.\nObjects are mutable. Explicit synchronization is required on multi-threaded environments.\nData is locked in objects. Data serialization is not trivial.\nCode is locked in classes. Class hierarchies are complex.\n1.2.1 Many relations between classes\nOne way to assess the complexity of a class diagram is to look only at the entities and\ntheir relations, ignoring members and methods, as in figure 1.10. When we design a\nsystem, we have to define the relations between different pieces of code and data.\nThat’s unavoidable.\nC Library\nC Catalog\n* *\nC Book C Librarian\n*\n*\nC Member\n*\nC Author\nC BookItem C User\nFigure 1.10 A class\ndiagram overview for\nC BookLending * Klafim’s Library\nManagement System\nTIP In OOP, code and data are mixed together in classes: data as members and code as\nmethods.\n--- Page 43 ---\n1.2 Sources of complexity 15\nFrom a system analysis perspective, the fact that code and data are mixed together\nmakes the system complex in the sense that entities tend to be involved in many rela-\ntions. In figure 1.11, we take a closer look at the Member class. Member is involved in five\nrelations: two data relations and three code relations.\n Data relations:\n– Library has many Members.\n– Member has many BookLendings.\n Code relations:\n– Member extends User.\n– Librarian uses Member.\n– Member uses BookItem.\nC Librarian\nC Library * C Member\n*\nC User C BookLending C BookItem Figure 1.11 The class Member is\ninvolved in five relations.\nImagine for a moment that we were able, somehow, to split the Member class into two\nseparate entities:\n MemberCode for the code\n MemberData for the data\nInstead of a Member class with five relations, we would have the diagram shown in fig-\nure 1.12 with:\n A MemberCode entity and three relations.\n A MemberData entity and two relations.\nC Library C Librarian\n*\nC MemberData C MemberCode\n*\nC BookLending C User C BookItem Figure 1.12 A class diagram where Member\nis split into code and data entities\n--- Page 44 ---\n16 CHAPTER 1 Complexity of object-orientedprogramming\nThe class diagram where Member is split into MemberCode and MemberData is made of\ntwo independent parts. Each part is easier to understand than the original diagram.\nLet’s split every class of our original class diagram into code and data entities.\nFigure 1.13 shows the resulting diagram. Now the system is made of two indepen-\ndent parts:\n A part that involves only data entities.\n A part that involves only code entities.\nC LibraryData * C LibrarianData C CatalogCode\n*\nC MemberData C CatalogData C LibrarianCode\n*\nC BookData C MemberCode C BookLendingCode C BookItemCode\n*\n* *\nC BookItemData C AuthorData C UserCode C BookItem\n*\nC BookLendingData\nFigure 1.13 A class diagram where every class is split into code and data entities\nTIP A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\nThe resulting system, made up of two independent subsystems, is easier to understand\nthan the original system. The fact that the two subsystems are independent means that\neach subsystem can be understood separately and in any order. The resulting system\nnot simpler by accident; it is a logical consequence of separating code from data.\nTIP A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n1.2.2 Unpredictable code behavior\nYou might be a bit tired after the system-level analysis that we presented in the previ-\nous section. Let’s get refreshed and look at some code.\nTake a look at the code in listing 1.1, where we get the blocked status of a member\nand display it twice. If I tell you that when I called displayBlockedStatusTwice, the\nprogram displayed true on the first console.log call, can you tell me what the pro-\ngram displayed on the second console.log call?\n--- Page 45 ---\n1.2 Sources of complexity 17\nListing1.1 Really simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nvar isBlocked = this.isBlocked;\nconsole.log(isBlocked);\nconsole.log(isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\n“Of course, it displayed true again,” you say. And you are right!\nNow, take a look at a slightly different pseudocode as shown in listing 1.2. Here we\ndisplay, twice, the blocked status of a member without assigning a variable. Same ques-\ntion as before: if I tell you that when I called displayBlockedStatusTwice, the pro-\ngram displayed true on the first console.log call, can you tell me what the program\ndisplayed on the second console.log call?\nListing1.2 Apparently simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nconsole.log(this.isBlocked);\nconsole.log(this.isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\nThe correct answer is...in a single-threaded environment, it displays true, while in a\nmulti-threaded environment, it’s unpredictable. Indeed, in a multi-threaded environ-\nment between the two console.log calls, there could be a context switch that changes\nthe state of the object (e.g., a librarian unblocked the member). In fact, with a slight\nmodification, the same kind of code unpredictability could occur even in a single-\nthreaded environment like JavaScript, when data is modified via asynchronous code\n(see the section about Principle #3 in appendix A). The difference between the two\ncode snippets is that\n In the first listing (listing 1.1), we access a Boolean value twice , which is a prim-\nitive value.\n In the second listing (listing 1.2), we access a member of an object twice.\nTIP When data is mutable, code is unpredictable.\n--- Page 46 ---\n18 CHAPTER 1 Complexity of object-orientedprogramming\nThis unpredictable behavior of the second listing is one of the annoying conse-\nquences of OOP. Unlike primitive types, which are usually immutable, object mem-\nbers are mutable. One way to solve this problem in OOP is to protect sensitive code\nwith concurrency safety mechanisms like mutexes, but that introduces issues like a\nperformance hit and a risk of deadlocks.\nWe will see later in the book that DOP treats every piece of data in the same way:\nboth primitive types and collection types are immutable values. This value treatment for\nall citizens brings serenity to DOP developers’ minds, and more brain cells are avail-\nable to handle the interesting pieces of the applications they build.\nTIP Data immutability brings serenity to DOP developers’ minds.\n1.2.3 Not trivial data serialization\nTheo is really tired, and he falls asleep at his desk. He’s having dream. In his dream, Nancy\nasks him to make Klafim’s Library Management System accessible via a REST API using\nJSON as a transport layer. Theo has to implement a /search endpoint that receives a\nquery in JSON format and returns the results in JSON format. Listing 1.3 shows an input\nexample of the /search endpoint, and listing 1.4 shows an output example of the /search\nendpoint.\nListing1.3 A JSON input of the /search endpoint\n{\n\"searchCriteria\": \"author\",\n\"query\": \"albert\"\n}\nListing1.4 A JSON output of the /search endpoint\n[\n{\n\"title\": \"The world as I see it\",\n\"authors\": [\n{\n\"fullName\": \"Albert Einstein\"\n}\n]\n},\n{\n\"title\": \"The Stranger\",\n\"authors\": [\n{\n\"fullName\": \"Albert Camus\"\n}\n]\n}\n]\n--- Page 47 ---\n1.2 Sources of complexity 19\nTheo would probably implement the /search endpoint by creating three classes simi-\nlarly to what is shown in the following list and in figure 1.14. (Not surprisingly, every-\nthing in OOP has to be wrapped in a class. Right?)\n SearchController is responsible for handling the query.\n SearchQuery converts the JSON query string into data.\n SearchResult converts the search result data into a JSON string.\nC SearchController\nString handle(searchQuery: String)\nC SearchQuery\nC SearchResult\nC Catalog\nsearchCriteria: String\nSearchResult(books: List<Book>)\nList<Book> search(searchCriteria, queryStr) query: String\nString toJSON()\nSearchQuery(jsonString: String)\n* *\nC Book\nid : String\ntitle : String\nFigure 1.14 The class diagram for SearchController\nThe SearchController (see figure 1.14) would have a single handle method with the\nfollowing flow:\n Creates a SearchQuery object from the JSON query string.\n Retrieves searchCriteria and queryStr from the SearchQuery object.\n Calls the search method of the catalog:Catalog with searchCriteria and\nqueryStr and receives books:List<Book>.\n Creates a SearchResult object with books.\n Converts the SearchResult object to a JSON string.\nWhat about other endpoints, for instance, those allowing librarians to add book items\nthrough /add-book-item? Theo would have to repeat the exact same process and cre-\nate three classes:\n AddBookItemController to handle the query\n BookItemQuery to convert the JSON query string into data\n BookItemResult to convert the search result data into a JSON string\nThe code that deals with JSON deserialization that Theo wrote previously in Search-\nQuery would have to be rewritten in BookItemQuery. Same thing for the code that\ndeals with JSON serialization he wrote previously in SearchResult; it would have to be\nrewritten in BookItemResult.\n--- Page 48 ---\n20 CHAPTER 1 Complexity of object-orientedprogramming\nThe bad news is that Theo would have to repeat the same process for every end-\npoint of the system. Each time he encounters a new kind of JSON input or output,\nhe would have to create a new class and write code. Theo’s dream is turning into a\nnightmare!\nSuddenly, his phone rings, next to where he was resting his head on the desk. As Theo\nwakes up, he realizes that Nancy never asked for JSON. It was all a dream...a really bad\ndream!\nTIP In OOP, data serialization is difficult.\nIt’s quite frustrating that handling JSON serialization and deserialization in OOP\nrequires the addition of so many classes and writing so much code—again and again!\nThe frustration grows when you consider that serializing a search query, a book item\nquery, or any query is quite similar. It comes down to\n Going over data fields.\n Concatenating the name of the data fields and the value of the data fields, sepa-\nrated by a comma.\nWhy is such a simple thing so hard to achieve in OOP? In OOP, data has to follow a\nrigid shape defined in classes, which means that data is locked in members. There is\nno simple way to access data generically.\nTIP In OOP, data is locked in classes as members.\nWe will refine later what we mean by generic access to the data, and we will see how\nDOP provides a generic way to handle JSON serialization and deserialization. Until\nthen, you will have to continue suffering. But at least you are starting to become aware\nof this suffering, and you know that it is avoidable.\n NOTE Most OOP programming languages alleviate a bit of the difficulty involved\nin the conversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n1.2.4 Complex class hierarchies\nOne way to avoid writing the same code twice in OOP involves class inheritance. Indeed,\nwhen every requirement of the system is known up front, you design your class hier-\narchy is such a way that classes with common behavior derive from a base class.\nFigure 1.15 shows an example of this pattern that focuses on the part of our class\ndiagram that deals with members and librarians. Both Librarians and Members need\nthe ability to log in, and they inherit this ability from the User class.\nSo far, so good, but when new requirements are introduced after the system is imple-\nmented, it’s a completely different story. Fast forward to Monday, March 29th, at 11:00 AM,\nwhere two days are left before the deadline (Wednesday at midnight).\n--- Page 49 ---\n1.2 Sources of complexity 21\nC Librarian\nblockMember(member: Member) : Bool\nunblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String Figure 1.15 The part of the\npassword : String class diagram that deals with\nlogin() : Bool members and librarians\nNancy calls Theo with an urgent request. Theo is not sure if it’s a dream or reality. He\npinches himself and he can feel the jolt. It’s definitely reality!\nNancy How is the project doing?\nTheo Fine, Nancy. We’re on schedule to meet the deadline. We’re running our last\nround of regression tests now.\nNancy Fantastic! It means we have time for adding a tiny feature to the system, right?\nTheo Depends what you mean by “tiny.”\nNancy We need to add VIP members to the system.\nTheo What do you mean by VIP members?\nNancy VIP members are allowed to add book items to the library by themselves.\nTheo Hmm...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nI’ll ask you the same question Nancy asked Theo: why is adding VIP members to our\nsystem not a tiny task? After all, Theo has already written the code that allows librari-\nans to add book items to the library (it’s in Librarian::addBookItem). What prevents\nhim from reusing this code for VIP members? The reason is that, in OOP, the code is\nlocked into classes as methods.\nTIP In OOP, code is locked into classes.\nVIP members are members that are allowed to add book items to the library by them-\nselves. Theo decomposes the customer requirements into two pieces:\n--- Page 50 ---\n22 CHAPTER 1 Complexity of object-orientedprogramming\n VIP members are library members.\n VIP members are allowed to add book items to the library by themselves.\nTheo then decides that he needs a new class, VIPMember. For the first requirement\n(VIP members are library members), it seems reasonable to make VIPMember derive\nfrom Member. However, handling the second requirement (VIP members are allowed\nto add book items) is more complex. He cannot make a VIPMember derive from\nLibrarian because the relation between VIPMember and Librarian is not linear:\n On one hand, VIP members are like librarians in that they are allowed to add\nbook items.\n On the other hand, VIP members are not like librarians in that they are not\nallowed to block members or list the books lent to a member.\nThe problem is that the code that adds book items is locked in the Librarian class.\nThere is no way for the VIPMember class to use this code.\nFigure 1.16 shows one possible solution that makes the code of Librarian::add-\nBookItem available to both Librarian and VIPMember classes. Here are the changes to\nthe previous class diagram:\n A base class UserWithBookItemRight extends User.\n addBookItem moves from Librarian to UserWithBookItemRight.\n Both VIPMember and Librarian extend UserWithBookItemRight.\nC Librarian\nblockMember(member: Member) : Bool C VIPMember\nunblockMember(member: Member) : Bool\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nCC UserWithBookItemRight\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool addBookItem(bookItem: BookItem) : BookItem\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.16 A class diagram for a system with VIP members\nIt wasn’t easy, but Theo manages to handle the change on time, thanks to an all nighter\ncoding on his laptop. He was even able to add new tests to the system and run the regres-\nsion tests again. However, he was so excited that he didn’t pay attention to the diamond\n--- Page 51 ---\n1.2 Sources of complexity 23\nproblem VIPMember introduced in his class diagram due to multiple inheritance: VIPMember\nextends both Member and UserWithBookItemRight, which both extend User.\nWednesday, March 31, at 10:00 AM (14 hours before the deadline), Theo calls Nancy to\ntell her the good news.\nTheo We were able to add VIP members to the system on time, Nancy.\nNancy Fantastic! I told you it was a tiny feature.\nTheo Yeah, well...\nNancy Look, I was going to call you anyway. I just finished a meeting with my business\npartner, and we realized that we need another tiny feature before the launch.\nWill you be able to handle it before the deadline?\nTheo Again, it depends what you mean by “tiny.”\nNancy We need to add Super members to the system.\nTheo What do you mean by Super members?\nNancy Super members are allowed to list the books lent to other members.\nTheo Err...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nAs with VIP members, adding Super members to the system requires changes to Theo’s\nclass hierarchy. Figure 1.17 shows the solution Theo has in mind.\nC Librarian\nC VIPMember C SuperMember\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC UserWithBlockMemberRight\nCC UserWithBookItemRight\nblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\nunblockMember(member: Member) : Bool\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.17 A class diagram for a system with Super and VIP members\nThe addition of Super members has made the system really complex. Theo suddenly\nnotices that he has three diamonds in his class diagram—not gemstones but three “Deadly\n--- Page 52 ---\n24 CHAPTER 1 Complexity of object-orientedprogramming\nDiamonds of Death” as OOP developers sometimes name the ambiguity that arises when a\nclass D inherits from two classes B and C, where both inherit from class A!\nHe tries to avoid the diamonds by transforming the User class into an interface and\nusing the composition over inheritance design pattern. But with the stress of the deadline\nlooming, he isn’t able to use all of his brain cells. In fact, the system has become so com-\nplex, he’s unable to deliver the system by the deadline. Theo tells himself that he should\nhave used composition instead of class inheritance. But, it’s too late now.\nTIP In OOP, prefer composition over class inheritance.\nAt 10:00 PM, two hours before the deadline, Theo calls Nancy to explain the situation.\nTheo Look Nancy, we really did our best, but we won’t be able to add Super mem-\nbers to the system before the deadline.\nNancy No worries, my business partner and I decided to omit this feature for now.\nWe’ll add it later.\nWith mixed feelings of anger and relief, Theo stops pacing around his office. He realizes\nhe will be spending tonight in his own bed, rather than plowing away on his computer at\nthe office. That should make his wife happy.\nTheo I guess that means we’re ready for the launch tomorrow morning.\nNancy Yes. We’ll offer this new product for a month or so, and if we get good market\ntraction, we’ll move forward with a bigger project.\nTheo Cool. Let’s be in touch in a month then. Good luck on the launch!\nSummary\n Complexity in the context of this book means hard to understand.\n We use the terms code and behavior interchangeably.\n DOP stands for data-oriented programming.\n OOP stands for object-oriented programming.\n FP stands for functional programming.\n In a composition relation, when one object dies, the other one also dies.\n A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\n In an association relation, each object has an independent life cycle.\n A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\n Dashed arrows indicate a usage relation; for instance, when a class uses a method\nof another class.\n Plain arrows with empty triangles represent class inheritance, where the arrow\npoints towards the superclass.\n The design presented in this chapter doesn’t pretend to be the smartest OOP\ndesign. Experienced OOP developers would probably use a couple of design\npatterns and suggest a much better diagram.\n--- Page 53 ---\nSummary 25\n Traditional OOP systems tend to increase system complexity, in the sense that\nOOP systems are hard to understand.\n In traditional OOP, code and data are mixed together in classes: data as mem-\nbers and code as methods.\n In traditional OOP, data is mutable.\n The root cause of the increase in complexity is related to the mixing of code\nand data together into objects.\n When code and data are mixed, classes tend to be involved in many relations.\n When objects are mutable, extra thinking is required in order to understand\nhow the code behaves.\n When objects are mutable, explicit synchronization mechanisms are required\non multi-threaded environments.\n When data is locked in objects, data serialization is not trivial.\n When code is locked in classes, class hierarchies tend to be complex.\n A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\n A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n When data is mutable, code is unpredictable.\n A strategic use of design patterns can help mitigate complexity in traditional\nOOP to some degree.\n Data immutability brings serenity to DOP developers’ minds.\n Most OOP programming languages alleviate slightly the difficulty involved the\nconversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n In traditional OOP, data serialization is difficult.\n In traditional OOP, data is locked in classes as members.\n In traditional OOP, code is locked into classes.\n DOP reduces complexity by rethinking data.\n DOP is compatible both with OOP and FP.\n--- Page 54 ---\nSeparation between\ncode and data\nA whole new world\nThis chapter covers\n The benefits of separating code from data\n Designing a system where code and data are\nseparate\n Implementing a system that respects the\nseparation between code and data\nThe first insight of DOP is that we can decrease the complexity of our systems by\nseparating code from data. Indeed, when code is separated from data, our systems\nare made of two main pieces that can be thought about separately: data entities and\ncode modules. This chapter is a deep dive in the first principle of DOP (summa-\nrized in figure 2.1).\nPRINCIPLE #1 Separate code from data such that the code resides in functions,\nwhose behavior doesn’t depend on data that is somehow encapsulated in the func-\ntion’s context.\n26\n--- Page 55 ---\n2.1 The two parts of a DOP system 27\nStateless (static)\nFunctions\nData asfirst argument\nCode modules\nUsage\nRelations\nNo inheritance\nSeparate code from data\nOnly members\nData entities No code\nAssociation\nRelations\nComposition\nFigure 2.1 DOP principle #1 summarized: Separate code from data.\nIn this chapter, we’ll illustrate the separation between code and data in the context of\nKlafim’s Library Management System that we introduced in chapter 1. We’ll also unveil\nthe benefits that this separation brings to the system:\n The system is simple. It is easy to understand.\n The system is flexible and extensible. Quite often, it requires no design changes to\nadapt to changing requirements.\nThis chapter focuses on the design of the code in a system where code and data are\nseparate. In the next chapter, we’ll focus on the design of the data. As we progress in\nthe book, we’ll discover other benefits of separating code from data.\n2.1 The two parts of a DOP system\nWhile Theo is driving home after delivering the prototype, he asks himself whether the\nKlafim project was a success or not. Sure, he was able to satisfy the customer, but it was\nmore luck than brains. He wouldn’t have made it on time if Nancy had decided to keep\nthe Super members feature. Why was it so complicated to add tiny features to the system?\nWhy was the system he built so complex? He thought there should be a way to build more\nflexible systems!\nThe next morning, Theo asks on Hacker News and on Reddit for ways to reduce system\ncomplexity and build flexible systems. Some folks mention using different programming\nlanguages, while others talk about advanced design patterns. Finally, Theo’s attention gets\ncaptured by a comment from a user named Joe. He mentions data-oriented programming and\nclaims that its main goal is to reduce system complexity. Theo has never heard this term\nbefore. Out of curiosity, he decides to contact Joe by email. What a coincidence! Joe lives\nin San Francisco too. Theo invites him to a meeting in his office.\nJoe is a 40-year-old developer. He was a Java developer for nearly a decade before adopt-\ning Clojure around 7 years ago. When Theo tells Joe about the Library Management System",
        "sections_found": []
      },
      "accurate_page_range": "32-55"
    },
    {
      "text": "- 1.2.0 Introduction (사용자 추가)",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "raw_line": "- 1.2.0 Introduction (사용자 추가) (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 8,
      "chapter_info": {
        "page": 32,
        "title": "Complexity of object-oriented programming",
        "pattern_matched": "Chapter 1",
        "text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased "
      },
      "chapter_sections": {
        "start_page": 32,
        "end_page": 55,
        "content": "\n--- Page 32 ---\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, and their new project were introduced in the opener for part 1.\nTake a moment to read the opener if you missed it.\nTheo gets back to the office with Nancy’s napkin in his pocket and a lot of anxiety in his\nheart because he knows he has committed to a tough deadline. But he had no choice! Last\nweek, Monica, his boss, told him quite clearly that he had to close the deal with Nancy no\nmatter what.\nAlbatross, where Theo works, is a software consulting company with customers all over\nthe world. It originally had lots of customers among startups. Over the last year, however,\nmany projects were badly managed, and the Startup department lost the trust of its cus-\ntomers. That’s why management moved Theo from the Enterprise department to the\nStartup department as a Senior Tech lead. His job is to close deals and to deliver on time.\n1.1.1 The design phase\nBefore rushing to his laptop to code the system, Theo grabs a sheet of paper, much big-\nger than a napkin, and starts to draw a UML class diagram of the system that will imple-\nment the Klafim prototype. Theo is an object-oriented programmer. For him, there is no\nquestion—every business entity is represented by an object, and every object is made\nfrom a class.\nThe requirements for the Klafim prototype\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There can be several copies of a book.\n A book belongs to a physical library.\nTheo spends some time thinking about the organization of the system. He identifies the\nmain classes for the Klafim Global Library Management System.\n--- Page 33 ---\n1.1 OOP design: Classic or classical? 5\nThe main classes of the library management system\n Library—The central part of the system design.\n Book—A book.\n BookItem—A book can have multiple copies, and each copy is considered as\na book item.\n BookLending—When a book is lent, a book lending object is created.\n Member—A member of the library.\n Librarian—A librarian.\n User—A base class for Librarian and Member.\n Catalog—Contains a list of books.\n Author—A book author.\nThat was the easy part. Now comes the difficult part: the relations between the classes.\nAfter two hours or so, Theo comes up with a first draft of a design for the Global Library\nManagement System. It looks like the diagram in figure 1.1.\n NOTE The design presented here doesn’t pretend to be the smartest OOP design:\nexperienced OOP developers would probably use a couple of design patterns to sug-\ngest a much better design. This design is meant to be naive and by no means covers all\nthe features of the system. It serves two purposes:\n For Theo, the developer, it is rich enough to start coding.\n For me, the author of the book, it is rich enough to illustrate the complexity of a\ntypical OOP system.\nTheo feels proud of himself and of the design diagram he just produced. He definitely\ndeserves a cup of coffee!\nNear the coffee machine, Theo meets Dave, a junior software developer who joined\nAlbatross a couple of weeks ago. Theo and Dave appreciate each other, as Dave’s curiosity\nleads him to ask challenging questions. Meetings near the coffee machine often turn into\ninteresting discussions about programming.\nTheo Hey Dave! How’s it going?\nDave Today? Not great. I’m trying to fix a bug in my code! I can’t understand why\nthe state of my objects always changes. I’ll figure it out though, I’m sure. How’s\nyour day going?\nTheo I just finished the design of a system for a new customer.\nDave Cool! Would it be OK for me to see it? I’m trying to improve my design skills.\nTheo Sure! I have the diagram on my desk. We can take a look now if you like.\n--- Page 34 ---\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool\nid : String block() : Bool\nfullName: String unblock() : Bool\nreturnBook(bookLending: BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\n*\nC User\nC BookItem\nid : String\nid : String\nemail : String\nlibId: String\npassword : String\ncheckout(member: Member) : BookLending\nlogin() : Bool\nC BookLending\nid : String\nlendingDate : date *\ndueDate : date\nisLate() : Bool\nreturnBook() : Bool\nFigure 1.1 A class diagram for Klafim’s Global Library Management System\n1.1.2 UML 101\nLatte in hand, Dave follows Theo to his desk. Theo proudly shows Dave his piece of art: the\nUML diagram for the Library Management System (figure 1.1). Dave seems really excited.\nDave Wow! Such a detailed class diagram.\nTheo Yeah. I’m pretty happy with it.\n--- Page 35 ---\n1.1 OOP design: Classic or classical? 7\nDave The thing is that I can never remember the meaning of the different arrows.\nTheo There are four types of arrows in my class diagram: composition, association,\ninheritance, and usage.\nDave What’s the difference between composition and association?\n NOTE Don’t worry if you’re not familiar with OOP jargon. We’re going to leave it\naside in the next chapter.\nTheo It’s all about whether the objects can live without each other. With composi-\ntion, when one object dies, the other one dies too. While in an association rela-\ntion, each object has an independent life.\nTIP In a composition relation, when one object dies, the other one also dies. While\nin an association relation, each object has an independent life cycle.\nIn the class diagram, there are two kinds of composition symbolized by an arrow with\na plain diamond at one edge and an optional star at the other edge. Figure 1.2 shows\nthe relation between:\n A Library that owns a Catalog—A one-to-one composition. If a Library object\ndies, then its Catalog object dies with it.\n A Library that owns many Members—A one-to-many composition. If a Library\nobject dies, then all its Member objects die with it.\nC Library\nname : String * C Member\naddress : String\nFigure 1.2 The two kinds of\nC Catalog composition: one-to-one and\none-to-many. In both cases,\nList<Book> search(searchCriteria, queryStr) when an object dies, the\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\ncomposed object dies with it.\nTIP A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\nDave Do you have association relations in your diagram?\nTheo Take a look at the arrow between Book and Author. It has an empty diamond\nand a star at both edges, so it’s a many-to-many association relation.\nA book can be written by multiple authors, and an author can write multiple books.\nMoreover, Book and Author objects can live independently. The relation between\nbooks and authors is a many-to-many association (figure 1.3).\n--- Page 36 ---\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the Librarian::blockMember method. It calls\nMember::block.\nTIP Dashed arrows indicate usage relations (figure 1.4), for instance, when a class\nuses a method of another class.\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember(member: Member)\nC Member\nBool isBlocked()\nBool block()\nBool unblock()\nBool returnBook(bookLending: BookLending) Figure 1.4 Usage relation: a class\nBookLending checkout(bookItem: BookItem) uses a method of another class.\nDave I see. And I guess a plain arrow with an empty triangle, like the one between\nMember and User, represents inheritance.\nTheo Absolutely!\nTIP Plain arrows with empty triangles represent class inheritance (figure 1.5), where\nthe arrow points towards the superclass.\n--- Page 37 ---\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasure. Want to see how it all fits together?\nDave What class should we look at first?\nTheo I think we should start with Library.\nTHE LIBRARY CLASS\nThe Library is the root class of the library system. Figure 1.6 shows the system structure.\nCC Library\nname : String\naddress : String\n*\nC Member\nC Catalog\nBool isBlocked()\nList<Book> search(searchCriteria, queryStr) Bool block()\nBookItem addBookItem(librarian: Librarian, Bool unblock()\nbookItem: BookItem) Bool returnBook(bookLending: BookLending)\nBookLending checkout(bookItem: BookItem)\n*\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember\n(member: Member)\nFigure 1.6 The Library class\n--- Page 38 ---\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC Member C Librarian\nisBlocked() : Bool blockMember(member: Member) : Bool\nblock() : Bool unblockMember(member: Member) : Bool\nunblock() : Bool addBookItem(bookItem: BookItem) : BookItem\nreturnBook(bookLending : BookLending) : Bool : Member) :\ncheckout(bookItem: BookItem) : BookLending\nCC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.7 Librarian and Member derive from User.\nThe User class represents a user of the library:\n In terms of data members, it sticks to the bare minimum: it has an id, email,\nand password (with no security and encryption for now).\n In terms of code, it can log in via login.\nThe Member class represents a member of the library:\n It inherits from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Check out a book via checkout.\n– Return a book via returnBook.\n– Block itself via block.\n– Unblock itself via unblock.\n– Answer if it is blocked via isBlocked.\n It owns multiple BookLending objects.\n It uses BookItem in order to implement checkout.\n--- Page 39 ---\n1.1 OOP design: Classic or classical? 11\nThe Librarian class represents a librarian:\n It derives from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Block and unblock a Member.\n– List the member’s book lendings via getBookLendings.\n– Add book items to the library via addBookItem.\n It uses Member to implement blockMember, unblockMember, and getBook-\nLendings.\n It uses BookItem to implement checkout.\n It uses BookLending to implement getBookLendings.\nTHE CATALOG CLASS\nThe Catalog class is responsible for the management of the books. Figure 1.8 shows\nthe relation among the Catalog, Librarian, and Book classes. In terms of code, a\nCatalog object can\n Search books via search.\n Add book items to the library via addBookItem.\nC Catalog\nList<Book> search(searchCriteria, queryStr)\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\nC Librarian *\nC Book\nBool blockMember(member: Member)\nBool unblockMember(member: Member) id : String\nBookItem addBookItem(bookItem: BookItem) title : String\nList<BookLending> getBookLendingsOfMember (member: Member)\nFigure 1.8 The Catalog class\nA Catalog object uses Librarian in order to implement addBookItem. In terms of\ndata, a Catalog owns multiple Book objects.\nTHE BOOK CLASS\nFigure 1.9 presents the Book class. In terms of data, a Book object\n Should have as its bare minimum an id and a title.\n Is associated with multiple Author objects (a book might have multiple authors).\n Owns multiple BookItem objects, one for each copy of the book.\n--- Page 40 ---\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare minimum data for members: an id and a libId (for its\nphysical library ID).\n Owns multiple BookLending objects, one for each time the book is lent.\nIn terms of code, a BookItem object can be checked out via checkout.\n1.1.4 The implementation phase\nAfter this detailed investigation of Theo’s diagrams, Dave lets it sink in as he slowly sips his\ncoffee. He then expresses his admiration to Theo.\nDave Wow! That’s amazing!\nTheo Thank you.\nDave I didn’t realize people were really spending the time to write down their design\nin such detail before coding.\nTheo I always do that. It saves me lot of time during the coding phase.\nDave When will you start coding?\nTheo When I finish my latte.\nTheo grabs his coffee mug and notices that his hot latte has become an iced latte. He was\nso excited to show his class diagram to Dave that he forgot to drink it!\n--- Page 41 ---\n1.2 Sources of complexity 13\n1.2 Sources of complexity\nWhile Theo is getting himself another cup of coffee (a cappuccino this time), I\nwould like to challenge his design. It might look beautiful and clear on the paper,\nbut I claim that this design makes the system hard to understand. It’s not that Theo\npicked the wrong classes or that he misunderstood the relations among the classes.\nIt goes much deeper:\n It’s about the programming paradigm he chose to implement the system.\n It’s about the object-oriented paradigm.\n It’s about the tendency of OOP to increase the complexity of a system.\nTIP OOP has a tendency to create complex systems.\nThroughout this book, the type of complexity I refer to is that which makes systems\nhard to understand as defined in the paper, “Out of the Tar Pit,” by Ben Moseley\nand Peter Marks (2006), available at http://mng.bz/enzq. It has nothing to do with\nthe type of complexity that deals with the amount of resources consumed by a pro-\ngram. Similarly, when I refer to simplicity, I mean not complex (in other words, easy\nto understand).\nKeep in mind that complexity and simplicity (like hard and easy) are not absolute\nbut relative concepts. We can compare the complexity of two systems and determine\nwhether system A is more complex (or simpler) than system B.\n NOTE Complexity in the context of this book means hard to understand.\nAs mentioned in the introduction of this chapter, there are many ways in OOP to\nalleviate complexity. The purpose of this book is not be critical of OOP, but rather\nto present a programming paradigm called data-oriented programming (DOP) that\ntends to build systems that are less complex. In fact, the DOP paradigm is compati-\nble with OOP.\nIf one chooses to build an OOP system that adheres to DOP principles, the system\nwill be less complex. According to DOP, the main sources of complexity in Theo’s sys-\ntem (and of many traditional OOP systems) are that\n Code and data are mixed.\n Objects are mutable.\n Data is locked in objects as members.\n Code is locked into classes as methods.\nThis analysis is similar to what functional programming (FP) thinks about traditional\nOOP. However, as we will see throughout the book, the data approach that DOP takes\nin order to reduce system complexity differs from the FP approach. In appendix A, we\nillustrate how to apply DOP principles both in OOP and in FP styles.\nTIP DOP is compatible both with OOP and FP.\n--- Page 42 ---\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Extra thinking is needed when reading code.\nObjects are mutable. Explicit synchronization is required on multi-threaded environments.\nData is locked in objects. Data serialization is not trivial.\nCode is locked in classes. Class hierarchies are complex.\n1.2.1 Many relations between classes\nOne way to assess the complexity of a class diagram is to look only at the entities and\ntheir relations, ignoring members and methods, as in figure 1.10. When we design a\nsystem, we have to define the relations between different pieces of code and data.\nThat’s unavoidable.\nC Library\nC Catalog\n* *\nC Book C Librarian\n*\n*\nC Member\n*\nC Author\nC BookItem C User\nFigure 1.10 A class\ndiagram overview for\nC BookLending * Klafim’s Library\nManagement System\nTIP In OOP, code and data are mixed together in classes: data as members and code as\nmethods.\n--- Page 43 ---\n1.2 Sources of complexity 15\nFrom a system analysis perspective, the fact that code and data are mixed together\nmakes the system complex in the sense that entities tend to be involved in many rela-\ntions. In figure 1.11, we take a closer look at the Member class. Member is involved in five\nrelations: two data relations and three code relations.\n Data relations:\n– Library has many Members.\n– Member has many BookLendings.\n Code relations:\n– Member extends User.\n– Librarian uses Member.\n– Member uses BookItem.\nC Librarian\nC Library * C Member\n*\nC User C BookLending C BookItem Figure 1.11 The class Member is\ninvolved in five relations.\nImagine for a moment that we were able, somehow, to split the Member class into two\nseparate entities:\n MemberCode for the code\n MemberData for the data\nInstead of a Member class with five relations, we would have the diagram shown in fig-\nure 1.12 with:\n A MemberCode entity and three relations.\n A MemberData entity and two relations.\nC Library C Librarian\n*\nC MemberData C MemberCode\n*\nC BookLending C User C BookItem Figure 1.12 A class diagram where Member\nis split into code and data entities\n--- Page 44 ---\n16 CHAPTER 1 Complexity of object-orientedprogramming\nThe class diagram where Member is split into MemberCode and MemberData is made of\ntwo independent parts. Each part is easier to understand than the original diagram.\nLet’s split every class of our original class diagram into code and data entities.\nFigure 1.13 shows the resulting diagram. Now the system is made of two indepen-\ndent parts:\n A part that involves only data entities.\n A part that involves only code entities.\nC LibraryData * C LibrarianData C CatalogCode\n*\nC MemberData C CatalogData C LibrarianCode\n*\nC BookData C MemberCode C BookLendingCode C BookItemCode\n*\n* *\nC BookItemData C AuthorData C UserCode C BookItem\n*\nC BookLendingData\nFigure 1.13 A class diagram where every class is split into code and data entities\nTIP A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\nThe resulting system, made up of two independent subsystems, is easier to understand\nthan the original system. The fact that the two subsystems are independent means that\neach subsystem can be understood separately and in any order. The resulting system\nnot simpler by accident; it is a logical consequence of separating code from data.\nTIP A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n1.2.2 Unpredictable code behavior\nYou might be a bit tired after the system-level analysis that we presented in the previ-\nous section. Let’s get refreshed and look at some code.\nTake a look at the code in listing 1.1, where we get the blocked status of a member\nand display it twice. If I tell you that when I called displayBlockedStatusTwice, the\nprogram displayed true on the first console.log call, can you tell me what the pro-\ngram displayed on the second console.log call?\n--- Page 45 ---\n1.2 Sources of complexity 17\nListing1.1 Really simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nvar isBlocked = this.isBlocked;\nconsole.log(isBlocked);\nconsole.log(isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\n“Of course, it displayed true again,” you say. And you are right!\nNow, take a look at a slightly different pseudocode as shown in listing 1.2. Here we\ndisplay, twice, the blocked status of a member without assigning a variable. Same ques-\ntion as before: if I tell you that when I called displayBlockedStatusTwice, the pro-\ngram displayed true on the first console.log call, can you tell me what the program\ndisplayed on the second console.log call?\nListing1.2 Apparently simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nconsole.log(this.isBlocked);\nconsole.log(this.isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\nThe correct answer is...in a single-threaded environment, it displays true, while in a\nmulti-threaded environment, it’s unpredictable. Indeed, in a multi-threaded environ-\nment between the two console.log calls, there could be a context switch that changes\nthe state of the object (e.g., a librarian unblocked the member). In fact, with a slight\nmodification, the same kind of code unpredictability could occur even in a single-\nthreaded environment like JavaScript, when data is modified via asynchronous code\n(see the section about Principle #3 in appendix A). The difference between the two\ncode snippets is that\n In the first listing (listing 1.1), we access a Boolean value twice , which is a prim-\nitive value.\n In the second listing (listing 1.2), we access a member of an object twice.\nTIP When data is mutable, code is unpredictable.\n--- Page 46 ---\n18 CHAPTER 1 Complexity of object-orientedprogramming\nThis unpredictable behavior of the second listing is one of the annoying conse-\nquences of OOP. Unlike primitive types, which are usually immutable, object mem-\nbers are mutable. One way to solve this problem in OOP is to protect sensitive code\nwith concurrency safety mechanisms like mutexes, but that introduces issues like a\nperformance hit and a risk of deadlocks.\nWe will see later in the book that DOP treats every piece of data in the same way:\nboth primitive types and collection types are immutable values. This value treatment for\nall citizens brings serenity to DOP developers’ minds, and more brain cells are avail-\nable to handle the interesting pieces of the applications they build.\nTIP Data immutability brings serenity to DOP developers’ minds.\n1.2.3 Not trivial data serialization\nTheo is really tired, and he falls asleep at his desk. He’s having dream. In his dream, Nancy\nasks him to make Klafim’s Library Management System accessible via a REST API using\nJSON as a transport layer. Theo has to implement a /search endpoint that receives a\nquery in JSON format and returns the results in JSON format. Listing 1.3 shows an input\nexample of the /search endpoint, and listing 1.4 shows an output example of the /search\nendpoint.\nListing1.3 A JSON input of the /search endpoint\n{\n\"searchCriteria\": \"author\",\n\"query\": \"albert\"\n}\nListing1.4 A JSON output of the /search endpoint\n[\n{\n\"title\": \"The world as I see it\",\n\"authors\": [\n{\n\"fullName\": \"Albert Einstein\"\n}\n]\n},\n{\n\"title\": \"The Stranger\",\n\"authors\": [\n{\n\"fullName\": \"Albert Camus\"\n}\n]\n}\n]\n--- Page 47 ---\n1.2 Sources of complexity 19\nTheo would probably implement the /search endpoint by creating three classes simi-\nlarly to what is shown in the following list and in figure 1.14. (Not surprisingly, every-\nthing in OOP has to be wrapped in a class. Right?)\n SearchController is responsible for handling the query.\n SearchQuery converts the JSON query string into data.\n SearchResult converts the search result data into a JSON string.\nC SearchController\nString handle(searchQuery: String)\nC SearchQuery\nC SearchResult\nC Catalog\nsearchCriteria: String\nSearchResult(books: List<Book>)\nList<Book> search(searchCriteria, queryStr) query: String\nString toJSON()\nSearchQuery(jsonString: String)\n* *\nC Book\nid : String\ntitle : String\nFigure 1.14 The class diagram for SearchController\nThe SearchController (see figure 1.14) would have a single handle method with the\nfollowing flow:\n Creates a SearchQuery object from the JSON query string.\n Retrieves searchCriteria and queryStr from the SearchQuery object.\n Calls the search method of the catalog:Catalog with searchCriteria and\nqueryStr and receives books:List<Book>.\n Creates a SearchResult object with books.\n Converts the SearchResult object to a JSON string.\nWhat about other endpoints, for instance, those allowing librarians to add book items\nthrough /add-book-item? Theo would have to repeat the exact same process and cre-\nate three classes:\n AddBookItemController to handle the query\n BookItemQuery to convert the JSON query string into data\n BookItemResult to convert the search result data into a JSON string\nThe code that deals with JSON deserialization that Theo wrote previously in Search-\nQuery would have to be rewritten in BookItemQuery. Same thing for the code that\ndeals with JSON serialization he wrote previously in SearchResult; it would have to be\nrewritten in BookItemResult.\n--- Page 48 ---\n20 CHAPTER 1 Complexity of object-orientedprogramming\nThe bad news is that Theo would have to repeat the same process for every end-\npoint of the system. Each time he encounters a new kind of JSON input or output,\nhe would have to create a new class and write code. Theo’s dream is turning into a\nnightmare!\nSuddenly, his phone rings, next to where he was resting his head on the desk. As Theo\nwakes up, he realizes that Nancy never asked for JSON. It was all a dream...a really bad\ndream!\nTIP In OOP, data serialization is difficult.\nIt’s quite frustrating that handling JSON serialization and deserialization in OOP\nrequires the addition of so many classes and writing so much code—again and again!\nThe frustration grows when you consider that serializing a search query, a book item\nquery, or any query is quite similar. It comes down to\n Going over data fields.\n Concatenating the name of the data fields and the value of the data fields, sepa-\nrated by a comma.\nWhy is such a simple thing so hard to achieve in OOP? In OOP, data has to follow a\nrigid shape defined in classes, which means that data is locked in members. There is\nno simple way to access data generically.\nTIP In OOP, data is locked in classes as members.\nWe will refine later what we mean by generic access to the data, and we will see how\nDOP provides a generic way to handle JSON serialization and deserialization. Until\nthen, you will have to continue suffering. But at least you are starting to become aware\nof this suffering, and you know that it is avoidable.\n NOTE Most OOP programming languages alleviate a bit of the difficulty involved\nin the conversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n1.2.4 Complex class hierarchies\nOne way to avoid writing the same code twice in OOP involves class inheritance. Indeed,\nwhen every requirement of the system is known up front, you design your class hier-\narchy is such a way that classes with common behavior derive from a base class.\nFigure 1.15 shows an example of this pattern that focuses on the part of our class\ndiagram that deals with members and librarians. Both Librarians and Members need\nthe ability to log in, and they inherit this ability from the User class.\nSo far, so good, but when new requirements are introduced after the system is imple-\nmented, it’s a completely different story. Fast forward to Monday, March 29th, at 11:00 AM,\nwhere two days are left before the deadline (Wednesday at midnight).\n--- Page 49 ---\n1.2 Sources of complexity 21\nC Librarian\nblockMember(member: Member) : Bool\nunblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String Figure 1.15 The part of the\npassword : String class diagram that deals with\nlogin() : Bool members and librarians\nNancy calls Theo with an urgent request. Theo is not sure if it’s a dream or reality. He\npinches himself and he can feel the jolt. It’s definitely reality!\nNancy How is the project doing?\nTheo Fine, Nancy. We’re on schedule to meet the deadline. We’re running our last\nround of regression tests now.\nNancy Fantastic! It means we have time for adding a tiny feature to the system, right?\nTheo Depends what you mean by “tiny.”\nNancy We need to add VIP members to the system.\nTheo What do you mean by VIP members?\nNancy VIP members are allowed to add book items to the library by themselves.\nTheo Hmm...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nI’ll ask you the same question Nancy asked Theo: why is adding VIP members to our\nsystem not a tiny task? After all, Theo has already written the code that allows librari-\nans to add book items to the library (it’s in Librarian::addBookItem). What prevents\nhim from reusing this code for VIP members? The reason is that, in OOP, the code is\nlocked into classes as methods.\nTIP In OOP, code is locked into classes.\nVIP members are members that are allowed to add book items to the library by them-\nselves. Theo decomposes the customer requirements into two pieces:\n--- Page 50 ---\n22 CHAPTER 1 Complexity of object-orientedprogramming\n VIP members are library members.\n VIP members are allowed to add book items to the library by themselves.\nTheo then decides that he needs a new class, VIPMember. For the first requirement\n(VIP members are library members), it seems reasonable to make VIPMember derive\nfrom Member. However, handling the second requirement (VIP members are allowed\nto add book items) is more complex. He cannot make a VIPMember derive from\nLibrarian because the relation between VIPMember and Librarian is not linear:\n On one hand, VIP members are like librarians in that they are allowed to add\nbook items.\n On the other hand, VIP members are not like librarians in that they are not\nallowed to block members or list the books lent to a member.\nThe problem is that the code that adds book items is locked in the Librarian class.\nThere is no way for the VIPMember class to use this code.\nFigure 1.16 shows one possible solution that makes the code of Librarian::add-\nBookItem available to both Librarian and VIPMember classes. Here are the changes to\nthe previous class diagram:\n A base class UserWithBookItemRight extends User.\n addBookItem moves from Librarian to UserWithBookItemRight.\n Both VIPMember and Librarian extend UserWithBookItemRight.\nC Librarian\nblockMember(member: Member) : Bool C VIPMember\nunblockMember(member: Member) : Bool\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nCC UserWithBookItemRight\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool addBookItem(bookItem: BookItem) : BookItem\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.16 A class diagram for a system with VIP members\nIt wasn’t easy, but Theo manages to handle the change on time, thanks to an all nighter\ncoding on his laptop. He was even able to add new tests to the system and run the regres-\nsion tests again. However, he was so excited that he didn’t pay attention to the diamond\n--- Page 51 ---\n1.2 Sources of complexity 23\nproblem VIPMember introduced in his class diagram due to multiple inheritance: VIPMember\nextends both Member and UserWithBookItemRight, which both extend User.\nWednesday, March 31, at 10:00 AM (14 hours before the deadline), Theo calls Nancy to\ntell her the good news.\nTheo We were able to add VIP members to the system on time, Nancy.\nNancy Fantastic! I told you it was a tiny feature.\nTheo Yeah, well...\nNancy Look, I was going to call you anyway. I just finished a meeting with my business\npartner, and we realized that we need another tiny feature before the launch.\nWill you be able to handle it before the deadline?\nTheo Again, it depends what you mean by “tiny.”\nNancy We need to add Super members to the system.\nTheo What do you mean by Super members?\nNancy Super members are allowed to list the books lent to other members.\nTheo Err...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nAs with VIP members, adding Super members to the system requires changes to Theo’s\nclass hierarchy. Figure 1.17 shows the solution Theo has in mind.\nC Librarian\nC VIPMember C SuperMember\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC UserWithBlockMemberRight\nCC UserWithBookItemRight\nblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\nunblockMember(member: Member) : Bool\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.17 A class diagram for a system with Super and VIP members\nThe addition of Super members has made the system really complex. Theo suddenly\nnotices that he has three diamonds in his class diagram—not gemstones but three “Deadly\n--- Page 52 ---\n24 CHAPTER 1 Complexity of object-orientedprogramming\nDiamonds of Death” as OOP developers sometimes name the ambiguity that arises when a\nclass D inherits from two classes B and C, where both inherit from class A!\nHe tries to avoid the diamonds by transforming the User class into an interface and\nusing the composition over inheritance design pattern. But with the stress of the deadline\nlooming, he isn’t able to use all of his brain cells. In fact, the system has become so com-\nplex, he’s unable to deliver the system by the deadline. Theo tells himself that he should\nhave used composition instead of class inheritance. But, it’s too late now.\nTIP In OOP, prefer composition over class inheritance.\nAt 10:00 PM, two hours before the deadline, Theo calls Nancy to explain the situation.\nTheo Look Nancy, we really did our best, but we won’t be able to add Super mem-\nbers to the system before the deadline.\nNancy No worries, my business partner and I decided to omit this feature for now.\nWe’ll add it later.\nWith mixed feelings of anger and relief, Theo stops pacing around his office. He realizes\nhe will be spending tonight in his own bed, rather than plowing away on his computer at\nthe office. That should make his wife happy.\nTheo I guess that means we’re ready for the launch tomorrow morning.\nNancy Yes. We’ll offer this new product for a month or so, and if we get good market\ntraction, we’ll move forward with a bigger project.\nTheo Cool. Let’s be in touch in a month then. Good luck on the launch!\nSummary\n Complexity in the context of this book means hard to understand.\n We use the terms code and behavior interchangeably.\n DOP stands for data-oriented programming.\n OOP stands for object-oriented programming.\n FP stands for functional programming.\n In a composition relation, when one object dies, the other one also dies.\n A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\n In an association relation, each object has an independent life cycle.\n A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\n Dashed arrows indicate a usage relation; for instance, when a class uses a method\nof another class.\n Plain arrows with empty triangles represent class inheritance, where the arrow\npoints towards the superclass.\n The design presented in this chapter doesn’t pretend to be the smartest OOP\ndesign. Experienced OOP developers would probably use a couple of design\npatterns and suggest a much better diagram.\n--- Page 53 ---\nSummary 25\n Traditional OOP systems tend to increase system complexity, in the sense that\nOOP systems are hard to understand.\n In traditional OOP, code and data are mixed together in classes: data as mem-\nbers and code as methods.\n In traditional OOP, data is mutable.\n The root cause of the increase in complexity is related to the mixing of code\nand data together into objects.\n When code and data are mixed, classes tend to be involved in many relations.\n When objects are mutable, extra thinking is required in order to understand\nhow the code behaves.\n When objects are mutable, explicit synchronization mechanisms are required\non multi-threaded environments.\n When data is locked in objects, data serialization is not trivial.\n When code is locked in classes, class hierarchies tend to be complex.\n A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\n A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n When data is mutable, code is unpredictable.\n A strategic use of design patterns can help mitigate complexity in traditional\nOOP to some degree.\n Data immutability brings serenity to DOP developers’ minds.\n Most OOP programming languages alleviate slightly the difficulty involved the\nconversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n In traditional OOP, data serialization is difficult.\n In traditional OOP, data is locked in classes as members.\n In traditional OOP, code is locked into classes.\n DOP reduces complexity by rethinking data.\n DOP is compatible both with OOP and FP.\n--- Page 54 ---\nSeparation between\ncode and data\nA whole new world\nThis chapter covers\n The benefits of separating code from data\n Designing a system where code and data are\nseparate\n Implementing a system that respects the\nseparation between code and data\nThe first insight of DOP is that we can decrease the complexity of our systems by\nseparating code from data. Indeed, when code is separated from data, our systems\nare made of two main pieces that can be thought about separately: data entities and\ncode modules. This chapter is a deep dive in the first principle of DOP (summa-\nrized in figure 2.1).\nPRINCIPLE #1 Separate code from data such that the code resides in functions,\nwhose behavior doesn’t depend on data that is somehow encapsulated in the func-\ntion’s context.\n26\n--- Page 55 ---\n2.1 The two parts of a DOP system 27\nStateless (static)\nFunctions\nData asfirst argument\nCode modules\nUsage\nRelations\nNo inheritance\nSeparate code from data\nOnly members\nData entities No code\nAssociation\nRelations\nComposition\nFigure 2.1 DOP principle #1 summarized: Separate code from data.\nIn this chapter, we’ll illustrate the separation between code and data in the context of\nKlafim’s Library Management System that we introduced in chapter 1. We’ll also unveil\nthe benefits that this separation brings to the system:\n The system is simple. It is easy to understand.\n The system is flexible and extensible. Quite often, it requires no design changes to\nadapt to changing requirements.\nThis chapter focuses on the design of the code in a system where code and data are\nseparate. In the next chapter, we’ll focus on the design of the data. As we progress in\nthe book, we’ll discover other benefits of separating code from data.\n2.1 The two parts of a DOP system\nWhile Theo is driving home after delivering the prototype, he asks himself whether the\nKlafim project was a success or not. Sure, he was able to satisfy the customer, but it was\nmore luck than brains. He wouldn’t have made it on time if Nancy had decided to keep\nthe Super members feature. Why was it so complicated to add tiny features to the system?\nWhy was the system he built so complex? He thought there should be a way to build more\nflexible systems!\nThe next morning, Theo asks on Hacker News and on Reddit for ways to reduce system\ncomplexity and build flexible systems. Some folks mention using different programming\nlanguages, while others talk about advanced design patterns. Finally, Theo’s attention gets\ncaptured by a comment from a user named Joe. He mentions data-oriented programming and\nclaims that its main goal is to reduce system complexity. Theo has never heard this term\nbefore. Out of curiosity, he decides to contact Joe by email. What a coincidence! Joe lives\nin San Francisco too. Theo invites him to a meeting in his office.\nJoe is a 40-year-old developer. He was a Java developer for nearly a decade before adopt-\ning Clojure around 7 years ago. When Theo tells Joe about the Library Management System",
        "sections_found": []
      },
      "accurate_page_range": "32-55"
    },
    {
      "text": "- 1.2.1 Many relations between classes",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "raw_line": "- 1.2.1 Many relations between classes (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 9,
      "chapter_info": {
        "page": 32,
        "title": "Complexity of object-oriented programming",
        "pattern_matched": "Chapter 1",
        "text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased "
      },
      "chapter_sections": {
        "start_page": 32,
        "end_page": 55,
        "content": "\n--- Page 32 ---\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, and their new project were introduced in the opener for part 1.\nTake a moment to read the opener if you missed it.\nTheo gets back to the office with Nancy’s napkin in his pocket and a lot of anxiety in his\nheart because he knows he has committed to a tough deadline. But he had no choice! Last\nweek, Monica, his boss, told him quite clearly that he had to close the deal with Nancy no\nmatter what.\nAlbatross, where Theo works, is a software consulting company with customers all over\nthe world. It originally had lots of customers among startups. Over the last year, however,\nmany projects were badly managed, and the Startup department lost the trust of its cus-\ntomers. That’s why management moved Theo from the Enterprise department to the\nStartup department as a Senior Tech lead. His job is to close deals and to deliver on time.\n1.1.1 The design phase\nBefore rushing to his laptop to code the system, Theo grabs a sheet of paper, much big-\nger than a napkin, and starts to draw a UML class diagram of the system that will imple-\nment the Klafim prototype. Theo is an object-oriented programmer. For him, there is no\nquestion—every business entity is represented by an object, and every object is made\nfrom a class.\nThe requirements for the Klafim prototype\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There can be several copies of a book.\n A book belongs to a physical library.\nTheo spends some time thinking about the organization of the system. He identifies the\nmain classes for the Klafim Global Library Management System.\n--- Page 33 ---\n1.1 OOP design: Classic or classical? 5\nThe main classes of the library management system\n Library—The central part of the system design.\n Book—A book.\n BookItem—A book can have multiple copies, and each copy is considered as\na book item.\n BookLending—When a book is lent, a book lending object is created.\n Member—A member of the library.\n Librarian—A librarian.\n User—A base class for Librarian and Member.\n Catalog—Contains a list of books.\n Author—A book author.\nThat was the easy part. Now comes the difficult part: the relations between the classes.\nAfter two hours or so, Theo comes up with a first draft of a design for the Global Library\nManagement System. It looks like the diagram in figure 1.1.\n NOTE The design presented here doesn’t pretend to be the smartest OOP design:\nexperienced OOP developers would probably use a couple of design patterns to sug-\ngest a much better design. This design is meant to be naive and by no means covers all\nthe features of the system. It serves two purposes:\n For Theo, the developer, it is rich enough to start coding.\n For me, the author of the book, it is rich enough to illustrate the complexity of a\ntypical OOP system.\nTheo feels proud of himself and of the design diagram he just produced. He definitely\ndeserves a cup of coffee!\nNear the coffee machine, Theo meets Dave, a junior software developer who joined\nAlbatross a couple of weeks ago. Theo and Dave appreciate each other, as Dave’s curiosity\nleads him to ask challenging questions. Meetings near the coffee machine often turn into\ninteresting discussions about programming.\nTheo Hey Dave! How’s it going?\nDave Today? Not great. I’m trying to fix a bug in my code! I can’t understand why\nthe state of my objects always changes. I’ll figure it out though, I’m sure. How’s\nyour day going?\nTheo I just finished the design of a system for a new customer.\nDave Cool! Would it be OK for me to see it? I’m trying to improve my design skills.\nTheo Sure! I have the diagram on my desk. We can take a look now if you like.\n--- Page 34 ---\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool\nid : String block() : Bool\nfullName: String unblock() : Bool\nreturnBook(bookLending: BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\n*\nC User\nC BookItem\nid : String\nid : String\nemail : String\nlibId: String\npassword : String\ncheckout(member: Member) : BookLending\nlogin() : Bool\nC BookLending\nid : String\nlendingDate : date *\ndueDate : date\nisLate() : Bool\nreturnBook() : Bool\nFigure 1.1 A class diagram for Klafim’s Global Library Management System\n1.1.2 UML 101\nLatte in hand, Dave follows Theo to his desk. Theo proudly shows Dave his piece of art: the\nUML diagram for the Library Management System (figure 1.1). Dave seems really excited.\nDave Wow! Such a detailed class diagram.\nTheo Yeah. I’m pretty happy with it.\n--- Page 35 ---\n1.1 OOP design: Classic or classical? 7\nDave The thing is that I can never remember the meaning of the different arrows.\nTheo There are four types of arrows in my class diagram: composition, association,\ninheritance, and usage.\nDave What’s the difference between composition and association?\n NOTE Don’t worry if you’re not familiar with OOP jargon. We’re going to leave it\naside in the next chapter.\nTheo It’s all about whether the objects can live without each other. With composi-\ntion, when one object dies, the other one dies too. While in an association rela-\ntion, each object has an independent life.\nTIP In a composition relation, when one object dies, the other one also dies. While\nin an association relation, each object has an independent life cycle.\nIn the class diagram, there are two kinds of composition symbolized by an arrow with\na plain diamond at one edge and an optional star at the other edge. Figure 1.2 shows\nthe relation between:\n A Library that owns a Catalog—A one-to-one composition. If a Library object\ndies, then its Catalog object dies with it.\n A Library that owns many Members—A one-to-many composition. If a Library\nobject dies, then all its Member objects die with it.\nC Library\nname : String * C Member\naddress : String\nFigure 1.2 The two kinds of\nC Catalog composition: one-to-one and\none-to-many. In both cases,\nList<Book> search(searchCriteria, queryStr) when an object dies, the\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\ncomposed object dies with it.\nTIP A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\nDave Do you have association relations in your diagram?\nTheo Take a look at the arrow between Book and Author. It has an empty diamond\nand a star at both edges, so it’s a many-to-many association relation.\nA book can be written by multiple authors, and an author can write multiple books.\nMoreover, Book and Author objects can live independently. The relation between\nbooks and authors is a many-to-many association (figure 1.3).\n--- Page 36 ---\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the Librarian::blockMember method. It calls\nMember::block.\nTIP Dashed arrows indicate usage relations (figure 1.4), for instance, when a class\nuses a method of another class.\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember(member: Member)\nC Member\nBool isBlocked()\nBool block()\nBool unblock()\nBool returnBook(bookLending: BookLending) Figure 1.4 Usage relation: a class\nBookLending checkout(bookItem: BookItem) uses a method of another class.\nDave I see. And I guess a plain arrow with an empty triangle, like the one between\nMember and User, represents inheritance.\nTheo Absolutely!\nTIP Plain arrows with empty triangles represent class inheritance (figure 1.5), where\nthe arrow points towards the superclass.\n--- Page 37 ---\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasure. Want to see how it all fits together?\nDave What class should we look at first?\nTheo I think we should start with Library.\nTHE LIBRARY CLASS\nThe Library is the root class of the library system. Figure 1.6 shows the system structure.\nCC Library\nname : String\naddress : String\n*\nC Member\nC Catalog\nBool isBlocked()\nList<Book> search(searchCriteria, queryStr) Bool block()\nBookItem addBookItem(librarian: Librarian, Bool unblock()\nbookItem: BookItem) Bool returnBook(bookLending: BookLending)\nBookLending checkout(bookItem: BookItem)\n*\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember\n(member: Member)\nFigure 1.6 The Library class\n--- Page 38 ---\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC Member C Librarian\nisBlocked() : Bool blockMember(member: Member) : Bool\nblock() : Bool unblockMember(member: Member) : Bool\nunblock() : Bool addBookItem(bookItem: BookItem) : BookItem\nreturnBook(bookLending : BookLending) : Bool : Member) :\ncheckout(bookItem: BookItem) : BookLending\nCC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.7 Librarian and Member derive from User.\nThe User class represents a user of the library:\n In terms of data members, it sticks to the bare minimum: it has an id, email,\nand password (with no security and encryption for now).\n In terms of code, it can log in via login.\nThe Member class represents a member of the library:\n It inherits from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Check out a book via checkout.\n– Return a book via returnBook.\n– Block itself via block.\n– Unblock itself via unblock.\n– Answer if it is blocked via isBlocked.\n It owns multiple BookLending objects.\n It uses BookItem in order to implement checkout.\n--- Page 39 ---\n1.1 OOP design: Classic or classical? 11\nThe Librarian class represents a librarian:\n It derives from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Block and unblock a Member.\n– List the member’s book lendings via getBookLendings.\n– Add book items to the library via addBookItem.\n It uses Member to implement blockMember, unblockMember, and getBook-\nLendings.\n It uses BookItem to implement checkout.\n It uses BookLending to implement getBookLendings.\nTHE CATALOG CLASS\nThe Catalog class is responsible for the management of the books. Figure 1.8 shows\nthe relation among the Catalog, Librarian, and Book classes. In terms of code, a\nCatalog object can\n Search books via search.\n Add book items to the library via addBookItem.\nC Catalog\nList<Book> search(searchCriteria, queryStr)\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\nC Librarian *\nC Book\nBool blockMember(member: Member)\nBool unblockMember(member: Member) id : String\nBookItem addBookItem(bookItem: BookItem) title : String\nList<BookLending> getBookLendingsOfMember (member: Member)\nFigure 1.8 The Catalog class\nA Catalog object uses Librarian in order to implement addBookItem. In terms of\ndata, a Catalog owns multiple Book objects.\nTHE BOOK CLASS\nFigure 1.9 presents the Book class. In terms of data, a Book object\n Should have as its bare minimum an id and a title.\n Is associated with multiple Author objects (a book might have multiple authors).\n Owns multiple BookItem objects, one for each copy of the book.\n--- Page 40 ---\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare minimum data for members: an id and a libId (for its\nphysical library ID).\n Owns multiple BookLending objects, one for each time the book is lent.\nIn terms of code, a BookItem object can be checked out via checkout.\n1.1.4 The implementation phase\nAfter this detailed investigation of Theo’s diagrams, Dave lets it sink in as he slowly sips his\ncoffee. He then expresses his admiration to Theo.\nDave Wow! That’s amazing!\nTheo Thank you.\nDave I didn’t realize people were really spending the time to write down their design\nin such detail before coding.\nTheo I always do that. It saves me lot of time during the coding phase.\nDave When will you start coding?\nTheo When I finish my latte.\nTheo grabs his coffee mug and notices that his hot latte has become an iced latte. He was\nso excited to show his class diagram to Dave that he forgot to drink it!\n--- Page 41 ---\n1.2 Sources of complexity 13\n1.2 Sources of complexity\nWhile Theo is getting himself another cup of coffee (a cappuccino this time), I\nwould like to challenge his design. It might look beautiful and clear on the paper,\nbut I claim that this design makes the system hard to understand. It’s not that Theo\npicked the wrong classes or that he misunderstood the relations among the classes.\nIt goes much deeper:\n It’s about the programming paradigm he chose to implement the system.\n It’s about the object-oriented paradigm.\n It’s about the tendency of OOP to increase the complexity of a system.\nTIP OOP has a tendency to create complex systems.\nThroughout this book, the type of complexity I refer to is that which makes systems\nhard to understand as defined in the paper, “Out of the Tar Pit,” by Ben Moseley\nand Peter Marks (2006), available at http://mng.bz/enzq. It has nothing to do with\nthe type of complexity that deals with the amount of resources consumed by a pro-\ngram. Similarly, when I refer to simplicity, I mean not complex (in other words, easy\nto understand).\nKeep in mind that complexity and simplicity (like hard and easy) are not absolute\nbut relative concepts. We can compare the complexity of two systems and determine\nwhether system A is more complex (or simpler) than system B.\n NOTE Complexity in the context of this book means hard to understand.\nAs mentioned in the introduction of this chapter, there are many ways in OOP to\nalleviate complexity. The purpose of this book is not be critical of OOP, but rather\nto present a programming paradigm called data-oriented programming (DOP) that\ntends to build systems that are less complex. In fact, the DOP paradigm is compati-\nble with OOP.\nIf one chooses to build an OOP system that adheres to DOP principles, the system\nwill be less complex. According to DOP, the main sources of complexity in Theo’s sys-\ntem (and of many traditional OOP systems) are that\n Code and data are mixed.\n Objects are mutable.\n Data is locked in objects as members.\n Code is locked into classes as methods.\nThis analysis is similar to what functional programming (FP) thinks about traditional\nOOP. However, as we will see throughout the book, the data approach that DOP takes\nin order to reduce system complexity differs from the FP approach. In appendix A, we\nillustrate how to apply DOP principles both in OOP and in FP styles.\nTIP DOP is compatible both with OOP and FP.\n--- Page 42 ---\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Extra thinking is needed when reading code.\nObjects are mutable. Explicit synchronization is required on multi-threaded environments.\nData is locked in objects. Data serialization is not trivial.\nCode is locked in classes. Class hierarchies are complex.\n1.2.1 Many relations between classes\nOne way to assess the complexity of a class diagram is to look only at the entities and\ntheir relations, ignoring members and methods, as in figure 1.10. When we design a\nsystem, we have to define the relations between different pieces of code and data.\nThat’s unavoidable.\nC Library\nC Catalog\n* *\nC Book C Librarian\n*\n*\nC Member\n*\nC Author\nC BookItem C User\nFigure 1.10 A class\ndiagram overview for\nC BookLending * Klafim’s Library\nManagement System\nTIP In OOP, code and data are mixed together in classes: data as members and code as\nmethods.\n--- Page 43 ---\n1.2 Sources of complexity 15\nFrom a system analysis perspective, the fact that code and data are mixed together\nmakes the system complex in the sense that entities tend to be involved in many rela-\ntions. In figure 1.11, we take a closer look at the Member class. Member is involved in five\nrelations: two data relations and three code relations.\n Data relations:\n– Library has many Members.\n– Member has many BookLendings.\n Code relations:\n– Member extends User.\n– Librarian uses Member.\n– Member uses BookItem.\nC Librarian\nC Library * C Member\n*\nC User C BookLending C BookItem Figure 1.11 The class Member is\ninvolved in five relations.\nImagine for a moment that we were able, somehow, to split the Member class into two\nseparate entities:\n MemberCode for the code\n MemberData for the data\nInstead of a Member class with five relations, we would have the diagram shown in fig-\nure 1.12 with:\n A MemberCode entity and three relations.\n A MemberData entity and two relations.\nC Library C Librarian\n*\nC MemberData C MemberCode\n*\nC BookLending C User C BookItem Figure 1.12 A class diagram where Member\nis split into code and data entities\n--- Page 44 ---\n16 CHAPTER 1 Complexity of object-orientedprogramming\nThe class diagram where Member is split into MemberCode and MemberData is made of\ntwo independent parts. Each part is easier to understand than the original diagram.\nLet’s split every class of our original class diagram into code and data entities.\nFigure 1.13 shows the resulting diagram. Now the system is made of two indepen-\ndent parts:\n A part that involves only data entities.\n A part that involves only code entities.\nC LibraryData * C LibrarianData C CatalogCode\n*\nC MemberData C CatalogData C LibrarianCode\n*\nC BookData C MemberCode C BookLendingCode C BookItemCode\n*\n* *\nC BookItemData C AuthorData C UserCode C BookItem\n*\nC BookLendingData\nFigure 1.13 A class diagram where every class is split into code and data entities\nTIP A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\nThe resulting system, made up of two independent subsystems, is easier to understand\nthan the original system. The fact that the two subsystems are independent means that\neach subsystem can be understood separately and in any order. The resulting system\nnot simpler by accident; it is a logical consequence of separating code from data.\nTIP A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n1.2.2 Unpredictable code behavior\nYou might be a bit tired after the system-level analysis that we presented in the previ-\nous section. Let’s get refreshed and look at some code.\nTake a look at the code in listing 1.1, where we get the blocked status of a member\nand display it twice. If I tell you that when I called displayBlockedStatusTwice, the\nprogram displayed true on the first console.log call, can you tell me what the pro-\ngram displayed on the second console.log call?\n--- Page 45 ---\n1.2 Sources of complexity 17\nListing1.1 Really simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nvar isBlocked = this.isBlocked;\nconsole.log(isBlocked);\nconsole.log(isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\n“Of course, it displayed true again,” you say. And you are right!\nNow, take a look at a slightly different pseudocode as shown in listing 1.2. Here we\ndisplay, twice, the blocked status of a member without assigning a variable. Same ques-\ntion as before: if I tell you that when I called displayBlockedStatusTwice, the pro-\ngram displayed true on the first console.log call, can you tell me what the program\ndisplayed on the second console.log call?\nListing1.2 Apparently simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nconsole.log(this.isBlocked);\nconsole.log(this.isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\nThe correct answer is...in a single-threaded environment, it displays true, while in a\nmulti-threaded environment, it’s unpredictable. Indeed, in a multi-threaded environ-\nment between the two console.log calls, there could be a context switch that changes\nthe state of the object (e.g., a librarian unblocked the member). In fact, with a slight\nmodification, the same kind of code unpredictability could occur even in a single-\nthreaded environment like JavaScript, when data is modified via asynchronous code\n(see the section about Principle #3 in appendix A). The difference between the two\ncode snippets is that\n In the first listing (listing 1.1), we access a Boolean value twice , which is a prim-\nitive value.\n In the second listing (listing 1.2), we access a member of an object twice.\nTIP When data is mutable, code is unpredictable.\n--- Page 46 ---\n18 CHAPTER 1 Complexity of object-orientedprogramming\nThis unpredictable behavior of the second listing is one of the annoying conse-\nquences of OOP. Unlike primitive types, which are usually immutable, object mem-\nbers are mutable. One way to solve this problem in OOP is to protect sensitive code\nwith concurrency safety mechanisms like mutexes, but that introduces issues like a\nperformance hit and a risk of deadlocks.\nWe will see later in the book that DOP treats every piece of data in the same way:\nboth primitive types and collection types are immutable values. This value treatment for\nall citizens brings serenity to DOP developers’ minds, and more brain cells are avail-\nable to handle the interesting pieces of the applications they build.\nTIP Data immutability brings serenity to DOP developers’ minds.\n1.2.3 Not trivial data serialization\nTheo is really tired, and he falls asleep at his desk. He’s having dream. In his dream, Nancy\nasks him to make Klafim’s Library Management System accessible via a REST API using\nJSON as a transport layer. Theo has to implement a /search endpoint that receives a\nquery in JSON format and returns the results in JSON format. Listing 1.3 shows an input\nexample of the /search endpoint, and listing 1.4 shows an output example of the /search\nendpoint.\nListing1.3 A JSON input of the /search endpoint\n{\n\"searchCriteria\": \"author\",\n\"query\": \"albert\"\n}\nListing1.4 A JSON output of the /search endpoint\n[\n{\n\"title\": \"The world as I see it\",\n\"authors\": [\n{\n\"fullName\": \"Albert Einstein\"\n}\n]\n},\n{\n\"title\": \"The Stranger\",\n\"authors\": [\n{\n\"fullName\": \"Albert Camus\"\n}\n]\n}\n]\n--- Page 47 ---\n1.2 Sources of complexity 19\nTheo would probably implement the /search endpoint by creating three classes simi-\nlarly to what is shown in the following list and in figure 1.14. (Not surprisingly, every-\nthing in OOP has to be wrapped in a class. Right?)\n SearchController is responsible for handling the query.\n SearchQuery converts the JSON query string into data.\n SearchResult converts the search result data into a JSON string.\nC SearchController\nString handle(searchQuery: String)\nC SearchQuery\nC SearchResult\nC Catalog\nsearchCriteria: String\nSearchResult(books: List<Book>)\nList<Book> search(searchCriteria, queryStr) query: String\nString toJSON()\nSearchQuery(jsonString: String)\n* *\nC Book\nid : String\ntitle : String\nFigure 1.14 The class diagram for SearchController\nThe SearchController (see figure 1.14) would have a single handle method with the\nfollowing flow:\n Creates a SearchQuery object from the JSON query string.\n Retrieves searchCriteria and queryStr from the SearchQuery object.\n Calls the search method of the catalog:Catalog with searchCriteria and\nqueryStr and receives books:List<Book>.\n Creates a SearchResult object with books.\n Converts the SearchResult object to a JSON string.\nWhat about other endpoints, for instance, those allowing librarians to add book items\nthrough /add-book-item? Theo would have to repeat the exact same process and cre-\nate three classes:\n AddBookItemController to handle the query\n BookItemQuery to convert the JSON query string into data\n BookItemResult to convert the search result data into a JSON string\nThe code that deals with JSON deserialization that Theo wrote previously in Search-\nQuery would have to be rewritten in BookItemQuery. Same thing for the code that\ndeals with JSON serialization he wrote previously in SearchResult; it would have to be\nrewritten in BookItemResult.\n--- Page 48 ---\n20 CHAPTER 1 Complexity of object-orientedprogramming\nThe bad news is that Theo would have to repeat the same process for every end-\npoint of the system. Each time he encounters a new kind of JSON input or output,\nhe would have to create a new class and write code. Theo’s dream is turning into a\nnightmare!\nSuddenly, his phone rings, next to where he was resting his head on the desk. As Theo\nwakes up, he realizes that Nancy never asked for JSON. It was all a dream...a really bad\ndream!\nTIP In OOP, data serialization is difficult.\nIt’s quite frustrating that handling JSON serialization and deserialization in OOP\nrequires the addition of so many classes and writing so much code—again and again!\nThe frustration grows when you consider that serializing a search query, a book item\nquery, or any query is quite similar. It comes down to\n Going over data fields.\n Concatenating the name of the data fields and the value of the data fields, sepa-\nrated by a comma.\nWhy is such a simple thing so hard to achieve in OOP? In OOP, data has to follow a\nrigid shape defined in classes, which means that data is locked in members. There is\nno simple way to access data generically.\nTIP In OOP, data is locked in classes as members.\nWe will refine later what we mean by generic access to the data, and we will see how\nDOP provides a generic way to handle JSON serialization and deserialization. Until\nthen, you will have to continue suffering. But at least you are starting to become aware\nof this suffering, and you know that it is avoidable.\n NOTE Most OOP programming languages alleviate a bit of the difficulty involved\nin the conversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n1.2.4 Complex class hierarchies\nOne way to avoid writing the same code twice in OOP involves class inheritance. Indeed,\nwhen every requirement of the system is known up front, you design your class hier-\narchy is such a way that classes with common behavior derive from a base class.\nFigure 1.15 shows an example of this pattern that focuses on the part of our class\ndiagram that deals with members and librarians. Both Librarians and Members need\nthe ability to log in, and they inherit this ability from the User class.\nSo far, so good, but when new requirements are introduced after the system is imple-\nmented, it’s a completely different story. Fast forward to Monday, March 29th, at 11:00 AM,\nwhere two days are left before the deadline (Wednesday at midnight).\n--- Page 49 ---\n1.2 Sources of complexity 21\nC Librarian\nblockMember(member: Member) : Bool\nunblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String Figure 1.15 The part of the\npassword : String class diagram that deals with\nlogin() : Bool members and librarians\nNancy calls Theo with an urgent request. Theo is not sure if it’s a dream or reality. He\npinches himself and he can feel the jolt. It’s definitely reality!\nNancy How is the project doing?\nTheo Fine, Nancy. We’re on schedule to meet the deadline. We’re running our last\nround of regression tests now.\nNancy Fantastic! It means we have time for adding a tiny feature to the system, right?\nTheo Depends what you mean by “tiny.”\nNancy We need to add VIP members to the system.\nTheo What do you mean by VIP members?\nNancy VIP members are allowed to add book items to the library by themselves.\nTheo Hmm...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nI’ll ask you the same question Nancy asked Theo: why is adding VIP members to our\nsystem not a tiny task? After all, Theo has already written the code that allows librari-\nans to add book items to the library (it’s in Librarian::addBookItem). What prevents\nhim from reusing this code for VIP members? The reason is that, in OOP, the code is\nlocked into classes as methods.\nTIP In OOP, code is locked into classes.\nVIP members are members that are allowed to add book items to the library by them-\nselves. Theo decomposes the customer requirements into two pieces:\n--- Page 50 ---\n22 CHAPTER 1 Complexity of object-orientedprogramming\n VIP members are library members.\n VIP members are allowed to add book items to the library by themselves.\nTheo then decides that he needs a new class, VIPMember. For the first requirement\n(VIP members are library members), it seems reasonable to make VIPMember derive\nfrom Member. However, handling the second requirement (VIP members are allowed\nto add book items) is more complex. He cannot make a VIPMember derive from\nLibrarian because the relation between VIPMember and Librarian is not linear:\n On one hand, VIP members are like librarians in that they are allowed to add\nbook items.\n On the other hand, VIP members are not like librarians in that they are not\nallowed to block members or list the books lent to a member.\nThe problem is that the code that adds book items is locked in the Librarian class.\nThere is no way for the VIPMember class to use this code.\nFigure 1.16 shows one possible solution that makes the code of Librarian::add-\nBookItem available to both Librarian and VIPMember classes. Here are the changes to\nthe previous class diagram:\n A base class UserWithBookItemRight extends User.\n addBookItem moves from Librarian to UserWithBookItemRight.\n Both VIPMember and Librarian extend UserWithBookItemRight.\nC Librarian\nblockMember(member: Member) : Bool C VIPMember\nunblockMember(member: Member) : Bool\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nCC UserWithBookItemRight\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool addBookItem(bookItem: BookItem) : BookItem\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.16 A class diagram for a system with VIP members\nIt wasn’t easy, but Theo manages to handle the change on time, thanks to an all nighter\ncoding on his laptop. He was even able to add new tests to the system and run the regres-\nsion tests again. However, he was so excited that he didn’t pay attention to the diamond\n--- Page 51 ---\n1.2 Sources of complexity 23\nproblem VIPMember introduced in his class diagram due to multiple inheritance: VIPMember\nextends both Member and UserWithBookItemRight, which both extend User.\nWednesday, March 31, at 10:00 AM (14 hours before the deadline), Theo calls Nancy to\ntell her the good news.\nTheo We were able to add VIP members to the system on time, Nancy.\nNancy Fantastic! I told you it was a tiny feature.\nTheo Yeah, well...\nNancy Look, I was going to call you anyway. I just finished a meeting with my business\npartner, and we realized that we need another tiny feature before the launch.\nWill you be able to handle it before the deadline?\nTheo Again, it depends what you mean by “tiny.”\nNancy We need to add Super members to the system.\nTheo What do you mean by Super members?\nNancy Super members are allowed to list the books lent to other members.\nTheo Err...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nAs with VIP members, adding Super members to the system requires changes to Theo’s\nclass hierarchy. Figure 1.17 shows the solution Theo has in mind.\nC Librarian\nC VIPMember C SuperMember\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC UserWithBlockMemberRight\nCC UserWithBookItemRight\nblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\nunblockMember(member: Member) : Bool\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.17 A class diagram for a system with Super and VIP members\nThe addition of Super members has made the system really complex. Theo suddenly\nnotices that he has three diamonds in his class diagram—not gemstones but three “Deadly\n--- Page 52 ---\n24 CHAPTER 1 Complexity of object-orientedprogramming\nDiamonds of Death” as OOP developers sometimes name the ambiguity that arises when a\nclass D inherits from two classes B and C, where both inherit from class A!\nHe tries to avoid the diamonds by transforming the User class into an interface and\nusing the composition over inheritance design pattern. But with the stress of the deadline\nlooming, he isn’t able to use all of his brain cells. In fact, the system has become so com-\nplex, he’s unable to deliver the system by the deadline. Theo tells himself that he should\nhave used composition instead of class inheritance. But, it’s too late now.\nTIP In OOP, prefer composition over class inheritance.\nAt 10:00 PM, two hours before the deadline, Theo calls Nancy to explain the situation.\nTheo Look Nancy, we really did our best, but we won’t be able to add Super mem-\nbers to the system before the deadline.\nNancy No worries, my business partner and I decided to omit this feature for now.\nWe’ll add it later.\nWith mixed feelings of anger and relief, Theo stops pacing around his office. He realizes\nhe will be spending tonight in his own bed, rather than plowing away on his computer at\nthe office. That should make his wife happy.\nTheo I guess that means we’re ready for the launch tomorrow morning.\nNancy Yes. We’ll offer this new product for a month or so, and if we get good market\ntraction, we’ll move forward with a bigger project.\nTheo Cool. Let’s be in touch in a month then. Good luck on the launch!\nSummary\n Complexity in the context of this book means hard to understand.\n We use the terms code and behavior interchangeably.\n DOP stands for data-oriented programming.\n OOP stands for object-oriented programming.\n FP stands for functional programming.\n In a composition relation, when one object dies, the other one also dies.\n A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\n In an association relation, each object has an independent life cycle.\n A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\n Dashed arrows indicate a usage relation; for instance, when a class uses a method\nof another class.\n Plain arrows with empty triangles represent class inheritance, where the arrow\npoints towards the superclass.\n The design presented in this chapter doesn’t pretend to be the smartest OOP\ndesign. Experienced OOP developers would probably use a couple of design\npatterns and suggest a much better diagram.\n--- Page 53 ---\nSummary 25\n Traditional OOP systems tend to increase system complexity, in the sense that\nOOP systems are hard to understand.\n In traditional OOP, code and data are mixed together in classes: data as mem-\nbers and code as methods.\n In traditional OOP, data is mutable.\n The root cause of the increase in complexity is related to the mixing of code\nand data together into objects.\n When code and data are mixed, classes tend to be involved in many relations.\n When objects are mutable, extra thinking is required in order to understand\nhow the code behaves.\n When objects are mutable, explicit synchronization mechanisms are required\non multi-threaded environments.\n When data is locked in objects, data serialization is not trivial.\n When code is locked in classes, class hierarchies tend to be complex.\n A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\n A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n When data is mutable, code is unpredictable.\n A strategic use of design patterns can help mitigate complexity in traditional\nOOP to some degree.\n Data immutability brings serenity to DOP developers’ minds.\n Most OOP programming languages alleviate slightly the difficulty involved the\nconversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n In traditional OOP, data serialization is difficult.\n In traditional OOP, data is locked in classes as members.\n In traditional OOP, code is locked into classes.\n DOP reduces complexity by rethinking data.\n DOP is compatible both with OOP and FP.\n--- Page 54 ---\nSeparation between\ncode and data\nA whole new world\nThis chapter covers\n The benefits of separating code from data\n Designing a system where code and data are\nseparate\n Implementing a system that respects the\nseparation between code and data\nThe first insight of DOP is that we can decrease the complexity of our systems by\nseparating code from data. Indeed, when code is separated from data, our systems\nare made of two main pieces that can be thought about separately: data entities and\ncode modules. This chapter is a deep dive in the first principle of DOP (summa-\nrized in figure 2.1).\nPRINCIPLE #1 Separate code from data such that the code resides in functions,\nwhose behavior doesn’t depend on data that is somehow encapsulated in the func-\ntion’s context.\n26\n--- Page 55 ---\n2.1 The two parts of a DOP system 27\nStateless (static)\nFunctions\nData asfirst argument\nCode modules\nUsage\nRelations\nNo inheritance\nSeparate code from data\nOnly members\nData entities No code\nAssociation\nRelations\nComposition\nFigure 2.1 DOP principle #1 summarized: Separate code from data.\nIn this chapter, we’ll illustrate the separation between code and data in the context of\nKlafim’s Library Management System that we introduced in chapter 1. We’ll also unveil\nthe benefits that this separation brings to the system:\n The system is simple. It is easy to understand.\n The system is flexible and extensible. Quite often, it requires no design changes to\nadapt to changing requirements.\nThis chapter focuses on the design of the code in a system where code and data are\nseparate. In the next chapter, we’ll focus on the design of the data. As we progress in\nthe book, we’ll discover other benefits of separating code from data.\n2.1 The two parts of a DOP system\nWhile Theo is driving home after delivering the prototype, he asks himself whether the\nKlafim project was a success or not. Sure, he was able to satisfy the customer, but it was\nmore luck than brains. He wouldn’t have made it on time if Nancy had decided to keep\nthe Super members feature. Why was it so complicated to add tiny features to the system?\nWhy was the system he built so complex? He thought there should be a way to build more\nflexible systems!\nThe next morning, Theo asks on Hacker News and on Reddit for ways to reduce system\ncomplexity and build flexible systems. Some folks mention using different programming\nlanguages, while others talk about advanced design patterns. Finally, Theo’s attention gets\ncaptured by a comment from a user named Joe. He mentions data-oriented programming and\nclaims that its main goal is to reduce system complexity. Theo has never heard this term\nbefore. Out of curiosity, he decides to contact Joe by email. What a coincidence! Joe lives\nin San Francisco too. Theo invites him to a meeting in his office.\nJoe is a 40-year-old developer. He was a Java developer for nearly a decade before adopt-\ning Clojure around 7 years ago. When Theo tells Joe about the Library Management System",
        "sections_found": []
      },
      "accurate_page_range": "32-55"
    },
    {
      "text": "- 1.2.2 Unpredictable code behavior",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "raw_line": "- 1.2.2 Unpredictable code behavior (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 10,
      "chapter_info": {
        "page": 32,
        "title": "Complexity of object-oriented programming",
        "pattern_matched": "Chapter 1",
        "text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased "
      },
      "chapter_sections": {
        "start_page": 32,
        "end_page": 55,
        "content": "\n--- Page 32 ---\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, and their new project were introduced in the opener for part 1.\nTake a moment to read the opener if you missed it.\nTheo gets back to the office with Nancy’s napkin in his pocket and a lot of anxiety in his\nheart because he knows he has committed to a tough deadline. But he had no choice! Last\nweek, Monica, his boss, told him quite clearly that he had to close the deal with Nancy no\nmatter what.\nAlbatross, where Theo works, is a software consulting company with customers all over\nthe world. It originally had lots of customers among startups. Over the last year, however,\nmany projects were badly managed, and the Startup department lost the trust of its cus-\ntomers. That’s why management moved Theo from the Enterprise department to the\nStartup department as a Senior Tech lead. His job is to close deals and to deliver on time.\n1.1.1 The design phase\nBefore rushing to his laptop to code the system, Theo grabs a sheet of paper, much big-\nger than a napkin, and starts to draw a UML class diagram of the system that will imple-\nment the Klafim prototype. Theo is an object-oriented programmer. For him, there is no\nquestion—every business entity is represented by an object, and every object is made\nfrom a class.\nThe requirements for the Klafim prototype\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There can be several copies of a book.\n A book belongs to a physical library.\nTheo spends some time thinking about the organization of the system. He identifies the\nmain classes for the Klafim Global Library Management System.\n--- Page 33 ---\n1.1 OOP design: Classic or classical? 5\nThe main classes of the library management system\n Library—The central part of the system design.\n Book—A book.\n BookItem—A book can have multiple copies, and each copy is considered as\na book item.\n BookLending—When a book is lent, a book lending object is created.\n Member—A member of the library.\n Librarian—A librarian.\n User—A base class for Librarian and Member.\n Catalog—Contains a list of books.\n Author—A book author.\nThat was the easy part. Now comes the difficult part: the relations between the classes.\nAfter two hours or so, Theo comes up with a first draft of a design for the Global Library\nManagement System. It looks like the diagram in figure 1.1.\n NOTE The design presented here doesn’t pretend to be the smartest OOP design:\nexperienced OOP developers would probably use a couple of design patterns to sug-\ngest a much better design. This design is meant to be naive and by no means covers all\nthe features of the system. It serves two purposes:\n For Theo, the developer, it is rich enough to start coding.\n For me, the author of the book, it is rich enough to illustrate the complexity of a\ntypical OOP system.\nTheo feels proud of himself and of the design diagram he just produced. He definitely\ndeserves a cup of coffee!\nNear the coffee machine, Theo meets Dave, a junior software developer who joined\nAlbatross a couple of weeks ago. Theo and Dave appreciate each other, as Dave’s curiosity\nleads him to ask challenging questions. Meetings near the coffee machine often turn into\ninteresting discussions about programming.\nTheo Hey Dave! How’s it going?\nDave Today? Not great. I’m trying to fix a bug in my code! I can’t understand why\nthe state of my objects always changes. I’ll figure it out though, I’m sure. How’s\nyour day going?\nTheo I just finished the design of a system for a new customer.\nDave Cool! Would it be OK for me to see it? I’m trying to improve my design skills.\nTheo Sure! I have the diagram on my desk. We can take a look now if you like.\n--- Page 34 ---\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool\nid : String block() : Bool\nfullName: String unblock() : Bool\nreturnBook(bookLending: BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\n*\nC User\nC BookItem\nid : String\nid : String\nemail : String\nlibId: String\npassword : String\ncheckout(member: Member) : BookLending\nlogin() : Bool\nC BookLending\nid : String\nlendingDate : date *\ndueDate : date\nisLate() : Bool\nreturnBook() : Bool\nFigure 1.1 A class diagram for Klafim’s Global Library Management System\n1.1.2 UML 101\nLatte in hand, Dave follows Theo to his desk. Theo proudly shows Dave his piece of art: the\nUML diagram for the Library Management System (figure 1.1). Dave seems really excited.\nDave Wow! Such a detailed class diagram.\nTheo Yeah. I’m pretty happy with it.\n--- Page 35 ---\n1.1 OOP design: Classic or classical? 7\nDave The thing is that I can never remember the meaning of the different arrows.\nTheo There are four types of arrows in my class diagram: composition, association,\ninheritance, and usage.\nDave What’s the difference between composition and association?\n NOTE Don’t worry if you’re not familiar with OOP jargon. We’re going to leave it\naside in the next chapter.\nTheo It’s all about whether the objects can live without each other. With composi-\ntion, when one object dies, the other one dies too. While in an association rela-\ntion, each object has an independent life.\nTIP In a composition relation, when one object dies, the other one also dies. While\nin an association relation, each object has an independent life cycle.\nIn the class diagram, there are two kinds of composition symbolized by an arrow with\na plain diamond at one edge and an optional star at the other edge. Figure 1.2 shows\nthe relation between:\n A Library that owns a Catalog—A one-to-one composition. If a Library object\ndies, then its Catalog object dies with it.\n A Library that owns many Members—A one-to-many composition. If a Library\nobject dies, then all its Member objects die with it.\nC Library\nname : String * C Member\naddress : String\nFigure 1.2 The two kinds of\nC Catalog composition: one-to-one and\none-to-many. In both cases,\nList<Book> search(searchCriteria, queryStr) when an object dies, the\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\ncomposed object dies with it.\nTIP A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\nDave Do you have association relations in your diagram?\nTheo Take a look at the arrow between Book and Author. It has an empty diamond\nand a star at both edges, so it’s a many-to-many association relation.\nA book can be written by multiple authors, and an author can write multiple books.\nMoreover, Book and Author objects can live independently. The relation between\nbooks and authors is a many-to-many association (figure 1.3).\n--- Page 36 ---\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the Librarian::blockMember method. It calls\nMember::block.\nTIP Dashed arrows indicate usage relations (figure 1.4), for instance, when a class\nuses a method of another class.\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember(member: Member)\nC Member\nBool isBlocked()\nBool block()\nBool unblock()\nBool returnBook(bookLending: BookLending) Figure 1.4 Usage relation: a class\nBookLending checkout(bookItem: BookItem) uses a method of another class.\nDave I see. And I guess a plain arrow with an empty triangle, like the one between\nMember and User, represents inheritance.\nTheo Absolutely!\nTIP Plain arrows with empty triangles represent class inheritance (figure 1.5), where\nthe arrow points towards the superclass.\n--- Page 37 ---\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasure. Want to see how it all fits together?\nDave What class should we look at first?\nTheo I think we should start with Library.\nTHE LIBRARY CLASS\nThe Library is the root class of the library system. Figure 1.6 shows the system structure.\nCC Library\nname : String\naddress : String\n*\nC Member\nC Catalog\nBool isBlocked()\nList<Book> search(searchCriteria, queryStr) Bool block()\nBookItem addBookItem(librarian: Librarian, Bool unblock()\nbookItem: BookItem) Bool returnBook(bookLending: BookLending)\nBookLending checkout(bookItem: BookItem)\n*\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember\n(member: Member)\nFigure 1.6 The Library class\n--- Page 38 ---\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC Member C Librarian\nisBlocked() : Bool blockMember(member: Member) : Bool\nblock() : Bool unblockMember(member: Member) : Bool\nunblock() : Bool addBookItem(bookItem: BookItem) : BookItem\nreturnBook(bookLending : BookLending) : Bool : Member) :\ncheckout(bookItem: BookItem) : BookLending\nCC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.7 Librarian and Member derive from User.\nThe User class represents a user of the library:\n In terms of data members, it sticks to the bare minimum: it has an id, email,\nand password (with no security and encryption for now).\n In terms of code, it can log in via login.\nThe Member class represents a member of the library:\n It inherits from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Check out a book via checkout.\n– Return a book via returnBook.\n– Block itself via block.\n– Unblock itself via unblock.\n– Answer if it is blocked via isBlocked.\n It owns multiple BookLending objects.\n It uses BookItem in order to implement checkout.\n--- Page 39 ---\n1.1 OOP design: Classic or classical? 11\nThe Librarian class represents a librarian:\n It derives from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Block and unblock a Member.\n– List the member’s book lendings via getBookLendings.\n– Add book items to the library via addBookItem.\n It uses Member to implement blockMember, unblockMember, and getBook-\nLendings.\n It uses BookItem to implement checkout.\n It uses BookLending to implement getBookLendings.\nTHE CATALOG CLASS\nThe Catalog class is responsible for the management of the books. Figure 1.8 shows\nthe relation among the Catalog, Librarian, and Book classes. In terms of code, a\nCatalog object can\n Search books via search.\n Add book items to the library via addBookItem.\nC Catalog\nList<Book> search(searchCriteria, queryStr)\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\nC Librarian *\nC Book\nBool blockMember(member: Member)\nBool unblockMember(member: Member) id : String\nBookItem addBookItem(bookItem: BookItem) title : String\nList<BookLending> getBookLendingsOfMember (member: Member)\nFigure 1.8 The Catalog class\nA Catalog object uses Librarian in order to implement addBookItem. In terms of\ndata, a Catalog owns multiple Book objects.\nTHE BOOK CLASS\nFigure 1.9 presents the Book class. In terms of data, a Book object\n Should have as its bare minimum an id and a title.\n Is associated with multiple Author objects (a book might have multiple authors).\n Owns multiple BookItem objects, one for each copy of the book.\n--- Page 40 ---\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare minimum data for members: an id and a libId (for its\nphysical library ID).\n Owns multiple BookLending objects, one for each time the book is lent.\nIn terms of code, a BookItem object can be checked out via checkout.\n1.1.4 The implementation phase\nAfter this detailed investigation of Theo’s diagrams, Dave lets it sink in as he slowly sips his\ncoffee. He then expresses his admiration to Theo.\nDave Wow! That’s amazing!\nTheo Thank you.\nDave I didn’t realize people were really spending the time to write down their design\nin such detail before coding.\nTheo I always do that. It saves me lot of time during the coding phase.\nDave When will you start coding?\nTheo When I finish my latte.\nTheo grabs his coffee mug and notices that his hot latte has become an iced latte. He was\nso excited to show his class diagram to Dave that he forgot to drink it!\n--- Page 41 ---\n1.2 Sources of complexity 13\n1.2 Sources of complexity\nWhile Theo is getting himself another cup of coffee (a cappuccino this time), I\nwould like to challenge his design. It might look beautiful and clear on the paper,\nbut I claim that this design makes the system hard to understand. It’s not that Theo\npicked the wrong classes or that he misunderstood the relations among the classes.\nIt goes much deeper:\n It’s about the programming paradigm he chose to implement the system.\n It’s about the object-oriented paradigm.\n It’s about the tendency of OOP to increase the complexity of a system.\nTIP OOP has a tendency to create complex systems.\nThroughout this book, the type of complexity I refer to is that which makes systems\nhard to understand as defined in the paper, “Out of the Tar Pit,” by Ben Moseley\nand Peter Marks (2006), available at http://mng.bz/enzq. It has nothing to do with\nthe type of complexity that deals with the amount of resources consumed by a pro-\ngram. Similarly, when I refer to simplicity, I mean not complex (in other words, easy\nto understand).\nKeep in mind that complexity and simplicity (like hard and easy) are not absolute\nbut relative concepts. We can compare the complexity of two systems and determine\nwhether system A is more complex (or simpler) than system B.\n NOTE Complexity in the context of this book means hard to understand.\nAs mentioned in the introduction of this chapter, there are many ways in OOP to\nalleviate complexity. The purpose of this book is not be critical of OOP, but rather\nto present a programming paradigm called data-oriented programming (DOP) that\ntends to build systems that are less complex. In fact, the DOP paradigm is compati-\nble with OOP.\nIf one chooses to build an OOP system that adheres to DOP principles, the system\nwill be less complex. According to DOP, the main sources of complexity in Theo’s sys-\ntem (and of many traditional OOP systems) are that\n Code and data are mixed.\n Objects are mutable.\n Data is locked in objects as members.\n Code is locked into classes as methods.\nThis analysis is similar to what functional programming (FP) thinks about traditional\nOOP. However, as we will see throughout the book, the data approach that DOP takes\nin order to reduce system complexity differs from the FP approach. In appendix A, we\nillustrate how to apply DOP principles both in OOP and in FP styles.\nTIP DOP is compatible both with OOP and FP.\n--- Page 42 ---\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Extra thinking is needed when reading code.\nObjects are mutable. Explicit synchronization is required on multi-threaded environments.\nData is locked in objects. Data serialization is not trivial.\nCode is locked in classes. Class hierarchies are complex.\n1.2.1 Many relations between classes\nOne way to assess the complexity of a class diagram is to look only at the entities and\ntheir relations, ignoring members and methods, as in figure 1.10. When we design a\nsystem, we have to define the relations between different pieces of code and data.\nThat’s unavoidable.\nC Library\nC Catalog\n* *\nC Book C Librarian\n*\n*\nC Member\n*\nC Author\nC BookItem C User\nFigure 1.10 A class\ndiagram overview for\nC BookLending * Klafim’s Library\nManagement System\nTIP In OOP, code and data are mixed together in classes: data as members and code as\nmethods.\n--- Page 43 ---\n1.2 Sources of complexity 15\nFrom a system analysis perspective, the fact that code and data are mixed together\nmakes the system complex in the sense that entities tend to be involved in many rela-\ntions. In figure 1.11, we take a closer look at the Member class. Member is involved in five\nrelations: two data relations and three code relations.\n Data relations:\n– Library has many Members.\n– Member has many BookLendings.\n Code relations:\n– Member extends User.\n– Librarian uses Member.\n– Member uses BookItem.\nC Librarian\nC Library * C Member\n*\nC User C BookLending C BookItem Figure 1.11 The class Member is\ninvolved in five relations.\nImagine for a moment that we were able, somehow, to split the Member class into two\nseparate entities:\n MemberCode for the code\n MemberData for the data\nInstead of a Member class with five relations, we would have the diagram shown in fig-\nure 1.12 with:\n A MemberCode entity and three relations.\n A MemberData entity and two relations.\nC Library C Librarian\n*\nC MemberData C MemberCode\n*\nC BookLending C User C BookItem Figure 1.12 A class diagram where Member\nis split into code and data entities\n--- Page 44 ---\n16 CHAPTER 1 Complexity of object-orientedprogramming\nThe class diagram where Member is split into MemberCode and MemberData is made of\ntwo independent parts. Each part is easier to understand than the original diagram.\nLet’s split every class of our original class diagram into code and data entities.\nFigure 1.13 shows the resulting diagram. Now the system is made of two indepen-\ndent parts:\n A part that involves only data entities.\n A part that involves only code entities.\nC LibraryData * C LibrarianData C CatalogCode\n*\nC MemberData C CatalogData C LibrarianCode\n*\nC BookData C MemberCode C BookLendingCode C BookItemCode\n*\n* *\nC BookItemData C AuthorData C UserCode C BookItem\n*\nC BookLendingData\nFigure 1.13 A class diagram where every class is split into code and data entities\nTIP A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\nThe resulting system, made up of two independent subsystems, is easier to understand\nthan the original system. The fact that the two subsystems are independent means that\neach subsystem can be understood separately and in any order. The resulting system\nnot simpler by accident; it is a logical consequence of separating code from data.\nTIP A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n1.2.2 Unpredictable code behavior\nYou might be a bit tired after the system-level analysis that we presented in the previ-\nous section. Let’s get refreshed and look at some code.\nTake a look at the code in listing 1.1, where we get the blocked status of a member\nand display it twice. If I tell you that when I called displayBlockedStatusTwice, the\nprogram displayed true on the first console.log call, can you tell me what the pro-\ngram displayed on the second console.log call?\n--- Page 45 ---\n1.2 Sources of complexity 17\nListing1.1 Really simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nvar isBlocked = this.isBlocked;\nconsole.log(isBlocked);\nconsole.log(isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\n“Of course, it displayed true again,” you say. And you are right!\nNow, take a look at a slightly different pseudocode as shown in listing 1.2. Here we\ndisplay, twice, the blocked status of a member without assigning a variable. Same ques-\ntion as before: if I tell you that when I called displayBlockedStatusTwice, the pro-\ngram displayed true on the first console.log call, can you tell me what the program\ndisplayed on the second console.log call?\nListing1.2 Apparently simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nconsole.log(this.isBlocked);\nconsole.log(this.isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\nThe correct answer is...in a single-threaded environment, it displays true, while in a\nmulti-threaded environment, it’s unpredictable. Indeed, in a multi-threaded environ-\nment between the two console.log calls, there could be a context switch that changes\nthe state of the object (e.g., a librarian unblocked the member). In fact, with a slight\nmodification, the same kind of code unpredictability could occur even in a single-\nthreaded environment like JavaScript, when data is modified via asynchronous code\n(see the section about Principle #3 in appendix A). The difference between the two\ncode snippets is that\n In the first listing (listing 1.1), we access a Boolean value twice , which is a prim-\nitive value.\n In the second listing (listing 1.2), we access a member of an object twice.\nTIP When data is mutable, code is unpredictable.\n--- Page 46 ---\n18 CHAPTER 1 Complexity of object-orientedprogramming\nThis unpredictable behavior of the second listing is one of the annoying conse-\nquences of OOP. Unlike primitive types, which are usually immutable, object mem-\nbers are mutable. One way to solve this problem in OOP is to protect sensitive code\nwith concurrency safety mechanisms like mutexes, but that introduces issues like a\nperformance hit and a risk of deadlocks.\nWe will see later in the book that DOP treats every piece of data in the same way:\nboth primitive types and collection types are immutable values. This value treatment for\nall citizens brings serenity to DOP developers’ minds, and more brain cells are avail-\nable to handle the interesting pieces of the applications they build.\nTIP Data immutability brings serenity to DOP developers’ minds.\n1.2.3 Not trivial data serialization\nTheo is really tired, and he falls asleep at his desk. He’s having dream. In his dream, Nancy\nasks him to make Klafim’s Library Management System accessible via a REST API using\nJSON as a transport layer. Theo has to implement a /search endpoint that receives a\nquery in JSON format and returns the results in JSON format. Listing 1.3 shows an input\nexample of the /search endpoint, and listing 1.4 shows an output example of the /search\nendpoint.\nListing1.3 A JSON input of the /search endpoint\n{\n\"searchCriteria\": \"author\",\n\"query\": \"albert\"\n}\nListing1.4 A JSON output of the /search endpoint\n[\n{\n\"title\": \"The world as I see it\",\n\"authors\": [\n{\n\"fullName\": \"Albert Einstein\"\n}\n]\n},\n{\n\"title\": \"The Stranger\",\n\"authors\": [\n{\n\"fullName\": \"Albert Camus\"\n}\n]\n}\n]\n--- Page 47 ---\n1.2 Sources of complexity 19\nTheo would probably implement the /search endpoint by creating three classes simi-\nlarly to what is shown in the following list and in figure 1.14. (Not surprisingly, every-\nthing in OOP has to be wrapped in a class. Right?)\n SearchController is responsible for handling the query.\n SearchQuery converts the JSON query string into data.\n SearchResult converts the search result data into a JSON string.\nC SearchController\nString handle(searchQuery: String)\nC SearchQuery\nC SearchResult\nC Catalog\nsearchCriteria: String\nSearchResult(books: List<Book>)\nList<Book> search(searchCriteria, queryStr) query: String\nString toJSON()\nSearchQuery(jsonString: String)\n* *\nC Book\nid : String\ntitle : String\nFigure 1.14 The class diagram for SearchController\nThe SearchController (see figure 1.14) would have a single handle method with the\nfollowing flow:\n Creates a SearchQuery object from the JSON query string.\n Retrieves searchCriteria and queryStr from the SearchQuery object.\n Calls the search method of the catalog:Catalog with searchCriteria and\nqueryStr and receives books:List<Book>.\n Creates a SearchResult object with books.\n Converts the SearchResult object to a JSON string.\nWhat about other endpoints, for instance, those allowing librarians to add book items\nthrough /add-book-item? Theo would have to repeat the exact same process and cre-\nate three classes:\n AddBookItemController to handle the query\n BookItemQuery to convert the JSON query string into data\n BookItemResult to convert the search result data into a JSON string\nThe code that deals with JSON deserialization that Theo wrote previously in Search-\nQuery would have to be rewritten in BookItemQuery. Same thing for the code that\ndeals with JSON serialization he wrote previously in SearchResult; it would have to be\nrewritten in BookItemResult.\n--- Page 48 ---\n20 CHAPTER 1 Complexity of object-orientedprogramming\nThe bad news is that Theo would have to repeat the same process for every end-\npoint of the system. Each time he encounters a new kind of JSON input or output,\nhe would have to create a new class and write code. Theo’s dream is turning into a\nnightmare!\nSuddenly, his phone rings, next to where he was resting his head on the desk. As Theo\nwakes up, he realizes that Nancy never asked for JSON. It was all a dream...a really bad\ndream!\nTIP In OOP, data serialization is difficult.\nIt’s quite frustrating that handling JSON serialization and deserialization in OOP\nrequires the addition of so many classes and writing so much code—again and again!\nThe frustration grows when you consider that serializing a search query, a book item\nquery, or any query is quite similar. It comes down to\n Going over data fields.\n Concatenating the name of the data fields and the value of the data fields, sepa-\nrated by a comma.\nWhy is such a simple thing so hard to achieve in OOP? In OOP, data has to follow a\nrigid shape defined in classes, which means that data is locked in members. There is\nno simple way to access data generically.\nTIP In OOP, data is locked in classes as members.\nWe will refine later what we mean by generic access to the data, and we will see how\nDOP provides a generic way to handle JSON serialization and deserialization. Until\nthen, you will have to continue suffering. But at least you are starting to become aware\nof this suffering, and you know that it is avoidable.\n NOTE Most OOP programming languages alleviate a bit of the difficulty involved\nin the conversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n1.2.4 Complex class hierarchies\nOne way to avoid writing the same code twice in OOP involves class inheritance. Indeed,\nwhen every requirement of the system is known up front, you design your class hier-\narchy is such a way that classes with common behavior derive from a base class.\nFigure 1.15 shows an example of this pattern that focuses on the part of our class\ndiagram that deals with members and librarians. Both Librarians and Members need\nthe ability to log in, and they inherit this ability from the User class.\nSo far, so good, but when new requirements are introduced after the system is imple-\nmented, it’s a completely different story. Fast forward to Monday, March 29th, at 11:00 AM,\nwhere two days are left before the deadline (Wednesday at midnight).\n--- Page 49 ---\n1.2 Sources of complexity 21\nC Librarian\nblockMember(member: Member) : Bool\nunblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String Figure 1.15 The part of the\npassword : String class diagram that deals with\nlogin() : Bool members and librarians\nNancy calls Theo with an urgent request. Theo is not sure if it’s a dream or reality. He\npinches himself and he can feel the jolt. It’s definitely reality!\nNancy How is the project doing?\nTheo Fine, Nancy. We’re on schedule to meet the deadline. We’re running our last\nround of regression tests now.\nNancy Fantastic! It means we have time for adding a tiny feature to the system, right?\nTheo Depends what you mean by “tiny.”\nNancy We need to add VIP members to the system.\nTheo What do you mean by VIP members?\nNancy VIP members are allowed to add book items to the library by themselves.\nTheo Hmm...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nI’ll ask you the same question Nancy asked Theo: why is adding VIP members to our\nsystem not a tiny task? After all, Theo has already written the code that allows librari-\nans to add book items to the library (it’s in Librarian::addBookItem). What prevents\nhim from reusing this code for VIP members? The reason is that, in OOP, the code is\nlocked into classes as methods.\nTIP In OOP, code is locked into classes.\nVIP members are members that are allowed to add book items to the library by them-\nselves. Theo decomposes the customer requirements into two pieces:\n--- Page 50 ---\n22 CHAPTER 1 Complexity of object-orientedprogramming\n VIP members are library members.\n VIP members are allowed to add book items to the library by themselves.\nTheo then decides that he needs a new class, VIPMember. For the first requirement\n(VIP members are library members), it seems reasonable to make VIPMember derive\nfrom Member. However, handling the second requirement (VIP members are allowed\nto add book items) is more complex. He cannot make a VIPMember derive from\nLibrarian because the relation between VIPMember and Librarian is not linear:\n On one hand, VIP members are like librarians in that they are allowed to add\nbook items.\n On the other hand, VIP members are not like librarians in that they are not\nallowed to block members or list the books lent to a member.\nThe problem is that the code that adds book items is locked in the Librarian class.\nThere is no way for the VIPMember class to use this code.\nFigure 1.16 shows one possible solution that makes the code of Librarian::add-\nBookItem available to both Librarian and VIPMember classes. Here are the changes to\nthe previous class diagram:\n A base class UserWithBookItemRight extends User.\n addBookItem moves from Librarian to UserWithBookItemRight.\n Both VIPMember and Librarian extend UserWithBookItemRight.\nC Librarian\nblockMember(member: Member) : Bool C VIPMember\nunblockMember(member: Member) : Bool\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nCC UserWithBookItemRight\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool addBookItem(bookItem: BookItem) : BookItem\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.16 A class diagram for a system with VIP members\nIt wasn’t easy, but Theo manages to handle the change on time, thanks to an all nighter\ncoding on his laptop. He was even able to add new tests to the system and run the regres-\nsion tests again. However, he was so excited that he didn’t pay attention to the diamond\n--- Page 51 ---\n1.2 Sources of complexity 23\nproblem VIPMember introduced in his class diagram due to multiple inheritance: VIPMember\nextends both Member and UserWithBookItemRight, which both extend User.\nWednesday, March 31, at 10:00 AM (14 hours before the deadline), Theo calls Nancy to\ntell her the good news.\nTheo We were able to add VIP members to the system on time, Nancy.\nNancy Fantastic! I told you it was a tiny feature.\nTheo Yeah, well...\nNancy Look, I was going to call you anyway. I just finished a meeting with my business\npartner, and we realized that we need another tiny feature before the launch.\nWill you be able to handle it before the deadline?\nTheo Again, it depends what you mean by “tiny.”\nNancy We need to add Super members to the system.\nTheo What do you mean by Super members?\nNancy Super members are allowed to list the books lent to other members.\nTheo Err...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nAs with VIP members, adding Super members to the system requires changes to Theo’s\nclass hierarchy. Figure 1.17 shows the solution Theo has in mind.\nC Librarian\nC VIPMember C SuperMember\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC UserWithBlockMemberRight\nCC UserWithBookItemRight\nblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\nunblockMember(member: Member) : Bool\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.17 A class diagram for a system with Super and VIP members\nThe addition of Super members has made the system really complex. Theo suddenly\nnotices that he has three diamonds in his class diagram—not gemstones but three “Deadly\n--- Page 52 ---\n24 CHAPTER 1 Complexity of object-orientedprogramming\nDiamonds of Death” as OOP developers sometimes name the ambiguity that arises when a\nclass D inherits from two classes B and C, where both inherit from class A!\nHe tries to avoid the diamonds by transforming the User class into an interface and\nusing the composition over inheritance design pattern. But with the stress of the deadline\nlooming, he isn’t able to use all of his brain cells. In fact, the system has become so com-\nplex, he’s unable to deliver the system by the deadline. Theo tells himself that he should\nhave used composition instead of class inheritance. But, it’s too late now.\nTIP In OOP, prefer composition over class inheritance.\nAt 10:00 PM, two hours before the deadline, Theo calls Nancy to explain the situation.\nTheo Look Nancy, we really did our best, but we won’t be able to add Super mem-\nbers to the system before the deadline.\nNancy No worries, my business partner and I decided to omit this feature for now.\nWe’ll add it later.\nWith mixed feelings of anger and relief, Theo stops pacing around his office. He realizes\nhe will be spending tonight in his own bed, rather than plowing away on his computer at\nthe office. That should make his wife happy.\nTheo I guess that means we’re ready for the launch tomorrow morning.\nNancy Yes. We’ll offer this new product for a month or so, and if we get good market\ntraction, we’ll move forward with a bigger project.\nTheo Cool. Let’s be in touch in a month then. Good luck on the launch!\nSummary\n Complexity in the context of this book means hard to understand.\n We use the terms code and behavior interchangeably.\n DOP stands for data-oriented programming.\n OOP stands for object-oriented programming.\n FP stands for functional programming.\n In a composition relation, when one object dies, the other one also dies.\n A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\n In an association relation, each object has an independent life cycle.\n A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\n Dashed arrows indicate a usage relation; for instance, when a class uses a method\nof another class.\n Plain arrows with empty triangles represent class inheritance, where the arrow\npoints towards the superclass.\n The design presented in this chapter doesn’t pretend to be the smartest OOP\ndesign. Experienced OOP developers would probably use a couple of design\npatterns and suggest a much better diagram.\n--- Page 53 ---\nSummary 25\n Traditional OOP systems tend to increase system complexity, in the sense that\nOOP systems are hard to understand.\n In traditional OOP, code and data are mixed together in classes: data as mem-\nbers and code as methods.\n In traditional OOP, data is mutable.\n The root cause of the increase in complexity is related to the mixing of code\nand data together into objects.\n When code and data are mixed, classes tend to be involved in many relations.\n When objects are mutable, extra thinking is required in order to understand\nhow the code behaves.\n When objects are mutable, explicit synchronization mechanisms are required\non multi-threaded environments.\n When data is locked in objects, data serialization is not trivial.\n When code is locked in classes, class hierarchies tend to be complex.\n A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\n A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n When data is mutable, code is unpredictable.\n A strategic use of design patterns can help mitigate complexity in traditional\nOOP to some degree.\n Data immutability brings serenity to DOP developers’ minds.\n Most OOP programming languages alleviate slightly the difficulty involved the\nconversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n In traditional OOP, data serialization is difficult.\n In traditional OOP, data is locked in classes as members.\n In traditional OOP, code is locked into classes.\n DOP reduces complexity by rethinking data.\n DOP is compatible both with OOP and FP.\n--- Page 54 ---\nSeparation between\ncode and data\nA whole new world\nThis chapter covers\n The benefits of separating code from data\n Designing a system where code and data are\nseparate\n Implementing a system that respects the\nseparation between code and data\nThe first insight of DOP is that we can decrease the complexity of our systems by\nseparating code from data. Indeed, when code is separated from data, our systems\nare made of two main pieces that can be thought about separately: data entities and\ncode modules. This chapter is a deep dive in the first principle of DOP (summa-\nrized in figure 2.1).\nPRINCIPLE #1 Separate code from data such that the code resides in functions,\nwhose behavior doesn’t depend on data that is somehow encapsulated in the func-\ntion’s context.\n26\n--- Page 55 ---\n2.1 The two parts of a DOP system 27\nStateless (static)\nFunctions\nData asfirst argument\nCode modules\nUsage\nRelations\nNo inheritance\nSeparate code from data\nOnly members\nData entities No code\nAssociation\nRelations\nComposition\nFigure 2.1 DOP principle #1 summarized: Separate code from data.\nIn this chapter, we’ll illustrate the separation between code and data in the context of\nKlafim’s Library Management System that we introduced in chapter 1. We’ll also unveil\nthe benefits that this separation brings to the system:\n The system is simple. It is easy to understand.\n The system is flexible and extensible. Quite often, it requires no design changes to\nadapt to changing requirements.\nThis chapter focuses on the design of the code in a system where code and data are\nseparate. In the next chapter, we’ll focus on the design of the data. As we progress in\nthe book, we’ll discover other benefits of separating code from data.\n2.1 The two parts of a DOP system\nWhile Theo is driving home after delivering the prototype, he asks himself whether the\nKlafim project was a success or not. Sure, he was able to satisfy the customer, but it was\nmore luck than brains. He wouldn’t have made it on time if Nancy had decided to keep\nthe Super members feature. Why was it so complicated to add tiny features to the system?\nWhy was the system he built so complex? He thought there should be a way to build more\nflexible systems!\nThe next morning, Theo asks on Hacker News and on Reddit for ways to reduce system\ncomplexity and build flexible systems. Some folks mention using different programming\nlanguages, while others talk about advanced design patterns. Finally, Theo’s attention gets\ncaptured by a comment from a user named Joe. He mentions data-oriented programming and\nclaims that its main goal is to reduce system complexity. Theo has never heard this term\nbefore. Out of curiosity, he decides to contact Joe by email. What a coincidence! Joe lives\nin San Francisco too. Theo invites him to a meeting in his office.\nJoe is a 40-year-old developer. He was a Java developer for nearly a decade before adopt-\ning Clojure around 7 years ago. When Theo tells Joe about the Library Management System",
        "sections_found": []
      },
      "accurate_page_range": "32-55"
    },
    {
      "text": "- 1.2.3 Not trivial data serialization",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "raw_line": "- 1.2.3 Not trivial data serialization (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 11,
      "chapter_info": {
        "page": 32,
        "title": "Complexity of object-oriented programming",
        "pattern_matched": "Chapter 1",
        "text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased "
      },
      "chapter_sections": {
        "start_page": 32,
        "end_page": 55,
        "content": "\n--- Page 32 ---\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, and their new project were introduced in the opener for part 1.\nTake a moment to read the opener if you missed it.\nTheo gets back to the office with Nancy’s napkin in his pocket and a lot of anxiety in his\nheart because he knows he has committed to a tough deadline. But he had no choice! Last\nweek, Monica, his boss, told him quite clearly that he had to close the deal with Nancy no\nmatter what.\nAlbatross, where Theo works, is a software consulting company with customers all over\nthe world. It originally had lots of customers among startups. Over the last year, however,\nmany projects were badly managed, and the Startup department lost the trust of its cus-\ntomers. That’s why management moved Theo from the Enterprise department to the\nStartup department as a Senior Tech lead. His job is to close deals and to deliver on time.\n1.1.1 The design phase\nBefore rushing to his laptop to code the system, Theo grabs a sheet of paper, much big-\nger than a napkin, and starts to draw a UML class diagram of the system that will imple-\nment the Klafim prototype. Theo is an object-oriented programmer. For him, there is no\nquestion—every business entity is represented by an object, and every object is made\nfrom a class.\nThe requirements for the Klafim prototype\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There can be several copies of a book.\n A book belongs to a physical library.\nTheo spends some time thinking about the organization of the system. He identifies the\nmain classes for the Klafim Global Library Management System.\n--- Page 33 ---\n1.1 OOP design: Classic or classical? 5\nThe main classes of the library management system\n Library—The central part of the system design.\n Book—A book.\n BookItem—A book can have multiple copies, and each copy is considered as\na book item.\n BookLending—When a book is lent, a book lending object is created.\n Member—A member of the library.\n Librarian—A librarian.\n User—A base class for Librarian and Member.\n Catalog—Contains a list of books.\n Author—A book author.\nThat was the easy part. Now comes the difficult part: the relations between the classes.\nAfter two hours or so, Theo comes up with a first draft of a design for the Global Library\nManagement System. It looks like the diagram in figure 1.1.\n NOTE The design presented here doesn’t pretend to be the smartest OOP design:\nexperienced OOP developers would probably use a couple of design patterns to sug-\ngest a much better design. This design is meant to be naive and by no means covers all\nthe features of the system. It serves two purposes:\n For Theo, the developer, it is rich enough to start coding.\n For me, the author of the book, it is rich enough to illustrate the complexity of a\ntypical OOP system.\nTheo feels proud of himself and of the design diagram he just produced. He definitely\ndeserves a cup of coffee!\nNear the coffee machine, Theo meets Dave, a junior software developer who joined\nAlbatross a couple of weeks ago. Theo and Dave appreciate each other, as Dave’s curiosity\nleads him to ask challenging questions. Meetings near the coffee machine often turn into\ninteresting discussions about programming.\nTheo Hey Dave! How’s it going?\nDave Today? Not great. I’m trying to fix a bug in my code! I can’t understand why\nthe state of my objects always changes. I’ll figure it out though, I’m sure. How’s\nyour day going?\nTheo I just finished the design of a system for a new customer.\nDave Cool! Would it be OK for me to see it? I’m trying to improve my design skills.\nTheo Sure! I have the diagram on my desk. We can take a look now if you like.\n--- Page 34 ---\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool\nid : String block() : Bool\nfullName: String unblock() : Bool\nreturnBook(bookLending: BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\n*\nC User\nC BookItem\nid : String\nid : String\nemail : String\nlibId: String\npassword : String\ncheckout(member: Member) : BookLending\nlogin() : Bool\nC BookLending\nid : String\nlendingDate : date *\ndueDate : date\nisLate() : Bool\nreturnBook() : Bool\nFigure 1.1 A class diagram for Klafim’s Global Library Management System\n1.1.2 UML 101\nLatte in hand, Dave follows Theo to his desk. Theo proudly shows Dave his piece of art: the\nUML diagram for the Library Management System (figure 1.1). Dave seems really excited.\nDave Wow! Such a detailed class diagram.\nTheo Yeah. I’m pretty happy with it.\n--- Page 35 ---\n1.1 OOP design: Classic or classical? 7\nDave The thing is that I can never remember the meaning of the different arrows.\nTheo There are four types of arrows in my class diagram: composition, association,\ninheritance, and usage.\nDave What’s the difference between composition and association?\n NOTE Don’t worry if you’re not familiar with OOP jargon. We’re going to leave it\naside in the next chapter.\nTheo It’s all about whether the objects can live without each other. With composi-\ntion, when one object dies, the other one dies too. While in an association rela-\ntion, each object has an independent life.\nTIP In a composition relation, when one object dies, the other one also dies. While\nin an association relation, each object has an independent life cycle.\nIn the class diagram, there are two kinds of composition symbolized by an arrow with\na plain diamond at one edge and an optional star at the other edge. Figure 1.2 shows\nthe relation between:\n A Library that owns a Catalog—A one-to-one composition. If a Library object\ndies, then its Catalog object dies with it.\n A Library that owns many Members—A one-to-many composition. If a Library\nobject dies, then all its Member objects die with it.\nC Library\nname : String * C Member\naddress : String\nFigure 1.2 The two kinds of\nC Catalog composition: one-to-one and\none-to-many. In both cases,\nList<Book> search(searchCriteria, queryStr) when an object dies, the\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\ncomposed object dies with it.\nTIP A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\nDave Do you have association relations in your diagram?\nTheo Take a look at the arrow between Book and Author. It has an empty diamond\nand a star at both edges, so it’s a many-to-many association relation.\nA book can be written by multiple authors, and an author can write multiple books.\nMoreover, Book and Author objects can live independently. The relation between\nbooks and authors is a many-to-many association (figure 1.3).\n--- Page 36 ---\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the Librarian::blockMember method. It calls\nMember::block.\nTIP Dashed arrows indicate usage relations (figure 1.4), for instance, when a class\nuses a method of another class.\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember(member: Member)\nC Member\nBool isBlocked()\nBool block()\nBool unblock()\nBool returnBook(bookLending: BookLending) Figure 1.4 Usage relation: a class\nBookLending checkout(bookItem: BookItem) uses a method of another class.\nDave I see. And I guess a plain arrow with an empty triangle, like the one between\nMember and User, represents inheritance.\nTheo Absolutely!\nTIP Plain arrows with empty triangles represent class inheritance (figure 1.5), where\nthe arrow points towards the superclass.\n--- Page 37 ---\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasure. Want to see how it all fits together?\nDave What class should we look at first?\nTheo I think we should start with Library.\nTHE LIBRARY CLASS\nThe Library is the root class of the library system. Figure 1.6 shows the system structure.\nCC Library\nname : String\naddress : String\n*\nC Member\nC Catalog\nBool isBlocked()\nList<Book> search(searchCriteria, queryStr) Bool block()\nBookItem addBookItem(librarian: Librarian, Bool unblock()\nbookItem: BookItem) Bool returnBook(bookLending: BookLending)\nBookLending checkout(bookItem: BookItem)\n*\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember\n(member: Member)\nFigure 1.6 The Library class\n--- Page 38 ---\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC Member C Librarian\nisBlocked() : Bool blockMember(member: Member) : Bool\nblock() : Bool unblockMember(member: Member) : Bool\nunblock() : Bool addBookItem(bookItem: BookItem) : BookItem\nreturnBook(bookLending : BookLending) : Bool : Member) :\ncheckout(bookItem: BookItem) : BookLending\nCC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.7 Librarian and Member derive from User.\nThe User class represents a user of the library:\n In terms of data members, it sticks to the bare minimum: it has an id, email,\nand password (with no security and encryption for now).\n In terms of code, it can log in via login.\nThe Member class represents a member of the library:\n It inherits from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Check out a book via checkout.\n– Return a book via returnBook.\n– Block itself via block.\n– Unblock itself via unblock.\n– Answer if it is blocked via isBlocked.\n It owns multiple BookLending objects.\n It uses BookItem in order to implement checkout.\n--- Page 39 ---\n1.1 OOP design: Classic or classical? 11\nThe Librarian class represents a librarian:\n It derives from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Block and unblock a Member.\n– List the member’s book lendings via getBookLendings.\n– Add book items to the library via addBookItem.\n It uses Member to implement blockMember, unblockMember, and getBook-\nLendings.\n It uses BookItem to implement checkout.\n It uses BookLending to implement getBookLendings.\nTHE CATALOG CLASS\nThe Catalog class is responsible for the management of the books. Figure 1.8 shows\nthe relation among the Catalog, Librarian, and Book classes. In terms of code, a\nCatalog object can\n Search books via search.\n Add book items to the library via addBookItem.\nC Catalog\nList<Book> search(searchCriteria, queryStr)\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\nC Librarian *\nC Book\nBool blockMember(member: Member)\nBool unblockMember(member: Member) id : String\nBookItem addBookItem(bookItem: BookItem) title : String\nList<BookLending> getBookLendingsOfMember (member: Member)\nFigure 1.8 The Catalog class\nA Catalog object uses Librarian in order to implement addBookItem. In terms of\ndata, a Catalog owns multiple Book objects.\nTHE BOOK CLASS\nFigure 1.9 presents the Book class. In terms of data, a Book object\n Should have as its bare minimum an id and a title.\n Is associated with multiple Author objects (a book might have multiple authors).\n Owns multiple BookItem objects, one for each copy of the book.\n--- Page 40 ---\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare minimum data for members: an id and a libId (for its\nphysical library ID).\n Owns multiple BookLending objects, one for each time the book is lent.\nIn terms of code, a BookItem object can be checked out via checkout.\n1.1.4 The implementation phase\nAfter this detailed investigation of Theo’s diagrams, Dave lets it sink in as he slowly sips his\ncoffee. He then expresses his admiration to Theo.\nDave Wow! That’s amazing!\nTheo Thank you.\nDave I didn’t realize people were really spending the time to write down their design\nin such detail before coding.\nTheo I always do that. It saves me lot of time during the coding phase.\nDave When will you start coding?\nTheo When I finish my latte.\nTheo grabs his coffee mug and notices that his hot latte has become an iced latte. He was\nso excited to show his class diagram to Dave that he forgot to drink it!\n--- Page 41 ---\n1.2 Sources of complexity 13\n1.2 Sources of complexity\nWhile Theo is getting himself another cup of coffee (a cappuccino this time), I\nwould like to challenge his design. It might look beautiful and clear on the paper,\nbut I claim that this design makes the system hard to understand. It’s not that Theo\npicked the wrong classes or that he misunderstood the relations among the classes.\nIt goes much deeper:\n It’s about the programming paradigm he chose to implement the system.\n It’s about the object-oriented paradigm.\n It’s about the tendency of OOP to increase the complexity of a system.\nTIP OOP has a tendency to create complex systems.\nThroughout this book, the type of complexity I refer to is that which makes systems\nhard to understand as defined in the paper, “Out of the Tar Pit,” by Ben Moseley\nand Peter Marks (2006), available at http://mng.bz/enzq. It has nothing to do with\nthe type of complexity that deals with the amount of resources consumed by a pro-\ngram. Similarly, when I refer to simplicity, I mean not complex (in other words, easy\nto understand).\nKeep in mind that complexity and simplicity (like hard and easy) are not absolute\nbut relative concepts. We can compare the complexity of two systems and determine\nwhether system A is more complex (or simpler) than system B.\n NOTE Complexity in the context of this book means hard to understand.\nAs mentioned in the introduction of this chapter, there are many ways in OOP to\nalleviate complexity. The purpose of this book is not be critical of OOP, but rather\nto present a programming paradigm called data-oriented programming (DOP) that\ntends to build systems that are less complex. In fact, the DOP paradigm is compati-\nble with OOP.\nIf one chooses to build an OOP system that adheres to DOP principles, the system\nwill be less complex. According to DOP, the main sources of complexity in Theo’s sys-\ntem (and of many traditional OOP systems) are that\n Code and data are mixed.\n Objects are mutable.\n Data is locked in objects as members.\n Code is locked into classes as methods.\nThis analysis is similar to what functional programming (FP) thinks about traditional\nOOP. However, as we will see throughout the book, the data approach that DOP takes\nin order to reduce system complexity differs from the FP approach. In appendix A, we\nillustrate how to apply DOP principles both in OOP and in FP styles.\nTIP DOP is compatible both with OOP and FP.\n--- Page 42 ---\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Extra thinking is needed when reading code.\nObjects are mutable. Explicit synchronization is required on multi-threaded environments.\nData is locked in objects. Data serialization is not trivial.\nCode is locked in classes. Class hierarchies are complex.\n1.2.1 Many relations between classes\nOne way to assess the complexity of a class diagram is to look only at the entities and\ntheir relations, ignoring members and methods, as in figure 1.10. When we design a\nsystem, we have to define the relations between different pieces of code and data.\nThat’s unavoidable.\nC Library\nC Catalog\n* *\nC Book C Librarian\n*\n*\nC Member\n*\nC Author\nC BookItem C User\nFigure 1.10 A class\ndiagram overview for\nC BookLending * Klafim’s Library\nManagement System\nTIP In OOP, code and data are mixed together in classes: data as members and code as\nmethods.\n--- Page 43 ---\n1.2 Sources of complexity 15\nFrom a system analysis perspective, the fact that code and data are mixed together\nmakes the system complex in the sense that entities tend to be involved in many rela-\ntions. In figure 1.11, we take a closer look at the Member class. Member is involved in five\nrelations: two data relations and three code relations.\n Data relations:\n– Library has many Members.\n– Member has many BookLendings.\n Code relations:\n– Member extends User.\n– Librarian uses Member.\n– Member uses BookItem.\nC Librarian\nC Library * C Member\n*\nC User C BookLending C BookItem Figure 1.11 The class Member is\ninvolved in five relations.\nImagine for a moment that we were able, somehow, to split the Member class into two\nseparate entities:\n MemberCode for the code\n MemberData for the data\nInstead of a Member class with five relations, we would have the diagram shown in fig-\nure 1.12 with:\n A MemberCode entity and three relations.\n A MemberData entity and two relations.\nC Library C Librarian\n*\nC MemberData C MemberCode\n*\nC BookLending C User C BookItem Figure 1.12 A class diagram where Member\nis split into code and data entities\n--- Page 44 ---\n16 CHAPTER 1 Complexity of object-orientedprogramming\nThe class diagram where Member is split into MemberCode and MemberData is made of\ntwo independent parts. Each part is easier to understand than the original diagram.\nLet’s split every class of our original class diagram into code and data entities.\nFigure 1.13 shows the resulting diagram. Now the system is made of two indepen-\ndent parts:\n A part that involves only data entities.\n A part that involves only code entities.\nC LibraryData * C LibrarianData C CatalogCode\n*\nC MemberData C CatalogData C LibrarianCode\n*\nC BookData C MemberCode C BookLendingCode C BookItemCode\n*\n* *\nC BookItemData C AuthorData C UserCode C BookItem\n*\nC BookLendingData\nFigure 1.13 A class diagram where every class is split into code and data entities\nTIP A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\nThe resulting system, made up of two independent subsystems, is easier to understand\nthan the original system. The fact that the two subsystems are independent means that\neach subsystem can be understood separately and in any order. The resulting system\nnot simpler by accident; it is a logical consequence of separating code from data.\nTIP A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n1.2.2 Unpredictable code behavior\nYou might be a bit tired after the system-level analysis that we presented in the previ-\nous section. Let’s get refreshed and look at some code.\nTake a look at the code in listing 1.1, where we get the blocked status of a member\nand display it twice. If I tell you that when I called displayBlockedStatusTwice, the\nprogram displayed true on the first console.log call, can you tell me what the pro-\ngram displayed on the second console.log call?\n--- Page 45 ---\n1.2 Sources of complexity 17\nListing1.1 Really simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nvar isBlocked = this.isBlocked;\nconsole.log(isBlocked);\nconsole.log(isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\n“Of course, it displayed true again,” you say. And you are right!\nNow, take a look at a slightly different pseudocode as shown in listing 1.2. Here we\ndisplay, twice, the blocked status of a member without assigning a variable. Same ques-\ntion as before: if I tell you that when I called displayBlockedStatusTwice, the pro-\ngram displayed true on the first console.log call, can you tell me what the program\ndisplayed on the second console.log call?\nListing1.2 Apparently simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nconsole.log(this.isBlocked);\nconsole.log(this.isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\nThe correct answer is...in a single-threaded environment, it displays true, while in a\nmulti-threaded environment, it’s unpredictable. Indeed, in a multi-threaded environ-\nment between the two console.log calls, there could be a context switch that changes\nthe state of the object (e.g., a librarian unblocked the member). In fact, with a slight\nmodification, the same kind of code unpredictability could occur even in a single-\nthreaded environment like JavaScript, when data is modified via asynchronous code\n(see the section about Principle #3 in appendix A). The difference between the two\ncode snippets is that\n In the first listing (listing 1.1), we access a Boolean value twice , which is a prim-\nitive value.\n In the second listing (listing 1.2), we access a member of an object twice.\nTIP When data is mutable, code is unpredictable.\n--- Page 46 ---\n18 CHAPTER 1 Complexity of object-orientedprogramming\nThis unpredictable behavior of the second listing is one of the annoying conse-\nquences of OOP. Unlike primitive types, which are usually immutable, object mem-\nbers are mutable. One way to solve this problem in OOP is to protect sensitive code\nwith concurrency safety mechanisms like mutexes, but that introduces issues like a\nperformance hit and a risk of deadlocks.\nWe will see later in the book that DOP treats every piece of data in the same way:\nboth primitive types and collection types are immutable values. This value treatment for\nall citizens brings serenity to DOP developers’ minds, and more brain cells are avail-\nable to handle the interesting pieces of the applications they build.\nTIP Data immutability brings serenity to DOP developers’ minds.\n1.2.3 Not trivial data serialization\nTheo is really tired, and he falls asleep at his desk. He’s having dream. In his dream, Nancy\nasks him to make Klafim’s Library Management System accessible via a REST API using\nJSON as a transport layer. Theo has to implement a /search endpoint that receives a\nquery in JSON format and returns the results in JSON format. Listing 1.3 shows an input\nexample of the /search endpoint, and listing 1.4 shows an output example of the /search\nendpoint.\nListing1.3 A JSON input of the /search endpoint\n{\n\"searchCriteria\": \"author\",\n\"query\": \"albert\"\n}\nListing1.4 A JSON output of the /search endpoint\n[\n{\n\"title\": \"The world as I see it\",\n\"authors\": [\n{\n\"fullName\": \"Albert Einstein\"\n}\n]\n},\n{\n\"title\": \"The Stranger\",\n\"authors\": [\n{\n\"fullName\": \"Albert Camus\"\n}\n]\n}\n]\n--- Page 47 ---\n1.2 Sources of complexity 19\nTheo would probably implement the /search endpoint by creating three classes simi-\nlarly to what is shown in the following list and in figure 1.14. (Not surprisingly, every-\nthing in OOP has to be wrapped in a class. Right?)\n SearchController is responsible for handling the query.\n SearchQuery converts the JSON query string into data.\n SearchResult converts the search result data into a JSON string.\nC SearchController\nString handle(searchQuery: String)\nC SearchQuery\nC SearchResult\nC Catalog\nsearchCriteria: String\nSearchResult(books: List<Book>)\nList<Book> search(searchCriteria, queryStr) query: String\nString toJSON()\nSearchQuery(jsonString: String)\n* *\nC Book\nid : String\ntitle : String\nFigure 1.14 The class diagram for SearchController\nThe SearchController (see figure 1.14) would have a single handle method with the\nfollowing flow:\n Creates a SearchQuery object from the JSON query string.\n Retrieves searchCriteria and queryStr from the SearchQuery object.\n Calls the search method of the catalog:Catalog with searchCriteria and\nqueryStr and receives books:List<Book>.\n Creates a SearchResult object with books.\n Converts the SearchResult object to a JSON string.\nWhat about other endpoints, for instance, those allowing librarians to add book items\nthrough /add-book-item? Theo would have to repeat the exact same process and cre-\nate three classes:\n AddBookItemController to handle the query\n BookItemQuery to convert the JSON query string into data\n BookItemResult to convert the search result data into a JSON string\nThe code that deals with JSON deserialization that Theo wrote previously in Search-\nQuery would have to be rewritten in BookItemQuery. Same thing for the code that\ndeals with JSON serialization he wrote previously in SearchResult; it would have to be\nrewritten in BookItemResult.\n--- Page 48 ---\n20 CHAPTER 1 Complexity of object-orientedprogramming\nThe bad news is that Theo would have to repeat the same process for every end-\npoint of the system. Each time he encounters a new kind of JSON input or output,\nhe would have to create a new class and write code. Theo’s dream is turning into a\nnightmare!\nSuddenly, his phone rings, next to where he was resting his head on the desk. As Theo\nwakes up, he realizes that Nancy never asked for JSON. It was all a dream...a really bad\ndream!\nTIP In OOP, data serialization is difficult.\nIt’s quite frustrating that handling JSON serialization and deserialization in OOP\nrequires the addition of so many classes and writing so much code—again and again!\nThe frustration grows when you consider that serializing a search query, a book item\nquery, or any query is quite similar. It comes down to\n Going over data fields.\n Concatenating the name of the data fields and the value of the data fields, sepa-\nrated by a comma.\nWhy is such a simple thing so hard to achieve in OOP? In OOP, data has to follow a\nrigid shape defined in classes, which means that data is locked in members. There is\nno simple way to access data generically.\nTIP In OOP, data is locked in classes as members.\nWe will refine later what we mean by generic access to the data, and we will see how\nDOP provides a generic way to handle JSON serialization and deserialization. Until\nthen, you will have to continue suffering. But at least you are starting to become aware\nof this suffering, and you know that it is avoidable.\n NOTE Most OOP programming languages alleviate a bit of the difficulty involved\nin the conversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n1.2.4 Complex class hierarchies\nOne way to avoid writing the same code twice in OOP involves class inheritance. Indeed,\nwhen every requirement of the system is known up front, you design your class hier-\narchy is such a way that classes with common behavior derive from a base class.\nFigure 1.15 shows an example of this pattern that focuses on the part of our class\ndiagram that deals with members and librarians. Both Librarians and Members need\nthe ability to log in, and they inherit this ability from the User class.\nSo far, so good, but when new requirements are introduced after the system is imple-\nmented, it’s a completely different story. Fast forward to Monday, March 29th, at 11:00 AM,\nwhere two days are left before the deadline (Wednesday at midnight).\n--- Page 49 ---\n1.2 Sources of complexity 21\nC Librarian\nblockMember(member: Member) : Bool\nunblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String Figure 1.15 The part of the\npassword : String class diagram that deals with\nlogin() : Bool members and librarians\nNancy calls Theo with an urgent request. Theo is not sure if it’s a dream or reality. He\npinches himself and he can feel the jolt. It’s definitely reality!\nNancy How is the project doing?\nTheo Fine, Nancy. We’re on schedule to meet the deadline. We’re running our last\nround of regression tests now.\nNancy Fantastic! It means we have time for adding a tiny feature to the system, right?\nTheo Depends what you mean by “tiny.”\nNancy We need to add VIP members to the system.\nTheo What do you mean by VIP members?\nNancy VIP members are allowed to add book items to the library by themselves.\nTheo Hmm...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nI’ll ask you the same question Nancy asked Theo: why is adding VIP members to our\nsystem not a tiny task? After all, Theo has already written the code that allows librari-\nans to add book items to the library (it’s in Librarian::addBookItem). What prevents\nhim from reusing this code for VIP members? The reason is that, in OOP, the code is\nlocked into classes as methods.\nTIP In OOP, code is locked into classes.\nVIP members are members that are allowed to add book items to the library by them-\nselves. Theo decomposes the customer requirements into two pieces:\n--- Page 50 ---\n22 CHAPTER 1 Complexity of object-orientedprogramming\n VIP members are library members.\n VIP members are allowed to add book items to the library by themselves.\nTheo then decides that he needs a new class, VIPMember. For the first requirement\n(VIP members are library members), it seems reasonable to make VIPMember derive\nfrom Member. However, handling the second requirement (VIP members are allowed\nto add book items) is more complex. He cannot make a VIPMember derive from\nLibrarian because the relation between VIPMember and Librarian is not linear:\n On one hand, VIP members are like librarians in that they are allowed to add\nbook items.\n On the other hand, VIP members are not like librarians in that they are not\nallowed to block members or list the books lent to a member.\nThe problem is that the code that adds book items is locked in the Librarian class.\nThere is no way for the VIPMember class to use this code.\nFigure 1.16 shows one possible solution that makes the code of Librarian::add-\nBookItem available to both Librarian and VIPMember classes. Here are the changes to\nthe previous class diagram:\n A base class UserWithBookItemRight extends User.\n addBookItem moves from Librarian to UserWithBookItemRight.\n Both VIPMember and Librarian extend UserWithBookItemRight.\nC Librarian\nblockMember(member: Member) : Bool C VIPMember\nunblockMember(member: Member) : Bool\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nCC UserWithBookItemRight\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool addBookItem(bookItem: BookItem) : BookItem\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.16 A class diagram for a system with VIP members\nIt wasn’t easy, but Theo manages to handle the change on time, thanks to an all nighter\ncoding on his laptop. He was even able to add new tests to the system and run the regres-\nsion tests again. However, he was so excited that he didn’t pay attention to the diamond\n--- Page 51 ---\n1.2 Sources of complexity 23\nproblem VIPMember introduced in his class diagram due to multiple inheritance: VIPMember\nextends both Member and UserWithBookItemRight, which both extend User.\nWednesday, March 31, at 10:00 AM (14 hours before the deadline), Theo calls Nancy to\ntell her the good news.\nTheo We were able to add VIP members to the system on time, Nancy.\nNancy Fantastic! I told you it was a tiny feature.\nTheo Yeah, well...\nNancy Look, I was going to call you anyway. I just finished a meeting with my business\npartner, and we realized that we need another tiny feature before the launch.\nWill you be able to handle it before the deadline?\nTheo Again, it depends what you mean by “tiny.”\nNancy We need to add Super members to the system.\nTheo What do you mean by Super members?\nNancy Super members are allowed to list the books lent to other members.\nTheo Err...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nAs with VIP members, adding Super members to the system requires changes to Theo’s\nclass hierarchy. Figure 1.17 shows the solution Theo has in mind.\nC Librarian\nC VIPMember C SuperMember\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC UserWithBlockMemberRight\nCC UserWithBookItemRight\nblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\nunblockMember(member: Member) : Bool\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.17 A class diagram for a system with Super and VIP members\nThe addition of Super members has made the system really complex. Theo suddenly\nnotices that he has three diamonds in his class diagram—not gemstones but three “Deadly\n--- Page 52 ---\n24 CHAPTER 1 Complexity of object-orientedprogramming\nDiamonds of Death” as OOP developers sometimes name the ambiguity that arises when a\nclass D inherits from two classes B and C, where both inherit from class A!\nHe tries to avoid the diamonds by transforming the User class into an interface and\nusing the composition over inheritance design pattern. But with the stress of the deadline\nlooming, he isn’t able to use all of his brain cells. In fact, the system has become so com-\nplex, he’s unable to deliver the system by the deadline. Theo tells himself that he should\nhave used composition instead of class inheritance. But, it’s too late now.\nTIP In OOP, prefer composition over class inheritance.\nAt 10:00 PM, two hours before the deadline, Theo calls Nancy to explain the situation.\nTheo Look Nancy, we really did our best, but we won’t be able to add Super mem-\nbers to the system before the deadline.\nNancy No worries, my business partner and I decided to omit this feature for now.\nWe’ll add it later.\nWith mixed feelings of anger and relief, Theo stops pacing around his office. He realizes\nhe will be spending tonight in his own bed, rather than plowing away on his computer at\nthe office. That should make his wife happy.\nTheo I guess that means we’re ready for the launch tomorrow morning.\nNancy Yes. We’ll offer this new product for a month or so, and if we get good market\ntraction, we’ll move forward with a bigger project.\nTheo Cool. Let’s be in touch in a month then. Good luck on the launch!\nSummary\n Complexity in the context of this book means hard to understand.\n We use the terms code and behavior interchangeably.\n DOP stands for data-oriented programming.\n OOP stands for object-oriented programming.\n FP stands for functional programming.\n In a composition relation, when one object dies, the other one also dies.\n A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\n In an association relation, each object has an independent life cycle.\n A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\n Dashed arrows indicate a usage relation; for instance, when a class uses a method\nof another class.\n Plain arrows with empty triangles represent class inheritance, where the arrow\npoints towards the superclass.\n The design presented in this chapter doesn’t pretend to be the smartest OOP\ndesign. Experienced OOP developers would probably use a couple of design\npatterns and suggest a much better diagram.\n--- Page 53 ---\nSummary 25\n Traditional OOP systems tend to increase system complexity, in the sense that\nOOP systems are hard to understand.\n In traditional OOP, code and data are mixed together in classes: data as mem-\nbers and code as methods.\n In traditional OOP, data is mutable.\n The root cause of the increase in complexity is related to the mixing of code\nand data together into objects.\n When code and data are mixed, classes tend to be involved in many relations.\n When objects are mutable, extra thinking is required in order to understand\nhow the code behaves.\n When objects are mutable, explicit synchronization mechanisms are required\non multi-threaded environments.\n When data is locked in objects, data serialization is not trivial.\n When code is locked in classes, class hierarchies tend to be complex.\n A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\n A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n When data is mutable, code is unpredictable.\n A strategic use of design patterns can help mitigate complexity in traditional\nOOP to some degree.\n Data immutability brings serenity to DOP developers’ minds.\n Most OOP programming languages alleviate slightly the difficulty involved the\nconversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n In traditional OOP, data serialization is difficult.\n In traditional OOP, data is locked in classes as members.\n In traditional OOP, code is locked into classes.\n DOP reduces complexity by rethinking data.\n DOP is compatible both with OOP and FP.\n--- Page 54 ---\nSeparation between\ncode and data\nA whole new world\nThis chapter covers\n The benefits of separating code from data\n Designing a system where code and data are\nseparate\n Implementing a system that respects the\nseparation between code and data\nThe first insight of DOP is that we can decrease the complexity of our systems by\nseparating code from data. Indeed, when code is separated from data, our systems\nare made of two main pieces that can be thought about separately: data entities and\ncode modules. This chapter is a deep dive in the first principle of DOP (summa-\nrized in figure 2.1).\nPRINCIPLE #1 Separate code from data such that the code resides in functions,\nwhose behavior doesn’t depend on data that is somehow encapsulated in the func-\ntion’s context.\n26\n--- Page 55 ---\n2.1 The two parts of a DOP system 27\nStateless (static)\nFunctions\nData asfirst argument\nCode modules\nUsage\nRelations\nNo inheritance\nSeparate code from data\nOnly members\nData entities No code\nAssociation\nRelations\nComposition\nFigure 2.1 DOP principle #1 summarized: Separate code from data.\nIn this chapter, we’ll illustrate the separation between code and data in the context of\nKlafim’s Library Management System that we introduced in chapter 1. We’ll also unveil\nthe benefits that this separation brings to the system:\n The system is simple. It is easy to understand.\n The system is flexible and extensible. Quite often, it requires no design changes to\nadapt to changing requirements.\nThis chapter focuses on the design of the code in a system where code and data are\nseparate. In the next chapter, we’ll focus on the design of the data. As we progress in\nthe book, we’ll discover other benefits of separating code from data.\n2.1 The two parts of a DOP system\nWhile Theo is driving home after delivering the prototype, he asks himself whether the\nKlafim project was a success or not. Sure, he was able to satisfy the customer, but it was\nmore luck than brains. He wouldn’t have made it on time if Nancy had decided to keep\nthe Super members feature. Why was it so complicated to add tiny features to the system?\nWhy was the system he built so complex? He thought there should be a way to build more\nflexible systems!\nThe next morning, Theo asks on Hacker News and on Reddit for ways to reduce system\ncomplexity and build flexible systems. Some folks mention using different programming\nlanguages, while others talk about advanced design patterns. Finally, Theo’s attention gets\ncaptured by a comment from a user named Joe. He mentions data-oriented programming and\nclaims that its main goal is to reduce system complexity. Theo has never heard this term\nbefore. Out of curiosity, he decides to contact Joe by email. What a coincidence! Joe lives\nin San Francisco too. Theo invites him to a meeting in his office.\nJoe is a 40-year-old developer. He was a Java developer for nearly a decade before adopt-\ning Clojure around 7 years ago. When Theo tells Joe about the Library Management System",
        "sections_found": []
      },
      "accurate_page_range": "32-55"
    },
    {
      "text": "- 1.2.4 Complex class hierarchies",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "raw_line": "- 1.2.4 Complex class hierarchies (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 12,
      "chapter_info": {
        "page": 32,
        "title": "Complexity of object-oriented programming",
        "pattern_matched": "Chapter 1",
        "text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased "
      },
      "chapter_sections": {
        "start_page": 32,
        "end_page": 55,
        "content": "\n--- Page 32 ---\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, and their new project were introduced in the opener for part 1.\nTake a moment to read the opener if you missed it.\nTheo gets back to the office with Nancy’s napkin in his pocket and a lot of anxiety in his\nheart because he knows he has committed to a tough deadline. But he had no choice! Last\nweek, Monica, his boss, told him quite clearly that he had to close the deal with Nancy no\nmatter what.\nAlbatross, where Theo works, is a software consulting company with customers all over\nthe world. It originally had lots of customers among startups. Over the last year, however,\nmany projects were badly managed, and the Startup department lost the trust of its cus-\ntomers. That’s why management moved Theo from the Enterprise department to the\nStartup department as a Senior Tech lead. His job is to close deals and to deliver on time.\n1.1.1 The design phase\nBefore rushing to his laptop to code the system, Theo grabs a sheet of paper, much big-\nger than a napkin, and starts to draw a UML class diagram of the system that will imple-\nment the Klafim prototype. Theo is an object-oriented programmer. For him, there is no\nquestion—every business entity is represented by an object, and every object is made\nfrom a class.\nThe requirements for the Klafim prototype\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There can be several copies of a book.\n A book belongs to a physical library.\nTheo spends some time thinking about the organization of the system. He identifies the\nmain classes for the Klafim Global Library Management System.\n--- Page 33 ---\n1.1 OOP design: Classic or classical? 5\nThe main classes of the library management system\n Library—The central part of the system design.\n Book—A book.\n BookItem—A book can have multiple copies, and each copy is considered as\na book item.\n BookLending—When a book is lent, a book lending object is created.\n Member—A member of the library.\n Librarian—A librarian.\n User—A base class for Librarian and Member.\n Catalog—Contains a list of books.\n Author—A book author.\nThat was the easy part. Now comes the difficult part: the relations between the classes.\nAfter two hours or so, Theo comes up with a first draft of a design for the Global Library\nManagement System. It looks like the diagram in figure 1.1.\n NOTE The design presented here doesn’t pretend to be the smartest OOP design:\nexperienced OOP developers would probably use a couple of design patterns to sug-\ngest a much better design. This design is meant to be naive and by no means covers all\nthe features of the system. It serves two purposes:\n For Theo, the developer, it is rich enough to start coding.\n For me, the author of the book, it is rich enough to illustrate the complexity of a\ntypical OOP system.\nTheo feels proud of himself and of the design diagram he just produced. He definitely\ndeserves a cup of coffee!\nNear the coffee machine, Theo meets Dave, a junior software developer who joined\nAlbatross a couple of weeks ago. Theo and Dave appreciate each other, as Dave’s curiosity\nleads him to ask challenging questions. Meetings near the coffee machine often turn into\ninteresting discussions about programming.\nTheo Hey Dave! How’s it going?\nDave Today? Not great. I’m trying to fix a bug in my code! I can’t understand why\nthe state of my objects always changes. I’ll figure it out though, I’m sure. How’s\nyour day going?\nTheo I just finished the design of a system for a new customer.\nDave Cool! Would it be OK for me to see it? I’m trying to improve my design skills.\nTheo Sure! I have the diagram on my desk. We can take a look now if you like.\n--- Page 34 ---\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool\nid : String block() : Bool\nfullName: String unblock() : Bool\nreturnBook(bookLending: BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\n*\nC User\nC BookItem\nid : String\nid : String\nemail : String\nlibId: String\npassword : String\ncheckout(member: Member) : BookLending\nlogin() : Bool\nC BookLending\nid : String\nlendingDate : date *\ndueDate : date\nisLate() : Bool\nreturnBook() : Bool\nFigure 1.1 A class diagram for Klafim’s Global Library Management System\n1.1.2 UML 101\nLatte in hand, Dave follows Theo to his desk. Theo proudly shows Dave his piece of art: the\nUML diagram for the Library Management System (figure 1.1). Dave seems really excited.\nDave Wow! Such a detailed class diagram.\nTheo Yeah. I’m pretty happy with it.\n--- Page 35 ---\n1.1 OOP design: Classic or classical? 7\nDave The thing is that I can never remember the meaning of the different arrows.\nTheo There are four types of arrows in my class diagram: composition, association,\ninheritance, and usage.\nDave What’s the difference between composition and association?\n NOTE Don’t worry if you’re not familiar with OOP jargon. We’re going to leave it\naside in the next chapter.\nTheo It’s all about whether the objects can live without each other. With composi-\ntion, when one object dies, the other one dies too. While in an association rela-\ntion, each object has an independent life.\nTIP In a composition relation, when one object dies, the other one also dies. While\nin an association relation, each object has an independent life cycle.\nIn the class diagram, there are two kinds of composition symbolized by an arrow with\na plain diamond at one edge and an optional star at the other edge. Figure 1.2 shows\nthe relation between:\n A Library that owns a Catalog—A one-to-one composition. If a Library object\ndies, then its Catalog object dies with it.\n A Library that owns many Members—A one-to-many composition. If a Library\nobject dies, then all its Member objects die with it.\nC Library\nname : String * C Member\naddress : String\nFigure 1.2 The two kinds of\nC Catalog composition: one-to-one and\none-to-many. In both cases,\nList<Book> search(searchCriteria, queryStr) when an object dies, the\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\ncomposed object dies with it.\nTIP A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\nDave Do you have association relations in your diagram?\nTheo Take a look at the arrow between Book and Author. It has an empty diamond\nand a star at both edges, so it’s a many-to-many association relation.\nA book can be written by multiple authors, and an author can write multiple books.\nMoreover, Book and Author objects can live independently. The relation between\nbooks and authors is a many-to-many association (figure 1.3).\n--- Page 36 ---\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the Librarian::blockMember method. It calls\nMember::block.\nTIP Dashed arrows indicate usage relations (figure 1.4), for instance, when a class\nuses a method of another class.\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember(member: Member)\nC Member\nBool isBlocked()\nBool block()\nBool unblock()\nBool returnBook(bookLending: BookLending) Figure 1.4 Usage relation: a class\nBookLending checkout(bookItem: BookItem) uses a method of another class.\nDave I see. And I guess a plain arrow with an empty triangle, like the one between\nMember and User, represents inheritance.\nTheo Absolutely!\nTIP Plain arrows with empty triangles represent class inheritance (figure 1.5), where\nthe arrow points towards the superclass.\n--- Page 37 ---\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasure. Want to see how it all fits together?\nDave What class should we look at first?\nTheo I think we should start with Library.\nTHE LIBRARY CLASS\nThe Library is the root class of the library system. Figure 1.6 shows the system structure.\nCC Library\nname : String\naddress : String\n*\nC Member\nC Catalog\nBool isBlocked()\nList<Book> search(searchCriteria, queryStr) Bool block()\nBookItem addBookItem(librarian: Librarian, Bool unblock()\nbookItem: BookItem) Bool returnBook(bookLending: BookLending)\nBookLending checkout(bookItem: BookItem)\n*\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember\n(member: Member)\nFigure 1.6 The Library class\n--- Page 38 ---\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC Member C Librarian\nisBlocked() : Bool blockMember(member: Member) : Bool\nblock() : Bool unblockMember(member: Member) : Bool\nunblock() : Bool addBookItem(bookItem: BookItem) : BookItem\nreturnBook(bookLending : BookLending) : Bool : Member) :\ncheckout(bookItem: BookItem) : BookLending\nCC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.7 Librarian and Member derive from User.\nThe User class represents a user of the library:\n In terms of data members, it sticks to the bare minimum: it has an id, email,\nand password (with no security and encryption for now).\n In terms of code, it can log in via login.\nThe Member class represents a member of the library:\n It inherits from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Check out a book via checkout.\n– Return a book via returnBook.\n– Block itself via block.\n– Unblock itself via unblock.\n– Answer if it is blocked via isBlocked.\n It owns multiple BookLending objects.\n It uses BookItem in order to implement checkout.\n--- Page 39 ---\n1.1 OOP design: Classic or classical? 11\nThe Librarian class represents a librarian:\n It derives from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Block and unblock a Member.\n– List the member’s book lendings via getBookLendings.\n– Add book items to the library via addBookItem.\n It uses Member to implement blockMember, unblockMember, and getBook-\nLendings.\n It uses BookItem to implement checkout.\n It uses BookLending to implement getBookLendings.\nTHE CATALOG CLASS\nThe Catalog class is responsible for the management of the books. Figure 1.8 shows\nthe relation among the Catalog, Librarian, and Book classes. In terms of code, a\nCatalog object can\n Search books via search.\n Add book items to the library via addBookItem.\nC Catalog\nList<Book> search(searchCriteria, queryStr)\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\nC Librarian *\nC Book\nBool blockMember(member: Member)\nBool unblockMember(member: Member) id : String\nBookItem addBookItem(bookItem: BookItem) title : String\nList<BookLending> getBookLendingsOfMember (member: Member)\nFigure 1.8 The Catalog class\nA Catalog object uses Librarian in order to implement addBookItem. In terms of\ndata, a Catalog owns multiple Book objects.\nTHE BOOK CLASS\nFigure 1.9 presents the Book class. In terms of data, a Book object\n Should have as its bare minimum an id and a title.\n Is associated with multiple Author objects (a book might have multiple authors).\n Owns multiple BookItem objects, one for each copy of the book.\n--- Page 40 ---\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare minimum data for members: an id and a libId (for its\nphysical library ID).\n Owns multiple BookLending objects, one for each time the book is lent.\nIn terms of code, a BookItem object can be checked out via checkout.\n1.1.4 The implementation phase\nAfter this detailed investigation of Theo’s diagrams, Dave lets it sink in as he slowly sips his\ncoffee. He then expresses his admiration to Theo.\nDave Wow! That’s amazing!\nTheo Thank you.\nDave I didn’t realize people were really spending the time to write down their design\nin such detail before coding.\nTheo I always do that. It saves me lot of time during the coding phase.\nDave When will you start coding?\nTheo When I finish my latte.\nTheo grabs his coffee mug and notices that his hot latte has become an iced latte. He was\nso excited to show his class diagram to Dave that he forgot to drink it!\n--- Page 41 ---\n1.2 Sources of complexity 13\n1.2 Sources of complexity\nWhile Theo is getting himself another cup of coffee (a cappuccino this time), I\nwould like to challenge his design. It might look beautiful and clear on the paper,\nbut I claim that this design makes the system hard to understand. It’s not that Theo\npicked the wrong classes or that he misunderstood the relations among the classes.\nIt goes much deeper:\n It’s about the programming paradigm he chose to implement the system.\n It’s about the object-oriented paradigm.\n It’s about the tendency of OOP to increase the complexity of a system.\nTIP OOP has a tendency to create complex systems.\nThroughout this book, the type of complexity I refer to is that which makes systems\nhard to understand as defined in the paper, “Out of the Tar Pit,” by Ben Moseley\nand Peter Marks (2006), available at http://mng.bz/enzq. It has nothing to do with\nthe type of complexity that deals with the amount of resources consumed by a pro-\ngram. Similarly, when I refer to simplicity, I mean not complex (in other words, easy\nto understand).\nKeep in mind that complexity and simplicity (like hard and easy) are not absolute\nbut relative concepts. We can compare the complexity of two systems and determine\nwhether system A is more complex (or simpler) than system B.\n NOTE Complexity in the context of this book means hard to understand.\nAs mentioned in the introduction of this chapter, there are many ways in OOP to\nalleviate complexity. The purpose of this book is not be critical of OOP, but rather\nto present a programming paradigm called data-oriented programming (DOP) that\ntends to build systems that are less complex. In fact, the DOP paradigm is compati-\nble with OOP.\nIf one chooses to build an OOP system that adheres to DOP principles, the system\nwill be less complex. According to DOP, the main sources of complexity in Theo’s sys-\ntem (and of many traditional OOP systems) are that\n Code and data are mixed.\n Objects are mutable.\n Data is locked in objects as members.\n Code is locked into classes as methods.\nThis analysis is similar to what functional programming (FP) thinks about traditional\nOOP. However, as we will see throughout the book, the data approach that DOP takes\nin order to reduce system complexity differs from the FP approach. In appendix A, we\nillustrate how to apply DOP principles both in OOP and in FP styles.\nTIP DOP is compatible both with OOP and FP.\n--- Page 42 ---\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Extra thinking is needed when reading code.\nObjects are mutable. Explicit synchronization is required on multi-threaded environments.\nData is locked in objects. Data serialization is not trivial.\nCode is locked in classes. Class hierarchies are complex.\n1.2.1 Many relations between classes\nOne way to assess the complexity of a class diagram is to look only at the entities and\ntheir relations, ignoring members and methods, as in figure 1.10. When we design a\nsystem, we have to define the relations between different pieces of code and data.\nThat’s unavoidable.\nC Library\nC Catalog\n* *\nC Book C Librarian\n*\n*\nC Member\n*\nC Author\nC BookItem C User\nFigure 1.10 A class\ndiagram overview for\nC BookLending * Klafim’s Library\nManagement System\nTIP In OOP, code and data are mixed together in classes: data as members and code as\nmethods.\n--- Page 43 ---\n1.2 Sources of complexity 15\nFrom a system analysis perspective, the fact that code and data are mixed together\nmakes the system complex in the sense that entities tend to be involved in many rela-\ntions. In figure 1.11, we take a closer look at the Member class. Member is involved in five\nrelations: two data relations and three code relations.\n Data relations:\n– Library has many Members.\n– Member has many BookLendings.\n Code relations:\n– Member extends User.\n– Librarian uses Member.\n– Member uses BookItem.\nC Librarian\nC Library * C Member\n*\nC User C BookLending C BookItem Figure 1.11 The class Member is\ninvolved in five relations.\nImagine for a moment that we were able, somehow, to split the Member class into two\nseparate entities:\n MemberCode for the code\n MemberData for the data\nInstead of a Member class with five relations, we would have the diagram shown in fig-\nure 1.12 with:\n A MemberCode entity and three relations.\n A MemberData entity and two relations.\nC Library C Librarian\n*\nC MemberData C MemberCode\n*\nC BookLending C User C BookItem Figure 1.12 A class diagram where Member\nis split into code and data entities\n--- Page 44 ---\n16 CHAPTER 1 Complexity of object-orientedprogramming\nThe class diagram where Member is split into MemberCode and MemberData is made of\ntwo independent parts. Each part is easier to understand than the original diagram.\nLet’s split every class of our original class diagram into code and data entities.\nFigure 1.13 shows the resulting diagram. Now the system is made of two indepen-\ndent parts:\n A part that involves only data entities.\n A part that involves only code entities.\nC LibraryData * C LibrarianData C CatalogCode\n*\nC MemberData C CatalogData C LibrarianCode\n*\nC BookData C MemberCode C BookLendingCode C BookItemCode\n*\n* *\nC BookItemData C AuthorData C UserCode C BookItem\n*\nC BookLendingData\nFigure 1.13 A class diagram where every class is split into code and data entities\nTIP A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\nThe resulting system, made up of two independent subsystems, is easier to understand\nthan the original system. The fact that the two subsystems are independent means that\neach subsystem can be understood separately and in any order. The resulting system\nnot simpler by accident; it is a logical consequence of separating code from data.\nTIP A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n1.2.2 Unpredictable code behavior\nYou might be a bit tired after the system-level analysis that we presented in the previ-\nous section. Let’s get refreshed and look at some code.\nTake a look at the code in listing 1.1, where we get the blocked status of a member\nand display it twice. If I tell you that when I called displayBlockedStatusTwice, the\nprogram displayed true on the first console.log call, can you tell me what the pro-\ngram displayed on the second console.log call?\n--- Page 45 ---\n1.2 Sources of complexity 17\nListing1.1 Really simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nvar isBlocked = this.isBlocked;\nconsole.log(isBlocked);\nconsole.log(isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\n“Of course, it displayed true again,” you say. And you are right!\nNow, take a look at a slightly different pseudocode as shown in listing 1.2. Here we\ndisplay, twice, the blocked status of a member without assigning a variable. Same ques-\ntion as before: if I tell you that when I called displayBlockedStatusTwice, the pro-\ngram displayed true on the first console.log call, can you tell me what the program\ndisplayed on the second console.log call?\nListing1.2 Apparently simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nconsole.log(this.isBlocked);\nconsole.log(this.isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\nThe correct answer is...in a single-threaded environment, it displays true, while in a\nmulti-threaded environment, it’s unpredictable. Indeed, in a multi-threaded environ-\nment between the two console.log calls, there could be a context switch that changes\nthe state of the object (e.g., a librarian unblocked the member). In fact, with a slight\nmodification, the same kind of code unpredictability could occur even in a single-\nthreaded environment like JavaScript, when data is modified via asynchronous code\n(see the section about Principle #3 in appendix A). The difference between the two\ncode snippets is that\n In the first listing (listing 1.1), we access a Boolean value twice , which is a prim-\nitive value.\n In the second listing (listing 1.2), we access a member of an object twice.\nTIP When data is mutable, code is unpredictable.\n--- Page 46 ---\n18 CHAPTER 1 Complexity of object-orientedprogramming\nThis unpredictable behavior of the second listing is one of the annoying conse-\nquences of OOP. Unlike primitive types, which are usually immutable, object mem-\nbers are mutable. One way to solve this problem in OOP is to protect sensitive code\nwith concurrency safety mechanisms like mutexes, but that introduces issues like a\nperformance hit and a risk of deadlocks.\nWe will see later in the book that DOP treats every piece of data in the same way:\nboth primitive types and collection types are immutable values. This value treatment for\nall citizens brings serenity to DOP developers’ minds, and more brain cells are avail-\nable to handle the interesting pieces of the applications they build.\nTIP Data immutability brings serenity to DOP developers’ minds.\n1.2.3 Not trivial data serialization\nTheo is really tired, and he falls asleep at his desk. He’s having dream. In his dream, Nancy\nasks him to make Klafim’s Library Management System accessible via a REST API using\nJSON as a transport layer. Theo has to implement a /search endpoint that receives a\nquery in JSON format and returns the results in JSON format. Listing 1.3 shows an input\nexample of the /search endpoint, and listing 1.4 shows an output example of the /search\nendpoint.\nListing1.3 A JSON input of the /search endpoint\n{\n\"searchCriteria\": \"author\",\n\"query\": \"albert\"\n}\nListing1.4 A JSON output of the /search endpoint\n[\n{\n\"title\": \"The world as I see it\",\n\"authors\": [\n{\n\"fullName\": \"Albert Einstein\"\n}\n]\n},\n{\n\"title\": \"The Stranger\",\n\"authors\": [\n{\n\"fullName\": \"Albert Camus\"\n}\n]\n}\n]\n--- Page 47 ---\n1.2 Sources of complexity 19\nTheo would probably implement the /search endpoint by creating three classes simi-\nlarly to what is shown in the following list and in figure 1.14. (Not surprisingly, every-\nthing in OOP has to be wrapped in a class. Right?)\n SearchController is responsible for handling the query.\n SearchQuery converts the JSON query string into data.\n SearchResult converts the search result data into a JSON string.\nC SearchController\nString handle(searchQuery: String)\nC SearchQuery\nC SearchResult\nC Catalog\nsearchCriteria: String\nSearchResult(books: List<Book>)\nList<Book> search(searchCriteria, queryStr) query: String\nString toJSON()\nSearchQuery(jsonString: String)\n* *\nC Book\nid : String\ntitle : String\nFigure 1.14 The class diagram for SearchController\nThe SearchController (see figure 1.14) would have a single handle method with the\nfollowing flow:\n Creates a SearchQuery object from the JSON query string.\n Retrieves searchCriteria and queryStr from the SearchQuery object.\n Calls the search method of the catalog:Catalog with searchCriteria and\nqueryStr and receives books:List<Book>.\n Creates a SearchResult object with books.\n Converts the SearchResult object to a JSON string.\nWhat about other endpoints, for instance, those allowing librarians to add book items\nthrough /add-book-item? Theo would have to repeat the exact same process and cre-\nate three classes:\n AddBookItemController to handle the query\n BookItemQuery to convert the JSON query string into data\n BookItemResult to convert the search result data into a JSON string\nThe code that deals with JSON deserialization that Theo wrote previously in Search-\nQuery would have to be rewritten in BookItemQuery. Same thing for the code that\ndeals with JSON serialization he wrote previously in SearchResult; it would have to be\nrewritten in BookItemResult.\n--- Page 48 ---\n20 CHAPTER 1 Complexity of object-orientedprogramming\nThe bad news is that Theo would have to repeat the same process for every end-\npoint of the system. Each time he encounters a new kind of JSON input or output,\nhe would have to create a new class and write code. Theo’s dream is turning into a\nnightmare!\nSuddenly, his phone rings, next to where he was resting his head on the desk. As Theo\nwakes up, he realizes that Nancy never asked for JSON. It was all a dream...a really bad\ndream!\nTIP In OOP, data serialization is difficult.\nIt’s quite frustrating that handling JSON serialization and deserialization in OOP\nrequires the addition of so many classes and writing so much code—again and again!\nThe frustration grows when you consider that serializing a search query, a book item\nquery, or any query is quite similar. It comes down to\n Going over data fields.\n Concatenating the name of the data fields and the value of the data fields, sepa-\nrated by a comma.\nWhy is such a simple thing so hard to achieve in OOP? In OOP, data has to follow a\nrigid shape defined in classes, which means that data is locked in members. There is\nno simple way to access data generically.\nTIP In OOP, data is locked in classes as members.\nWe will refine later what we mean by generic access to the data, and we will see how\nDOP provides a generic way to handle JSON serialization and deserialization. Until\nthen, you will have to continue suffering. But at least you are starting to become aware\nof this suffering, and you know that it is avoidable.\n NOTE Most OOP programming languages alleviate a bit of the difficulty involved\nin the conversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n1.2.4 Complex class hierarchies\nOne way to avoid writing the same code twice in OOP involves class inheritance. Indeed,\nwhen every requirement of the system is known up front, you design your class hier-\narchy is such a way that classes with common behavior derive from a base class.\nFigure 1.15 shows an example of this pattern that focuses on the part of our class\ndiagram that deals with members and librarians. Both Librarians and Members need\nthe ability to log in, and they inherit this ability from the User class.\nSo far, so good, but when new requirements are introduced after the system is imple-\nmented, it’s a completely different story. Fast forward to Monday, March 29th, at 11:00 AM,\nwhere two days are left before the deadline (Wednesday at midnight).\n--- Page 49 ---\n1.2 Sources of complexity 21\nC Librarian\nblockMember(member: Member) : Bool\nunblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String Figure 1.15 The part of the\npassword : String class diagram that deals with\nlogin() : Bool members and librarians\nNancy calls Theo with an urgent request. Theo is not sure if it’s a dream or reality. He\npinches himself and he can feel the jolt. It’s definitely reality!\nNancy How is the project doing?\nTheo Fine, Nancy. We’re on schedule to meet the deadline. We’re running our last\nround of regression tests now.\nNancy Fantastic! It means we have time for adding a tiny feature to the system, right?\nTheo Depends what you mean by “tiny.”\nNancy We need to add VIP members to the system.\nTheo What do you mean by VIP members?\nNancy VIP members are allowed to add book items to the library by themselves.\nTheo Hmm...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nI’ll ask you the same question Nancy asked Theo: why is adding VIP members to our\nsystem not a tiny task? After all, Theo has already written the code that allows librari-\nans to add book items to the library (it’s in Librarian::addBookItem). What prevents\nhim from reusing this code for VIP members? The reason is that, in OOP, the code is\nlocked into classes as methods.\nTIP In OOP, code is locked into classes.\nVIP members are members that are allowed to add book items to the library by them-\nselves. Theo decomposes the customer requirements into two pieces:\n--- Page 50 ---\n22 CHAPTER 1 Complexity of object-orientedprogramming\n VIP members are library members.\n VIP members are allowed to add book items to the library by themselves.\nTheo then decides that he needs a new class, VIPMember. For the first requirement\n(VIP members are library members), it seems reasonable to make VIPMember derive\nfrom Member. However, handling the second requirement (VIP members are allowed\nto add book items) is more complex. He cannot make a VIPMember derive from\nLibrarian because the relation between VIPMember and Librarian is not linear:\n On one hand, VIP members are like librarians in that they are allowed to add\nbook items.\n On the other hand, VIP members are not like librarians in that they are not\nallowed to block members or list the books lent to a member.\nThe problem is that the code that adds book items is locked in the Librarian class.\nThere is no way for the VIPMember class to use this code.\nFigure 1.16 shows one possible solution that makes the code of Librarian::add-\nBookItem available to both Librarian and VIPMember classes. Here are the changes to\nthe previous class diagram:\n A base class UserWithBookItemRight extends User.\n addBookItem moves from Librarian to UserWithBookItemRight.\n Both VIPMember and Librarian extend UserWithBookItemRight.\nC Librarian\nblockMember(member: Member) : Bool C VIPMember\nunblockMember(member: Member) : Bool\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nCC UserWithBookItemRight\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool addBookItem(bookItem: BookItem) : BookItem\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.16 A class diagram for a system with VIP members\nIt wasn’t easy, but Theo manages to handle the change on time, thanks to an all nighter\ncoding on his laptop. He was even able to add new tests to the system and run the regres-\nsion tests again. However, he was so excited that he didn’t pay attention to the diamond\n--- Page 51 ---\n1.2 Sources of complexity 23\nproblem VIPMember introduced in his class diagram due to multiple inheritance: VIPMember\nextends both Member and UserWithBookItemRight, which both extend User.\nWednesday, March 31, at 10:00 AM (14 hours before the deadline), Theo calls Nancy to\ntell her the good news.\nTheo We were able to add VIP members to the system on time, Nancy.\nNancy Fantastic! I told you it was a tiny feature.\nTheo Yeah, well...\nNancy Look, I was going to call you anyway. I just finished a meeting with my business\npartner, and we realized that we need another tiny feature before the launch.\nWill you be able to handle it before the deadline?\nTheo Again, it depends what you mean by “tiny.”\nNancy We need to add Super members to the system.\nTheo What do you mean by Super members?\nNancy Super members are allowed to list the books lent to other members.\nTheo Err...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nAs with VIP members, adding Super members to the system requires changes to Theo’s\nclass hierarchy. Figure 1.17 shows the solution Theo has in mind.\nC Librarian\nC VIPMember C SuperMember\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC UserWithBlockMemberRight\nCC UserWithBookItemRight\nblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\nunblockMember(member: Member) : Bool\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.17 A class diagram for a system with Super and VIP members\nThe addition of Super members has made the system really complex. Theo suddenly\nnotices that he has three diamonds in his class diagram—not gemstones but three “Deadly\n--- Page 52 ---\n24 CHAPTER 1 Complexity of object-orientedprogramming\nDiamonds of Death” as OOP developers sometimes name the ambiguity that arises when a\nclass D inherits from two classes B and C, where both inherit from class A!\nHe tries to avoid the diamonds by transforming the User class into an interface and\nusing the composition over inheritance design pattern. But with the stress of the deadline\nlooming, he isn’t able to use all of his brain cells. In fact, the system has become so com-\nplex, he’s unable to deliver the system by the deadline. Theo tells himself that he should\nhave used composition instead of class inheritance. But, it’s too late now.\nTIP In OOP, prefer composition over class inheritance.\nAt 10:00 PM, two hours before the deadline, Theo calls Nancy to explain the situation.\nTheo Look Nancy, we really did our best, but we won’t be able to add Super mem-\nbers to the system before the deadline.\nNancy No worries, my business partner and I decided to omit this feature for now.\nWe’ll add it later.\nWith mixed feelings of anger and relief, Theo stops pacing around his office. He realizes\nhe will be spending tonight in his own bed, rather than plowing away on his computer at\nthe office. That should make his wife happy.\nTheo I guess that means we’re ready for the launch tomorrow morning.\nNancy Yes. We’ll offer this new product for a month or so, and if we get good market\ntraction, we’ll move forward with a bigger project.\nTheo Cool. Let’s be in touch in a month then. Good luck on the launch!\nSummary\n Complexity in the context of this book means hard to understand.\n We use the terms code and behavior interchangeably.\n DOP stands for data-oriented programming.\n OOP stands for object-oriented programming.\n FP stands for functional programming.\n In a composition relation, when one object dies, the other one also dies.\n A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\n In an association relation, each object has an independent life cycle.\n A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\n Dashed arrows indicate a usage relation; for instance, when a class uses a method\nof another class.\n Plain arrows with empty triangles represent class inheritance, where the arrow\npoints towards the superclass.\n The design presented in this chapter doesn’t pretend to be the smartest OOP\ndesign. Experienced OOP developers would probably use a couple of design\npatterns and suggest a much better diagram.\n--- Page 53 ---\nSummary 25\n Traditional OOP systems tend to increase system complexity, in the sense that\nOOP systems are hard to understand.\n In traditional OOP, code and data are mixed together in classes: data as mem-\nbers and code as methods.\n In traditional OOP, data is mutable.\n The root cause of the increase in complexity is related to the mixing of code\nand data together into objects.\n When code and data are mixed, classes tend to be involved in many relations.\n When objects are mutable, extra thinking is required in order to understand\nhow the code behaves.\n When objects are mutable, explicit synchronization mechanisms are required\non multi-threaded environments.\n When data is locked in objects, data serialization is not trivial.\n When code is locked in classes, class hierarchies tend to be complex.\n A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\n A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n When data is mutable, code is unpredictable.\n A strategic use of design patterns can help mitigate complexity in traditional\nOOP to some degree.\n Data immutability brings serenity to DOP developers’ minds.\n Most OOP programming languages alleviate slightly the difficulty involved the\nconversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n In traditional OOP, data serialization is difficult.\n In traditional OOP, data is locked in classes as members.\n In traditional OOP, code is locked into classes.\n DOP reduces complexity by rethinking data.\n DOP is compatible both with OOP and FP.\n--- Page 54 ---\nSeparation between\ncode and data\nA whole new world\nThis chapter covers\n The benefits of separating code from data\n Designing a system where code and data are\nseparate\n Implementing a system that respects the\nseparation between code and data\nThe first insight of DOP is that we can decrease the complexity of our systems by\nseparating code from data. Indeed, when code is separated from data, our systems\nare made of two main pieces that can be thought about separately: data entities and\ncode modules. This chapter is a deep dive in the first principle of DOP (summa-\nrized in figure 2.1).\nPRINCIPLE #1 Separate code from data such that the code resides in functions,\nwhose behavior doesn’t depend on data that is somehow encapsulated in the func-\ntion’s context.\n26\n--- Page 55 ---\n2.1 The two parts of a DOP system 27\nStateless (static)\nFunctions\nData asfirst argument\nCode modules\nUsage\nRelations\nNo inheritance\nSeparate code from data\nOnly members\nData entities No code\nAssociation\nRelations\nComposition\nFigure 2.1 DOP principle #1 summarized: Separate code from data.\nIn this chapter, we’ll illustrate the separation between code and data in the context of\nKlafim’s Library Management System that we introduced in chapter 1. We’ll also unveil\nthe benefits that this separation brings to the system:\n The system is simple. It is easy to understand.\n The system is flexible and extensible. Quite often, it requires no design changes to\nadapt to changing requirements.\nThis chapter focuses on the design of the code in a system where code and data are\nseparate. In the next chapter, we’ll focus on the design of the data. As we progress in\nthe book, we’ll discover other benefits of separating code from data.\n2.1 The two parts of a DOP system\nWhile Theo is driving home after delivering the prototype, he asks himself whether the\nKlafim project was a success or not. Sure, he was able to satisfy the customer, but it was\nmore luck than brains. He wouldn’t have made it on time if Nancy had decided to keep\nthe Super members feature. Why was it so complicated to add tiny features to the system?\nWhy was the system he built so complex? He thought there should be a way to build more\nflexible systems!\nThe next morning, Theo asks on Hacker News and on Reddit for ways to reduce system\ncomplexity and build flexible systems. Some folks mention using different programming\nlanguages, while others talk about advanced design patterns. Finally, Theo’s attention gets\ncaptured by a comment from a user named Joe. He mentions data-oriented programming and\nclaims that its main goal is to reduce system complexity. Theo has never heard this term\nbefore. Out of curiosity, he decides to contact Joe by email. What a coincidence! Joe lives\nin San Francisco too. Theo invites him to a meeting in his office.\nJoe is a 40-year-old developer. He was a Java developer for nearly a decade before adopt-\ning Clojure around 7 years ago. When Theo tells Joe about the Library Management System",
        "sections_found": []
      },
      "accurate_page_range": "32-55"
    },
    {
      "text": "- Summary",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "raw_line": "- Summary (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 13,
      "chapter_info": {
        "page": 32,
        "title": "Complexity of object-oriented programming",
        "pattern_matched": "Chapter 1",
        "text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased "
      },
      "chapter_sections": {
        "start_page": 32,
        "end_page": 55,
        "content": "\n--- Page 32 ---\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, and their new project were introduced in the opener for part 1.\nTake a moment to read the opener if you missed it.\nTheo gets back to the office with Nancy’s napkin in his pocket and a lot of anxiety in his\nheart because he knows he has committed to a tough deadline. But he had no choice! Last\nweek, Monica, his boss, told him quite clearly that he had to close the deal with Nancy no\nmatter what.\nAlbatross, where Theo works, is a software consulting company with customers all over\nthe world. It originally had lots of customers among startups. Over the last year, however,\nmany projects were badly managed, and the Startup department lost the trust of its cus-\ntomers. That’s why management moved Theo from the Enterprise department to the\nStartup department as a Senior Tech lead. His job is to close deals and to deliver on time.\n1.1.1 The design phase\nBefore rushing to his laptop to code the system, Theo grabs a sheet of paper, much big-\nger than a napkin, and starts to draw a UML class diagram of the system that will imple-\nment the Klafim prototype. Theo is an object-oriented programmer. For him, there is no\nquestion—every business entity is represented by an object, and every object is made\nfrom a class.\nThe requirements for the Klafim prototype\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There can be several copies of a book.\n A book belongs to a physical library.\nTheo spends some time thinking about the organization of the system. He identifies the\nmain classes for the Klafim Global Library Management System.\n--- Page 33 ---\n1.1 OOP design: Classic or classical? 5\nThe main classes of the library management system\n Library—The central part of the system design.\n Book—A book.\n BookItem—A book can have multiple copies, and each copy is considered as\na book item.\n BookLending—When a book is lent, a book lending object is created.\n Member—A member of the library.\n Librarian—A librarian.\n User—A base class for Librarian and Member.\n Catalog—Contains a list of books.\n Author—A book author.\nThat was the easy part. Now comes the difficult part: the relations between the classes.\nAfter two hours or so, Theo comes up with a first draft of a design for the Global Library\nManagement System. It looks like the diagram in figure 1.1.\n NOTE The design presented here doesn’t pretend to be the smartest OOP design:\nexperienced OOP developers would probably use a couple of design patterns to sug-\ngest a much better design. This design is meant to be naive and by no means covers all\nthe features of the system. It serves two purposes:\n For Theo, the developer, it is rich enough to start coding.\n For me, the author of the book, it is rich enough to illustrate the complexity of a\ntypical OOP system.\nTheo feels proud of himself and of the design diagram he just produced. He definitely\ndeserves a cup of coffee!\nNear the coffee machine, Theo meets Dave, a junior software developer who joined\nAlbatross a couple of weeks ago. Theo and Dave appreciate each other, as Dave’s curiosity\nleads him to ask challenging questions. Meetings near the coffee machine often turn into\ninteresting discussions about programming.\nTheo Hey Dave! How’s it going?\nDave Today? Not great. I’m trying to fix a bug in my code! I can’t understand why\nthe state of my objects always changes. I’ll figure it out though, I’m sure. How’s\nyour day going?\nTheo I just finished the design of a system for a new customer.\nDave Cool! Would it be OK for me to see it? I’m trying to improve my design skills.\nTheo Sure! I have the diagram on my desk. We can take a look now if you like.\n--- Page 34 ---\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool\nid : String block() : Bool\nfullName: String unblock() : Bool\nreturnBook(bookLending: BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\n*\nC User\nC BookItem\nid : String\nid : String\nemail : String\nlibId: String\npassword : String\ncheckout(member: Member) : BookLending\nlogin() : Bool\nC BookLending\nid : String\nlendingDate : date *\ndueDate : date\nisLate() : Bool\nreturnBook() : Bool\nFigure 1.1 A class diagram for Klafim’s Global Library Management System\n1.1.2 UML 101\nLatte in hand, Dave follows Theo to his desk. Theo proudly shows Dave his piece of art: the\nUML diagram for the Library Management System (figure 1.1). Dave seems really excited.\nDave Wow! Such a detailed class diagram.\nTheo Yeah. I’m pretty happy with it.\n--- Page 35 ---\n1.1 OOP design: Classic or classical? 7\nDave The thing is that I can never remember the meaning of the different arrows.\nTheo There are four types of arrows in my class diagram: composition, association,\ninheritance, and usage.\nDave What’s the difference between composition and association?\n NOTE Don’t worry if you’re not familiar with OOP jargon. We’re going to leave it\naside in the next chapter.\nTheo It’s all about whether the objects can live without each other. With composi-\ntion, when one object dies, the other one dies too. While in an association rela-\ntion, each object has an independent life.\nTIP In a composition relation, when one object dies, the other one also dies. While\nin an association relation, each object has an independent life cycle.\nIn the class diagram, there are two kinds of composition symbolized by an arrow with\na plain diamond at one edge and an optional star at the other edge. Figure 1.2 shows\nthe relation between:\n A Library that owns a Catalog—A one-to-one composition. If a Library object\ndies, then its Catalog object dies with it.\n A Library that owns many Members—A one-to-many composition. If a Library\nobject dies, then all its Member objects die with it.\nC Library\nname : String * C Member\naddress : String\nFigure 1.2 The two kinds of\nC Catalog composition: one-to-one and\none-to-many. In both cases,\nList<Book> search(searchCriteria, queryStr) when an object dies, the\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\ncomposed object dies with it.\nTIP A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\nDave Do you have association relations in your diagram?\nTheo Take a look at the arrow between Book and Author. It has an empty diamond\nand a star at both edges, so it’s a many-to-many association relation.\nA book can be written by multiple authors, and an author can write multiple books.\nMoreover, Book and Author objects can live independently. The relation between\nbooks and authors is a many-to-many association (figure 1.3).\n--- Page 36 ---\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the Librarian::blockMember method. It calls\nMember::block.\nTIP Dashed arrows indicate usage relations (figure 1.4), for instance, when a class\nuses a method of another class.\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember(member: Member)\nC Member\nBool isBlocked()\nBool block()\nBool unblock()\nBool returnBook(bookLending: BookLending) Figure 1.4 Usage relation: a class\nBookLending checkout(bookItem: BookItem) uses a method of another class.\nDave I see. And I guess a plain arrow with an empty triangle, like the one between\nMember and User, represents inheritance.\nTheo Absolutely!\nTIP Plain arrows with empty triangles represent class inheritance (figure 1.5), where\nthe arrow points towards the superclass.\n--- Page 37 ---\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasure. Want to see how it all fits together?\nDave What class should we look at first?\nTheo I think we should start with Library.\nTHE LIBRARY CLASS\nThe Library is the root class of the library system. Figure 1.6 shows the system structure.\nCC Library\nname : String\naddress : String\n*\nC Member\nC Catalog\nBool isBlocked()\nList<Book> search(searchCriteria, queryStr) Bool block()\nBookItem addBookItem(librarian: Librarian, Bool unblock()\nbookItem: BookItem) Bool returnBook(bookLending: BookLending)\nBookLending checkout(bookItem: BookItem)\n*\nCC Librarian\nBool blockMember(member: Member)\nBool unblockMember(member: Member)\nBookItem addBookItem(bookItem: BookItem)\nList<BookLending> getBookLendingsOfMember\n(member: Member)\nFigure 1.6 The Library class\n--- Page 38 ---\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC Member C Librarian\nisBlocked() : Bool blockMember(member: Member) : Bool\nblock() : Bool unblockMember(member: Member) : Bool\nunblock() : Bool addBookItem(bookItem: BookItem) : BookItem\nreturnBook(bookLending : BookLending) : Bool : Member) :\ncheckout(bookItem: BookItem) : BookLending\nCC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.7 Librarian and Member derive from User.\nThe User class represents a user of the library:\n In terms of data members, it sticks to the bare minimum: it has an id, email,\nand password (with no security and encryption for now).\n In terms of code, it can log in via login.\nThe Member class represents a member of the library:\n It inherits from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Check out a book via checkout.\n– Return a book via returnBook.\n– Block itself via block.\n– Unblock itself via unblock.\n– Answer if it is blocked via isBlocked.\n It owns multiple BookLending objects.\n It uses BookItem in order to implement checkout.\n--- Page 39 ---\n1.1 OOP design: Classic or classical? 11\nThe Librarian class represents a librarian:\n It derives from User.\n In terms of data members, it has nothing more than User.\n In terms of code, it can\n– Block and unblock a Member.\n– List the member’s book lendings via getBookLendings.\n– Add book items to the library via addBookItem.\n It uses Member to implement blockMember, unblockMember, and getBook-\nLendings.\n It uses BookItem to implement checkout.\n It uses BookLending to implement getBookLendings.\nTHE CATALOG CLASS\nThe Catalog class is responsible for the management of the books. Figure 1.8 shows\nthe relation among the Catalog, Librarian, and Book classes. In terms of code, a\nCatalog object can\n Search books via search.\n Add book items to the library via addBookItem.\nC Catalog\nList<Book> search(searchCriteria, queryStr)\nBookItem addBookItem(librarian: Librarian, bookItem: BookItem)\nC Librarian *\nC Book\nBool blockMember(member: Member)\nBool unblockMember(member: Member) id : String\nBookItem addBookItem(bookItem: BookItem) title : String\nList<BookLending> getBookLendingsOfMember (member: Member)\nFigure 1.8 The Catalog class\nA Catalog object uses Librarian in order to implement addBookItem. In terms of\ndata, a Catalog owns multiple Book objects.\nTHE BOOK CLASS\nFigure 1.9 presents the Book class. In terms of data, a Book object\n Should have as its bare minimum an id and a title.\n Is associated with multiple Author objects (a book might have multiple authors).\n Owns multiple BookItem objects, one for each copy of the book.\n--- Page 40 ---\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare minimum data for members: an id and a libId (for its\nphysical library ID).\n Owns multiple BookLending objects, one for each time the book is lent.\nIn terms of code, a BookItem object can be checked out via checkout.\n1.1.4 The implementation phase\nAfter this detailed investigation of Theo’s diagrams, Dave lets it sink in as he slowly sips his\ncoffee. He then expresses his admiration to Theo.\nDave Wow! That’s amazing!\nTheo Thank you.\nDave I didn’t realize people were really spending the time to write down their design\nin such detail before coding.\nTheo I always do that. It saves me lot of time during the coding phase.\nDave When will you start coding?\nTheo When I finish my latte.\nTheo grabs his coffee mug and notices that his hot latte has become an iced latte. He was\nso excited to show his class diagram to Dave that he forgot to drink it!\n--- Page 41 ---\n1.2 Sources of complexity 13\n1.2 Sources of complexity\nWhile Theo is getting himself another cup of coffee (a cappuccino this time), I\nwould like to challenge his design. It might look beautiful and clear on the paper,\nbut I claim that this design makes the system hard to understand. It’s not that Theo\npicked the wrong classes or that he misunderstood the relations among the classes.\nIt goes much deeper:\n It’s about the programming paradigm he chose to implement the system.\n It’s about the object-oriented paradigm.\n It’s about the tendency of OOP to increase the complexity of a system.\nTIP OOP has a tendency to create complex systems.\nThroughout this book, the type of complexity I refer to is that which makes systems\nhard to understand as defined in the paper, “Out of the Tar Pit,” by Ben Moseley\nand Peter Marks (2006), available at http://mng.bz/enzq. It has nothing to do with\nthe type of complexity that deals with the amount of resources consumed by a pro-\ngram. Similarly, when I refer to simplicity, I mean not complex (in other words, easy\nto understand).\nKeep in mind that complexity and simplicity (like hard and easy) are not absolute\nbut relative concepts. We can compare the complexity of two systems and determine\nwhether system A is more complex (or simpler) than system B.\n NOTE Complexity in the context of this book means hard to understand.\nAs mentioned in the introduction of this chapter, there are many ways in OOP to\nalleviate complexity. The purpose of this book is not be critical of OOP, but rather\nto present a programming paradigm called data-oriented programming (DOP) that\ntends to build systems that are less complex. In fact, the DOP paradigm is compati-\nble with OOP.\nIf one chooses to build an OOP system that adheres to DOP principles, the system\nwill be less complex. According to DOP, the main sources of complexity in Theo’s sys-\ntem (and of many traditional OOP systems) are that\n Code and data are mixed.\n Objects are mutable.\n Data is locked in objects as members.\n Code is locked into classes as methods.\nThis analysis is similar to what functional programming (FP) thinks about traditional\nOOP. However, as we will see throughout the book, the data approach that DOP takes\nin order to reduce system complexity differs from the FP approach. In appendix A, we\nillustrate how to apply DOP principles both in OOP and in FP styles.\nTIP DOP is compatible both with OOP and FP.\n--- Page 42 ---\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Extra thinking is needed when reading code.\nObjects are mutable. Explicit synchronization is required on multi-threaded environments.\nData is locked in objects. Data serialization is not trivial.\nCode is locked in classes. Class hierarchies are complex.\n1.2.1 Many relations between classes\nOne way to assess the complexity of a class diagram is to look only at the entities and\ntheir relations, ignoring members and methods, as in figure 1.10. When we design a\nsystem, we have to define the relations between different pieces of code and data.\nThat’s unavoidable.\nC Library\nC Catalog\n* *\nC Book C Librarian\n*\n*\nC Member\n*\nC Author\nC BookItem C User\nFigure 1.10 A class\ndiagram overview for\nC BookLending * Klafim’s Library\nManagement System\nTIP In OOP, code and data are mixed together in classes: data as members and code as\nmethods.\n--- Page 43 ---\n1.2 Sources of complexity 15\nFrom a system analysis perspective, the fact that code and data are mixed together\nmakes the system complex in the sense that entities tend to be involved in many rela-\ntions. In figure 1.11, we take a closer look at the Member class. Member is involved in five\nrelations: two data relations and three code relations.\n Data relations:\n– Library has many Members.\n– Member has many BookLendings.\n Code relations:\n– Member extends User.\n– Librarian uses Member.\n– Member uses BookItem.\nC Librarian\nC Library * C Member\n*\nC User C BookLending C BookItem Figure 1.11 The class Member is\ninvolved in five relations.\nImagine for a moment that we were able, somehow, to split the Member class into two\nseparate entities:\n MemberCode for the code\n MemberData for the data\nInstead of a Member class with five relations, we would have the diagram shown in fig-\nure 1.12 with:\n A MemberCode entity and three relations.\n A MemberData entity and two relations.\nC Library C Librarian\n*\nC MemberData C MemberCode\n*\nC BookLending C User C BookItem Figure 1.12 A class diagram where Member\nis split into code and data entities\n--- Page 44 ---\n16 CHAPTER 1 Complexity of object-orientedprogramming\nThe class diagram where Member is split into MemberCode and MemberData is made of\ntwo independent parts. Each part is easier to understand than the original diagram.\nLet’s split every class of our original class diagram into code and data entities.\nFigure 1.13 shows the resulting diagram. Now the system is made of two indepen-\ndent parts:\n A part that involves only data entities.\n A part that involves only code entities.\nC LibraryData * C LibrarianData C CatalogCode\n*\nC MemberData C CatalogData C LibrarianCode\n*\nC BookData C MemberCode C BookLendingCode C BookItemCode\n*\n* *\nC BookItemData C AuthorData C UserCode C BookItem\n*\nC BookLendingData\nFigure 1.13 A class diagram where every class is split into code and data entities\nTIP A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\nThe resulting system, made up of two independent subsystems, is easier to understand\nthan the original system. The fact that the two subsystems are independent means that\neach subsystem can be understood separately and in any order. The resulting system\nnot simpler by accident; it is a logical consequence of separating code from data.\nTIP A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n1.2.2 Unpredictable code behavior\nYou might be a bit tired after the system-level analysis that we presented in the previ-\nous section. Let’s get refreshed and look at some code.\nTake a look at the code in listing 1.1, where we get the blocked status of a member\nand display it twice. If I tell you that when I called displayBlockedStatusTwice, the\nprogram displayed true on the first console.log call, can you tell me what the pro-\ngram displayed on the second console.log call?\n--- Page 45 ---\n1.2 Sources of complexity 17\nListing1.1 Really simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nvar isBlocked = this.isBlocked;\nconsole.log(isBlocked);\nconsole.log(isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\n“Of course, it displayed true again,” you say. And you are right!\nNow, take a look at a slightly different pseudocode as shown in listing 1.2. Here we\ndisplay, twice, the blocked status of a member without assigning a variable. Same ques-\ntion as before: if I tell you that when I called displayBlockedStatusTwice, the pro-\ngram displayed true on the first console.log call, can you tell me what the program\ndisplayed on the second console.log call?\nListing1.2 Apparently simple code\nclass Member {\nisBlocked;\ndisplayBlockedStatusTwice() {\nconsole.log(this.isBlocked);\nconsole.log(this.isBlocked);\n}\n}\nmember.displayBlockedStatusTwice();\nThe correct answer is...in a single-threaded environment, it displays true, while in a\nmulti-threaded environment, it’s unpredictable. Indeed, in a multi-threaded environ-\nment between the two console.log calls, there could be a context switch that changes\nthe state of the object (e.g., a librarian unblocked the member). In fact, with a slight\nmodification, the same kind of code unpredictability could occur even in a single-\nthreaded environment like JavaScript, when data is modified via asynchronous code\n(see the section about Principle #3 in appendix A). The difference between the two\ncode snippets is that\n In the first listing (listing 1.1), we access a Boolean value twice , which is a prim-\nitive value.\n In the second listing (listing 1.2), we access a member of an object twice.\nTIP When data is mutable, code is unpredictable.\n--- Page 46 ---\n18 CHAPTER 1 Complexity of object-orientedprogramming\nThis unpredictable behavior of the second listing is one of the annoying conse-\nquences of OOP. Unlike primitive types, which are usually immutable, object mem-\nbers are mutable. One way to solve this problem in OOP is to protect sensitive code\nwith concurrency safety mechanisms like mutexes, but that introduces issues like a\nperformance hit and a risk of deadlocks.\nWe will see later in the book that DOP treats every piece of data in the same way:\nboth primitive types and collection types are immutable values. This value treatment for\nall citizens brings serenity to DOP developers’ minds, and more brain cells are avail-\nable to handle the interesting pieces of the applications they build.\nTIP Data immutability brings serenity to DOP developers’ minds.\n1.2.3 Not trivial data serialization\nTheo is really tired, and he falls asleep at his desk. He’s having dream. In his dream, Nancy\nasks him to make Klafim’s Library Management System accessible via a REST API using\nJSON as a transport layer. Theo has to implement a /search endpoint that receives a\nquery in JSON format and returns the results in JSON format. Listing 1.3 shows an input\nexample of the /search endpoint, and listing 1.4 shows an output example of the /search\nendpoint.\nListing1.3 A JSON input of the /search endpoint\n{\n\"searchCriteria\": \"author\",\n\"query\": \"albert\"\n}\nListing1.4 A JSON output of the /search endpoint\n[\n{\n\"title\": \"The world as I see it\",\n\"authors\": [\n{\n\"fullName\": \"Albert Einstein\"\n}\n]\n},\n{\n\"title\": \"The Stranger\",\n\"authors\": [\n{\n\"fullName\": \"Albert Camus\"\n}\n]\n}\n]\n--- Page 47 ---\n1.2 Sources of complexity 19\nTheo would probably implement the /search endpoint by creating three classes simi-\nlarly to what is shown in the following list and in figure 1.14. (Not surprisingly, every-\nthing in OOP has to be wrapped in a class. Right?)\n SearchController is responsible for handling the query.\n SearchQuery converts the JSON query string into data.\n SearchResult converts the search result data into a JSON string.\nC SearchController\nString handle(searchQuery: String)\nC SearchQuery\nC SearchResult\nC Catalog\nsearchCriteria: String\nSearchResult(books: List<Book>)\nList<Book> search(searchCriteria, queryStr) query: String\nString toJSON()\nSearchQuery(jsonString: String)\n* *\nC Book\nid : String\ntitle : String\nFigure 1.14 The class diagram for SearchController\nThe SearchController (see figure 1.14) would have a single handle method with the\nfollowing flow:\n Creates a SearchQuery object from the JSON query string.\n Retrieves searchCriteria and queryStr from the SearchQuery object.\n Calls the search method of the catalog:Catalog with searchCriteria and\nqueryStr and receives books:List<Book>.\n Creates a SearchResult object with books.\n Converts the SearchResult object to a JSON string.\nWhat about other endpoints, for instance, those allowing librarians to add book items\nthrough /add-book-item? Theo would have to repeat the exact same process and cre-\nate three classes:\n AddBookItemController to handle the query\n BookItemQuery to convert the JSON query string into data\n BookItemResult to convert the search result data into a JSON string\nThe code that deals with JSON deserialization that Theo wrote previously in Search-\nQuery would have to be rewritten in BookItemQuery. Same thing for the code that\ndeals with JSON serialization he wrote previously in SearchResult; it would have to be\nrewritten in BookItemResult.\n--- Page 48 ---\n20 CHAPTER 1 Complexity of object-orientedprogramming\nThe bad news is that Theo would have to repeat the same process for every end-\npoint of the system. Each time he encounters a new kind of JSON input or output,\nhe would have to create a new class and write code. Theo’s dream is turning into a\nnightmare!\nSuddenly, his phone rings, next to where he was resting his head on the desk. As Theo\nwakes up, he realizes that Nancy never asked for JSON. It was all a dream...a really bad\ndream!\nTIP In OOP, data serialization is difficult.\nIt’s quite frustrating that handling JSON serialization and deserialization in OOP\nrequires the addition of so many classes and writing so much code—again and again!\nThe frustration grows when you consider that serializing a search query, a book item\nquery, or any query is quite similar. It comes down to\n Going over data fields.\n Concatenating the name of the data fields and the value of the data fields, sepa-\nrated by a comma.\nWhy is such a simple thing so hard to achieve in OOP? In OOP, data has to follow a\nrigid shape defined in classes, which means that data is locked in members. There is\nno simple way to access data generically.\nTIP In OOP, data is locked in classes as members.\nWe will refine later what we mean by generic access to the data, and we will see how\nDOP provides a generic way to handle JSON serialization and deserialization. Until\nthen, you will have to continue suffering. But at least you are starting to become aware\nof this suffering, and you know that it is avoidable.\n NOTE Most OOP programming languages alleviate a bit of the difficulty involved\nin the conversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n1.2.4 Complex class hierarchies\nOne way to avoid writing the same code twice in OOP involves class inheritance. Indeed,\nwhen every requirement of the system is known up front, you design your class hier-\narchy is such a way that classes with common behavior derive from a base class.\nFigure 1.15 shows an example of this pattern that focuses on the part of our class\ndiagram that deals with members and librarians. Both Librarians and Members need\nthe ability to log in, and they inherit this ability from the User class.\nSo far, so good, but when new requirements are introduced after the system is imple-\nmented, it’s a completely different story. Fast forward to Monday, March 29th, at 11:00 AM,\nwhere two days are left before the deadline (Wednesday at midnight).\n--- Page 49 ---\n1.2 Sources of complexity 21\nC Librarian\nblockMember(member: Member) : Bool\nunblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String Figure 1.15 The part of the\npassword : String class diagram that deals with\nlogin() : Bool members and librarians\nNancy calls Theo with an urgent request. Theo is not sure if it’s a dream or reality. He\npinches himself and he can feel the jolt. It’s definitely reality!\nNancy How is the project doing?\nTheo Fine, Nancy. We’re on schedule to meet the deadline. We’re running our last\nround of regression tests now.\nNancy Fantastic! It means we have time for adding a tiny feature to the system, right?\nTheo Depends what you mean by “tiny.”\nNancy We need to add VIP members to the system.\nTheo What do you mean by VIP members?\nNancy VIP members are allowed to add book items to the library by themselves.\nTheo Hmm...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nI’ll ask you the same question Nancy asked Theo: why is adding VIP members to our\nsystem not a tiny task? After all, Theo has already written the code that allows librari-\nans to add book items to the library (it’s in Librarian::addBookItem). What prevents\nhim from reusing this code for VIP members? The reason is that, in OOP, the code is\nlocked into classes as methods.\nTIP In OOP, code is locked into classes.\nVIP members are members that are allowed to add book items to the library by them-\nselves. Theo decomposes the customer requirements into two pieces:\n--- Page 50 ---\n22 CHAPTER 1 Complexity of object-orientedprogramming\n VIP members are library members.\n VIP members are allowed to add book items to the library by themselves.\nTheo then decides that he needs a new class, VIPMember. For the first requirement\n(VIP members are library members), it seems reasonable to make VIPMember derive\nfrom Member. However, handling the second requirement (VIP members are allowed\nto add book items) is more complex. He cannot make a VIPMember derive from\nLibrarian because the relation between VIPMember and Librarian is not linear:\n On one hand, VIP members are like librarians in that they are allowed to add\nbook items.\n On the other hand, VIP members are not like librarians in that they are not\nallowed to block members or list the books lent to a member.\nThe problem is that the code that adds book items is locked in the Librarian class.\nThere is no way for the VIPMember class to use this code.\nFigure 1.16 shows one possible solution that makes the code of Librarian::add-\nBookItem available to both Librarian and VIPMember classes. Here are the changes to\nthe previous class diagram:\n A base class UserWithBookItemRight extends User.\n addBookItem moves from Librarian to UserWithBookItemRight.\n Both VIPMember and Librarian extend UserWithBookItemRight.\nC Librarian\nblockMember(member: Member) : Bool C VIPMember\nunblockMember(member: Member) : Bool\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC Member\nCC UserWithBookItemRight\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool addBookItem(bookItem: BookItem) : BookItem\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.16 A class diagram for a system with VIP members\nIt wasn’t easy, but Theo manages to handle the change on time, thanks to an all nighter\ncoding on his laptop. He was even able to add new tests to the system and run the regres-\nsion tests again. However, he was so excited that he didn’t pay attention to the diamond\n--- Page 51 ---\n1.2 Sources of complexity 23\nproblem VIPMember introduced in his class diagram due to multiple inheritance: VIPMember\nextends both Member and UserWithBookItemRight, which both extend User.\nWednesday, March 31, at 10:00 AM (14 hours before the deadline), Theo calls Nancy to\ntell her the good news.\nTheo We were able to add VIP members to the system on time, Nancy.\nNancy Fantastic! I told you it was a tiny feature.\nTheo Yeah, well...\nNancy Look, I was going to call you anyway. I just finished a meeting with my business\npartner, and we realized that we need another tiny feature before the launch.\nWill you be able to handle it before the deadline?\nTheo Again, it depends what you mean by “tiny.”\nNancy We need to add Super members to the system.\nTheo What do you mean by Super members?\nNancy Super members are allowed to list the books lent to other members.\nTheo Err...\nNancy What?\nTheo That’s not a tiny change!\nNancy Why?\nAs with VIP members, adding Super members to the system requires changes to Theo’s\nclass hierarchy. Figure 1.17 shows the solution Theo has in mind.\nC Librarian\nC VIPMember C SuperMember\ngetBookLendingsOfMember(member: Member) : List<BookLending>\nCC UserWithBlockMemberRight\nCC UserWithBookItemRight\nblockMember(member: Member) : Bool\naddBookItem(bookItem: BookItem) : BookItem\nunblockMember(member: Member) : Bool\nCC Member\nisBlocked() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String\nlogin() : Bool\nFigure 1.17 A class diagram for a system with Super and VIP members\nThe addition of Super members has made the system really complex. Theo suddenly\nnotices that he has three diamonds in his class diagram—not gemstones but three “Deadly\n--- Page 52 ---\n24 CHAPTER 1 Complexity of object-orientedprogramming\nDiamonds of Death” as OOP developers sometimes name the ambiguity that arises when a\nclass D inherits from two classes B and C, where both inherit from class A!\nHe tries to avoid the diamonds by transforming the User class into an interface and\nusing the composition over inheritance design pattern. But with the stress of the deadline\nlooming, he isn’t able to use all of his brain cells. In fact, the system has become so com-\nplex, he’s unable to deliver the system by the deadline. Theo tells himself that he should\nhave used composition instead of class inheritance. But, it’s too late now.\nTIP In OOP, prefer composition over class inheritance.\nAt 10:00 PM, two hours before the deadline, Theo calls Nancy to explain the situation.\nTheo Look Nancy, we really did our best, but we won’t be able to add Super mem-\nbers to the system before the deadline.\nNancy No worries, my business partner and I decided to omit this feature for now.\nWe’ll add it later.\nWith mixed feelings of anger and relief, Theo stops pacing around his office. He realizes\nhe will be spending tonight in his own bed, rather than plowing away on his computer at\nthe office. That should make his wife happy.\nTheo I guess that means we’re ready for the launch tomorrow morning.\nNancy Yes. We’ll offer this new product for a month or so, and if we get good market\ntraction, we’ll move forward with a bigger project.\nTheo Cool. Let’s be in touch in a month then. Good luck on the launch!\nSummary\n Complexity in the context of this book means hard to understand.\n We use the terms code and behavior interchangeably.\n DOP stands for data-oriented programming.\n OOP stands for object-oriented programming.\n FP stands for functional programming.\n In a composition relation, when one object dies, the other one also dies.\n A composition relation is represented by a plain diamond at one edge and an\noptional star at the other edge.\n In an association relation, each object has an independent life cycle.\n A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\n Dashed arrows indicate a usage relation; for instance, when a class uses a method\nof another class.\n Plain arrows with empty triangles represent class inheritance, where the arrow\npoints towards the superclass.\n The design presented in this chapter doesn’t pretend to be the smartest OOP\ndesign. Experienced OOP developers would probably use a couple of design\npatterns and suggest a much better diagram.\n--- Page 53 ---\nSummary 25\n Traditional OOP systems tend to increase system complexity, in the sense that\nOOP systems are hard to understand.\n In traditional OOP, code and data are mixed together in classes: data as mem-\nbers and code as methods.\n In traditional OOP, data is mutable.\n The root cause of the increase in complexity is related to the mixing of code\nand data together into objects.\n When code and data are mixed, classes tend to be involved in many relations.\n When objects are mutable, extra thinking is required in order to understand\nhow the code behaves.\n When objects are mutable, explicit synchronization mechanisms are required\non multi-threaded environments.\n When data is locked in objects, data serialization is not trivial.\n When code is locked in classes, class hierarchies tend to be complex.\n A system where every class is split into two independent parts, code and data, is\nsimpler than a system where code and data are mixed.\n A system made of multiple simple independent parts is less complex than a sys-\ntem made of a single complex part.\n When data is mutable, code is unpredictable.\n A strategic use of design patterns can help mitigate complexity in traditional\nOOP to some degree.\n Data immutability brings serenity to DOP developers’ minds.\n Most OOP programming languages alleviate slightly the difficulty involved the\nconversion from and to JSON. It either involves reflection, which is definitely a\ncomplex thing, or code verbosity.\n In traditional OOP, data serialization is difficult.\n In traditional OOP, data is locked in classes as members.\n In traditional OOP, code is locked into classes.\n DOP reduces complexity by rethinking data.\n DOP is compatible both with OOP and FP.\n--- Page 54 ---\nSeparation between\ncode and data\nA whole new world\nThis chapter covers\n The benefits of separating code from data\n Designing a system where code and data are\nseparate\n Implementing a system that respects the\nseparation between code and data\nThe first insight of DOP is that we can decrease the complexity of our systems by\nseparating code from data. Indeed, when code is separated from data, our systems\nare made of two main pieces that can be thought about separately: data entities and\ncode modules. This chapter is a deep dive in the first principle of DOP (summa-\nrized in figure 2.1).\nPRINCIPLE #1 Separate code from data such that the code resides in functions,\nwhose behavior doesn’t depend on data that is somehow encapsulated in the func-\ntion’s context.\n26\n--- Page 55 ---\n2.1 The two parts of a DOP system 27\nStateless (static)\nFunctions\nData asfirst argument\nCode modules\nUsage\nRelations\nNo inheritance\nSeparate code from data\nOnly members\nData entities No code\nAssociation\nRelations\nComposition\nFigure 2.1 DOP principle #1 summarized: Separate code from data.\nIn this chapter, we’ll illustrate the separation between code and data in the context of\nKlafim’s Library Management System that we introduced in chapter 1. We’ll also unveil\nthe benefits that this separation brings to the system:\n The system is simple. It is easy to understand.\n The system is flexible and extensible. Quite often, it requires no design changes to\nadapt to changing requirements.\nThis chapter focuses on the design of the code in a system where code and data are\nseparate. In the next chapter, we’ll focus on the design of the data. As we progress in\nthe book, we’ll discover other benefits of separating code from data.\n2.1 The two parts of a DOP system\nWhile Theo is driving home after delivering the prototype, he asks himself whether the\nKlafim project was a success or not. Sure, he was able to satisfy the customer, but it was\nmore luck than brains. He wouldn’t have made it on time if Nancy had decided to keep\nthe Super members feature. Why was it so complicated to add tiny features to the system?\nWhy was the system he built so complex? He thought there should be a way to build more\nflexible systems!\nThe next morning, Theo asks on Hacker News and on Reddit for ways to reduce system\ncomplexity and build flexible systems. Some folks mention using different programming\nlanguages, while others talk about advanced design patterns. Finally, Theo’s attention gets\ncaptured by a comment from a user named Joe. He mentions data-oriented programming and\nclaims that its main goal is to reduce system complexity. Theo has never heard this term\nbefore. Out of curiosity, he decides to contact Joe by email. What a coincidence! Joe lives\nin San Francisco too. Theo invites him to a meeting in his office.\nJoe is a 40-year-old developer. He was a Java developer for nearly a decade before adopt-\ning Clojure around 7 years ago. When Theo tells Joe about the Library Management System",
        "sections_found": []
      },
      "accurate_page_range": "32-55"
    },
    {
      "text": "- 10.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "10 Database operations",
      "raw_line": "- 10.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 82,
      "chapter_info": {
        "page": 262,
        "title": "Database operations",
        "pattern_matched": "Chapter 10",
        "text_preview": "234 CHAPTER 11 Web services\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physic"
      },
      "chapter_sections": {
        "start_page": 262,
        "end_page": 292,
        "content": "\n--- Page 262 ---\n234 CHAPTER 11 Web services\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nTheo Yes! I think we now have all the pieces to enrich our search results.\n11.6 Search result enrichment in action\nJoe Can you write the steps of the enrichment data flow?\nTheo Sure.\nTheo goes to the whiteboard. He takes a moment to gather his thoughts, and then erases\nenough space so there’s room to list the steps.\nThe steps for the search result enrichment data flow\n1 Receive a request from a client.\n2 Extract from the client’s request the query and the fields to fetch from Open\nLibrary.\n3 Retrieve from the database the books that match the query.\n4 Fetch information from Open Library for each ISBN that match the query.\n5 Extract from Open Library responses for the required fields.\n6 Combine book information from the database with information from Open\nLibrary.\n7 Send the response to the client.\nJoe Perfect! Would you like to try to implement it?\nTheo I think I’ll start with the implementation of the book retrieval from the data-\nbase. It’s quite similar to what we did last month.\n NOTE See chapter 10 for last month’s lesson.\nJoe Actually, it’s even simpler because you don’t need to join tables.\nTheo That’s right, I need values only for the isbn and available columns.\nTheo works for a bit in his IDE. He begins with the book retrieval from the database.\nListing11.14 Retrieving books whose title matches a query\nvar dbSearchResultSchema = {\n\"type\": \"array\",\n\"items\": {\n--- Page 263 ---\n11.6 Search result enrichment in action 235\n\"type\": \"object\",\n\"required\": [\"isbn\", \"available\"],\n\"properties\": {\n\"isbn\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"}\n}\n}\n};\nclass CatalogDB {\nstatic matchingBooks(title) {\nvar matchingBooksQuery = `\nSELECT isbn, available\nFROM books\nWHERE title = like '%$1%';\n`;\nvar books = dbClient.query(catalogDB, matchingBooksQuery, [title]);\nif(!ajv.validate(dbSearchResultSchema, books)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from the database: \" +\nerrors;\n}\nreturn books;\n}\n}\nJoe So far, so good...\nTheo Next, I’ll go with the implementation of the retrieval of book information from\nOpen Library for several books. Unfortunately, the Open Library Books API\ndoesn’t support querying several books at once. I’ll need to send one request\nper book.\nJoe That’s a bit annoying. Let’s make our life easier and pretend that _.map works\nwith asynchronous functions. In real life, you’d need something like Promise\n.all in order to send the requests in parallel and combine the responses.\nTheo OK, then it’s quite straightforward. I’ll take the book retrieval code and add a\nmultipleBookInfo function that maps over bookInfo.\nTheo looks over the book retrieval code in listing 11.9 and then concentrates as he types\ninto his IDE. When he’s done, he shows the result in listing 11.15 to Joe.\nListing11.15 Retrieving book information from Open Library for several books\nclass OpenLibraryDataSource {\nstatic rawBookInfo(isbn) {\nvar url = `https:/ /openlibrary.org/isbn/${isbn}.json`;\nvar jsonString = fetchResponseBody(url);\nreturn JSON.parse(jsonString);\n}\nstatic bookInfo(isbn, requestedFields) {\nvar relevantFields = [\"title\", \"full_title\",\n\"subtitle\", \"publisher\",\n\"publish_date\", \"weight\",\n--- Page 264 ---\n236 CHAPTER 11 Web services\n\"physical_dimensions\", \"genre\",\n\"subjects\", \"number_of_pages\"];\nvar rawInfo = rawBookInfo(isbn);\nif(!ajv.validate(dbSearchResultSchema, bookInfoSchema)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from Open Books API: \" +\nerrors;\n}\nvar relevantInfo =\n_.pick(_.pick(rawInfo, relevantFields), requestedFields);\nreturn _.set(relevantInfo, \"isbn\", isbn);\n}\nstatic multipleBookInfo(isbns, fields) {\nreturn _.map(function(isbn) {\nreturn bookInfo(isbn, fields);\n}, isbns);\n}\n}\nJoe Nice! Now comes the fun part: combining information from several data sources.\nTheo Yeah. I have two arrays in my hands: one with book information from the data-\nbase and one with book information from Open Library. I somehow need to\njoin the arrays, but I’m not sure I can assume that the positions of the book\ninformation are the same in both arrays.\nJoe What would you like to have in your hands?\nTheo I wish I had two hash maps.\nJoe And what would the keys in the hash maps be?\nTheo Book ISBNs.\nJoe Well, I have good news for you: your wish is granted!\nTheo How?\nJoe Lodash provides a function named _.keyBy that transforms an array into a map.\nTheo I can’t believe it. Can you show me an example?\nJoe Sure. Let’s call _.keyBy on an array with two books.\nListing11.16 Transforming an array into a map with _.keyBy\nvar books = [\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"isbn\": \"978-1982137274\",\n\"available\": true\n},\n{\n\"title\": \"The Power of Habit\",\n\"isbn\": \"978-0812981605\",\n\"available\": false\n}\n];\n_.keyBy(books, \"isbn\");\n--- Page 265 ---\n11.6 Search result enrichment in action 237\nJoe And here’s the result.\nListing11.17 The result of keyBy\n{\n\"978-0812981605\": {\n\"available\": false,\n\"isbn\": \"978-0812981605\",\n\"title\": \"The Power of Habit\"\n},\n\"978-1982137274\": {\n\"available\": true,\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\"\n}\n}\nTheo keyBy is awesome!\nJoe Don’t exaggerate, my friend; _.keyBy is quite similar to _.groupBy. The\nonly difference is that _.keyBy assumes that there’s only one element in\neach group.\nTheo I think that, with _.keyBy, I’ll be able to write a generic joinArrays function.\nJoe I’m glad to see you thinking in terms of implementing business logic through\ngeneric data manipulation functions.\nTIP Many parts of the business logic can be implemented through generic data\nmanipulation functions.\nTheo The joinArrays function needs to receive the arrays and the field name for\nwhich we decide the two elements that need to be combined, for instance,\nisbn.\nJoe Remember, in general, it’s not necessarily the same field name for both arrays.\nTheo Right, so joinArrays needs to receive four arguments: two arrays and two\nfield names.\nJoe Go for it! And, please, write a unit test for joinArrays.\nTheo Of course...\nTheo works for a while and produces the code in listing 11.18. He then types the unit test\nin listing 11.19.\nListing11.18 A generic function for joining arrays\nfunction joinArrays(a, b, keyA, keyB) {\nvar mapA = _.keyBy(a, keyA);\nvar mapB = _.keyBy(b, keyB);\nvar mapsMerged = _.merge(mapA, mapB);\nreturn _.values(mapsMerged);\n}\n--- Page 266 ---\n238 CHAPTER 11 Web services\nListing11.19 A unit test for joinArrays\nvar dbBookInfos = [\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true\n},\n{\n\"isbn\": \"978-0812981605\",\n\"title\": \"The Power of Habit\",\n\"available\": false\n}\n];\nvar openLibBookInfos = [\n{\n\"isbn\": \"978-0812981605\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432,\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"The Power of Habit\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n],\n}\n];\nvar joinedArrays = [\n{\n\"available\": true,\n\"isbn\": \"978-1982137274\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\",\n],\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"title\": \"The Power of Habit\",\n},\n{\n\"available\": false,\n\"isbn\": \"978-0812981605\",\n\"number_of_pages\": 432,\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"title\": \"7 Habits of Highly Effective People\",\n},\n]\n--- Page 267 ---\n11.6 Search result enrichment in action 239\n_.isEqual(joinedArrays,\njoinArrays(dbBookInfos, openLibBookInfos, \"isbn\", \"isbn\"));\nJoe Excellent! Now, you are ready to adjust the last piece of the extended search\nresult endpoint.\nTheo That’s quite easy. We fetch data from the database and from Open Library and\njoin them.\nTheo works quite rapidly. He then shows Joe the code.\nListing11.20 Search books and enriched book information\nclass Catalog {\nstatic enrichedSearchBooksByTitle(searchPayload) {\nif(!ajv.validate(searchBooksRequestSchema, searchPayload)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid request:\" + errors;\n}\nvar title = _.get(searchPayload, \"title\");\nvar fields = _.get(searchPayload, \"fields\");\nvar dbBookInfos = CatalogDataSource.matchingBooks(title);\nvar isbns = _.map(dbBookInfos, \"isbn\");\nvar openLibBookInfos =\nOpenLibraryDataSource.multipleBookInfo(isbns, fields);\nvar res = joinArrays(dbBookInfos, openLibBookInfos);\nif(!ajv.validate(searchBooksResponseSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid response:\" + errors;\n}\nreturn res;\n}\n}\nNow comes the tricky part. Theo takes a few moments to meditate about the simplicity of\nthe code that implements the extended search endpoint. He thinks about how classes are\nmuch less complex when we use them only to aggregate stateless functions that operate on\nsimilar domain entities and then goes to work plotting the code.\nListing11.21 Schema for the extended search endpoint (Open Books API part)\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n--- Page 268 ---\n240 CHAPTER 11 Web services\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing11.22 Extended search endpoint (Open Books API part)\nvar ajv = new Ajv({allErrors: true});\nclass OpenLibraryDataSource {\nstatic rawBookInfo(isbn) {\nvar url = `https:/ /openlibrary.org/isbn/${isbn}.json`;\nvar jsonString = fetchResponseBody(url);\nreturn JSON.parse(jsonString);\n}\nstatic bookInfo(isbn, requestedFields) {\nvar relevantFields = [\"title\", \"full_title\",\n\"subtitle\", \"publisher\",\n\"publish_date\", \"weight\",\n--- Page 269 ---\n11.6 Search result enrichment in action 241\n\"physical_dimensions\", \"genre\",\n\"subjects\", \"number_of_pages\"];\nvar rawInfo = rawBookInfo(isbn);\nif(!ajv.validate(bookInfoSchema, rawInfo)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from Open Books API: \" +\nerrors;\n}\nvar relevantInfo = _.pick(\n_.pick(rawInfo, relevantFields),\nrequestedFields);\nreturn _.set(relevantInfo, \"isbn\", isbn);\n}\nstatic multipleBookInfo(isbns, fields) {\nreturn _.map(function(isbn) {\nreturn bookInfo(isbn, fields);\n}, isbns);\n}\n}\nListing11.23 Extended search endpoint (database part)\nvar dbClient;\nvar dbSearchResultSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"isbn\", \"available\"],\n\"properties\": {\n\"isbn\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"}\n}\n}\n};\nclass CatalogDB {\nstatic matchingBooks(title) {\nvar matchingBooksQuery = `\nSELECT isbn, available\nFROM books\nWHERE title = like '%$1%';\n`;\nvar books = dbClient.query(catalogDB, matchingBooksQuery, [title]);\nif(!ajv.validate(dbSearchResultSchema, books)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from the database: \"\n+ errors;\n}\nreturn books;\n}\n}\n--- Page 270 ---\n242 CHAPTER 11 Web services\nListing11.24 Schema for the implementation of the extended search endpoint\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"type\": [\n\"title\",\n\"full_title\",\n\"subtitle\",\n\"publisher\",\n\"publish_date\",\n\"weight\",\n\"physical_dimensions\",\n\"number_of_pages\",\n\"subjects\",\n\"publishers\",\n\"genre\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksResponseSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nListing11.25 Schema for the extended search endpoint (combines the pieces)\nclass Catalog {\nstatic enrichedSearchBooksByTitle(request) {\n--- Page 271 ---\n11.6 Search result enrichment in action 243\nif(!ajv.validate(searchBooksRequestSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid request:\" + errors;\n}\nvar title = _.get(request, \"title\");\nvar fields = _.get(request, \"fields\");\nvar dbBookInfos = CatalogDataSource.matchingBooks(title);\nvar isbns = _.map(dbBookInfos, \"isbn\");\nvar openLibBookInfos =\nOpenLibraryDataSource.multipleBookInfo(isbns, fields);\nvar response = joinArrays(dbBookInfos, openLibBookInfos);\nif(!ajv.validate(searchBooksResponseSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid response:\" + errors;\n}\nreturn response;\n}\n}\nclass Library {\nstatic searchBooksByTitle(payloadBody) {\nvar payloadData = JSON.parse(payloadBody);\nvar results = Catalog.searchBooksByTitle(payloadData);\nreturn JSON.stringify(results);\n}\n}\nTIP Classes are much less complex when we use them as a means to aggregate state-\nless functions that operate on similar domain entities.\nJoe interrupts Theo’s meditation moment. After looking over the code in the previous list-\nings, he congratulates Theo.\nJoe Excellent job, my friend! By the way, after reading The Power of Habit, I quit\nchewing my nails.\nTheo Wow! That’s terrific! Maybe I should read that book to overcome my habit of\ndrinking too much coffee.\nJoe Thanks, and good luck with the coffee habit.\nTheo I was supposed to call Nancy later today with an ETA for the Open Library\nBook milestone. I wonder what her reaction will be when I tell her the feature\nis ready.\nJoe Maybe you should tell her it’ll be ready in a week, which would give you time to\nbegin work on the next milestone.\n--- Page 272 ---\n244 CHAPTER 11 Web services\nDelivering on time\nJoe was right! Theo recalls Joe’s story about the young woodcutter and the old man. Theo\nwas able to learn DOP and deliver the project on time! He’s pleased that he took the time\n“to sharpen his saw and commit to a deeper level of practice.”\n NOTE If you are unable to recall the story or if you missed it, check out the opener\nto part 2.\nThe Klafim project is a success. Nancy is pleased. Theo’s boss is satisfied. Theo got pro-\nmoted. What more can a person ask for?\nTheo remembers his deal with Joe. As he strolls through the stores of the Westfield San\nFrancisco Center to look for a gift for each of Joe’s children, Neriah and Aurelia, he is\nfilled with a sense of purpose and great pleasure. He buys a DJI Mavic Air 2 drone for Ner-\niah, and the latest Apple Airpod Pros for Aurelia. He also takes this opportunity to buy a\nnecklace and a pair of earrings for his wife, Jane. It’s a way for him to thank her for having\nendured his long days at work since the beginning of the Klafim project.\n NOTE The story continues in the opener of part 3.\nSummary\n We build the insides of our systems like we build the outsides.\n Components inside a program communicate via data that is represented as\nimmutable data collections in the same way as components communicate via\ndata over the wire.\n In DOP, the inner components of a program are loosely coupled.\n Many parts of business logic can be implemented through generic data manipu-\nlation functions. We use generic functions to\n– Implement each step of the data flow inside a web service.\n– Parse a request from a client.\n– Apply business logic to the request.\n– Fetch data from external sources (e.g., database and other web services).\n– Apply business logic to the responses from external sources.\n– Serialize response to the client.\n Classes are much less complex when we use them as a means to aggregate\ntogether stateless functions that operate on similar domain entities.\nLodash functions introduced in this chapter\nFunction Description\nkeyBy(coll, f) Creates a map composed of keys generated from the results of running each ele-\nment of coll through f; the corresponding value for each key is the last element\nresponsible for generating the key.\n--- Page 273 ---\nPart 3\nMaintainability\nA\nfter a month, the Klafim project enters what Alabatross calls the mainte-\nnance phase. Small new features need to be added on a weekly basis. Bugs need to be\nfixed; nothing dramatic....\nMonica, Theo’s boss, decides to allocate Dave to the maintenance of the Klafim\nproject. It makes sense. Over the last few months, Dave has demonstrated a great atti-\ntude of curiosity and interest, and he has solid programming skills. Theo sets up a\nmeeting with Joe and Dave, hoping that Joe will be willing to teach DOP to Dave so\nthat he can continue to advance the good work he’s already done on Klafim. Theo\nand Dave place a conference call to Joe.\nTheo Hi, Joe. Will you have time over the next few weeks to teach Dave the\nprinciples of DOP?\nJoe Yes, but I prefer not to.\nDave Why? Is it because I don’t have enough experience in software develop-\nment? I can guarantee you that I’m a fast learner.\nJoe It has nothing to do with your experience, Dave.\nTheo Why not then?\nJoe Theo, I think that you could be a great mentor for Dave.\nTheo But, I don’t even know all the parts of DOP!\nDave Come on! No false modesty between us, my friend.\nJoe Knowledge is never complete. As the great Socrates used to say, “The more\nI know, the more I realize I know nothing.” I’m confident you will be able\nto learn the missing parts by yourself and maybe even invent some.\nTheo How will I be able to invent missing parts?\n--- Page 274 ---\n246 PART 3 Maintainability\nJoe You see, DOP is such a simple paradigm that it’s fertile material for innovation.\nPart of the material I taught you I learned from others, and part of it was an\ninvention of mine. If you keep practicing DOP, I’m quite sure you, too, will\ncome up with some inventions of your own.\nTheo What do you say Dave? Are you willing to learn DOP from me?\nDave Definitely!\nTheo Joe, will you be continue to be available if we need your help from time to time?\nJoe Of course!\n--- Page 275 ---\nAdvanced data\nvalidation\nA self-made gift\nThis chapter covers\n Validating function arguments\n Validating function return values\n Data validation beyond static types\n Automatic generation of data model diagrams\n Automatic generation of schema-based unit tests\nAs the size of a code base grows in a project that follows DOP principles, it becomes\nharder to manipulate functions that receive and return only generic data. It is hard\nto figure out the expected shape of the function arguments, and when we pass\ninvalid data, we don’t get meaningful errors.\nUntil now, we have illustrated how to validate data at system boundaries. In this\nchapter, we will illustrate how to validate data when it flows inside the system by\ndefining data schemas for function arguments and their return values. This allows\nus to make explicit the expected shape of function arguments, and it eases develop-\nment. We gain some additional benefits from this endeavor, such as automatic gen-\neration of data model diagrams and schema-based unit tests.\n247\n--- Page 276 ---\n248 CHAPTER 12 Advanced data validation\n12.1 Function arguments validation\nDave’s first task is to implement a couple of new HTTP endpoints to download the catalog\nas a CSV file, search books by author, and rate the books. Once he is done with the tasks,\nDave calls Theo for a code review.\n NOTE The involvement of Dave in the Klafim project is explained in the opener for\npart 3. Please take a moment to read the opener if you missed it.\nTheo Was it difficult to get your head around the DOP code?\nDave Not so much. I read your notes of the meetings with Joe, and I must admit, the\ncode is quite simple to grasp.\nTheo Cool!\nDave But there is something that I can’t get used to.\nTheo What’s that?\nDave I’m struggling with the fact that all the functions receive and return generic\ndata. In OOP, I know the expected shape of the arguments for each and every\nfunction.\nTheo Did you validate data at system boundaries, like I have done?\nDave Absolutely. I defined a data schema for every additional user request, database\nquery, and external service response.\nTheo Nice!\nDave Indeed, when the system runs in production, it works well. When data is valid,\nthe data flows through the system, and when data is invalid, we are able to dis-\nplay a meaningful error message to the user.\nTheo What’s the problem then?\nDave The problem is that during development, it’s hard to figure out the expected\nshape of the function arguments. And when I pass invalid data by mistake, I\ndon’t get clear error messages.\nTheo I see. I remember that when Joe showed me how to validate data at system\nboundaries, I raised this concern about the development phase. Joe told me\nthen that we validate data as it flows inside the system exactly like we validate data\nat system boundaries: we separate between data schema and data representation.\nDave Are we going to use JSON Schema also?\nTheo Yes.\nDave Cool.... I like JSON Schema.\nTheo The main purpose of data validation at system boundaries is to prevent invalid\ndata from getting into the system, whereas the main purpose of data validation\ninside the system is to make it easier to develop the system. Here, let me draw a\ntable on the whiteboard for you to visualize this (table 12.1).\nTable 12.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\n--- Page 277 ---\n12.1 Function arguments validation 249\nDave By making it easier to develop the system, do you mean to help the developers\nunderstand the expected shape of function arguments as in OOP?\nTheo Exactly.\nDave But I’m impatient.... Will you help me figure out how to validate the argu-\nments of the function that implements a book search?\nTheo Let me see the code of the implementation, and I’ll do my best.\nDave We have two implementations of a book search: one where library data lives\nin memory from the prototype phase and one where library data lives in the\ndatabase.\nTheo I think that the schema for library data in memory is going to be more interest-\ning than the schema for library data in the database, as the book search func-\ntion receives catalog data in addition to the query.\nDave When you say more interesting data schema, you mean more difficult to write?\nTheo More difficult to write, but it’s also more insightful.\nDave Then let’s go with library data in memory. The code for Catalog.search-\nBooksByTitle from the prototype phase would look like this.\nDave pulls up some code on his laptop. He shows it to Theo.\nListing12.1 The implementation of search without data validation\nclass Catalog {\nstatic authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nreturn bookInfo;\n}\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\n--- Page 278 ---\n250 CHAPTER 12 Advanced data validation\nTheo Dave, please remind me of the expected shapes for catalogData and query.\nDave Sure. query should be a string, and catalogData should be a map that con-\nforms to the catalog data model.\nTheo What is the catalog data model?\nDave Let me see. I have seen a diagram of it somewhere.\nDave rummages around a bit in his folder for Klafim’s Library Management System. Find-\ning what he’s looking for, he draws the diagram in figure 12.1 on the whiteboard.\nC Catalog\nbooksByIsbn: {Book}\nauthorsById: {Author}\nC Book\nC Author\ntitle : String\npublicationYear: Number id: String\nisbn: String name: String\nauthorlds: [String] booklsbns: [String]\nbookltems: [Bookltem]\nC Bookltem\nid: String\nlibld: String\npurchaseDate: String\nisLent: Boolean\nFigure 12.1 The catalog data model\n NOTE The schemas for this book use JSON Schema version 2020-12.\nTheo Can you write a JSON Schema for the catalog data model?\nDave Am I allowed to use internal variables for book and author schemas, or do I\nhave to nest all the schemas inside the catalog schema?\nTheo JSON Schema is part of the code. If you feel that using internal variables would\nmake the code more readable, go for it.\nDave OK. Now I need the JSON Schema gift that Joe gave you.\nTheo picks up a well-worn piece of paper that is a bit torn and quite wrinkled. He gives\nDave the JSON Schema cheat sheet.\nListing12.2 JSON Schema cheat sheet\nAt the root level,\n{\ndata is an array.\n\"type\": \"array\",\n\"items\": { Each element of the array is a map.\n\"type\": \"object\",\nThe properties of each field in the map\n\"properties\": {\n--- Page 279 ---\n12.1 Function arguments validation 251\n\"myNumber\": {\"type\": \"number\"},\nmyNumber\n\"myString\": {\"type\": \"string\"}, myEnum is an enumeration\nis a number.\n\"myEnum\": {\"enum\": [\"myVal\", \"yourVal\"]}, value with two possibilities,\nmyString is \"myBool\": {\"type\": \"boolean\"} \"myVal\" and \"yourVal\".\na string. },\n\"required\": [\"myNumber\", \"myString\"], myBool is a boolean.\n\"additionalProperties\": false\n} The mandatory fields in the map\n} We don’t allow fields that are not are myNumber and myString.\nexplicitly mentioned in the schema. Other fields are optional.\nDave I think I’ll start with the author schema. It seems simpler than the book schema.\nQuickly composing the code, Dave shows Theo the author schema. Dave, still new to DOP,\nlooks for Theo’s reaction.\nListing12.3 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"id\", \"name\", \"bookIsbns\"],\n\"properties\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nTheo Well done! Let’s move on to the book schema now.\nDave I think I am going to store the book item schema in a variable.\nListing12.4 The book item schema\nvar bookItemSchema = {\n\"type\": \"object\",\n\"properties\":{\n\"id\": {\"type\": \"string\"},\n\"libId\": {\"type\": \"string\"},\n\"purchaseDate\": {\"type\": \"string\"},\n\"isLent\": {\"type\": \"boolean\"}\n},\n\"required\": [\"id\", \"libId\", \"purchaseDate\", \"isLent\"]\n};\nvar bookSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorIds\", \"bookItems\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publicationYear\": {\"type\": \"integer\"},\n--- Page 280 ---\n252 CHAPTER 12 Advanced data validation\n\"isbn\": {\"type\": \"string\"},\n\"authorIds\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"bookItems\": {\n\"type\": \"array\",\n\"items\": bookItemSchema\n}\n}\n};\nTIP When you define a complex data schema, it is advisable to store nested schemas\nin variables to make the schemas easier to read.\nTheo Why didn’t you include publicationYear in the list of required fields in the\nbook schema?\nDave Because, for some books, the publication year is missing. Unlike in OOP, it will\nthen be easy to deal with nullable fields.\nTheo Excellent! And now, please tackle the final piece, the catalog schema.\nDave Here I have a problem. The catalog should be a map with two fields, books-\nByIsbn and authorsById. Both values should be indexes, represented in the\nmodel diagram with curly braces. I have no idea how to define the schema for\nan index.\nTheo Do you remember how we represent indexes in DOP?\nDave Yes, indexes are represented as maps.\nTheo Right, and what’s the difference between those maps and the maps that we use\nfor records?\nDave For records, we use maps where the names of the fields are known and the val-\nues can have different shapes. For indexes, we use maps where the names of\nthe fields are unknown and the values have a common shape.\nTheo Right. We call the maps for records heterogeneous maps and the maps for\nindexes homogeneous maps.\nTIP In DOP, records are represented as heterogeneous maps, whereas indexes are repre-\nsented as homogeneous maps.\nDave Then how do we define the schema of an homogeneous map in JSON Schema?\nTheo I don’t know. Let’s check the JSON Schema online documentation.\n NOTE See https://json-schema.org/ to access the online documentation for JSON\nSchema version 2020-12.\nAfter a couple of minutes of digging into the JSON Schema online documentation, Theo\nfinds a piece about additionalProperties. He studies the information for a while before\nmaking up his mind.\n--- Page 281 ---\n12.1 Function arguments validation 253\nTheo I think we could use additionalProperties. Here’s the JSON Schema for an\nhomogeneous map where the values are numbers.\nListing12.5 The JSON Schema for an homogeneous map with values as numbers\n{\n\"type\": \"object\",\n\"additionalProperties\": {\"type\": \"number\"}\n}\nDave I thought that additionalProperties was supposed to be a boolean and that\nit was used to allow or forbid properties not mentioned in the schema.\nTheo That’s correct. Usually additionalProperties is a boolean, but the documen-\ntation says it could also be a map that defines a schema. In that case, it means\nproperties not mentioned in the schema should have the value of the schema\nassociated with additionalProperties.\nDave I see. But what does that have to do with homogeneous maps?\nTheo Well, a homogeneous map could be seen as a map with no predefined proper-\nties, where all the additional properties are of an expected type.\nDave Tricky!\nTIP In JSON Schema, homogeneous string maps have type: object with no\nproperties and additionalProperties associated to a schema.\nTheo Indeed. Now, let me show you what the catalog schema looks like.\nTheo types briefly on his laptop. He shows Dave the catalog schema.\nListing12.6 The schema for catalog data\nvar catalogSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"booksByIsbn\": {\n\"type\": \"object\",\n\"additionalProperties\": bookSchema\n},\n\"authorsById\": {\n\"type\": \"object\",\n\"additionalProperties\": authorSchema\n}\n},\n\"required\": [\"booksByIsbn\", \"authorsById\"]\n};\nDave Are we ready to plug the catalog and the query schema into the Catalog\n.searchBooksByTitle implementation?\nTheo We could, but I think we can do better by defining a single schema that com-\nbines both the catalog and query schemas.\nDave How would we combine two schemas into a single schema?\n--- Page 282 ---\n254 CHAPTER 12 Advanced data validation\nTheo Do you know what a tuple is?\nDave I think I know, but I can’t define it formally.\nTheo A tuple is an array where the size is fixed, and the elements can be of different\nshapes.\nDave OK. So, how do we define tuples in JSON Schema?\nOnce again, Theo explores the JSON Schema online documentation. Fortunately, he has\nbookmarked the page, and in no time at all, finds the information he needs.\nTheo I found it! We use prefixItems in the definition of a tuple made of a string\nand a number, for instance.\nTheo types more code on his laptop. When he finishes, he shows Dave the schema for a\ntuple.\nListing12.7 The schema for a tuple made of a string and a number\n{\n\"type\": \"array\",\n\"prefixItems\": [\n{ \"type\": \"string\" },\n{ \"type\": \"number\" }\n]\n}\nDave I see. And how would you define the schema for the arguments of Catalog\n.searchBooksByTitle?\nTheo Well, it’s a tuple of size 2, where the first element is a catalog and the second\nelement is a string.\nDave Something like this schema?\nListing12.8 The schema for the arguments of Catalog.searchBooksByTitle\nvar searchBooksArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\ncatalogSchema,\n{ \"type\": \"string\" },\n]\n};\nTheo Exactly!\nDave Now that we have the schema for the arguments, how do we plug it into the\nimplementation of search books?\nTheo That’s similar to the way we validate data at system boundaries. The main dif-\nference is that the data validation for data that flows inside the system should\nrun only at development time, and it should be disabled when the code runs in\nproduction.\nDave Why?\n--- Page 283 ---\n12.2 Return value validation 255\nTheo Because that data has been already validated up front at a system boundary.\nValidating it again on a function call is superfluous, and it would impact\nperformance.\nDave When you say development time, does that include testing and staging\nenvironments?\nTheo Yes, all the environments besides production.\nDave I see. It’s like assertions in Java. They are disabled in production code.\nTIP Data validation inside the system should be disabled in production.\nTheo Exactly. For now, I am going to assume that we have a dev function that returns\ntrue when the code runs in the development environment and false when it\nruns in production. Having said that, take a look at this code.\nListing12.9 Implementation of search with validation of function arguments\nCatalog.searchBooksByTitle = function(catalogData, query) {\nif(dev()) {\nvar args = [catalogData, query];\nif(!ajv.validate(searchBooksArgsSchema, args)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle called with invalid arguments: \" +\nerrors);\nThe implementation of dev() depends on the run-time\n}\nenvironment: it returns true when the code runs in dev\n}\nenvironments and false when it runs in production.\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nDave Do you think we should validate the arguments of all the functions?\nTheo No. I think we should treat data validation like we treat unit tests. We should\nvalidate function arguments only for functions for whom we would write unit\ntests.\nTIP Treat data validation like unit tests.\n12.2 Return value validation\nDave Do you think it would make sense to also validate the return value of functions?\nTheo Absolutely.\nDave Cool. Let me try to write the JSON Schema for the return value of Catalog\n.searchBooksByTitle.\n--- Page 284 ---\n256 CHAPTER 12 Advanced data validation\nAfter a few minutes, Dave comes up with the schema. Taking a deep breath, then releasing\nit, he shows the code to Theo.\nListing12.10 The schema for the return value of Catalog.searchBooksByTitle\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorNames\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"isbn\": {\"type\": \"string\"},\n\"authorNames\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n};\nTheo Well done! Now, would you like to try adding return value validation to the\ncode of Catalog.searchBooksByTitle?\nDave Sure.\nDave works for a bit in his IDE. A bit more confident this time, he shows the result to Theo.\nListing12.11 Search with data validation for both input and output\nCatalog.searchBooksByTitle = function(catalogData, query) {\nif(dev()) {\nif(!ajv.validate(searchBooksArgsSchema, [catalogData, query])) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle called with invalid arguments: \" +\nerrors);\n}\n}\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nif(dev()) {\nif(!ajv.validate(searchBooksResponseSchema, bookInfos)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle returned an invalid value: \" +\nerrors);\n}\n}\n--- Page 285 ---\n12.3 Advanced data validation 257\nreturn bookInfos;\n};\nTheo Excellent! Now we need to figure out how to deal with advanced data validation.\n12.3 Advanced data validation\nDave What do you mean by advanced data validation?\nTheo I mean going beyond static types.\nDave Could you give me an example?\nTheo Sure. Take, for instance, the publication year of a book. It’s an integer, but\nwhat else could you say about this number?\nDave It has to be positive. It would say it’s a positive integer.\nTheo Come on, Dave! Be courageous, go beyond types.\nDave I don’t know. I would say it’s a number that should be higher than 1900. I\ndon’t think it makes sense to have a book that is published before 1900.\nTheo Exactly. And what about the higher limit?\nDave I’d say that the publication year should be less than the current year.\nTheo Very good! I see that JSON Schema supports number ranges. Here is how we\ncan write the schema for an integer that represents a year and should be\nbetween 1900 and 2021.\nListing12.12 The schema for an integer between 1900 and 2021\nvar publicationYearSchema = {\n\"type\": \"integer\",\n\"minimum\": 1900,\n\"maximum\": 2021\n};\nDave Why isn’t this kind of data validation possible in OOP?\nTheo I’ll let you think about that for a moment.\nDave I think have it! In DOP, data validation is executed at run time, while static\ntype validation in OOP is executed at compile time. At compile time, we only\nhave information about static types; at run time, we have the data itself. That’s\nwhy in DOP data validation, it’s possible to go beyond types.\n NOTE Of course, it’s also possible in traditional OOP to write custom run-time data\nvalidation. Here, though, we are comparing data schema with static types.\nTheo You got it! Now, let me show you how to write the schema for a string that\nshould match a regular expression.\n NOTE See http://mng.bz/OGNP for the JavaScript Guide to regular expressions.\nTheo Let’s take for example the book ID. I am assuming it must be a UUID.\nDave Right.\nTheo Can you write the regular expression for a valid UUID?\n--- Page 286 ---\n258 CHAPTER 12 Advanced data validation\nDave googles “UUID regex” and finds something he thinks just might work. He shows the\nregular expression to Theo.\nListing12.13 The regular expression for a valid UUID\n[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\nDave Now, how do we plug a regular expression into a JSON Schema?\nTheo While you were looking for the UUID regular expression, I read about the\npattern field. Here’s how we can plug the UUID regular expression into a\nJSON Schema.\nListing12.14 The schema for a UUID\nvar uuidSchema = {\n\"type\": \"string\",\n\"pattern\": \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}\" +\n\"-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\n};\nDave Nice! Let me improve the catalog schema and refine the schema for purchase-\nDate, isbn, libId, and authorId with regular expressions.\nTheo Before you do that, though, let me tell you something I read about regular\nexpressions: some of them are predefined. For example, there is a predefined\nregular expression for dates.\nDave How does it work?\nTheo With the help of the format field.\n NOTE According to JSON Schema specification, format is just for annotation and\ndoesn’t affect validation. But in practice, JSON Schema validation libraries use format\nalso for validation.\nTheo moves to his laptop. He inputs the schema for a date and shows it to Dave.\nListing12.15 The schema for a date\n{\n\"type\": \"string\",\n\"format\": \"date\"\n}\nTIP In DOP, data validation goes beyond static types (e.g., number ranges, regular\nexpressions, and so on).\nDave Very cool! Do I have all the information I need in order to refine the catalog\nschema?\nTheo Yes, go for it!\nIt takes Dave a bit of time to write the regular expressions for isbn, authorId, and libId.\nBut with the help of Google (again) and a bit of simplification, Dave comes up with the\nschema in listings 12.16 and 12.17.\n--- Page 287 ---\n12.3 Advanced data validation 259\nListing12.16 The refined schema of the catalog data (Part 1)\nvar isbnSchema = {\n\"type\": \"string\",\n\"pattern\": \"^[0-9-]{10,20}$\"\n};\nvar libIdSchema = {\n\"type\": \"string\",\n\"pattern\": \"^[a-z0-9-]{3,20}$\"\n};\nvar authorIdSchema ={\n\"type\": \"string\",\n\"pattern\": \"[a-z-]{2,50}\"\n};\nvar bookItemSchema = {\n\"type\": \"object\",\n\"additionalProperties\": {\n\"id\": uuidSchema,\n\"libId\": libIdSchema,\n\"purchaseDate\": {\n\"type\": \"string\",\n\"format\": \"date\"\n},\n\"isLent\": {\"type\": \"boolean\"}\n}\n};\nListing12.17 The refined schema of the catalog data (Part 2)\nvar bookSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorIds\", \"bookItems\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publicationYear\": publicationYearSchema,\n\"isbn\": isbnSchema,\n\"publisher\": {\"type\": \"string\"},\n\"authorIds\": {\n\"type\": \"array\",\n\"items\": authorIdSchema\n},\n\"bookItems\": bookItemSchema\n}\n};\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"id\", \"name\", \"bookIsbns\"],\n\"properties\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n--- Page 288 ---\n260 CHAPTER 12 Advanced data validation\n\"bookIsbns\": {\n\"items\": isbnSchema\n}\n}\n};\nvar catalogSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"booksByIsbn\": {\n\"type\": \"object\",\n\"additionalProperties\": bookSchema\n},\n\"authorsById\": {\n\"type\": \"object\",\n\"additionalProperties\": authorSchema\n}\n},\n\"required\": [\"booksByIsbn\", \"authorsById\"]\n};\n12.4 Automatic generation of data model diagrams\nBefore going home, Theo phones Joe to tell him about how he and Dave used data valida-\ntion inside the system. Joe tells Theo that that’s exactly how he recommends doing it and\nsuggests he come and visit Theo and Dave at the office tomorrow. He wants to show them\nsome cool advanced stuff related to data validation. The next day, with coffee in hand, Joe\nstarts the discussion.\nJoe Are you guys starting to feel the power of data validation à la DOP?\nDave Yes, it’s a bit less convenient to validate a JSON Schema than it is to write the\nclass of function arguments, but this drawback is compensated by the fact that\nJSON Schema supports conditions that go beyond static types.\nTheo We also realized that we don’t have to validate data for each and every function.\nJoe Correct. Now, let me show you another cool thing that we can do with JSON\nSchema.\nDave What’s that?\nJoe Generate a data model diagram.\nDave Wow! How does that work?\nJoe There are tools that receive a JSON Schema as input and produce a diagram in\na data model format.\nDave What is a data model format?\nJoe It’s a format that allows you to define a data model in plain text. After that, you\ncan generate an image from the text. My favorite data format is PlantUML.\n NOTE For more on PlantUML, see https://plantuml.com/.\nDave Do you know of other tools that generate data model diagrams?\nJoe I have used JSON Schema Viewer and Malli.\n--- Page 289 ---\n12.4 Automatic generation of data model diagrams 261\n NOTE You can find information on the JSON Schema Viewer at https://navneethg\n.github.io/jsonschemaviewer/ and on Malli at https://github.com/metosin/malli.\nJoe shows Dave and Theo the PlantUML diagram that Malli generated (listing 12.18) from\nthe catalog schema in listings 12.16 and 12.17.\nListing12.18 A PlantUML diagram generated from the catalog data schema\n@startuml\nEntity1 *-- Entity2\nEntity1 *-- Entity4\nEntity2 *-- Entity3\nclass Entity1 {\n+ booksByIsbn: {Entity2}\n+ authorsById: {Entity4}\n}\nclass Entity2 {\n+ title : String\n+ publicationYear: Number\n+ isbn: String\n+ authorIds: [String]\n+ bookItems: [Entity3]\n}\nclass Entity3 {\n+ id: String\n+ libId: String\n+ purchaseDate: String\n+ isLent: Boolean\n}\nclass Entity4 {\n+ id: String\n+ name: String\n+ bookIsbns: [String]\n}\n@enduml\nDave Is it possible to visualize this diagram?\nJoe Absolutely. Let me copy and paste the diagram text into the PlantText online\ntool.\n NOTE See https://www.planttext.com/ for more on the PlantText online tool.\nDave opens his web browser and types the URL for PlantText. After copying and pasting\nthe text, he steps aside so that Theo and Dave can view the diagram that looks like the\nimage in figure 12.2.\n--- Page 290 ---\n262 CHAPTER 12 Advanced data validation\nC Entity1\nbooksByIsbn: {Entity2}\nauthorsById: {Entity3}\nC Entity2 C Entity4\ntitle : String id: String\npublicationYear: Number name: String\nisbn: String booklsbns: [String]\nauthorlds: [String]\nbookltems: [Entity3]\nC Entity3\nid: String\nlibld: String\nFigure 12.2 A visualization of\npurchaseDate: String\nthe PlantUML diagram generated\nisLent: Boolean\nfrom the catalog data schema\nDave That’s cool! But why are the diagram entities named Entity1, Entity2, and\nso on?\nJoe Because in JSON Schema, there’s no way to give a name to a schema. Malli has\nto autogenerate random names for you.\nTheo Also, I see that the extra information we have in the schema, like the number\nrange for publicationYear and string regular expression for isbn, is missing\nfrom the diagram.\nJoe Right, that extra information is not part of the data model. That’s why it’s not\nincluded in the generated data model diagram.\nDave Anyway, it’s very cool!\nJoe If you guys like the data model generation feature, I’m sure you’re going to\nlike the next feature.\nDave What’s it about?\nJoe Automatic generation of unit tests.\nTheo Wow, sounds exciting!\n12.5 Automatic generation of schema-based unit tests\nJoe Once you’ve defined a data schema for function arguments and for its return\nvalue, it’s quite simple to generate a unit test for this function.\nDave How?\nJoe Well, think about it. What’s the essence of a unit test for a function?\nDave A unit test calls a function with some arguments and checks whether the func-\ntion returns the expected value.\nJoe Exactly! Now, let’s adapt it to the context of data schema and DOP. Let’s say you\nhave a function with a schema for their arguments and for their return value.\n--- Page 291 ---\n12.5 Automatic generation of schema-based unit tests 263\nDave OK.\nJoe Here’s the flow of a schema-based unit test. We call the function with random\narguments that conform to the schema of the function arguments. Then, we\ncheck whether the function returns a value that conforms to the schema of the\nreturn value. Here, let me diagram it.\nJoe goes to the whiteboard. He draws the diagram in figure 12.3.\nGeneraterandom datathat conforms toinput schema\nExecute the function The input\nis random.\nYes No\nOutput conforms to output schema\nTest passes Test fails\nFigure 12.3 The flow of\na schema-based unit test\nDave How do you generate random data that conforms to a schema?\nJoe Using a tool like JSON Schema Faker. For example, let’s start with a simple\nschema: the schema for a UUID. Let me show you how to generate random\ndata that conforms to the schema.\n NOTE You’ll find more information about JSON Schema Faker at https://github\n.com/json-schema-faker/json-schema-faker.\nJoe types on the keyboard for a bit. He then shows the code to generate random data to\nDave and Theo.\nListing12.19 Generating random data that conforms to a UUID schema\nvar uuidSchema = {\n\"type\": \"string\",\n\"pattern\": \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}\" +\n\"-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\n};\nJSONSchemaFaker.generate(uuidSchema);\n// → \"7aA8CdF3-14DF-9EF5-1A19-47dacdB16Fa9\"\nDave executes the code snippet a couple of times, and indeed, on each evaluation, it returns\na different UUID.\nDave Very cool! Let me see how it works with more complex schemas like the cata-\nlog schema.\n--- Page 292 ---\n264 CHAPTER 12 Advanced data validation\nWhen Dave calls JSONSchemaFaker.generate with the catalog schema, he gets some\nquite long random data. He’s a bit surprised by the results.\nListing12.20 Generating random data that conforms to the catalog schema\n{\n\"booksByIsbn\": {\n\"Excepteur7\": {\n\"title\": \"elit veniam anim\",\n\"isbn\": \"5419903-3563-7\",\n\"authorIds\": [\n\"vfbzqahmuemgdegkzntfhzcjhjrbgfoljfzogfuqweggchum\",\n\"inxmqh-\",\n],\n\"bookItems\": {\n\"ullamco5\": {\n\"id\": \"f7dac8c3-E59D-bc2E-7B33-C27F3794E2d6\",\n\"libId\": \"4jtbj7q7nrylfu114m\",\n\"purchaseDate\": \"2001-08-01\",\n\"isLent\": false\n},\n\"culpa_3e\": {\n\"id\": \"423DCdDF-CDAe-2CAa-f956-C6cd9dA8054b\",\n\"libId\": \"6wcxbh\",\n\"purchaseDate\": \"1970-06-24\",\n\"isLent\": true\n}\n},\n\"publicationYear\": 1930,\n\"publisher\": \"sunt do nisi\"\n},\n\"aliquip_d7\": {\n\"title\": \"aute\",\n\"isbn\": \"348782167518177\",\n\"authorIds\": [\"owfgtdxjbiidsobfgvjpjlxuabqpjhdcqmmmrjb-ezrsz-u\"],\n\"bookItems\": {\n\"ipsum__0b\": {\n\"id\": \"6DfE93ca-DB23-5856-56Fd-82Ab8CffEFF5\",\n\"libId\": \"bvjh0p2p2666vs7dd\",\n\"purchaseDate\": \"2018-03-30\",\n\"isLent\": false\n}\n},\n\"publisher\": \"ea anim ut ex id\",\n\"publicationYear\": 1928\n}\n},\n\"authorsById\": {\n\"labore_b88\": {\n\"id\": \"adipisicing nulla proident\",\n\"name\": \"culpa in minim\",\n\"bookIsbns\": [\n\"6243029--7\",\n\"5557199424742986\"\n]",
        "sections_found": []
      },
      "accurate_page_range": "262-292"
    },
    {
      "text": "- 10.1 Fetching data from the database",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "10 Database operations",
      "raw_line": "- 10.1 Fetching data from the database (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 83,
      "chapter_info": {
        "page": 262,
        "title": "Database operations",
        "pattern_matched": "Chapter 10",
        "text_preview": "234 CHAPTER 11 Web services\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physic"
      },
      "chapter_sections": {
        "start_page": 262,
        "end_page": 292,
        "content": "\n--- Page 262 ---\n234 CHAPTER 11 Web services\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nTheo Yes! I think we now have all the pieces to enrich our search results.\n11.6 Search result enrichment in action\nJoe Can you write the steps of the enrichment data flow?\nTheo Sure.\nTheo goes to the whiteboard. He takes a moment to gather his thoughts, and then erases\nenough space so there’s room to list the steps.\nThe steps for the search result enrichment data flow\n1 Receive a request from a client.\n2 Extract from the client’s request the query and the fields to fetch from Open\nLibrary.\n3 Retrieve from the database the books that match the query.\n4 Fetch information from Open Library for each ISBN that match the query.\n5 Extract from Open Library responses for the required fields.\n6 Combine book information from the database with information from Open\nLibrary.\n7 Send the response to the client.\nJoe Perfect! Would you like to try to implement it?\nTheo I think I’ll start with the implementation of the book retrieval from the data-\nbase. It’s quite similar to what we did last month.\n NOTE See chapter 10 for last month’s lesson.\nJoe Actually, it’s even simpler because you don’t need to join tables.\nTheo That’s right, I need values only for the isbn and available columns.\nTheo works for a bit in his IDE. He begins with the book retrieval from the database.\nListing11.14 Retrieving books whose title matches a query\nvar dbSearchResultSchema = {\n\"type\": \"array\",\n\"items\": {\n--- Page 263 ---\n11.6 Search result enrichment in action 235\n\"type\": \"object\",\n\"required\": [\"isbn\", \"available\"],\n\"properties\": {\n\"isbn\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"}\n}\n}\n};\nclass CatalogDB {\nstatic matchingBooks(title) {\nvar matchingBooksQuery = `\nSELECT isbn, available\nFROM books\nWHERE title = like '%$1%';\n`;\nvar books = dbClient.query(catalogDB, matchingBooksQuery, [title]);\nif(!ajv.validate(dbSearchResultSchema, books)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from the database: \" +\nerrors;\n}\nreturn books;\n}\n}\nJoe So far, so good...\nTheo Next, I’ll go with the implementation of the retrieval of book information from\nOpen Library for several books. Unfortunately, the Open Library Books API\ndoesn’t support querying several books at once. I’ll need to send one request\nper book.\nJoe That’s a bit annoying. Let’s make our life easier and pretend that _.map works\nwith asynchronous functions. In real life, you’d need something like Promise\n.all in order to send the requests in parallel and combine the responses.\nTheo OK, then it’s quite straightforward. I’ll take the book retrieval code and add a\nmultipleBookInfo function that maps over bookInfo.\nTheo looks over the book retrieval code in listing 11.9 and then concentrates as he types\ninto his IDE. When he’s done, he shows the result in listing 11.15 to Joe.\nListing11.15 Retrieving book information from Open Library for several books\nclass OpenLibraryDataSource {\nstatic rawBookInfo(isbn) {\nvar url = `https:/ /openlibrary.org/isbn/${isbn}.json`;\nvar jsonString = fetchResponseBody(url);\nreturn JSON.parse(jsonString);\n}\nstatic bookInfo(isbn, requestedFields) {\nvar relevantFields = [\"title\", \"full_title\",\n\"subtitle\", \"publisher\",\n\"publish_date\", \"weight\",\n--- Page 264 ---\n236 CHAPTER 11 Web services\n\"physical_dimensions\", \"genre\",\n\"subjects\", \"number_of_pages\"];\nvar rawInfo = rawBookInfo(isbn);\nif(!ajv.validate(dbSearchResultSchema, bookInfoSchema)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from Open Books API: \" +\nerrors;\n}\nvar relevantInfo =\n_.pick(_.pick(rawInfo, relevantFields), requestedFields);\nreturn _.set(relevantInfo, \"isbn\", isbn);\n}\nstatic multipleBookInfo(isbns, fields) {\nreturn _.map(function(isbn) {\nreturn bookInfo(isbn, fields);\n}, isbns);\n}\n}\nJoe Nice! Now comes the fun part: combining information from several data sources.\nTheo Yeah. I have two arrays in my hands: one with book information from the data-\nbase and one with book information from Open Library. I somehow need to\njoin the arrays, but I’m not sure I can assume that the positions of the book\ninformation are the same in both arrays.\nJoe What would you like to have in your hands?\nTheo I wish I had two hash maps.\nJoe And what would the keys in the hash maps be?\nTheo Book ISBNs.\nJoe Well, I have good news for you: your wish is granted!\nTheo How?\nJoe Lodash provides a function named _.keyBy that transforms an array into a map.\nTheo I can’t believe it. Can you show me an example?\nJoe Sure. Let’s call _.keyBy on an array with two books.\nListing11.16 Transforming an array into a map with _.keyBy\nvar books = [\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"isbn\": \"978-1982137274\",\n\"available\": true\n},\n{\n\"title\": \"The Power of Habit\",\n\"isbn\": \"978-0812981605\",\n\"available\": false\n}\n];\n_.keyBy(books, \"isbn\");\n--- Page 265 ---\n11.6 Search result enrichment in action 237\nJoe And here’s the result.\nListing11.17 The result of keyBy\n{\n\"978-0812981605\": {\n\"available\": false,\n\"isbn\": \"978-0812981605\",\n\"title\": \"The Power of Habit\"\n},\n\"978-1982137274\": {\n\"available\": true,\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\"\n}\n}\nTheo keyBy is awesome!\nJoe Don’t exaggerate, my friend; _.keyBy is quite similar to _.groupBy. The\nonly difference is that _.keyBy assumes that there’s only one element in\neach group.\nTheo I think that, with _.keyBy, I’ll be able to write a generic joinArrays function.\nJoe I’m glad to see you thinking in terms of implementing business logic through\ngeneric data manipulation functions.\nTIP Many parts of the business logic can be implemented through generic data\nmanipulation functions.\nTheo The joinArrays function needs to receive the arrays and the field name for\nwhich we decide the two elements that need to be combined, for instance,\nisbn.\nJoe Remember, in general, it’s not necessarily the same field name for both arrays.\nTheo Right, so joinArrays needs to receive four arguments: two arrays and two\nfield names.\nJoe Go for it! And, please, write a unit test for joinArrays.\nTheo Of course...\nTheo works for a while and produces the code in listing 11.18. He then types the unit test\nin listing 11.19.\nListing11.18 A generic function for joining arrays\nfunction joinArrays(a, b, keyA, keyB) {\nvar mapA = _.keyBy(a, keyA);\nvar mapB = _.keyBy(b, keyB);\nvar mapsMerged = _.merge(mapA, mapB);\nreturn _.values(mapsMerged);\n}\n--- Page 266 ---\n238 CHAPTER 11 Web services\nListing11.19 A unit test for joinArrays\nvar dbBookInfos = [\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true\n},\n{\n\"isbn\": \"978-0812981605\",\n\"title\": \"The Power of Habit\",\n\"available\": false\n}\n];\nvar openLibBookInfos = [\n{\n\"isbn\": \"978-0812981605\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432,\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"The Power of Habit\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n],\n}\n];\nvar joinedArrays = [\n{\n\"available\": true,\n\"isbn\": \"978-1982137274\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\",\n],\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"title\": \"The Power of Habit\",\n},\n{\n\"available\": false,\n\"isbn\": \"978-0812981605\",\n\"number_of_pages\": 432,\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"title\": \"7 Habits of Highly Effective People\",\n},\n]\n--- Page 267 ---\n11.6 Search result enrichment in action 239\n_.isEqual(joinedArrays,\njoinArrays(dbBookInfos, openLibBookInfos, \"isbn\", \"isbn\"));\nJoe Excellent! Now, you are ready to adjust the last piece of the extended search\nresult endpoint.\nTheo That’s quite easy. We fetch data from the database and from Open Library and\njoin them.\nTheo works quite rapidly. He then shows Joe the code.\nListing11.20 Search books and enriched book information\nclass Catalog {\nstatic enrichedSearchBooksByTitle(searchPayload) {\nif(!ajv.validate(searchBooksRequestSchema, searchPayload)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid request:\" + errors;\n}\nvar title = _.get(searchPayload, \"title\");\nvar fields = _.get(searchPayload, \"fields\");\nvar dbBookInfos = CatalogDataSource.matchingBooks(title);\nvar isbns = _.map(dbBookInfos, \"isbn\");\nvar openLibBookInfos =\nOpenLibraryDataSource.multipleBookInfo(isbns, fields);\nvar res = joinArrays(dbBookInfos, openLibBookInfos);\nif(!ajv.validate(searchBooksResponseSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid response:\" + errors;\n}\nreturn res;\n}\n}\nNow comes the tricky part. Theo takes a few moments to meditate about the simplicity of\nthe code that implements the extended search endpoint. He thinks about how classes are\nmuch less complex when we use them only to aggregate stateless functions that operate on\nsimilar domain entities and then goes to work plotting the code.\nListing11.21 Schema for the extended search endpoint (Open Books API part)\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n--- Page 268 ---\n240 CHAPTER 11 Web services\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing11.22 Extended search endpoint (Open Books API part)\nvar ajv = new Ajv({allErrors: true});\nclass OpenLibraryDataSource {\nstatic rawBookInfo(isbn) {\nvar url = `https:/ /openlibrary.org/isbn/${isbn}.json`;\nvar jsonString = fetchResponseBody(url);\nreturn JSON.parse(jsonString);\n}\nstatic bookInfo(isbn, requestedFields) {\nvar relevantFields = [\"title\", \"full_title\",\n\"subtitle\", \"publisher\",\n\"publish_date\", \"weight\",\n--- Page 269 ---\n11.6 Search result enrichment in action 241\n\"physical_dimensions\", \"genre\",\n\"subjects\", \"number_of_pages\"];\nvar rawInfo = rawBookInfo(isbn);\nif(!ajv.validate(bookInfoSchema, rawInfo)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from Open Books API: \" +\nerrors;\n}\nvar relevantInfo = _.pick(\n_.pick(rawInfo, relevantFields),\nrequestedFields);\nreturn _.set(relevantInfo, \"isbn\", isbn);\n}\nstatic multipleBookInfo(isbns, fields) {\nreturn _.map(function(isbn) {\nreturn bookInfo(isbn, fields);\n}, isbns);\n}\n}\nListing11.23 Extended search endpoint (database part)\nvar dbClient;\nvar dbSearchResultSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"isbn\", \"available\"],\n\"properties\": {\n\"isbn\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"}\n}\n}\n};\nclass CatalogDB {\nstatic matchingBooks(title) {\nvar matchingBooksQuery = `\nSELECT isbn, available\nFROM books\nWHERE title = like '%$1%';\n`;\nvar books = dbClient.query(catalogDB, matchingBooksQuery, [title]);\nif(!ajv.validate(dbSearchResultSchema, books)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from the database: \"\n+ errors;\n}\nreturn books;\n}\n}\n--- Page 270 ---\n242 CHAPTER 11 Web services\nListing11.24 Schema for the implementation of the extended search endpoint\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"type\": [\n\"title\",\n\"full_title\",\n\"subtitle\",\n\"publisher\",\n\"publish_date\",\n\"weight\",\n\"physical_dimensions\",\n\"number_of_pages\",\n\"subjects\",\n\"publishers\",\n\"genre\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksResponseSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nListing11.25 Schema for the extended search endpoint (combines the pieces)\nclass Catalog {\nstatic enrichedSearchBooksByTitle(request) {\n--- Page 271 ---\n11.6 Search result enrichment in action 243\nif(!ajv.validate(searchBooksRequestSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid request:\" + errors;\n}\nvar title = _.get(request, \"title\");\nvar fields = _.get(request, \"fields\");\nvar dbBookInfos = CatalogDataSource.matchingBooks(title);\nvar isbns = _.map(dbBookInfos, \"isbn\");\nvar openLibBookInfos =\nOpenLibraryDataSource.multipleBookInfo(isbns, fields);\nvar response = joinArrays(dbBookInfos, openLibBookInfos);\nif(!ajv.validate(searchBooksResponseSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid response:\" + errors;\n}\nreturn response;\n}\n}\nclass Library {\nstatic searchBooksByTitle(payloadBody) {\nvar payloadData = JSON.parse(payloadBody);\nvar results = Catalog.searchBooksByTitle(payloadData);\nreturn JSON.stringify(results);\n}\n}\nTIP Classes are much less complex when we use them as a means to aggregate state-\nless functions that operate on similar domain entities.\nJoe interrupts Theo’s meditation moment. After looking over the code in the previous list-\nings, he congratulates Theo.\nJoe Excellent job, my friend! By the way, after reading The Power of Habit, I quit\nchewing my nails.\nTheo Wow! That’s terrific! Maybe I should read that book to overcome my habit of\ndrinking too much coffee.\nJoe Thanks, and good luck with the coffee habit.\nTheo I was supposed to call Nancy later today with an ETA for the Open Library\nBook milestone. I wonder what her reaction will be when I tell her the feature\nis ready.\nJoe Maybe you should tell her it’ll be ready in a week, which would give you time to\nbegin work on the next milestone.\n--- Page 272 ---\n244 CHAPTER 11 Web services\nDelivering on time\nJoe was right! Theo recalls Joe’s story about the young woodcutter and the old man. Theo\nwas able to learn DOP and deliver the project on time! He’s pleased that he took the time\n“to sharpen his saw and commit to a deeper level of practice.”\n NOTE If you are unable to recall the story or if you missed it, check out the opener\nto part 2.\nThe Klafim project is a success. Nancy is pleased. Theo’s boss is satisfied. Theo got pro-\nmoted. What more can a person ask for?\nTheo remembers his deal with Joe. As he strolls through the stores of the Westfield San\nFrancisco Center to look for a gift for each of Joe’s children, Neriah and Aurelia, he is\nfilled with a sense of purpose and great pleasure. He buys a DJI Mavic Air 2 drone for Ner-\niah, and the latest Apple Airpod Pros for Aurelia. He also takes this opportunity to buy a\nnecklace and a pair of earrings for his wife, Jane. It’s a way for him to thank her for having\nendured his long days at work since the beginning of the Klafim project.\n NOTE The story continues in the opener of part 3.\nSummary\n We build the insides of our systems like we build the outsides.\n Components inside a program communicate via data that is represented as\nimmutable data collections in the same way as components communicate via\ndata over the wire.\n In DOP, the inner components of a program are loosely coupled.\n Many parts of business logic can be implemented through generic data manipu-\nlation functions. We use generic functions to\n– Implement each step of the data flow inside a web service.\n– Parse a request from a client.\n– Apply business logic to the request.\n– Fetch data from external sources (e.g., database and other web services).\n– Apply business logic to the responses from external sources.\n– Serialize response to the client.\n Classes are much less complex when we use them as a means to aggregate\ntogether stateless functions that operate on similar domain entities.\nLodash functions introduced in this chapter\nFunction Description\nkeyBy(coll, f) Creates a map composed of keys generated from the results of running each ele-\nment of coll through f; the corresponding value for each key is the last element\nresponsible for generating the key.\n--- Page 273 ---\nPart 3\nMaintainability\nA\nfter a month, the Klafim project enters what Alabatross calls the mainte-\nnance phase. Small new features need to be added on a weekly basis. Bugs need to be\nfixed; nothing dramatic....\nMonica, Theo’s boss, decides to allocate Dave to the maintenance of the Klafim\nproject. It makes sense. Over the last few months, Dave has demonstrated a great atti-\ntude of curiosity and interest, and he has solid programming skills. Theo sets up a\nmeeting with Joe and Dave, hoping that Joe will be willing to teach DOP to Dave so\nthat he can continue to advance the good work he’s already done on Klafim. Theo\nand Dave place a conference call to Joe.\nTheo Hi, Joe. Will you have time over the next few weeks to teach Dave the\nprinciples of DOP?\nJoe Yes, but I prefer not to.\nDave Why? Is it because I don’t have enough experience in software develop-\nment? I can guarantee you that I’m a fast learner.\nJoe It has nothing to do with your experience, Dave.\nTheo Why not then?\nJoe Theo, I think that you could be a great mentor for Dave.\nTheo But, I don’t even know all the parts of DOP!\nDave Come on! No false modesty between us, my friend.\nJoe Knowledge is never complete. As the great Socrates used to say, “The more\nI know, the more I realize I know nothing.” I’m confident you will be able\nto learn the missing parts by yourself and maybe even invent some.\nTheo How will I be able to invent missing parts?\n--- Page 274 ---\n246 PART 3 Maintainability\nJoe You see, DOP is such a simple paradigm that it’s fertile material for innovation.\nPart of the material I taught you I learned from others, and part of it was an\ninvention of mine. If you keep practicing DOP, I’m quite sure you, too, will\ncome up with some inventions of your own.\nTheo What do you say Dave? Are you willing to learn DOP from me?\nDave Definitely!\nTheo Joe, will you be continue to be available if we need your help from time to time?\nJoe Of course!\n--- Page 275 ---\nAdvanced data\nvalidation\nA self-made gift\nThis chapter covers\n Validating function arguments\n Validating function return values\n Data validation beyond static types\n Automatic generation of data model diagrams\n Automatic generation of schema-based unit tests\nAs the size of a code base grows in a project that follows DOP principles, it becomes\nharder to manipulate functions that receive and return only generic data. It is hard\nto figure out the expected shape of the function arguments, and when we pass\ninvalid data, we don’t get meaningful errors.\nUntil now, we have illustrated how to validate data at system boundaries. In this\nchapter, we will illustrate how to validate data when it flows inside the system by\ndefining data schemas for function arguments and their return values. This allows\nus to make explicit the expected shape of function arguments, and it eases develop-\nment. We gain some additional benefits from this endeavor, such as automatic gen-\neration of data model diagrams and schema-based unit tests.\n247\n--- Page 276 ---\n248 CHAPTER 12 Advanced data validation\n12.1 Function arguments validation\nDave’s first task is to implement a couple of new HTTP endpoints to download the catalog\nas a CSV file, search books by author, and rate the books. Once he is done with the tasks,\nDave calls Theo for a code review.\n NOTE The involvement of Dave in the Klafim project is explained in the opener for\npart 3. Please take a moment to read the opener if you missed it.\nTheo Was it difficult to get your head around the DOP code?\nDave Not so much. I read your notes of the meetings with Joe, and I must admit, the\ncode is quite simple to grasp.\nTheo Cool!\nDave But there is something that I can’t get used to.\nTheo What’s that?\nDave I’m struggling with the fact that all the functions receive and return generic\ndata. In OOP, I know the expected shape of the arguments for each and every\nfunction.\nTheo Did you validate data at system boundaries, like I have done?\nDave Absolutely. I defined a data schema for every additional user request, database\nquery, and external service response.\nTheo Nice!\nDave Indeed, when the system runs in production, it works well. When data is valid,\nthe data flows through the system, and when data is invalid, we are able to dis-\nplay a meaningful error message to the user.\nTheo What’s the problem then?\nDave The problem is that during development, it’s hard to figure out the expected\nshape of the function arguments. And when I pass invalid data by mistake, I\ndon’t get clear error messages.\nTheo I see. I remember that when Joe showed me how to validate data at system\nboundaries, I raised this concern about the development phase. Joe told me\nthen that we validate data as it flows inside the system exactly like we validate data\nat system boundaries: we separate between data schema and data representation.\nDave Are we going to use JSON Schema also?\nTheo Yes.\nDave Cool.... I like JSON Schema.\nTheo The main purpose of data validation at system boundaries is to prevent invalid\ndata from getting into the system, whereas the main purpose of data validation\ninside the system is to make it easier to develop the system. Here, let me draw a\ntable on the whiteboard for you to visualize this (table 12.1).\nTable 12.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\n--- Page 277 ---\n12.1 Function arguments validation 249\nDave By making it easier to develop the system, do you mean to help the developers\nunderstand the expected shape of function arguments as in OOP?\nTheo Exactly.\nDave But I’m impatient.... Will you help me figure out how to validate the argu-\nments of the function that implements a book search?\nTheo Let me see the code of the implementation, and I’ll do my best.\nDave We have two implementations of a book search: one where library data lives\nin memory from the prototype phase and one where library data lives in the\ndatabase.\nTheo I think that the schema for library data in memory is going to be more interest-\ning than the schema for library data in the database, as the book search func-\ntion receives catalog data in addition to the query.\nDave When you say more interesting data schema, you mean more difficult to write?\nTheo More difficult to write, but it’s also more insightful.\nDave Then let’s go with library data in memory. The code for Catalog.search-\nBooksByTitle from the prototype phase would look like this.\nDave pulls up some code on his laptop. He shows it to Theo.\nListing12.1 The implementation of search without data validation\nclass Catalog {\nstatic authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nreturn bookInfo;\n}\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\n--- Page 278 ---\n250 CHAPTER 12 Advanced data validation\nTheo Dave, please remind me of the expected shapes for catalogData and query.\nDave Sure. query should be a string, and catalogData should be a map that con-\nforms to the catalog data model.\nTheo What is the catalog data model?\nDave Let me see. I have seen a diagram of it somewhere.\nDave rummages around a bit in his folder for Klafim’s Library Management System. Find-\ning what he’s looking for, he draws the diagram in figure 12.1 on the whiteboard.\nC Catalog\nbooksByIsbn: {Book}\nauthorsById: {Author}\nC Book\nC Author\ntitle : String\npublicationYear: Number id: String\nisbn: String name: String\nauthorlds: [String] booklsbns: [String]\nbookltems: [Bookltem]\nC Bookltem\nid: String\nlibld: String\npurchaseDate: String\nisLent: Boolean\nFigure 12.1 The catalog data model\n NOTE The schemas for this book use JSON Schema version 2020-12.\nTheo Can you write a JSON Schema for the catalog data model?\nDave Am I allowed to use internal variables for book and author schemas, or do I\nhave to nest all the schemas inside the catalog schema?\nTheo JSON Schema is part of the code. If you feel that using internal variables would\nmake the code more readable, go for it.\nDave OK. Now I need the JSON Schema gift that Joe gave you.\nTheo picks up a well-worn piece of paper that is a bit torn and quite wrinkled. He gives\nDave the JSON Schema cheat sheet.\nListing12.2 JSON Schema cheat sheet\nAt the root level,\n{\ndata is an array.\n\"type\": \"array\",\n\"items\": { Each element of the array is a map.\n\"type\": \"object\",\nThe properties of each field in the map\n\"properties\": {\n--- Page 279 ---\n12.1 Function arguments validation 251\n\"myNumber\": {\"type\": \"number\"},\nmyNumber\n\"myString\": {\"type\": \"string\"}, myEnum is an enumeration\nis a number.\n\"myEnum\": {\"enum\": [\"myVal\", \"yourVal\"]}, value with two possibilities,\nmyString is \"myBool\": {\"type\": \"boolean\"} \"myVal\" and \"yourVal\".\na string. },\n\"required\": [\"myNumber\", \"myString\"], myBool is a boolean.\n\"additionalProperties\": false\n} The mandatory fields in the map\n} We don’t allow fields that are not are myNumber and myString.\nexplicitly mentioned in the schema. Other fields are optional.\nDave I think I’ll start with the author schema. It seems simpler than the book schema.\nQuickly composing the code, Dave shows Theo the author schema. Dave, still new to DOP,\nlooks for Theo’s reaction.\nListing12.3 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"id\", \"name\", \"bookIsbns\"],\n\"properties\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nTheo Well done! Let’s move on to the book schema now.\nDave I think I am going to store the book item schema in a variable.\nListing12.4 The book item schema\nvar bookItemSchema = {\n\"type\": \"object\",\n\"properties\":{\n\"id\": {\"type\": \"string\"},\n\"libId\": {\"type\": \"string\"},\n\"purchaseDate\": {\"type\": \"string\"},\n\"isLent\": {\"type\": \"boolean\"}\n},\n\"required\": [\"id\", \"libId\", \"purchaseDate\", \"isLent\"]\n};\nvar bookSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorIds\", \"bookItems\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publicationYear\": {\"type\": \"integer\"},\n--- Page 280 ---\n252 CHAPTER 12 Advanced data validation\n\"isbn\": {\"type\": \"string\"},\n\"authorIds\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"bookItems\": {\n\"type\": \"array\",\n\"items\": bookItemSchema\n}\n}\n};\nTIP When you define a complex data schema, it is advisable to store nested schemas\nin variables to make the schemas easier to read.\nTheo Why didn’t you include publicationYear in the list of required fields in the\nbook schema?\nDave Because, for some books, the publication year is missing. Unlike in OOP, it will\nthen be easy to deal with nullable fields.\nTheo Excellent! And now, please tackle the final piece, the catalog schema.\nDave Here I have a problem. The catalog should be a map with two fields, books-\nByIsbn and authorsById. Both values should be indexes, represented in the\nmodel diagram with curly braces. I have no idea how to define the schema for\nan index.\nTheo Do you remember how we represent indexes in DOP?\nDave Yes, indexes are represented as maps.\nTheo Right, and what’s the difference between those maps and the maps that we use\nfor records?\nDave For records, we use maps where the names of the fields are known and the val-\nues can have different shapes. For indexes, we use maps where the names of\nthe fields are unknown and the values have a common shape.\nTheo Right. We call the maps for records heterogeneous maps and the maps for\nindexes homogeneous maps.\nTIP In DOP, records are represented as heterogeneous maps, whereas indexes are repre-\nsented as homogeneous maps.\nDave Then how do we define the schema of an homogeneous map in JSON Schema?\nTheo I don’t know. Let’s check the JSON Schema online documentation.\n NOTE See https://json-schema.org/ to access the online documentation for JSON\nSchema version 2020-12.\nAfter a couple of minutes of digging into the JSON Schema online documentation, Theo\nfinds a piece about additionalProperties. He studies the information for a while before\nmaking up his mind.\n--- Page 281 ---\n12.1 Function arguments validation 253\nTheo I think we could use additionalProperties. Here’s the JSON Schema for an\nhomogeneous map where the values are numbers.\nListing12.5 The JSON Schema for an homogeneous map with values as numbers\n{\n\"type\": \"object\",\n\"additionalProperties\": {\"type\": \"number\"}\n}\nDave I thought that additionalProperties was supposed to be a boolean and that\nit was used to allow or forbid properties not mentioned in the schema.\nTheo That’s correct. Usually additionalProperties is a boolean, but the documen-\ntation says it could also be a map that defines a schema. In that case, it means\nproperties not mentioned in the schema should have the value of the schema\nassociated with additionalProperties.\nDave I see. But what does that have to do with homogeneous maps?\nTheo Well, a homogeneous map could be seen as a map with no predefined proper-\nties, where all the additional properties are of an expected type.\nDave Tricky!\nTIP In JSON Schema, homogeneous string maps have type: object with no\nproperties and additionalProperties associated to a schema.\nTheo Indeed. Now, let me show you what the catalog schema looks like.\nTheo types briefly on his laptop. He shows Dave the catalog schema.\nListing12.6 The schema for catalog data\nvar catalogSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"booksByIsbn\": {\n\"type\": \"object\",\n\"additionalProperties\": bookSchema\n},\n\"authorsById\": {\n\"type\": \"object\",\n\"additionalProperties\": authorSchema\n}\n},\n\"required\": [\"booksByIsbn\", \"authorsById\"]\n};\nDave Are we ready to plug the catalog and the query schema into the Catalog\n.searchBooksByTitle implementation?\nTheo We could, but I think we can do better by defining a single schema that com-\nbines both the catalog and query schemas.\nDave How would we combine two schemas into a single schema?\n--- Page 282 ---\n254 CHAPTER 12 Advanced data validation\nTheo Do you know what a tuple is?\nDave I think I know, but I can’t define it formally.\nTheo A tuple is an array where the size is fixed, and the elements can be of different\nshapes.\nDave OK. So, how do we define tuples in JSON Schema?\nOnce again, Theo explores the JSON Schema online documentation. Fortunately, he has\nbookmarked the page, and in no time at all, finds the information he needs.\nTheo I found it! We use prefixItems in the definition of a tuple made of a string\nand a number, for instance.\nTheo types more code on his laptop. When he finishes, he shows Dave the schema for a\ntuple.\nListing12.7 The schema for a tuple made of a string and a number\n{\n\"type\": \"array\",\n\"prefixItems\": [\n{ \"type\": \"string\" },\n{ \"type\": \"number\" }\n]\n}\nDave I see. And how would you define the schema for the arguments of Catalog\n.searchBooksByTitle?\nTheo Well, it’s a tuple of size 2, where the first element is a catalog and the second\nelement is a string.\nDave Something like this schema?\nListing12.8 The schema for the arguments of Catalog.searchBooksByTitle\nvar searchBooksArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\ncatalogSchema,\n{ \"type\": \"string\" },\n]\n};\nTheo Exactly!\nDave Now that we have the schema for the arguments, how do we plug it into the\nimplementation of search books?\nTheo That’s similar to the way we validate data at system boundaries. The main dif-\nference is that the data validation for data that flows inside the system should\nrun only at development time, and it should be disabled when the code runs in\nproduction.\nDave Why?\n--- Page 283 ---\n12.2 Return value validation 255\nTheo Because that data has been already validated up front at a system boundary.\nValidating it again on a function call is superfluous, and it would impact\nperformance.\nDave When you say development time, does that include testing and staging\nenvironments?\nTheo Yes, all the environments besides production.\nDave I see. It’s like assertions in Java. They are disabled in production code.\nTIP Data validation inside the system should be disabled in production.\nTheo Exactly. For now, I am going to assume that we have a dev function that returns\ntrue when the code runs in the development environment and false when it\nruns in production. Having said that, take a look at this code.\nListing12.9 Implementation of search with validation of function arguments\nCatalog.searchBooksByTitle = function(catalogData, query) {\nif(dev()) {\nvar args = [catalogData, query];\nif(!ajv.validate(searchBooksArgsSchema, args)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle called with invalid arguments: \" +\nerrors);\nThe implementation of dev() depends on the run-time\n}\nenvironment: it returns true when the code runs in dev\n}\nenvironments and false when it runs in production.\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nDave Do you think we should validate the arguments of all the functions?\nTheo No. I think we should treat data validation like we treat unit tests. We should\nvalidate function arguments only for functions for whom we would write unit\ntests.\nTIP Treat data validation like unit tests.\n12.2 Return value validation\nDave Do you think it would make sense to also validate the return value of functions?\nTheo Absolutely.\nDave Cool. Let me try to write the JSON Schema for the return value of Catalog\n.searchBooksByTitle.\n--- Page 284 ---\n256 CHAPTER 12 Advanced data validation\nAfter a few minutes, Dave comes up with the schema. Taking a deep breath, then releasing\nit, he shows the code to Theo.\nListing12.10 The schema for the return value of Catalog.searchBooksByTitle\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorNames\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"isbn\": {\"type\": \"string\"},\n\"authorNames\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n};\nTheo Well done! Now, would you like to try adding return value validation to the\ncode of Catalog.searchBooksByTitle?\nDave Sure.\nDave works for a bit in his IDE. A bit more confident this time, he shows the result to Theo.\nListing12.11 Search with data validation for both input and output\nCatalog.searchBooksByTitle = function(catalogData, query) {\nif(dev()) {\nif(!ajv.validate(searchBooksArgsSchema, [catalogData, query])) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle called with invalid arguments: \" +\nerrors);\n}\n}\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nif(dev()) {\nif(!ajv.validate(searchBooksResponseSchema, bookInfos)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle returned an invalid value: \" +\nerrors);\n}\n}\n--- Page 285 ---\n12.3 Advanced data validation 257\nreturn bookInfos;\n};\nTheo Excellent! Now we need to figure out how to deal with advanced data validation.\n12.3 Advanced data validation\nDave What do you mean by advanced data validation?\nTheo I mean going beyond static types.\nDave Could you give me an example?\nTheo Sure. Take, for instance, the publication year of a book. It’s an integer, but\nwhat else could you say about this number?\nDave It has to be positive. It would say it’s a positive integer.\nTheo Come on, Dave! Be courageous, go beyond types.\nDave I don’t know. I would say it’s a number that should be higher than 1900. I\ndon’t think it makes sense to have a book that is published before 1900.\nTheo Exactly. And what about the higher limit?\nDave I’d say that the publication year should be less than the current year.\nTheo Very good! I see that JSON Schema supports number ranges. Here is how we\ncan write the schema for an integer that represents a year and should be\nbetween 1900 and 2021.\nListing12.12 The schema for an integer between 1900 and 2021\nvar publicationYearSchema = {\n\"type\": \"integer\",\n\"minimum\": 1900,\n\"maximum\": 2021\n};\nDave Why isn’t this kind of data validation possible in OOP?\nTheo I’ll let you think about that for a moment.\nDave I think have it! In DOP, data validation is executed at run time, while static\ntype validation in OOP is executed at compile time. At compile time, we only\nhave information about static types; at run time, we have the data itself. That’s\nwhy in DOP data validation, it’s possible to go beyond types.\n NOTE Of course, it’s also possible in traditional OOP to write custom run-time data\nvalidation. Here, though, we are comparing data schema with static types.\nTheo You got it! Now, let me show you how to write the schema for a string that\nshould match a regular expression.\n NOTE See http://mng.bz/OGNP for the JavaScript Guide to regular expressions.\nTheo Let’s take for example the book ID. I am assuming it must be a UUID.\nDave Right.\nTheo Can you write the regular expression for a valid UUID?\n--- Page 286 ---\n258 CHAPTER 12 Advanced data validation\nDave googles “UUID regex” and finds something he thinks just might work. He shows the\nregular expression to Theo.\nListing12.13 The regular expression for a valid UUID\n[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\nDave Now, how do we plug a regular expression into a JSON Schema?\nTheo While you were looking for the UUID regular expression, I read about the\npattern field. Here’s how we can plug the UUID regular expression into a\nJSON Schema.\nListing12.14 The schema for a UUID\nvar uuidSchema = {\n\"type\": \"string\",\n\"pattern\": \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}\" +\n\"-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\n};\nDave Nice! Let me improve the catalog schema and refine the schema for purchase-\nDate, isbn, libId, and authorId with regular expressions.\nTheo Before you do that, though, let me tell you something I read about regular\nexpressions: some of them are predefined. For example, there is a predefined\nregular expression for dates.\nDave How does it work?\nTheo With the help of the format field.\n NOTE According to JSON Schema specification, format is just for annotation and\ndoesn’t affect validation. But in practice, JSON Schema validation libraries use format\nalso for validation.\nTheo moves to his laptop. He inputs the schema for a date and shows it to Dave.\nListing12.15 The schema for a date\n{\n\"type\": \"string\",\n\"format\": \"date\"\n}\nTIP In DOP, data validation goes beyond static types (e.g., number ranges, regular\nexpressions, and so on).\nDave Very cool! Do I have all the information I need in order to refine the catalog\nschema?\nTheo Yes, go for it!\nIt takes Dave a bit of time to write the regular expressions for isbn, authorId, and libId.\nBut with the help of Google (again) and a bit of simplification, Dave comes up with the\nschema in listings 12.16 and 12.17.\n--- Page 287 ---\n12.3 Advanced data validation 259\nListing12.16 The refined schema of the catalog data (Part 1)\nvar isbnSchema = {\n\"type\": \"string\",\n\"pattern\": \"^[0-9-]{10,20}$\"\n};\nvar libIdSchema = {\n\"type\": \"string\",\n\"pattern\": \"^[a-z0-9-]{3,20}$\"\n};\nvar authorIdSchema ={\n\"type\": \"string\",\n\"pattern\": \"[a-z-]{2,50}\"\n};\nvar bookItemSchema = {\n\"type\": \"object\",\n\"additionalProperties\": {\n\"id\": uuidSchema,\n\"libId\": libIdSchema,\n\"purchaseDate\": {\n\"type\": \"string\",\n\"format\": \"date\"\n},\n\"isLent\": {\"type\": \"boolean\"}\n}\n};\nListing12.17 The refined schema of the catalog data (Part 2)\nvar bookSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorIds\", \"bookItems\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publicationYear\": publicationYearSchema,\n\"isbn\": isbnSchema,\n\"publisher\": {\"type\": \"string\"},\n\"authorIds\": {\n\"type\": \"array\",\n\"items\": authorIdSchema\n},\n\"bookItems\": bookItemSchema\n}\n};\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"id\", \"name\", \"bookIsbns\"],\n\"properties\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n--- Page 288 ---\n260 CHAPTER 12 Advanced data validation\n\"bookIsbns\": {\n\"items\": isbnSchema\n}\n}\n};\nvar catalogSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"booksByIsbn\": {\n\"type\": \"object\",\n\"additionalProperties\": bookSchema\n},\n\"authorsById\": {\n\"type\": \"object\",\n\"additionalProperties\": authorSchema\n}\n},\n\"required\": [\"booksByIsbn\", \"authorsById\"]\n};\n12.4 Automatic generation of data model diagrams\nBefore going home, Theo phones Joe to tell him about how he and Dave used data valida-\ntion inside the system. Joe tells Theo that that’s exactly how he recommends doing it and\nsuggests he come and visit Theo and Dave at the office tomorrow. He wants to show them\nsome cool advanced stuff related to data validation. The next day, with coffee in hand, Joe\nstarts the discussion.\nJoe Are you guys starting to feel the power of data validation à la DOP?\nDave Yes, it’s a bit less convenient to validate a JSON Schema than it is to write the\nclass of function arguments, but this drawback is compensated by the fact that\nJSON Schema supports conditions that go beyond static types.\nTheo We also realized that we don’t have to validate data for each and every function.\nJoe Correct. Now, let me show you another cool thing that we can do with JSON\nSchema.\nDave What’s that?\nJoe Generate a data model diagram.\nDave Wow! How does that work?\nJoe There are tools that receive a JSON Schema as input and produce a diagram in\na data model format.\nDave What is a data model format?\nJoe It’s a format that allows you to define a data model in plain text. After that, you\ncan generate an image from the text. My favorite data format is PlantUML.\n NOTE For more on PlantUML, see https://plantuml.com/.\nDave Do you know of other tools that generate data model diagrams?\nJoe I have used JSON Schema Viewer and Malli.\n--- Page 289 ---\n12.4 Automatic generation of data model diagrams 261\n NOTE You can find information on the JSON Schema Viewer at https://navneethg\n.github.io/jsonschemaviewer/ and on Malli at https://github.com/metosin/malli.\nJoe shows Dave and Theo the PlantUML diagram that Malli generated (listing 12.18) from\nthe catalog schema in listings 12.16 and 12.17.\nListing12.18 A PlantUML diagram generated from the catalog data schema\n@startuml\nEntity1 *-- Entity2\nEntity1 *-- Entity4\nEntity2 *-- Entity3\nclass Entity1 {\n+ booksByIsbn: {Entity2}\n+ authorsById: {Entity4}\n}\nclass Entity2 {\n+ title : String\n+ publicationYear: Number\n+ isbn: String\n+ authorIds: [String]\n+ bookItems: [Entity3]\n}\nclass Entity3 {\n+ id: String\n+ libId: String\n+ purchaseDate: String\n+ isLent: Boolean\n}\nclass Entity4 {\n+ id: String\n+ name: String\n+ bookIsbns: [String]\n}\n@enduml\nDave Is it possible to visualize this diagram?\nJoe Absolutely. Let me copy and paste the diagram text into the PlantText online\ntool.\n NOTE See https://www.planttext.com/ for more on the PlantText online tool.\nDave opens his web browser and types the URL for PlantText. After copying and pasting\nthe text, he steps aside so that Theo and Dave can view the diagram that looks like the\nimage in figure 12.2.\n--- Page 290 ---\n262 CHAPTER 12 Advanced data validation\nC Entity1\nbooksByIsbn: {Entity2}\nauthorsById: {Entity3}\nC Entity2 C Entity4\ntitle : String id: String\npublicationYear: Number name: String\nisbn: String booklsbns: [String]\nauthorlds: [String]\nbookltems: [Entity3]\nC Entity3\nid: String\nlibld: String\nFigure 12.2 A visualization of\npurchaseDate: String\nthe PlantUML diagram generated\nisLent: Boolean\nfrom the catalog data schema\nDave That’s cool! But why are the diagram entities named Entity1, Entity2, and\nso on?\nJoe Because in JSON Schema, there’s no way to give a name to a schema. Malli has\nto autogenerate random names for you.\nTheo Also, I see that the extra information we have in the schema, like the number\nrange for publicationYear and string regular expression for isbn, is missing\nfrom the diagram.\nJoe Right, that extra information is not part of the data model. That’s why it’s not\nincluded in the generated data model diagram.\nDave Anyway, it’s very cool!\nJoe If you guys like the data model generation feature, I’m sure you’re going to\nlike the next feature.\nDave What’s it about?\nJoe Automatic generation of unit tests.\nTheo Wow, sounds exciting!\n12.5 Automatic generation of schema-based unit tests\nJoe Once you’ve defined a data schema for function arguments and for its return\nvalue, it’s quite simple to generate a unit test for this function.\nDave How?\nJoe Well, think about it. What’s the essence of a unit test for a function?\nDave A unit test calls a function with some arguments and checks whether the func-\ntion returns the expected value.\nJoe Exactly! Now, let’s adapt it to the context of data schema and DOP. Let’s say you\nhave a function with a schema for their arguments and for their return value.\n--- Page 291 ---\n12.5 Automatic generation of schema-based unit tests 263\nDave OK.\nJoe Here’s the flow of a schema-based unit test. We call the function with random\narguments that conform to the schema of the function arguments. Then, we\ncheck whether the function returns a value that conforms to the schema of the\nreturn value. Here, let me diagram it.\nJoe goes to the whiteboard. He draws the diagram in figure 12.3.\nGeneraterandom datathat conforms toinput schema\nExecute the function The input\nis random.\nYes No\nOutput conforms to output schema\nTest passes Test fails\nFigure 12.3 The flow of\na schema-based unit test\nDave How do you generate random data that conforms to a schema?\nJoe Using a tool like JSON Schema Faker. For example, let’s start with a simple\nschema: the schema for a UUID. Let me show you how to generate random\ndata that conforms to the schema.\n NOTE You’ll find more information about JSON Schema Faker at https://github\n.com/json-schema-faker/json-schema-faker.\nJoe types on the keyboard for a bit. He then shows the code to generate random data to\nDave and Theo.\nListing12.19 Generating random data that conforms to a UUID schema\nvar uuidSchema = {\n\"type\": \"string\",\n\"pattern\": \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}\" +\n\"-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\n};\nJSONSchemaFaker.generate(uuidSchema);\n// → \"7aA8CdF3-14DF-9EF5-1A19-47dacdB16Fa9\"\nDave executes the code snippet a couple of times, and indeed, on each evaluation, it returns\na different UUID.\nDave Very cool! Let me see how it works with more complex schemas like the cata-\nlog schema.\n--- Page 292 ---\n264 CHAPTER 12 Advanced data validation\nWhen Dave calls JSONSchemaFaker.generate with the catalog schema, he gets some\nquite long random data. He’s a bit surprised by the results.\nListing12.20 Generating random data that conforms to the catalog schema\n{\n\"booksByIsbn\": {\n\"Excepteur7\": {\n\"title\": \"elit veniam anim\",\n\"isbn\": \"5419903-3563-7\",\n\"authorIds\": [\n\"vfbzqahmuemgdegkzntfhzcjhjrbgfoljfzogfuqweggchum\",\n\"inxmqh-\",\n],\n\"bookItems\": {\n\"ullamco5\": {\n\"id\": \"f7dac8c3-E59D-bc2E-7B33-C27F3794E2d6\",\n\"libId\": \"4jtbj7q7nrylfu114m\",\n\"purchaseDate\": \"2001-08-01\",\n\"isLent\": false\n},\n\"culpa_3e\": {\n\"id\": \"423DCdDF-CDAe-2CAa-f956-C6cd9dA8054b\",\n\"libId\": \"6wcxbh\",\n\"purchaseDate\": \"1970-06-24\",\n\"isLent\": true\n}\n},\n\"publicationYear\": 1930,\n\"publisher\": \"sunt do nisi\"\n},\n\"aliquip_d7\": {\n\"title\": \"aute\",\n\"isbn\": \"348782167518177\",\n\"authorIds\": [\"owfgtdxjbiidsobfgvjpjlxuabqpjhdcqmmmrjb-ezrsz-u\"],\n\"bookItems\": {\n\"ipsum__0b\": {\n\"id\": \"6DfE93ca-DB23-5856-56Fd-82Ab8CffEFF5\",\n\"libId\": \"bvjh0p2p2666vs7dd\",\n\"purchaseDate\": \"2018-03-30\",\n\"isLent\": false\n}\n},\n\"publisher\": \"ea anim ut ex id\",\n\"publicationYear\": 1928\n}\n},\n\"authorsById\": {\n\"labore_b88\": {\n\"id\": \"adipisicing nulla proident\",\n\"name\": \"culpa in minim\",\n\"bookIsbns\": [\n\"6243029--7\",\n\"5557199424742986\"\n]",
        "sections_found": []
      },
      "accurate_page_range": "262-292"
    },
    {
      "text": "- 10.2 Storing data in the database",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "10 Database operations",
      "raw_line": "- 10.2 Storing data in the database (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 84,
      "chapter_info": {
        "page": 262,
        "title": "Database operations",
        "pattern_matched": "Chapter 10",
        "text_preview": "234 CHAPTER 11 Web services\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physic"
      },
      "chapter_sections": {
        "start_page": 262,
        "end_page": 292,
        "content": "\n--- Page 262 ---\n234 CHAPTER 11 Web services\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nTheo Yes! I think we now have all the pieces to enrich our search results.\n11.6 Search result enrichment in action\nJoe Can you write the steps of the enrichment data flow?\nTheo Sure.\nTheo goes to the whiteboard. He takes a moment to gather his thoughts, and then erases\nenough space so there’s room to list the steps.\nThe steps for the search result enrichment data flow\n1 Receive a request from a client.\n2 Extract from the client’s request the query and the fields to fetch from Open\nLibrary.\n3 Retrieve from the database the books that match the query.\n4 Fetch information from Open Library for each ISBN that match the query.\n5 Extract from Open Library responses for the required fields.\n6 Combine book information from the database with information from Open\nLibrary.\n7 Send the response to the client.\nJoe Perfect! Would you like to try to implement it?\nTheo I think I’ll start with the implementation of the book retrieval from the data-\nbase. It’s quite similar to what we did last month.\n NOTE See chapter 10 for last month’s lesson.\nJoe Actually, it’s even simpler because you don’t need to join tables.\nTheo That’s right, I need values only for the isbn and available columns.\nTheo works for a bit in his IDE. He begins with the book retrieval from the database.\nListing11.14 Retrieving books whose title matches a query\nvar dbSearchResultSchema = {\n\"type\": \"array\",\n\"items\": {\n--- Page 263 ---\n11.6 Search result enrichment in action 235\n\"type\": \"object\",\n\"required\": [\"isbn\", \"available\"],\n\"properties\": {\n\"isbn\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"}\n}\n}\n};\nclass CatalogDB {\nstatic matchingBooks(title) {\nvar matchingBooksQuery = `\nSELECT isbn, available\nFROM books\nWHERE title = like '%$1%';\n`;\nvar books = dbClient.query(catalogDB, matchingBooksQuery, [title]);\nif(!ajv.validate(dbSearchResultSchema, books)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from the database: \" +\nerrors;\n}\nreturn books;\n}\n}\nJoe So far, so good...\nTheo Next, I’ll go with the implementation of the retrieval of book information from\nOpen Library for several books. Unfortunately, the Open Library Books API\ndoesn’t support querying several books at once. I’ll need to send one request\nper book.\nJoe That’s a bit annoying. Let’s make our life easier and pretend that _.map works\nwith asynchronous functions. In real life, you’d need something like Promise\n.all in order to send the requests in parallel and combine the responses.\nTheo OK, then it’s quite straightforward. I’ll take the book retrieval code and add a\nmultipleBookInfo function that maps over bookInfo.\nTheo looks over the book retrieval code in listing 11.9 and then concentrates as he types\ninto his IDE. When he’s done, he shows the result in listing 11.15 to Joe.\nListing11.15 Retrieving book information from Open Library for several books\nclass OpenLibraryDataSource {\nstatic rawBookInfo(isbn) {\nvar url = `https:/ /openlibrary.org/isbn/${isbn}.json`;\nvar jsonString = fetchResponseBody(url);\nreturn JSON.parse(jsonString);\n}\nstatic bookInfo(isbn, requestedFields) {\nvar relevantFields = [\"title\", \"full_title\",\n\"subtitle\", \"publisher\",\n\"publish_date\", \"weight\",\n--- Page 264 ---\n236 CHAPTER 11 Web services\n\"physical_dimensions\", \"genre\",\n\"subjects\", \"number_of_pages\"];\nvar rawInfo = rawBookInfo(isbn);\nif(!ajv.validate(dbSearchResultSchema, bookInfoSchema)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from Open Books API: \" +\nerrors;\n}\nvar relevantInfo =\n_.pick(_.pick(rawInfo, relevantFields), requestedFields);\nreturn _.set(relevantInfo, \"isbn\", isbn);\n}\nstatic multipleBookInfo(isbns, fields) {\nreturn _.map(function(isbn) {\nreturn bookInfo(isbn, fields);\n}, isbns);\n}\n}\nJoe Nice! Now comes the fun part: combining information from several data sources.\nTheo Yeah. I have two arrays in my hands: one with book information from the data-\nbase and one with book information from Open Library. I somehow need to\njoin the arrays, but I’m not sure I can assume that the positions of the book\ninformation are the same in both arrays.\nJoe What would you like to have in your hands?\nTheo I wish I had two hash maps.\nJoe And what would the keys in the hash maps be?\nTheo Book ISBNs.\nJoe Well, I have good news for you: your wish is granted!\nTheo How?\nJoe Lodash provides a function named _.keyBy that transforms an array into a map.\nTheo I can’t believe it. Can you show me an example?\nJoe Sure. Let’s call _.keyBy on an array with two books.\nListing11.16 Transforming an array into a map with _.keyBy\nvar books = [\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"isbn\": \"978-1982137274\",\n\"available\": true\n},\n{\n\"title\": \"The Power of Habit\",\n\"isbn\": \"978-0812981605\",\n\"available\": false\n}\n];\n_.keyBy(books, \"isbn\");\n--- Page 265 ---\n11.6 Search result enrichment in action 237\nJoe And here’s the result.\nListing11.17 The result of keyBy\n{\n\"978-0812981605\": {\n\"available\": false,\n\"isbn\": \"978-0812981605\",\n\"title\": \"The Power of Habit\"\n},\n\"978-1982137274\": {\n\"available\": true,\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\"\n}\n}\nTheo keyBy is awesome!\nJoe Don’t exaggerate, my friend; _.keyBy is quite similar to _.groupBy. The\nonly difference is that _.keyBy assumes that there’s only one element in\neach group.\nTheo I think that, with _.keyBy, I’ll be able to write a generic joinArrays function.\nJoe I’m glad to see you thinking in terms of implementing business logic through\ngeneric data manipulation functions.\nTIP Many parts of the business logic can be implemented through generic data\nmanipulation functions.\nTheo The joinArrays function needs to receive the arrays and the field name for\nwhich we decide the two elements that need to be combined, for instance,\nisbn.\nJoe Remember, in general, it’s not necessarily the same field name for both arrays.\nTheo Right, so joinArrays needs to receive four arguments: two arrays and two\nfield names.\nJoe Go for it! And, please, write a unit test for joinArrays.\nTheo Of course...\nTheo works for a while and produces the code in listing 11.18. He then types the unit test\nin listing 11.19.\nListing11.18 A generic function for joining arrays\nfunction joinArrays(a, b, keyA, keyB) {\nvar mapA = _.keyBy(a, keyA);\nvar mapB = _.keyBy(b, keyB);\nvar mapsMerged = _.merge(mapA, mapB);\nreturn _.values(mapsMerged);\n}\n--- Page 266 ---\n238 CHAPTER 11 Web services\nListing11.19 A unit test for joinArrays\nvar dbBookInfos = [\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true\n},\n{\n\"isbn\": \"978-0812981605\",\n\"title\": \"The Power of Habit\",\n\"available\": false\n}\n];\nvar openLibBookInfos = [\n{\n\"isbn\": \"978-0812981605\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432,\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"The Power of Habit\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n],\n}\n];\nvar joinedArrays = [\n{\n\"available\": true,\n\"isbn\": \"978-1982137274\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\",\n],\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"title\": \"The Power of Habit\",\n},\n{\n\"available\": false,\n\"isbn\": \"978-0812981605\",\n\"number_of_pages\": 432,\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"title\": \"7 Habits of Highly Effective People\",\n},\n]\n--- Page 267 ---\n11.6 Search result enrichment in action 239\n_.isEqual(joinedArrays,\njoinArrays(dbBookInfos, openLibBookInfos, \"isbn\", \"isbn\"));\nJoe Excellent! Now, you are ready to adjust the last piece of the extended search\nresult endpoint.\nTheo That’s quite easy. We fetch data from the database and from Open Library and\njoin them.\nTheo works quite rapidly. He then shows Joe the code.\nListing11.20 Search books and enriched book information\nclass Catalog {\nstatic enrichedSearchBooksByTitle(searchPayload) {\nif(!ajv.validate(searchBooksRequestSchema, searchPayload)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid request:\" + errors;\n}\nvar title = _.get(searchPayload, \"title\");\nvar fields = _.get(searchPayload, \"fields\");\nvar dbBookInfos = CatalogDataSource.matchingBooks(title);\nvar isbns = _.map(dbBookInfos, \"isbn\");\nvar openLibBookInfos =\nOpenLibraryDataSource.multipleBookInfo(isbns, fields);\nvar res = joinArrays(dbBookInfos, openLibBookInfos);\nif(!ajv.validate(searchBooksResponseSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid response:\" + errors;\n}\nreturn res;\n}\n}\nNow comes the tricky part. Theo takes a few moments to meditate about the simplicity of\nthe code that implements the extended search endpoint. He thinks about how classes are\nmuch less complex when we use them only to aggregate stateless functions that operate on\nsimilar domain entities and then goes to work plotting the code.\nListing11.21 Schema for the extended search endpoint (Open Books API part)\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n--- Page 268 ---\n240 CHAPTER 11 Web services\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing11.22 Extended search endpoint (Open Books API part)\nvar ajv = new Ajv({allErrors: true});\nclass OpenLibraryDataSource {\nstatic rawBookInfo(isbn) {\nvar url = `https:/ /openlibrary.org/isbn/${isbn}.json`;\nvar jsonString = fetchResponseBody(url);\nreturn JSON.parse(jsonString);\n}\nstatic bookInfo(isbn, requestedFields) {\nvar relevantFields = [\"title\", \"full_title\",\n\"subtitle\", \"publisher\",\n\"publish_date\", \"weight\",\n--- Page 269 ---\n11.6 Search result enrichment in action 241\n\"physical_dimensions\", \"genre\",\n\"subjects\", \"number_of_pages\"];\nvar rawInfo = rawBookInfo(isbn);\nif(!ajv.validate(bookInfoSchema, rawInfo)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from Open Books API: \" +\nerrors;\n}\nvar relevantInfo = _.pick(\n_.pick(rawInfo, relevantFields),\nrequestedFields);\nreturn _.set(relevantInfo, \"isbn\", isbn);\n}\nstatic multipleBookInfo(isbns, fields) {\nreturn _.map(function(isbn) {\nreturn bookInfo(isbn, fields);\n}, isbns);\n}\n}\nListing11.23 Extended search endpoint (database part)\nvar dbClient;\nvar dbSearchResultSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"isbn\", \"available\"],\n\"properties\": {\n\"isbn\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"}\n}\n}\n};\nclass CatalogDB {\nstatic matchingBooks(title) {\nvar matchingBooksQuery = `\nSELECT isbn, available\nFROM books\nWHERE title = like '%$1%';\n`;\nvar books = dbClient.query(catalogDB, matchingBooksQuery, [title]);\nif(!ajv.validate(dbSearchResultSchema, books)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from the database: \"\n+ errors;\n}\nreturn books;\n}\n}\n--- Page 270 ---\n242 CHAPTER 11 Web services\nListing11.24 Schema for the implementation of the extended search endpoint\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"type\": [\n\"title\",\n\"full_title\",\n\"subtitle\",\n\"publisher\",\n\"publish_date\",\n\"weight\",\n\"physical_dimensions\",\n\"number_of_pages\",\n\"subjects\",\n\"publishers\",\n\"genre\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksResponseSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nListing11.25 Schema for the extended search endpoint (combines the pieces)\nclass Catalog {\nstatic enrichedSearchBooksByTitle(request) {\n--- Page 271 ---\n11.6 Search result enrichment in action 243\nif(!ajv.validate(searchBooksRequestSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid request:\" + errors;\n}\nvar title = _.get(request, \"title\");\nvar fields = _.get(request, \"fields\");\nvar dbBookInfos = CatalogDataSource.matchingBooks(title);\nvar isbns = _.map(dbBookInfos, \"isbn\");\nvar openLibBookInfos =\nOpenLibraryDataSource.multipleBookInfo(isbns, fields);\nvar response = joinArrays(dbBookInfos, openLibBookInfos);\nif(!ajv.validate(searchBooksResponseSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid response:\" + errors;\n}\nreturn response;\n}\n}\nclass Library {\nstatic searchBooksByTitle(payloadBody) {\nvar payloadData = JSON.parse(payloadBody);\nvar results = Catalog.searchBooksByTitle(payloadData);\nreturn JSON.stringify(results);\n}\n}\nTIP Classes are much less complex when we use them as a means to aggregate state-\nless functions that operate on similar domain entities.\nJoe interrupts Theo’s meditation moment. After looking over the code in the previous list-\nings, he congratulates Theo.\nJoe Excellent job, my friend! By the way, after reading The Power of Habit, I quit\nchewing my nails.\nTheo Wow! That’s terrific! Maybe I should read that book to overcome my habit of\ndrinking too much coffee.\nJoe Thanks, and good luck with the coffee habit.\nTheo I was supposed to call Nancy later today with an ETA for the Open Library\nBook milestone. I wonder what her reaction will be when I tell her the feature\nis ready.\nJoe Maybe you should tell her it’ll be ready in a week, which would give you time to\nbegin work on the next milestone.\n--- Page 272 ---\n244 CHAPTER 11 Web services\nDelivering on time\nJoe was right! Theo recalls Joe’s story about the young woodcutter and the old man. Theo\nwas able to learn DOP and deliver the project on time! He’s pleased that he took the time\n“to sharpen his saw and commit to a deeper level of practice.”\n NOTE If you are unable to recall the story or if you missed it, check out the opener\nto part 2.\nThe Klafim project is a success. Nancy is pleased. Theo’s boss is satisfied. Theo got pro-\nmoted. What more can a person ask for?\nTheo remembers his deal with Joe. As he strolls through the stores of the Westfield San\nFrancisco Center to look for a gift for each of Joe’s children, Neriah and Aurelia, he is\nfilled with a sense of purpose and great pleasure. He buys a DJI Mavic Air 2 drone for Ner-\niah, and the latest Apple Airpod Pros for Aurelia. He also takes this opportunity to buy a\nnecklace and a pair of earrings for his wife, Jane. It’s a way for him to thank her for having\nendured his long days at work since the beginning of the Klafim project.\n NOTE The story continues in the opener of part 3.\nSummary\n We build the insides of our systems like we build the outsides.\n Components inside a program communicate via data that is represented as\nimmutable data collections in the same way as components communicate via\ndata over the wire.\n In DOP, the inner components of a program are loosely coupled.\n Many parts of business logic can be implemented through generic data manipu-\nlation functions. We use generic functions to\n– Implement each step of the data flow inside a web service.\n– Parse a request from a client.\n– Apply business logic to the request.\n– Fetch data from external sources (e.g., database and other web services).\n– Apply business logic to the responses from external sources.\n– Serialize response to the client.\n Classes are much less complex when we use them as a means to aggregate\ntogether stateless functions that operate on similar domain entities.\nLodash functions introduced in this chapter\nFunction Description\nkeyBy(coll, f) Creates a map composed of keys generated from the results of running each ele-\nment of coll through f; the corresponding value for each key is the last element\nresponsible for generating the key.\n--- Page 273 ---\nPart 3\nMaintainability\nA\nfter a month, the Klafim project enters what Alabatross calls the mainte-\nnance phase. Small new features need to be added on a weekly basis. Bugs need to be\nfixed; nothing dramatic....\nMonica, Theo’s boss, decides to allocate Dave to the maintenance of the Klafim\nproject. It makes sense. Over the last few months, Dave has demonstrated a great atti-\ntude of curiosity and interest, and he has solid programming skills. Theo sets up a\nmeeting with Joe and Dave, hoping that Joe will be willing to teach DOP to Dave so\nthat he can continue to advance the good work he’s already done on Klafim. Theo\nand Dave place a conference call to Joe.\nTheo Hi, Joe. Will you have time over the next few weeks to teach Dave the\nprinciples of DOP?\nJoe Yes, but I prefer not to.\nDave Why? Is it because I don’t have enough experience in software develop-\nment? I can guarantee you that I’m a fast learner.\nJoe It has nothing to do with your experience, Dave.\nTheo Why not then?\nJoe Theo, I think that you could be a great mentor for Dave.\nTheo But, I don’t even know all the parts of DOP!\nDave Come on! No false modesty between us, my friend.\nJoe Knowledge is never complete. As the great Socrates used to say, “The more\nI know, the more I realize I know nothing.” I’m confident you will be able\nto learn the missing parts by yourself and maybe even invent some.\nTheo How will I be able to invent missing parts?\n--- Page 274 ---\n246 PART 3 Maintainability\nJoe You see, DOP is such a simple paradigm that it’s fertile material for innovation.\nPart of the material I taught you I learned from others, and part of it was an\ninvention of mine. If you keep practicing DOP, I’m quite sure you, too, will\ncome up with some inventions of your own.\nTheo What do you say Dave? Are you willing to learn DOP from me?\nDave Definitely!\nTheo Joe, will you be continue to be available if we need your help from time to time?\nJoe Of course!\n--- Page 275 ---\nAdvanced data\nvalidation\nA self-made gift\nThis chapter covers\n Validating function arguments\n Validating function return values\n Data validation beyond static types\n Automatic generation of data model diagrams\n Automatic generation of schema-based unit tests\nAs the size of a code base grows in a project that follows DOP principles, it becomes\nharder to manipulate functions that receive and return only generic data. It is hard\nto figure out the expected shape of the function arguments, and when we pass\ninvalid data, we don’t get meaningful errors.\nUntil now, we have illustrated how to validate data at system boundaries. In this\nchapter, we will illustrate how to validate data when it flows inside the system by\ndefining data schemas for function arguments and their return values. This allows\nus to make explicit the expected shape of function arguments, and it eases develop-\nment. We gain some additional benefits from this endeavor, such as automatic gen-\neration of data model diagrams and schema-based unit tests.\n247\n--- Page 276 ---\n248 CHAPTER 12 Advanced data validation\n12.1 Function arguments validation\nDave’s first task is to implement a couple of new HTTP endpoints to download the catalog\nas a CSV file, search books by author, and rate the books. Once he is done with the tasks,\nDave calls Theo for a code review.\n NOTE The involvement of Dave in the Klafim project is explained in the opener for\npart 3. Please take a moment to read the opener if you missed it.\nTheo Was it difficult to get your head around the DOP code?\nDave Not so much. I read your notes of the meetings with Joe, and I must admit, the\ncode is quite simple to grasp.\nTheo Cool!\nDave But there is something that I can’t get used to.\nTheo What’s that?\nDave I’m struggling with the fact that all the functions receive and return generic\ndata. In OOP, I know the expected shape of the arguments for each and every\nfunction.\nTheo Did you validate data at system boundaries, like I have done?\nDave Absolutely. I defined a data schema for every additional user request, database\nquery, and external service response.\nTheo Nice!\nDave Indeed, when the system runs in production, it works well. When data is valid,\nthe data flows through the system, and when data is invalid, we are able to dis-\nplay a meaningful error message to the user.\nTheo What’s the problem then?\nDave The problem is that during development, it’s hard to figure out the expected\nshape of the function arguments. And when I pass invalid data by mistake, I\ndon’t get clear error messages.\nTheo I see. I remember that when Joe showed me how to validate data at system\nboundaries, I raised this concern about the development phase. Joe told me\nthen that we validate data as it flows inside the system exactly like we validate data\nat system boundaries: we separate between data schema and data representation.\nDave Are we going to use JSON Schema also?\nTheo Yes.\nDave Cool.... I like JSON Schema.\nTheo The main purpose of data validation at system boundaries is to prevent invalid\ndata from getting into the system, whereas the main purpose of data validation\ninside the system is to make it easier to develop the system. Here, let me draw a\ntable on the whiteboard for you to visualize this (table 12.1).\nTable 12.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\n--- Page 277 ---\n12.1 Function arguments validation 249\nDave By making it easier to develop the system, do you mean to help the developers\nunderstand the expected shape of function arguments as in OOP?\nTheo Exactly.\nDave But I’m impatient.... Will you help me figure out how to validate the argu-\nments of the function that implements a book search?\nTheo Let me see the code of the implementation, and I’ll do my best.\nDave We have two implementations of a book search: one where library data lives\nin memory from the prototype phase and one where library data lives in the\ndatabase.\nTheo I think that the schema for library data in memory is going to be more interest-\ning than the schema for library data in the database, as the book search func-\ntion receives catalog data in addition to the query.\nDave When you say more interesting data schema, you mean more difficult to write?\nTheo More difficult to write, but it’s also more insightful.\nDave Then let’s go with library data in memory. The code for Catalog.search-\nBooksByTitle from the prototype phase would look like this.\nDave pulls up some code on his laptop. He shows it to Theo.\nListing12.1 The implementation of search without data validation\nclass Catalog {\nstatic authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nreturn bookInfo;\n}\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\n--- Page 278 ---\n250 CHAPTER 12 Advanced data validation\nTheo Dave, please remind me of the expected shapes for catalogData and query.\nDave Sure. query should be a string, and catalogData should be a map that con-\nforms to the catalog data model.\nTheo What is the catalog data model?\nDave Let me see. I have seen a diagram of it somewhere.\nDave rummages around a bit in his folder for Klafim’s Library Management System. Find-\ning what he’s looking for, he draws the diagram in figure 12.1 on the whiteboard.\nC Catalog\nbooksByIsbn: {Book}\nauthorsById: {Author}\nC Book\nC Author\ntitle : String\npublicationYear: Number id: String\nisbn: String name: String\nauthorlds: [String] booklsbns: [String]\nbookltems: [Bookltem]\nC Bookltem\nid: String\nlibld: String\npurchaseDate: String\nisLent: Boolean\nFigure 12.1 The catalog data model\n NOTE The schemas for this book use JSON Schema version 2020-12.\nTheo Can you write a JSON Schema for the catalog data model?\nDave Am I allowed to use internal variables for book and author schemas, or do I\nhave to nest all the schemas inside the catalog schema?\nTheo JSON Schema is part of the code. If you feel that using internal variables would\nmake the code more readable, go for it.\nDave OK. Now I need the JSON Schema gift that Joe gave you.\nTheo picks up a well-worn piece of paper that is a bit torn and quite wrinkled. He gives\nDave the JSON Schema cheat sheet.\nListing12.2 JSON Schema cheat sheet\nAt the root level,\n{\ndata is an array.\n\"type\": \"array\",\n\"items\": { Each element of the array is a map.\n\"type\": \"object\",\nThe properties of each field in the map\n\"properties\": {\n--- Page 279 ---\n12.1 Function arguments validation 251\n\"myNumber\": {\"type\": \"number\"},\nmyNumber\n\"myString\": {\"type\": \"string\"}, myEnum is an enumeration\nis a number.\n\"myEnum\": {\"enum\": [\"myVal\", \"yourVal\"]}, value with two possibilities,\nmyString is \"myBool\": {\"type\": \"boolean\"} \"myVal\" and \"yourVal\".\na string. },\n\"required\": [\"myNumber\", \"myString\"], myBool is a boolean.\n\"additionalProperties\": false\n} The mandatory fields in the map\n} We don’t allow fields that are not are myNumber and myString.\nexplicitly mentioned in the schema. Other fields are optional.\nDave I think I’ll start with the author schema. It seems simpler than the book schema.\nQuickly composing the code, Dave shows Theo the author schema. Dave, still new to DOP,\nlooks for Theo’s reaction.\nListing12.3 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"id\", \"name\", \"bookIsbns\"],\n\"properties\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nTheo Well done! Let’s move on to the book schema now.\nDave I think I am going to store the book item schema in a variable.\nListing12.4 The book item schema\nvar bookItemSchema = {\n\"type\": \"object\",\n\"properties\":{\n\"id\": {\"type\": \"string\"},\n\"libId\": {\"type\": \"string\"},\n\"purchaseDate\": {\"type\": \"string\"},\n\"isLent\": {\"type\": \"boolean\"}\n},\n\"required\": [\"id\", \"libId\", \"purchaseDate\", \"isLent\"]\n};\nvar bookSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorIds\", \"bookItems\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publicationYear\": {\"type\": \"integer\"},\n--- Page 280 ---\n252 CHAPTER 12 Advanced data validation\n\"isbn\": {\"type\": \"string\"},\n\"authorIds\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"bookItems\": {\n\"type\": \"array\",\n\"items\": bookItemSchema\n}\n}\n};\nTIP When you define a complex data schema, it is advisable to store nested schemas\nin variables to make the schemas easier to read.\nTheo Why didn’t you include publicationYear in the list of required fields in the\nbook schema?\nDave Because, for some books, the publication year is missing. Unlike in OOP, it will\nthen be easy to deal with nullable fields.\nTheo Excellent! And now, please tackle the final piece, the catalog schema.\nDave Here I have a problem. The catalog should be a map with two fields, books-\nByIsbn and authorsById. Both values should be indexes, represented in the\nmodel diagram with curly braces. I have no idea how to define the schema for\nan index.\nTheo Do you remember how we represent indexes in DOP?\nDave Yes, indexes are represented as maps.\nTheo Right, and what’s the difference between those maps and the maps that we use\nfor records?\nDave For records, we use maps where the names of the fields are known and the val-\nues can have different shapes. For indexes, we use maps where the names of\nthe fields are unknown and the values have a common shape.\nTheo Right. We call the maps for records heterogeneous maps and the maps for\nindexes homogeneous maps.\nTIP In DOP, records are represented as heterogeneous maps, whereas indexes are repre-\nsented as homogeneous maps.\nDave Then how do we define the schema of an homogeneous map in JSON Schema?\nTheo I don’t know. Let’s check the JSON Schema online documentation.\n NOTE See https://json-schema.org/ to access the online documentation for JSON\nSchema version 2020-12.\nAfter a couple of minutes of digging into the JSON Schema online documentation, Theo\nfinds a piece about additionalProperties. He studies the information for a while before\nmaking up his mind.\n--- Page 281 ---\n12.1 Function arguments validation 253\nTheo I think we could use additionalProperties. Here’s the JSON Schema for an\nhomogeneous map where the values are numbers.\nListing12.5 The JSON Schema for an homogeneous map with values as numbers\n{\n\"type\": \"object\",\n\"additionalProperties\": {\"type\": \"number\"}\n}\nDave I thought that additionalProperties was supposed to be a boolean and that\nit was used to allow or forbid properties not mentioned in the schema.\nTheo That’s correct. Usually additionalProperties is a boolean, but the documen-\ntation says it could also be a map that defines a schema. In that case, it means\nproperties not mentioned in the schema should have the value of the schema\nassociated with additionalProperties.\nDave I see. But what does that have to do with homogeneous maps?\nTheo Well, a homogeneous map could be seen as a map with no predefined proper-\nties, where all the additional properties are of an expected type.\nDave Tricky!\nTIP In JSON Schema, homogeneous string maps have type: object with no\nproperties and additionalProperties associated to a schema.\nTheo Indeed. Now, let me show you what the catalog schema looks like.\nTheo types briefly on his laptop. He shows Dave the catalog schema.\nListing12.6 The schema for catalog data\nvar catalogSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"booksByIsbn\": {\n\"type\": \"object\",\n\"additionalProperties\": bookSchema\n},\n\"authorsById\": {\n\"type\": \"object\",\n\"additionalProperties\": authorSchema\n}\n},\n\"required\": [\"booksByIsbn\", \"authorsById\"]\n};\nDave Are we ready to plug the catalog and the query schema into the Catalog\n.searchBooksByTitle implementation?\nTheo We could, but I think we can do better by defining a single schema that com-\nbines both the catalog and query schemas.\nDave How would we combine two schemas into a single schema?\n--- Page 282 ---\n254 CHAPTER 12 Advanced data validation\nTheo Do you know what a tuple is?\nDave I think I know, but I can’t define it formally.\nTheo A tuple is an array where the size is fixed, and the elements can be of different\nshapes.\nDave OK. So, how do we define tuples in JSON Schema?\nOnce again, Theo explores the JSON Schema online documentation. Fortunately, he has\nbookmarked the page, and in no time at all, finds the information he needs.\nTheo I found it! We use prefixItems in the definition of a tuple made of a string\nand a number, for instance.\nTheo types more code on his laptop. When he finishes, he shows Dave the schema for a\ntuple.\nListing12.7 The schema for a tuple made of a string and a number\n{\n\"type\": \"array\",\n\"prefixItems\": [\n{ \"type\": \"string\" },\n{ \"type\": \"number\" }\n]\n}\nDave I see. And how would you define the schema for the arguments of Catalog\n.searchBooksByTitle?\nTheo Well, it’s a tuple of size 2, where the first element is a catalog and the second\nelement is a string.\nDave Something like this schema?\nListing12.8 The schema for the arguments of Catalog.searchBooksByTitle\nvar searchBooksArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\ncatalogSchema,\n{ \"type\": \"string\" },\n]\n};\nTheo Exactly!\nDave Now that we have the schema for the arguments, how do we plug it into the\nimplementation of search books?\nTheo That’s similar to the way we validate data at system boundaries. The main dif-\nference is that the data validation for data that flows inside the system should\nrun only at development time, and it should be disabled when the code runs in\nproduction.\nDave Why?\n--- Page 283 ---\n12.2 Return value validation 255\nTheo Because that data has been already validated up front at a system boundary.\nValidating it again on a function call is superfluous, and it would impact\nperformance.\nDave When you say development time, does that include testing and staging\nenvironments?\nTheo Yes, all the environments besides production.\nDave I see. It’s like assertions in Java. They are disabled in production code.\nTIP Data validation inside the system should be disabled in production.\nTheo Exactly. For now, I am going to assume that we have a dev function that returns\ntrue when the code runs in the development environment and false when it\nruns in production. Having said that, take a look at this code.\nListing12.9 Implementation of search with validation of function arguments\nCatalog.searchBooksByTitle = function(catalogData, query) {\nif(dev()) {\nvar args = [catalogData, query];\nif(!ajv.validate(searchBooksArgsSchema, args)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle called with invalid arguments: \" +\nerrors);\nThe implementation of dev() depends on the run-time\n}\nenvironment: it returns true when the code runs in dev\n}\nenvironments and false when it runs in production.\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nDave Do you think we should validate the arguments of all the functions?\nTheo No. I think we should treat data validation like we treat unit tests. We should\nvalidate function arguments only for functions for whom we would write unit\ntests.\nTIP Treat data validation like unit tests.\n12.2 Return value validation\nDave Do you think it would make sense to also validate the return value of functions?\nTheo Absolutely.\nDave Cool. Let me try to write the JSON Schema for the return value of Catalog\n.searchBooksByTitle.\n--- Page 284 ---\n256 CHAPTER 12 Advanced data validation\nAfter a few minutes, Dave comes up with the schema. Taking a deep breath, then releasing\nit, he shows the code to Theo.\nListing12.10 The schema for the return value of Catalog.searchBooksByTitle\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorNames\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"isbn\": {\"type\": \"string\"},\n\"authorNames\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n};\nTheo Well done! Now, would you like to try adding return value validation to the\ncode of Catalog.searchBooksByTitle?\nDave Sure.\nDave works for a bit in his IDE. A bit more confident this time, he shows the result to Theo.\nListing12.11 Search with data validation for both input and output\nCatalog.searchBooksByTitle = function(catalogData, query) {\nif(dev()) {\nif(!ajv.validate(searchBooksArgsSchema, [catalogData, query])) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle called with invalid arguments: \" +\nerrors);\n}\n}\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nif(dev()) {\nif(!ajv.validate(searchBooksResponseSchema, bookInfos)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle returned an invalid value: \" +\nerrors);\n}\n}\n--- Page 285 ---\n12.3 Advanced data validation 257\nreturn bookInfos;\n};\nTheo Excellent! Now we need to figure out how to deal with advanced data validation.\n12.3 Advanced data validation\nDave What do you mean by advanced data validation?\nTheo I mean going beyond static types.\nDave Could you give me an example?\nTheo Sure. Take, for instance, the publication year of a book. It’s an integer, but\nwhat else could you say about this number?\nDave It has to be positive. It would say it’s a positive integer.\nTheo Come on, Dave! Be courageous, go beyond types.\nDave I don’t know. I would say it’s a number that should be higher than 1900. I\ndon’t think it makes sense to have a book that is published before 1900.\nTheo Exactly. And what about the higher limit?\nDave I’d say that the publication year should be less than the current year.\nTheo Very good! I see that JSON Schema supports number ranges. Here is how we\ncan write the schema for an integer that represents a year and should be\nbetween 1900 and 2021.\nListing12.12 The schema for an integer between 1900 and 2021\nvar publicationYearSchema = {\n\"type\": \"integer\",\n\"minimum\": 1900,\n\"maximum\": 2021\n};\nDave Why isn’t this kind of data validation possible in OOP?\nTheo I’ll let you think about that for a moment.\nDave I think have it! In DOP, data validation is executed at run time, while static\ntype validation in OOP is executed at compile time. At compile time, we only\nhave information about static types; at run time, we have the data itself. That’s\nwhy in DOP data validation, it’s possible to go beyond types.\n NOTE Of course, it’s also possible in traditional OOP to write custom run-time data\nvalidation. Here, though, we are comparing data schema with static types.\nTheo You got it! Now, let me show you how to write the schema for a string that\nshould match a regular expression.\n NOTE See http://mng.bz/OGNP for the JavaScript Guide to regular expressions.\nTheo Let’s take for example the book ID. I am assuming it must be a UUID.\nDave Right.\nTheo Can you write the regular expression for a valid UUID?\n--- Page 286 ---\n258 CHAPTER 12 Advanced data validation\nDave googles “UUID regex” and finds something he thinks just might work. He shows the\nregular expression to Theo.\nListing12.13 The regular expression for a valid UUID\n[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\nDave Now, how do we plug a regular expression into a JSON Schema?\nTheo While you were looking for the UUID regular expression, I read about the\npattern field. Here’s how we can plug the UUID regular expression into a\nJSON Schema.\nListing12.14 The schema for a UUID\nvar uuidSchema = {\n\"type\": \"string\",\n\"pattern\": \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}\" +\n\"-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\n};\nDave Nice! Let me improve the catalog schema and refine the schema for purchase-\nDate, isbn, libId, and authorId with regular expressions.\nTheo Before you do that, though, let me tell you something I read about regular\nexpressions: some of them are predefined. For example, there is a predefined\nregular expression for dates.\nDave How does it work?\nTheo With the help of the format field.\n NOTE According to JSON Schema specification, format is just for annotation and\ndoesn’t affect validation. But in practice, JSON Schema validation libraries use format\nalso for validation.\nTheo moves to his laptop. He inputs the schema for a date and shows it to Dave.\nListing12.15 The schema for a date\n{\n\"type\": \"string\",\n\"format\": \"date\"\n}\nTIP In DOP, data validation goes beyond static types (e.g., number ranges, regular\nexpressions, and so on).\nDave Very cool! Do I have all the information I need in order to refine the catalog\nschema?\nTheo Yes, go for it!\nIt takes Dave a bit of time to write the regular expressions for isbn, authorId, and libId.\nBut with the help of Google (again) and a bit of simplification, Dave comes up with the\nschema in listings 12.16 and 12.17.\n--- Page 287 ---\n12.3 Advanced data validation 259\nListing12.16 The refined schema of the catalog data (Part 1)\nvar isbnSchema = {\n\"type\": \"string\",\n\"pattern\": \"^[0-9-]{10,20}$\"\n};\nvar libIdSchema = {\n\"type\": \"string\",\n\"pattern\": \"^[a-z0-9-]{3,20}$\"\n};\nvar authorIdSchema ={\n\"type\": \"string\",\n\"pattern\": \"[a-z-]{2,50}\"\n};\nvar bookItemSchema = {\n\"type\": \"object\",\n\"additionalProperties\": {\n\"id\": uuidSchema,\n\"libId\": libIdSchema,\n\"purchaseDate\": {\n\"type\": \"string\",\n\"format\": \"date\"\n},\n\"isLent\": {\"type\": \"boolean\"}\n}\n};\nListing12.17 The refined schema of the catalog data (Part 2)\nvar bookSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorIds\", \"bookItems\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publicationYear\": publicationYearSchema,\n\"isbn\": isbnSchema,\n\"publisher\": {\"type\": \"string\"},\n\"authorIds\": {\n\"type\": \"array\",\n\"items\": authorIdSchema\n},\n\"bookItems\": bookItemSchema\n}\n};\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"id\", \"name\", \"bookIsbns\"],\n\"properties\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n--- Page 288 ---\n260 CHAPTER 12 Advanced data validation\n\"bookIsbns\": {\n\"items\": isbnSchema\n}\n}\n};\nvar catalogSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"booksByIsbn\": {\n\"type\": \"object\",\n\"additionalProperties\": bookSchema\n},\n\"authorsById\": {\n\"type\": \"object\",\n\"additionalProperties\": authorSchema\n}\n},\n\"required\": [\"booksByIsbn\", \"authorsById\"]\n};\n12.4 Automatic generation of data model diagrams\nBefore going home, Theo phones Joe to tell him about how he and Dave used data valida-\ntion inside the system. Joe tells Theo that that’s exactly how he recommends doing it and\nsuggests he come and visit Theo and Dave at the office tomorrow. He wants to show them\nsome cool advanced stuff related to data validation. The next day, with coffee in hand, Joe\nstarts the discussion.\nJoe Are you guys starting to feel the power of data validation à la DOP?\nDave Yes, it’s a bit less convenient to validate a JSON Schema than it is to write the\nclass of function arguments, but this drawback is compensated by the fact that\nJSON Schema supports conditions that go beyond static types.\nTheo We also realized that we don’t have to validate data for each and every function.\nJoe Correct. Now, let me show you another cool thing that we can do with JSON\nSchema.\nDave What’s that?\nJoe Generate a data model diagram.\nDave Wow! How does that work?\nJoe There are tools that receive a JSON Schema as input and produce a diagram in\na data model format.\nDave What is a data model format?\nJoe It’s a format that allows you to define a data model in plain text. After that, you\ncan generate an image from the text. My favorite data format is PlantUML.\n NOTE For more on PlantUML, see https://plantuml.com/.\nDave Do you know of other tools that generate data model diagrams?\nJoe I have used JSON Schema Viewer and Malli.\n--- Page 289 ---\n12.4 Automatic generation of data model diagrams 261\n NOTE You can find information on the JSON Schema Viewer at https://navneethg\n.github.io/jsonschemaviewer/ and on Malli at https://github.com/metosin/malli.\nJoe shows Dave and Theo the PlantUML diagram that Malli generated (listing 12.18) from\nthe catalog schema in listings 12.16 and 12.17.\nListing12.18 A PlantUML diagram generated from the catalog data schema\n@startuml\nEntity1 *-- Entity2\nEntity1 *-- Entity4\nEntity2 *-- Entity3\nclass Entity1 {\n+ booksByIsbn: {Entity2}\n+ authorsById: {Entity4}\n}\nclass Entity2 {\n+ title : String\n+ publicationYear: Number\n+ isbn: String\n+ authorIds: [String]\n+ bookItems: [Entity3]\n}\nclass Entity3 {\n+ id: String\n+ libId: String\n+ purchaseDate: String\n+ isLent: Boolean\n}\nclass Entity4 {\n+ id: String\n+ name: String\n+ bookIsbns: [String]\n}\n@enduml\nDave Is it possible to visualize this diagram?\nJoe Absolutely. Let me copy and paste the diagram text into the PlantText online\ntool.\n NOTE See https://www.planttext.com/ for more on the PlantText online tool.\nDave opens his web browser and types the URL for PlantText. After copying and pasting\nthe text, he steps aside so that Theo and Dave can view the diagram that looks like the\nimage in figure 12.2.\n--- Page 290 ---\n262 CHAPTER 12 Advanced data validation\nC Entity1\nbooksByIsbn: {Entity2}\nauthorsById: {Entity3}\nC Entity2 C Entity4\ntitle : String id: String\npublicationYear: Number name: String\nisbn: String booklsbns: [String]\nauthorlds: [String]\nbookltems: [Entity3]\nC Entity3\nid: String\nlibld: String\nFigure 12.2 A visualization of\npurchaseDate: String\nthe PlantUML diagram generated\nisLent: Boolean\nfrom the catalog data schema\nDave That’s cool! But why are the diagram entities named Entity1, Entity2, and\nso on?\nJoe Because in JSON Schema, there’s no way to give a name to a schema. Malli has\nto autogenerate random names for you.\nTheo Also, I see that the extra information we have in the schema, like the number\nrange for publicationYear and string regular expression for isbn, is missing\nfrom the diagram.\nJoe Right, that extra information is not part of the data model. That’s why it’s not\nincluded in the generated data model diagram.\nDave Anyway, it’s very cool!\nJoe If you guys like the data model generation feature, I’m sure you’re going to\nlike the next feature.\nDave What’s it about?\nJoe Automatic generation of unit tests.\nTheo Wow, sounds exciting!\n12.5 Automatic generation of schema-based unit tests\nJoe Once you’ve defined a data schema for function arguments and for its return\nvalue, it’s quite simple to generate a unit test for this function.\nDave How?\nJoe Well, think about it. What’s the essence of a unit test for a function?\nDave A unit test calls a function with some arguments and checks whether the func-\ntion returns the expected value.\nJoe Exactly! Now, let’s adapt it to the context of data schema and DOP. Let’s say you\nhave a function with a schema for their arguments and for their return value.\n--- Page 291 ---\n12.5 Automatic generation of schema-based unit tests 263\nDave OK.\nJoe Here’s the flow of a schema-based unit test. We call the function with random\narguments that conform to the schema of the function arguments. Then, we\ncheck whether the function returns a value that conforms to the schema of the\nreturn value. Here, let me diagram it.\nJoe goes to the whiteboard. He draws the diagram in figure 12.3.\nGeneraterandom datathat conforms toinput schema\nExecute the function The input\nis random.\nYes No\nOutput conforms to output schema\nTest passes Test fails\nFigure 12.3 The flow of\na schema-based unit test\nDave How do you generate random data that conforms to a schema?\nJoe Using a tool like JSON Schema Faker. For example, let’s start with a simple\nschema: the schema for a UUID. Let me show you how to generate random\ndata that conforms to the schema.\n NOTE You’ll find more information about JSON Schema Faker at https://github\n.com/json-schema-faker/json-schema-faker.\nJoe types on the keyboard for a bit. He then shows the code to generate random data to\nDave and Theo.\nListing12.19 Generating random data that conforms to a UUID schema\nvar uuidSchema = {\n\"type\": \"string\",\n\"pattern\": \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}\" +\n\"-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\n};\nJSONSchemaFaker.generate(uuidSchema);\n// → \"7aA8CdF3-14DF-9EF5-1A19-47dacdB16Fa9\"\nDave executes the code snippet a couple of times, and indeed, on each evaluation, it returns\na different UUID.\nDave Very cool! Let me see how it works with more complex schemas like the cata-\nlog schema.\n--- Page 292 ---\n264 CHAPTER 12 Advanced data validation\nWhen Dave calls JSONSchemaFaker.generate with the catalog schema, he gets some\nquite long random data. He’s a bit surprised by the results.\nListing12.20 Generating random data that conforms to the catalog schema\n{\n\"booksByIsbn\": {\n\"Excepteur7\": {\n\"title\": \"elit veniam anim\",\n\"isbn\": \"5419903-3563-7\",\n\"authorIds\": [\n\"vfbzqahmuemgdegkzntfhzcjhjrbgfoljfzogfuqweggchum\",\n\"inxmqh-\",\n],\n\"bookItems\": {\n\"ullamco5\": {\n\"id\": \"f7dac8c3-E59D-bc2E-7B33-C27F3794E2d6\",\n\"libId\": \"4jtbj7q7nrylfu114m\",\n\"purchaseDate\": \"2001-08-01\",\n\"isLent\": false\n},\n\"culpa_3e\": {\n\"id\": \"423DCdDF-CDAe-2CAa-f956-C6cd9dA8054b\",\n\"libId\": \"6wcxbh\",\n\"purchaseDate\": \"1970-06-24\",\n\"isLent\": true\n}\n},\n\"publicationYear\": 1930,\n\"publisher\": \"sunt do nisi\"\n},\n\"aliquip_d7\": {\n\"title\": \"aute\",\n\"isbn\": \"348782167518177\",\n\"authorIds\": [\"owfgtdxjbiidsobfgvjpjlxuabqpjhdcqmmmrjb-ezrsz-u\"],\n\"bookItems\": {\n\"ipsum__0b\": {\n\"id\": \"6DfE93ca-DB23-5856-56Fd-82Ab8CffEFF5\",\n\"libId\": \"bvjh0p2p2666vs7dd\",\n\"purchaseDate\": \"2018-03-30\",\n\"isLent\": false\n}\n},\n\"publisher\": \"ea anim ut ex id\",\n\"publicationYear\": 1928\n}\n},\n\"authorsById\": {\n\"labore_b88\": {\n\"id\": \"adipisicing nulla proident\",\n\"name\": \"culpa in minim\",\n\"bookIsbns\": [\n\"6243029--7\",\n\"5557199424742986\"\n]",
        "sections_found": []
      },
      "accurate_page_range": "262-292"
    },
    {
      "text": "- 10.3 Simple data manipulation",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "10 Database operations",
      "raw_line": "- 10.3 Simple data manipulation (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 85,
      "chapter_info": {
        "page": 262,
        "title": "Database operations",
        "pattern_matched": "Chapter 10",
        "text_preview": "234 CHAPTER 11 Web services\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physic"
      },
      "chapter_sections": {
        "start_page": 262,
        "end_page": 292,
        "content": "\n--- Page 262 ---\n234 CHAPTER 11 Web services\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nTheo Yes! I think we now have all the pieces to enrich our search results.\n11.6 Search result enrichment in action\nJoe Can you write the steps of the enrichment data flow?\nTheo Sure.\nTheo goes to the whiteboard. He takes a moment to gather his thoughts, and then erases\nenough space so there’s room to list the steps.\nThe steps for the search result enrichment data flow\n1 Receive a request from a client.\n2 Extract from the client’s request the query and the fields to fetch from Open\nLibrary.\n3 Retrieve from the database the books that match the query.\n4 Fetch information from Open Library for each ISBN that match the query.\n5 Extract from Open Library responses for the required fields.\n6 Combine book information from the database with information from Open\nLibrary.\n7 Send the response to the client.\nJoe Perfect! Would you like to try to implement it?\nTheo I think I’ll start with the implementation of the book retrieval from the data-\nbase. It’s quite similar to what we did last month.\n NOTE See chapter 10 for last month’s lesson.\nJoe Actually, it’s even simpler because you don’t need to join tables.\nTheo That’s right, I need values only for the isbn and available columns.\nTheo works for a bit in his IDE. He begins with the book retrieval from the database.\nListing11.14 Retrieving books whose title matches a query\nvar dbSearchResultSchema = {\n\"type\": \"array\",\n\"items\": {\n--- Page 263 ---\n11.6 Search result enrichment in action 235\n\"type\": \"object\",\n\"required\": [\"isbn\", \"available\"],\n\"properties\": {\n\"isbn\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"}\n}\n}\n};\nclass CatalogDB {\nstatic matchingBooks(title) {\nvar matchingBooksQuery = `\nSELECT isbn, available\nFROM books\nWHERE title = like '%$1%';\n`;\nvar books = dbClient.query(catalogDB, matchingBooksQuery, [title]);\nif(!ajv.validate(dbSearchResultSchema, books)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from the database: \" +\nerrors;\n}\nreturn books;\n}\n}\nJoe So far, so good...\nTheo Next, I’ll go with the implementation of the retrieval of book information from\nOpen Library for several books. Unfortunately, the Open Library Books API\ndoesn’t support querying several books at once. I’ll need to send one request\nper book.\nJoe That’s a bit annoying. Let’s make our life easier and pretend that _.map works\nwith asynchronous functions. In real life, you’d need something like Promise\n.all in order to send the requests in parallel and combine the responses.\nTheo OK, then it’s quite straightforward. I’ll take the book retrieval code and add a\nmultipleBookInfo function that maps over bookInfo.\nTheo looks over the book retrieval code in listing 11.9 and then concentrates as he types\ninto his IDE. When he’s done, he shows the result in listing 11.15 to Joe.\nListing11.15 Retrieving book information from Open Library for several books\nclass OpenLibraryDataSource {\nstatic rawBookInfo(isbn) {\nvar url = `https:/ /openlibrary.org/isbn/${isbn}.json`;\nvar jsonString = fetchResponseBody(url);\nreturn JSON.parse(jsonString);\n}\nstatic bookInfo(isbn, requestedFields) {\nvar relevantFields = [\"title\", \"full_title\",\n\"subtitle\", \"publisher\",\n\"publish_date\", \"weight\",\n--- Page 264 ---\n236 CHAPTER 11 Web services\n\"physical_dimensions\", \"genre\",\n\"subjects\", \"number_of_pages\"];\nvar rawInfo = rawBookInfo(isbn);\nif(!ajv.validate(dbSearchResultSchema, bookInfoSchema)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from Open Books API: \" +\nerrors;\n}\nvar relevantInfo =\n_.pick(_.pick(rawInfo, relevantFields), requestedFields);\nreturn _.set(relevantInfo, \"isbn\", isbn);\n}\nstatic multipleBookInfo(isbns, fields) {\nreturn _.map(function(isbn) {\nreturn bookInfo(isbn, fields);\n}, isbns);\n}\n}\nJoe Nice! Now comes the fun part: combining information from several data sources.\nTheo Yeah. I have two arrays in my hands: one with book information from the data-\nbase and one with book information from Open Library. I somehow need to\njoin the arrays, but I’m not sure I can assume that the positions of the book\ninformation are the same in both arrays.\nJoe What would you like to have in your hands?\nTheo I wish I had two hash maps.\nJoe And what would the keys in the hash maps be?\nTheo Book ISBNs.\nJoe Well, I have good news for you: your wish is granted!\nTheo How?\nJoe Lodash provides a function named _.keyBy that transforms an array into a map.\nTheo I can’t believe it. Can you show me an example?\nJoe Sure. Let’s call _.keyBy on an array with two books.\nListing11.16 Transforming an array into a map with _.keyBy\nvar books = [\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"isbn\": \"978-1982137274\",\n\"available\": true\n},\n{\n\"title\": \"The Power of Habit\",\n\"isbn\": \"978-0812981605\",\n\"available\": false\n}\n];\n_.keyBy(books, \"isbn\");\n--- Page 265 ---\n11.6 Search result enrichment in action 237\nJoe And here’s the result.\nListing11.17 The result of keyBy\n{\n\"978-0812981605\": {\n\"available\": false,\n\"isbn\": \"978-0812981605\",\n\"title\": \"The Power of Habit\"\n},\n\"978-1982137274\": {\n\"available\": true,\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\"\n}\n}\nTheo keyBy is awesome!\nJoe Don’t exaggerate, my friend; _.keyBy is quite similar to _.groupBy. The\nonly difference is that _.keyBy assumes that there’s only one element in\neach group.\nTheo I think that, with _.keyBy, I’ll be able to write a generic joinArrays function.\nJoe I’m glad to see you thinking in terms of implementing business logic through\ngeneric data manipulation functions.\nTIP Many parts of the business logic can be implemented through generic data\nmanipulation functions.\nTheo The joinArrays function needs to receive the arrays and the field name for\nwhich we decide the two elements that need to be combined, for instance,\nisbn.\nJoe Remember, in general, it’s not necessarily the same field name for both arrays.\nTheo Right, so joinArrays needs to receive four arguments: two arrays and two\nfield names.\nJoe Go for it! And, please, write a unit test for joinArrays.\nTheo Of course...\nTheo works for a while and produces the code in listing 11.18. He then types the unit test\nin listing 11.19.\nListing11.18 A generic function for joining arrays\nfunction joinArrays(a, b, keyA, keyB) {\nvar mapA = _.keyBy(a, keyA);\nvar mapB = _.keyBy(b, keyB);\nvar mapsMerged = _.merge(mapA, mapB);\nreturn _.values(mapsMerged);\n}\n--- Page 266 ---\n238 CHAPTER 11 Web services\nListing11.19 A unit test for joinArrays\nvar dbBookInfos = [\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true\n},\n{\n\"isbn\": \"978-0812981605\",\n\"title\": \"The Power of Habit\",\n\"available\": false\n}\n];\nvar openLibBookInfos = [\n{\n\"isbn\": \"978-0812981605\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432,\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"The Power of Habit\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n],\n}\n];\nvar joinedArrays = [\n{\n\"available\": true,\n\"isbn\": \"978-1982137274\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\",\n],\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"title\": \"The Power of Habit\",\n},\n{\n\"available\": false,\n\"isbn\": \"978-0812981605\",\n\"number_of_pages\": 432,\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"title\": \"7 Habits of Highly Effective People\",\n},\n]\n--- Page 267 ---\n11.6 Search result enrichment in action 239\n_.isEqual(joinedArrays,\njoinArrays(dbBookInfos, openLibBookInfos, \"isbn\", \"isbn\"));\nJoe Excellent! Now, you are ready to adjust the last piece of the extended search\nresult endpoint.\nTheo That’s quite easy. We fetch data from the database and from Open Library and\njoin them.\nTheo works quite rapidly. He then shows Joe the code.\nListing11.20 Search books and enriched book information\nclass Catalog {\nstatic enrichedSearchBooksByTitle(searchPayload) {\nif(!ajv.validate(searchBooksRequestSchema, searchPayload)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid request:\" + errors;\n}\nvar title = _.get(searchPayload, \"title\");\nvar fields = _.get(searchPayload, \"fields\");\nvar dbBookInfos = CatalogDataSource.matchingBooks(title);\nvar isbns = _.map(dbBookInfos, \"isbn\");\nvar openLibBookInfos =\nOpenLibraryDataSource.multipleBookInfo(isbns, fields);\nvar res = joinArrays(dbBookInfos, openLibBookInfos);\nif(!ajv.validate(searchBooksResponseSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid response:\" + errors;\n}\nreturn res;\n}\n}\nNow comes the tricky part. Theo takes a few moments to meditate about the simplicity of\nthe code that implements the extended search endpoint. He thinks about how classes are\nmuch less complex when we use them only to aggregate stateless functions that operate on\nsimilar domain entities and then goes to work plotting the code.\nListing11.21 Schema for the extended search endpoint (Open Books API part)\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n--- Page 268 ---\n240 CHAPTER 11 Web services\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing11.22 Extended search endpoint (Open Books API part)\nvar ajv = new Ajv({allErrors: true});\nclass OpenLibraryDataSource {\nstatic rawBookInfo(isbn) {\nvar url = `https:/ /openlibrary.org/isbn/${isbn}.json`;\nvar jsonString = fetchResponseBody(url);\nreturn JSON.parse(jsonString);\n}\nstatic bookInfo(isbn, requestedFields) {\nvar relevantFields = [\"title\", \"full_title\",\n\"subtitle\", \"publisher\",\n\"publish_date\", \"weight\",\n--- Page 269 ---\n11.6 Search result enrichment in action 241\n\"physical_dimensions\", \"genre\",\n\"subjects\", \"number_of_pages\"];\nvar rawInfo = rawBookInfo(isbn);\nif(!ajv.validate(bookInfoSchema, rawInfo)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from Open Books API: \" +\nerrors;\n}\nvar relevantInfo = _.pick(\n_.pick(rawInfo, relevantFields),\nrequestedFields);\nreturn _.set(relevantInfo, \"isbn\", isbn);\n}\nstatic multipleBookInfo(isbns, fields) {\nreturn _.map(function(isbn) {\nreturn bookInfo(isbn, fields);\n}, isbns);\n}\n}\nListing11.23 Extended search endpoint (database part)\nvar dbClient;\nvar dbSearchResultSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"isbn\", \"available\"],\n\"properties\": {\n\"isbn\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"}\n}\n}\n};\nclass CatalogDB {\nstatic matchingBooks(title) {\nvar matchingBooksQuery = `\nSELECT isbn, available\nFROM books\nWHERE title = like '%$1%';\n`;\nvar books = dbClient.query(catalogDB, matchingBooksQuery, [title]);\nif(!ajv.validate(dbSearchResultSchema, books)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from the database: \"\n+ errors;\n}\nreturn books;\n}\n}\n--- Page 270 ---\n242 CHAPTER 11 Web services\nListing11.24 Schema for the implementation of the extended search endpoint\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"type\": [\n\"title\",\n\"full_title\",\n\"subtitle\",\n\"publisher\",\n\"publish_date\",\n\"weight\",\n\"physical_dimensions\",\n\"number_of_pages\",\n\"subjects\",\n\"publishers\",\n\"genre\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksResponseSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nListing11.25 Schema for the extended search endpoint (combines the pieces)\nclass Catalog {\nstatic enrichedSearchBooksByTitle(request) {\n--- Page 271 ---\n11.6 Search result enrichment in action 243\nif(!ajv.validate(searchBooksRequestSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid request:\" + errors;\n}\nvar title = _.get(request, \"title\");\nvar fields = _.get(request, \"fields\");\nvar dbBookInfos = CatalogDataSource.matchingBooks(title);\nvar isbns = _.map(dbBookInfos, \"isbn\");\nvar openLibBookInfos =\nOpenLibraryDataSource.multipleBookInfo(isbns, fields);\nvar response = joinArrays(dbBookInfos, openLibBookInfos);\nif(!ajv.validate(searchBooksResponseSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid response:\" + errors;\n}\nreturn response;\n}\n}\nclass Library {\nstatic searchBooksByTitle(payloadBody) {\nvar payloadData = JSON.parse(payloadBody);\nvar results = Catalog.searchBooksByTitle(payloadData);\nreturn JSON.stringify(results);\n}\n}\nTIP Classes are much less complex when we use them as a means to aggregate state-\nless functions that operate on similar domain entities.\nJoe interrupts Theo’s meditation moment. After looking over the code in the previous list-\nings, he congratulates Theo.\nJoe Excellent job, my friend! By the way, after reading The Power of Habit, I quit\nchewing my nails.\nTheo Wow! That’s terrific! Maybe I should read that book to overcome my habit of\ndrinking too much coffee.\nJoe Thanks, and good luck with the coffee habit.\nTheo I was supposed to call Nancy later today with an ETA for the Open Library\nBook milestone. I wonder what her reaction will be when I tell her the feature\nis ready.\nJoe Maybe you should tell her it’ll be ready in a week, which would give you time to\nbegin work on the next milestone.\n--- Page 272 ---\n244 CHAPTER 11 Web services\nDelivering on time\nJoe was right! Theo recalls Joe’s story about the young woodcutter and the old man. Theo\nwas able to learn DOP and deliver the project on time! He’s pleased that he took the time\n“to sharpen his saw and commit to a deeper level of practice.”\n NOTE If you are unable to recall the story or if you missed it, check out the opener\nto part 2.\nThe Klafim project is a success. Nancy is pleased. Theo’s boss is satisfied. Theo got pro-\nmoted. What more can a person ask for?\nTheo remembers his deal with Joe. As he strolls through the stores of the Westfield San\nFrancisco Center to look for a gift for each of Joe’s children, Neriah and Aurelia, he is\nfilled with a sense of purpose and great pleasure. He buys a DJI Mavic Air 2 drone for Ner-\niah, and the latest Apple Airpod Pros for Aurelia. He also takes this opportunity to buy a\nnecklace and a pair of earrings for his wife, Jane. It’s a way for him to thank her for having\nendured his long days at work since the beginning of the Klafim project.\n NOTE The story continues in the opener of part 3.\nSummary\n We build the insides of our systems like we build the outsides.\n Components inside a program communicate via data that is represented as\nimmutable data collections in the same way as components communicate via\ndata over the wire.\n In DOP, the inner components of a program are loosely coupled.\n Many parts of business logic can be implemented through generic data manipu-\nlation functions. We use generic functions to\n– Implement each step of the data flow inside a web service.\n– Parse a request from a client.\n– Apply business logic to the request.\n– Fetch data from external sources (e.g., database and other web services).\n– Apply business logic to the responses from external sources.\n– Serialize response to the client.\n Classes are much less complex when we use them as a means to aggregate\ntogether stateless functions that operate on similar domain entities.\nLodash functions introduced in this chapter\nFunction Description\nkeyBy(coll, f) Creates a map composed of keys generated from the results of running each ele-\nment of coll through f; the corresponding value for each key is the last element\nresponsible for generating the key.\n--- Page 273 ---\nPart 3\nMaintainability\nA\nfter a month, the Klafim project enters what Alabatross calls the mainte-\nnance phase. Small new features need to be added on a weekly basis. Bugs need to be\nfixed; nothing dramatic....\nMonica, Theo’s boss, decides to allocate Dave to the maintenance of the Klafim\nproject. It makes sense. Over the last few months, Dave has demonstrated a great atti-\ntude of curiosity and interest, and he has solid programming skills. Theo sets up a\nmeeting with Joe and Dave, hoping that Joe will be willing to teach DOP to Dave so\nthat he can continue to advance the good work he’s already done on Klafim. Theo\nand Dave place a conference call to Joe.\nTheo Hi, Joe. Will you have time over the next few weeks to teach Dave the\nprinciples of DOP?\nJoe Yes, but I prefer not to.\nDave Why? Is it because I don’t have enough experience in software develop-\nment? I can guarantee you that I’m a fast learner.\nJoe It has nothing to do with your experience, Dave.\nTheo Why not then?\nJoe Theo, I think that you could be a great mentor for Dave.\nTheo But, I don’t even know all the parts of DOP!\nDave Come on! No false modesty between us, my friend.\nJoe Knowledge is never complete. As the great Socrates used to say, “The more\nI know, the more I realize I know nothing.” I’m confident you will be able\nto learn the missing parts by yourself and maybe even invent some.\nTheo How will I be able to invent missing parts?\n--- Page 274 ---\n246 PART 3 Maintainability\nJoe You see, DOP is such a simple paradigm that it’s fertile material for innovation.\nPart of the material I taught you I learned from others, and part of it was an\ninvention of mine. If you keep practicing DOP, I’m quite sure you, too, will\ncome up with some inventions of your own.\nTheo What do you say Dave? Are you willing to learn DOP from me?\nDave Definitely!\nTheo Joe, will you be continue to be available if we need your help from time to time?\nJoe Of course!\n--- Page 275 ---\nAdvanced data\nvalidation\nA self-made gift\nThis chapter covers\n Validating function arguments\n Validating function return values\n Data validation beyond static types\n Automatic generation of data model diagrams\n Automatic generation of schema-based unit tests\nAs the size of a code base grows in a project that follows DOP principles, it becomes\nharder to manipulate functions that receive and return only generic data. It is hard\nto figure out the expected shape of the function arguments, and when we pass\ninvalid data, we don’t get meaningful errors.\nUntil now, we have illustrated how to validate data at system boundaries. In this\nchapter, we will illustrate how to validate data when it flows inside the system by\ndefining data schemas for function arguments and their return values. This allows\nus to make explicit the expected shape of function arguments, and it eases develop-\nment. We gain some additional benefits from this endeavor, such as automatic gen-\neration of data model diagrams and schema-based unit tests.\n247\n--- Page 276 ---\n248 CHAPTER 12 Advanced data validation\n12.1 Function arguments validation\nDave’s first task is to implement a couple of new HTTP endpoints to download the catalog\nas a CSV file, search books by author, and rate the books. Once he is done with the tasks,\nDave calls Theo for a code review.\n NOTE The involvement of Dave in the Klafim project is explained in the opener for\npart 3. Please take a moment to read the opener if you missed it.\nTheo Was it difficult to get your head around the DOP code?\nDave Not so much. I read your notes of the meetings with Joe, and I must admit, the\ncode is quite simple to grasp.\nTheo Cool!\nDave But there is something that I can’t get used to.\nTheo What’s that?\nDave I’m struggling with the fact that all the functions receive and return generic\ndata. In OOP, I know the expected shape of the arguments for each and every\nfunction.\nTheo Did you validate data at system boundaries, like I have done?\nDave Absolutely. I defined a data schema for every additional user request, database\nquery, and external service response.\nTheo Nice!\nDave Indeed, when the system runs in production, it works well. When data is valid,\nthe data flows through the system, and when data is invalid, we are able to dis-\nplay a meaningful error message to the user.\nTheo What’s the problem then?\nDave The problem is that during development, it’s hard to figure out the expected\nshape of the function arguments. And when I pass invalid data by mistake, I\ndon’t get clear error messages.\nTheo I see. I remember that when Joe showed me how to validate data at system\nboundaries, I raised this concern about the development phase. Joe told me\nthen that we validate data as it flows inside the system exactly like we validate data\nat system boundaries: we separate between data schema and data representation.\nDave Are we going to use JSON Schema also?\nTheo Yes.\nDave Cool.... I like JSON Schema.\nTheo The main purpose of data validation at system boundaries is to prevent invalid\ndata from getting into the system, whereas the main purpose of data validation\ninside the system is to make it easier to develop the system. Here, let me draw a\ntable on the whiteboard for you to visualize this (table 12.1).\nTable 12.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\n--- Page 277 ---\n12.1 Function arguments validation 249\nDave By making it easier to develop the system, do you mean to help the developers\nunderstand the expected shape of function arguments as in OOP?\nTheo Exactly.\nDave But I’m impatient.... Will you help me figure out how to validate the argu-\nments of the function that implements a book search?\nTheo Let me see the code of the implementation, and I’ll do my best.\nDave We have two implementations of a book search: one where library data lives\nin memory from the prototype phase and one where library data lives in the\ndatabase.\nTheo I think that the schema for library data in memory is going to be more interest-\ning than the schema for library data in the database, as the book search func-\ntion receives catalog data in addition to the query.\nDave When you say more interesting data schema, you mean more difficult to write?\nTheo More difficult to write, but it’s also more insightful.\nDave Then let’s go with library data in memory. The code for Catalog.search-\nBooksByTitle from the prototype phase would look like this.\nDave pulls up some code on his laptop. He shows it to Theo.\nListing12.1 The implementation of search without data validation\nclass Catalog {\nstatic authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nreturn bookInfo;\n}\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\n--- Page 278 ---\n250 CHAPTER 12 Advanced data validation\nTheo Dave, please remind me of the expected shapes for catalogData and query.\nDave Sure. query should be a string, and catalogData should be a map that con-\nforms to the catalog data model.\nTheo What is the catalog data model?\nDave Let me see. I have seen a diagram of it somewhere.\nDave rummages around a bit in his folder for Klafim’s Library Management System. Find-\ning what he’s looking for, he draws the diagram in figure 12.1 on the whiteboard.\nC Catalog\nbooksByIsbn: {Book}\nauthorsById: {Author}\nC Book\nC Author\ntitle : String\npublicationYear: Number id: String\nisbn: String name: String\nauthorlds: [String] booklsbns: [String]\nbookltems: [Bookltem]\nC Bookltem\nid: String\nlibld: String\npurchaseDate: String\nisLent: Boolean\nFigure 12.1 The catalog data model\n NOTE The schemas for this book use JSON Schema version 2020-12.\nTheo Can you write a JSON Schema for the catalog data model?\nDave Am I allowed to use internal variables for book and author schemas, or do I\nhave to nest all the schemas inside the catalog schema?\nTheo JSON Schema is part of the code. If you feel that using internal variables would\nmake the code more readable, go for it.\nDave OK. Now I need the JSON Schema gift that Joe gave you.\nTheo picks up a well-worn piece of paper that is a bit torn and quite wrinkled. He gives\nDave the JSON Schema cheat sheet.\nListing12.2 JSON Schema cheat sheet\nAt the root level,\n{\ndata is an array.\n\"type\": \"array\",\n\"items\": { Each element of the array is a map.\n\"type\": \"object\",\nThe properties of each field in the map\n\"properties\": {\n--- Page 279 ---\n12.1 Function arguments validation 251\n\"myNumber\": {\"type\": \"number\"},\nmyNumber\n\"myString\": {\"type\": \"string\"}, myEnum is an enumeration\nis a number.\n\"myEnum\": {\"enum\": [\"myVal\", \"yourVal\"]}, value with two possibilities,\nmyString is \"myBool\": {\"type\": \"boolean\"} \"myVal\" and \"yourVal\".\na string. },\n\"required\": [\"myNumber\", \"myString\"], myBool is a boolean.\n\"additionalProperties\": false\n} The mandatory fields in the map\n} We don’t allow fields that are not are myNumber and myString.\nexplicitly mentioned in the schema. Other fields are optional.\nDave I think I’ll start with the author schema. It seems simpler than the book schema.\nQuickly composing the code, Dave shows Theo the author schema. Dave, still new to DOP,\nlooks for Theo’s reaction.\nListing12.3 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"id\", \"name\", \"bookIsbns\"],\n\"properties\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nTheo Well done! Let’s move on to the book schema now.\nDave I think I am going to store the book item schema in a variable.\nListing12.4 The book item schema\nvar bookItemSchema = {\n\"type\": \"object\",\n\"properties\":{\n\"id\": {\"type\": \"string\"},\n\"libId\": {\"type\": \"string\"},\n\"purchaseDate\": {\"type\": \"string\"},\n\"isLent\": {\"type\": \"boolean\"}\n},\n\"required\": [\"id\", \"libId\", \"purchaseDate\", \"isLent\"]\n};\nvar bookSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorIds\", \"bookItems\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publicationYear\": {\"type\": \"integer\"},\n--- Page 280 ---\n252 CHAPTER 12 Advanced data validation\n\"isbn\": {\"type\": \"string\"},\n\"authorIds\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"bookItems\": {\n\"type\": \"array\",\n\"items\": bookItemSchema\n}\n}\n};\nTIP When you define a complex data schema, it is advisable to store nested schemas\nin variables to make the schemas easier to read.\nTheo Why didn’t you include publicationYear in the list of required fields in the\nbook schema?\nDave Because, for some books, the publication year is missing. Unlike in OOP, it will\nthen be easy to deal with nullable fields.\nTheo Excellent! And now, please tackle the final piece, the catalog schema.\nDave Here I have a problem. The catalog should be a map with two fields, books-\nByIsbn and authorsById. Both values should be indexes, represented in the\nmodel diagram with curly braces. I have no idea how to define the schema for\nan index.\nTheo Do you remember how we represent indexes in DOP?\nDave Yes, indexes are represented as maps.\nTheo Right, and what’s the difference between those maps and the maps that we use\nfor records?\nDave For records, we use maps where the names of the fields are known and the val-\nues can have different shapes. For indexes, we use maps where the names of\nthe fields are unknown and the values have a common shape.\nTheo Right. We call the maps for records heterogeneous maps and the maps for\nindexes homogeneous maps.\nTIP In DOP, records are represented as heterogeneous maps, whereas indexes are repre-\nsented as homogeneous maps.\nDave Then how do we define the schema of an homogeneous map in JSON Schema?\nTheo I don’t know. Let’s check the JSON Schema online documentation.\n NOTE See https://json-schema.org/ to access the online documentation for JSON\nSchema version 2020-12.\nAfter a couple of minutes of digging into the JSON Schema online documentation, Theo\nfinds a piece about additionalProperties. He studies the information for a while before\nmaking up his mind.\n--- Page 281 ---\n12.1 Function arguments validation 253\nTheo I think we could use additionalProperties. Here’s the JSON Schema for an\nhomogeneous map where the values are numbers.\nListing12.5 The JSON Schema for an homogeneous map with values as numbers\n{\n\"type\": \"object\",\n\"additionalProperties\": {\"type\": \"number\"}\n}\nDave I thought that additionalProperties was supposed to be a boolean and that\nit was used to allow or forbid properties not mentioned in the schema.\nTheo That’s correct. Usually additionalProperties is a boolean, but the documen-\ntation says it could also be a map that defines a schema. In that case, it means\nproperties not mentioned in the schema should have the value of the schema\nassociated with additionalProperties.\nDave I see. But what does that have to do with homogeneous maps?\nTheo Well, a homogeneous map could be seen as a map with no predefined proper-\nties, where all the additional properties are of an expected type.\nDave Tricky!\nTIP In JSON Schema, homogeneous string maps have type: object with no\nproperties and additionalProperties associated to a schema.\nTheo Indeed. Now, let me show you what the catalog schema looks like.\nTheo types briefly on his laptop. He shows Dave the catalog schema.\nListing12.6 The schema for catalog data\nvar catalogSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"booksByIsbn\": {\n\"type\": \"object\",\n\"additionalProperties\": bookSchema\n},\n\"authorsById\": {\n\"type\": \"object\",\n\"additionalProperties\": authorSchema\n}\n},\n\"required\": [\"booksByIsbn\", \"authorsById\"]\n};\nDave Are we ready to plug the catalog and the query schema into the Catalog\n.searchBooksByTitle implementation?\nTheo We could, but I think we can do better by defining a single schema that com-\nbines both the catalog and query schemas.\nDave How would we combine two schemas into a single schema?\n--- Page 282 ---\n254 CHAPTER 12 Advanced data validation\nTheo Do you know what a tuple is?\nDave I think I know, but I can’t define it formally.\nTheo A tuple is an array where the size is fixed, and the elements can be of different\nshapes.\nDave OK. So, how do we define tuples in JSON Schema?\nOnce again, Theo explores the JSON Schema online documentation. Fortunately, he has\nbookmarked the page, and in no time at all, finds the information he needs.\nTheo I found it! We use prefixItems in the definition of a tuple made of a string\nand a number, for instance.\nTheo types more code on his laptop. When he finishes, he shows Dave the schema for a\ntuple.\nListing12.7 The schema for a tuple made of a string and a number\n{\n\"type\": \"array\",\n\"prefixItems\": [\n{ \"type\": \"string\" },\n{ \"type\": \"number\" }\n]\n}\nDave I see. And how would you define the schema for the arguments of Catalog\n.searchBooksByTitle?\nTheo Well, it’s a tuple of size 2, where the first element is a catalog and the second\nelement is a string.\nDave Something like this schema?\nListing12.8 The schema for the arguments of Catalog.searchBooksByTitle\nvar searchBooksArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\ncatalogSchema,\n{ \"type\": \"string\" },\n]\n};\nTheo Exactly!\nDave Now that we have the schema for the arguments, how do we plug it into the\nimplementation of search books?\nTheo That’s similar to the way we validate data at system boundaries. The main dif-\nference is that the data validation for data that flows inside the system should\nrun only at development time, and it should be disabled when the code runs in\nproduction.\nDave Why?\n--- Page 283 ---\n12.2 Return value validation 255\nTheo Because that data has been already validated up front at a system boundary.\nValidating it again on a function call is superfluous, and it would impact\nperformance.\nDave When you say development time, does that include testing and staging\nenvironments?\nTheo Yes, all the environments besides production.\nDave I see. It’s like assertions in Java. They are disabled in production code.\nTIP Data validation inside the system should be disabled in production.\nTheo Exactly. For now, I am going to assume that we have a dev function that returns\ntrue when the code runs in the development environment and false when it\nruns in production. Having said that, take a look at this code.\nListing12.9 Implementation of search with validation of function arguments\nCatalog.searchBooksByTitle = function(catalogData, query) {\nif(dev()) {\nvar args = [catalogData, query];\nif(!ajv.validate(searchBooksArgsSchema, args)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle called with invalid arguments: \" +\nerrors);\nThe implementation of dev() depends on the run-time\n}\nenvironment: it returns true when the code runs in dev\n}\nenvironments and false when it runs in production.\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nDave Do you think we should validate the arguments of all the functions?\nTheo No. I think we should treat data validation like we treat unit tests. We should\nvalidate function arguments only for functions for whom we would write unit\ntests.\nTIP Treat data validation like unit tests.\n12.2 Return value validation\nDave Do you think it would make sense to also validate the return value of functions?\nTheo Absolutely.\nDave Cool. Let me try to write the JSON Schema for the return value of Catalog\n.searchBooksByTitle.\n--- Page 284 ---\n256 CHAPTER 12 Advanced data validation\nAfter a few minutes, Dave comes up with the schema. Taking a deep breath, then releasing\nit, he shows the code to Theo.\nListing12.10 The schema for the return value of Catalog.searchBooksByTitle\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorNames\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"isbn\": {\"type\": \"string\"},\n\"authorNames\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n};\nTheo Well done! Now, would you like to try adding return value validation to the\ncode of Catalog.searchBooksByTitle?\nDave Sure.\nDave works for a bit in his IDE. A bit more confident this time, he shows the result to Theo.\nListing12.11 Search with data validation for both input and output\nCatalog.searchBooksByTitle = function(catalogData, query) {\nif(dev()) {\nif(!ajv.validate(searchBooksArgsSchema, [catalogData, query])) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle called with invalid arguments: \" +\nerrors);\n}\n}\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nif(dev()) {\nif(!ajv.validate(searchBooksResponseSchema, bookInfos)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle returned an invalid value: \" +\nerrors);\n}\n}\n--- Page 285 ---\n12.3 Advanced data validation 257\nreturn bookInfos;\n};\nTheo Excellent! Now we need to figure out how to deal with advanced data validation.\n12.3 Advanced data validation\nDave What do you mean by advanced data validation?\nTheo I mean going beyond static types.\nDave Could you give me an example?\nTheo Sure. Take, for instance, the publication year of a book. It’s an integer, but\nwhat else could you say about this number?\nDave It has to be positive. It would say it’s a positive integer.\nTheo Come on, Dave! Be courageous, go beyond types.\nDave I don’t know. I would say it’s a number that should be higher than 1900. I\ndon’t think it makes sense to have a book that is published before 1900.\nTheo Exactly. And what about the higher limit?\nDave I’d say that the publication year should be less than the current year.\nTheo Very good! I see that JSON Schema supports number ranges. Here is how we\ncan write the schema for an integer that represents a year and should be\nbetween 1900 and 2021.\nListing12.12 The schema for an integer between 1900 and 2021\nvar publicationYearSchema = {\n\"type\": \"integer\",\n\"minimum\": 1900,\n\"maximum\": 2021\n};\nDave Why isn’t this kind of data validation possible in OOP?\nTheo I’ll let you think about that for a moment.\nDave I think have it! In DOP, data validation is executed at run time, while static\ntype validation in OOP is executed at compile time. At compile time, we only\nhave information about static types; at run time, we have the data itself. That’s\nwhy in DOP data validation, it’s possible to go beyond types.\n NOTE Of course, it’s also possible in traditional OOP to write custom run-time data\nvalidation. Here, though, we are comparing data schema with static types.\nTheo You got it! Now, let me show you how to write the schema for a string that\nshould match a regular expression.\n NOTE See http://mng.bz/OGNP for the JavaScript Guide to regular expressions.\nTheo Let’s take for example the book ID. I am assuming it must be a UUID.\nDave Right.\nTheo Can you write the regular expression for a valid UUID?\n--- Page 286 ---\n258 CHAPTER 12 Advanced data validation\nDave googles “UUID regex” and finds something he thinks just might work. He shows the\nregular expression to Theo.\nListing12.13 The regular expression for a valid UUID\n[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\nDave Now, how do we plug a regular expression into a JSON Schema?\nTheo While you were looking for the UUID regular expression, I read about the\npattern field. Here’s how we can plug the UUID regular expression into a\nJSON Schema.\nListing12.14 The schema for a UUID\nvar uuidSchema = {\n\"type\": \"string\",\n\"pattern\": \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}\" +\n\"-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\n};\nDave Nice! Let me improve the catalog schema and refine the schema for purchase-\nDate, isbn, libId, and authorId with regular expressions.\nTheo Before you do that, though, let me tell you something I read about regular\nexpressions: some of them are predefined. For example, there is a predefined\nregular expression for dates.\nDave How does it work?\nTheo With the help of the format field.\n NOTE According to JSON Schema specification, format is just for annotation and\ndoesn’t affect validation. But in practice, JSON Schema validation libraries use format\nalso for validation.\nTheo moves to his laptop. He inputs the schema for a date and shows it to Dave.\nListing12.15 The schema for a date\n{\n\"type\": \"string\",\n\"format\": \"date\"\n}\nTIP In DOP, data validation goes beyond static types (e.g., number ranges, regular\nexpressions, and so on).\nDave Very cool! Do I have all the information I need in order to refine the catalog\nschema?\nTheo Yes, go for it!\nIt takes Dave a bit of time to write the regular expressions for isbn, authorId, and libId.\nBut with the help of Google (again) and a bit of simplification, Dave comes up with the\nschema in listings 12.16 and 12.17.\n--- Page 287 ---\n12.3 Advanced data validation 259\nListing12.16 The refined schema of the catalog data (Part 1)\nvar isbnSchema = {\n\"type\": \"string\",\n\"pattern\": \"^[0-9-]{10,20}$\"\n};\nvar libIdSchema = {\n\"type\": \"string\",\n\"pattern\": \"^[a-z0-9-]{3,20}$\"\n};\nvar authorIdSchema ={\n\"type\": \"string\",\n\"pattern\": \"[a-z-]{2,50}\"\n};\nvar bookItemSchema = {\n\"type\": \"object\",\n\"additionalProperties\": {\n\"id\": uuidSchema,\n\"libId\": libIdSchema,\n\"purchaseDate\": {\n\"type\": \"string\",\n\"format\": \"date\"\n},\n\"isLent\": {\"type\": \"boolean\"}\n}\n};\nListing12.17 The refined schema of the catalog data (Part 2)\nvar bookSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorIds\", \"bookItems\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publicationYear\": publicationYearSchema,\n\"isbn\": isbnSchema,\n\"publisher\": {\"type\": \"string\"},\n\"authorIds\": {\n\"type\": \"array\",\n\"items\": authorIdSchema\n},\n\"bookItems\": bookItemSchema\n}\n};\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"id\", \"name\", \"bookIsbns\"],\n\"properties\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n--- Page 288 ---\n260 CHAPTER 12 Advanced data validation\n\"bookIsbns\": {\n\"items\": isbnSchema\n}\n}\n};\nvar catalogSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"booksByIsbn\": {\n\"type\": \"object\",\n\"additionalProperties\": bookSchema\n},\n\"authorsById\": {\n\"type\": \"object\",\n\"additionalProperties\": authorSchema\n}\n},\n\"required\": [\"booksByIsbn\", \"authorsById\"]\n};\n12.4 Automatic generation of data model diagrams\nBefore going home, Theo phones Joe to tell him about how he and Dave used data valida-\ntion inside the system. Joe tells Theo that that’s exactly how he recommends doing it and\nsuggests he come and visit Theo and Dave at the office tomorrow. He wants to show them\nsome cool advanced stuff related to data validation. The next day, with coffee in hand, Joe\nstarts the discussion.\nJoe Are you guys starting to feel the power of data validation à la DOP?\nDave Yes, it’s a bit less convenient to validate a JSON Schema than it is to write the\nclass of function arguments, but this drawback is compensated by the fact that\nJSON Schema supports conditions that go beyond static types.\nTheo We also realized that we don’t have to validate data for each and every function.\nJoe Correct. Now, let me show you another cool thing that we can do with JSON\nSchema.\nDave What’s that?\nJoe Generate a data model diagram.\nDave Wow! How does that work?\nJoe There are tools that receive a JSON Schema as input and produce a diagram in\na data model format.\nDave What is a data model format?\nJoe It’s a format that allows you to define a data model in plain text. After that, you\ncan generate an image from the text. My favorite data format is PlantUML.\n NOTE For more on PlantUML, see https://plantuml.com/.\nDave Do you know of other tools that generate data model diagrams?\nJoe I have used JSON Schema Viewer and Malli.\n--- Page 289 ---\n12.4 Automatic generation of data model diagrams 261\n NOTE You can find information on the JSON Schema Viewer at https://navneethg\n.github.io/jsonschemaviewer/ and on Malli at https://github.com/metosin/malli.\nJoe shows Dave and Theo the PlantUML diagram that Malli generated (listing 12.18) from\nthe catalog schema in listings 12.16 and 12.17.\nListing12.18 A PlantUML diagram generated from the catalog data schema\n@startuml\nEntity1 *-- Entity2\nEntity1 *-- Entity4\nEntity2 *-- Entity3\nclass Entity1 {\n+ booksByIsbn: {Entity2}\n+ authorsById: {Entity4}\n}\nclass Entity2 {\n+ title : String\n+ publicationYear: Number\n+ isbn: String\n+ authorIds: [String]\n+ bookItems: [Entity3]\n}\nclass Entity3 {\n+ id: String\n+ libId: String\n+ purchaseDate: String\n+ isLent: Boolean\n}\nclass Entity4 {\n+ id: String\n+ name: String\n+ bookIsbns: [String]\n}\n@enduml\nDave Is it possible to visualize this diagram?\nJoe Absolutely. Let me copy and paste the diagram text into the PlantText online\ntool.\n NOTE See https://www.planttext.com/ for more on the PlantText online tool.\nDave opens his web browser and types the URL for PlantText. After copying and pasting\nthe text, he steps aside so that Theo and Dave can view the diagram that looks like the\nimage in figure 12.2.\n--- Page 290 ---\n262 CHAPTER 12 Advanced data validation\nC Entity1\nbooksByIsbn: {Entity2}\nauthorsById: {Entity3}\nC Entity2 C Entity4\ntitle : String id: String\npublicationYear: Number name: String\nisbn: String booklsbns: [String]\nauthorlds: [String]\nbookltems: [Entity3]\nC Entity3\nid: String\nlibld: String\nFigure 12.2 A visualization of\npurchaseDate: String\nthe PlantUML diagram generated\nisLent: Boolean\nfrom the catalog data schema\nDave That’s cool! But why are the diagram entities named Entity1, Entity2, and\nso on?\nJoe Because in JSON Schema, there’s no way to give a name to a schema. Malli has\nto autogenerate random names for you.\nTheo Also, I see that the extra information we have in the schema, like the number\nrange for publicationYear and string regular expression for isbn, is missing\nfrom the diagram.\nJoe Right, that extra information is not part of the data model. That’s why it’s not\nincluded in the generated data model diagram.\nDave Anyway, it’s very cool!\nJoe If you guys like the data model generation feature, I’m sure you’re going to\nlike the next feature.\nDave What’s it about?\nJoe Automatic generation of unit tests.\nTheo Wow, sounds exciting!\n12.5 Automatic generation of schema-based unit tests\nJoe Once you’ve defined a data schema for function arguments and for its return\nvalue, it’s quite simple to generate a unit test for this function.\nDave How?\nJoe Well, think about it. What’s the essence of a unit test for a function?\nDave A unit test calls a function with some arguments and checks whether the func-\ntion returns the expected value.\nJoe Exactly! Now, let’s adapt it to the context of data schema and DOP. Let’s say you\nhave a function with a schema for their arguments and for their return value.\n--- Page 291 ---\n12.5 Automatic generation of schema-based unit tests 263\nDave OK.\nJoe Here’s the flow of a schema-based unit test. We call the function with random\narguments that conform to the schema of the function arguments. Then, we\ncheck whether the function returns a value that conforms to the schema of the\nreturn value. Here, let me diagram it.\nJoe goes to the whiteboard. He draws the diagram in figure 12.3.\nGeneraterandom datathat conforms toinput schema\nExecute the function The input\nis random.\nYes No\nOutput conforms to output schema\nTest passes Test fails\nFigure 12.3 The flow of\na schema-based unit test\nDave How do you generate random data that conforms to a schema?\nJoe Using a tool like JSON Schema Faker. For example, let’s start with a simple\nschema: the schema for a UUID. Let me show you how to generate random\ndata that conforms to the schema.\n NOTE You’ll find more information about JSON Schema Faker at https://github\n.com/json-schema-faker/json-schema-faker.\nJoe types on the keyboard for a bit. He then shows the code to generate random data to\nDave and Theo.\nListing12.19 Generating random data that conforms to a UUID schema\nvar uuidSchema = {\n\"type\": \"string\",\n\"pattern\": \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}\" +\n\"-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\n};\nJSONSchemaFaker.generate(uuidSchema);\n// → \"7aA8CdF3-14DF-9EF5-1A19-47dacdB16Fa9\"\nDave executes the code snippet a couple of times, and indeed, on each evaluation, it returns\na different UUID.\nDave Very cool! Let me see how it works with more complex schemas like the cata-\nlog schema.\n--- Page 292 ---\n264 CHAPTER 12 Advanced data validation\nWhen Dave calls JSONSchemaFaker.generate with the catalog schema, he gets some\nquite long random data. He’s a bit surprised by the results.\nListing12.20 Generating random data that conforms to the catalog schema\n{\n\"booksByIsbn\": {\n\"Excepteur7\": {\n\"title\": \"elit veniam anim\",\n\"isbn\": \"5419903-3563-7\",\n\"authorIds\": [\n\"vfbzqahmuemgdegkzntfhzcjhjrbgfoljfzogfuqweggchum\",\n\"inxmqh-\",\n],\n\"bookItems\": {\n\"ullamco5\": {\n\"id\": \"f7dac8c3-E59D-bc2E-7B33-C27F3794E2d6\",\n\"libId\": \"4jtbj7q7nrylfu114m\",\n\"purchaseDate\": \"2001-08-01\",\n\"isLent\": false\n},\n\"culpa_3e\": {\n\"id\": \"423DCdDF-CDAe-2CAa-f956-C6cd9dA8054b\",\n\"libId\": \"6wcxbh\",\n\"purchaseDate\": \"1970-06-24\",\n\"isLent\": true\n}\n},\n\"publicationYear\": 1930,\n\"publisher\": \"sunt do nisi\"\n},\n\"aliquip_d7\": {\n\"title\": \"aute\",\n\"isbn\": \"348782167518177\",\n\"authorIds\": [\"owfgtdxjbiidsobfgvjpjlxuabqpjhdcqmmmrjb-ezrsz-u\"],\n\"bookItems\": {\n\"ipsum__0b\": {\n\"id\": \"6DfE93ca-DB23-5856-56Fd-82Ab8CffEFF5\",\n\"libId\": \"bvjh0p2p2666vs7dd\",\n\"purchaseDate\": \"2018-03-30\",\n\"isLent\": false\n}\n},\n\"publisher\": \"ea anim ut ex id\",\n\"publicationYear\": 1928\n}\n},\n\"authorsById\": {\n\"labore_b88\": {\n\"id\": \"adipisicing nulla proident\",\n\"name\": \"culpa in minim\",\n\"bookIsbns\": [\n\"6243029--7\",\n\"5557199424742986\"\n]",
        "sections_found": []
      },
      "accurate_page_range": "262-292"
    },
    {
      "text": "- 10.4 Advanced data manipulation",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "10 Database operations",
      "raw_line": "- 10.4 Advanced data manipulation (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 86,
      "chapter_info": {
        "page": 262,
        "title": "Database operations",
        "pattern_matched": "Chapter 10",
        "text_preview": "234 CHAPTER 11 Web services\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physic"
      },
      "chapter_sections": {
        "start_page": 262,
        "end_page": 292,
        "content": "\n--- Page 262 ---\n234 CHAPTER 11 Web services\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nTheo Yes! I think we now have all the pieces to enrich our search results.\n11.6 Search result enrichment in action\nJoe Can you write the steps of the enrichment data flow?\nTheo Sure.\nTheo goes to the whiteboard. He takes a moment to gather his thoughts, and then erases\nenough space so there’s room to list the steps.\nThe steps for the search result enrichment data flow\n1 Receive a request from a client.\n2 Extract from the client’s request the query and the fields to fetch from Open\nLibrary.\n3 Retrieve from the database the books that match the query.\n4 Fetch information from Open Library for each ISBN that match the query.\n5 Extract from Open Library responses for the required fields.\n6 Combine book information from the database with information from Open\nLibrary.\n7 Send the response to the client.\nJoe Perfect! Would you like to try to implement it?\nTheo I think I’ll start with the implementation of the book retrieval from the data-\nbase. It’s quite similar to what we did last month.\n NOTE See chapter 10 for last month’s lesson.\nJoe Actually, it’s even simpler because you don’t need to join tables.\nTheo That’s right, I need values only for the isbn and available columns.\nTheo works for a bit in his IDE. He begins with the book retrieval from the database.\nListing11.14 Retrieving books whose title matches a query\nvar dbSearchResultSchema = {\n\"type\": \"array\",\n\"items\": {\n--- Page 263 ---\n11.6 Search result enrichment in action 235\n\"type\": \"object\",\n\"required\": [\"isbn\", \"available\"],\n\"properties\": {\n\"isbn\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"}\n}\n}\n};\nclass CatalogDB {\nstatic matchingBooks(title) {\nvar matchingBooksQuery = `\nSELECT isbn, available\nFROM books\nWHERE title = like '%$1%';\n`;\nvar books = dbClient.query(catalogDB, matchingBooksQuery, [title]);\nif(!ajv.validate(dbSearchResultSchema, books)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from the database: \" +\nerrors;\n}\nreturn books;\n}\n}\nJoe So far, so good...\nTheo Next, I’ll go with the implementation of the retrieval of book information from\nOpen Library for several books. Unfortunately, the Open Library Books API\ndoesn’t support querying several books at once. I’ll need to send one request\nper book.\nJoe That’s a bit annoying. Let’s make our life easier and pretend that _.map works\nwith asynchronous functions. In real life, you’d need something like Promise\n.all in order to send the requests in parallel and combine the responses.\nTheo OK, then it’s quite straightforward. I’ll take the book retrieval code and add a\nmultipleBookInfo function that maps over bookInfo.\nTheo looks over the book retrieval code in listing 11.9 and then concentrates as he types\ninto his IDE. When he’s done, he shows the result in listing 11.15 to Joe.\nListing11.15 Retrieving book information from Open Library for several books\nclass OpenLibraryDataSource {\nstatic rawBookInfo(isbn) {\nvar url = `https:/ /openlibrary.org/isbn/${isbn}.json`;\nvar jsonString = fetchResponseBody(url);\nreturn JSON.parse(jsonString);\n}\nstatic bookInfo(isbn, requestedFields) {\nvar relevantFields = [\"title\", \"full_title\",\n\"subtitle\", \"publisher\",\n\"publish_date\", \"weight\",\n--- Page 264 ---\n236 CHAPTER 11 Web services\n\"physical_dimensions\", \"genre\",\n\"subjects\", \"number_of_pages\"];\nvar rawInfo = rawBookInfo(isbn);\nif(!ajv.validate(dbSearchResultSchema, bookInfoSchema)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from Open Books API: \" +\nerrors;\n}\nvar relevantInfo =\n_.pick(_.pick(rawInfo, relevantFields), requestedFields);\nreturn _.set(relevantInfo, \"isbn\", isbn);\n}\nstatic multipleBookInfo(isbns, fields) {\nreturn _.map(function(isbn) {\nreturn bookInfo(isbn, fields);\n}, isbns);\n}\n}\nJoe Nice! Now comes the fun part: combining information from several data sources.\nTheo Yeah. I have two arrays in my hands: one with book information from the data-\nbase and one with book information from Open Library. I somehow need to\njoin the arrays, but I’m not sure I can assume that the positions of the book\ninformation are the same in both arrays.\nJoe What would you like to have in your hands?\nTheo I wish I had two hash maps.\nJoe And what would the keys in the hash maps be?\nTheo Book ISBNs.\nJoe Well, I have good news for you: your wish is granted!\nTheo How?\nJoe Lodash provides a function named _.keyBy that transforms an array into a map.\nTheo I can’t believe it. Can you show me an example?\nJoe Sure. Let’s call _.keyBy on an array with two books.\nListing11.16 Transforming an array into a map with _.keyBy\nvar books = [\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"isbn\": \"978-1982137274\",\n\"available\": true\n},\n{\n\"title\": \"The Power of Habit\",\n\"isbn\": \"978-0812981605\",\n\"available\": false\n}\n];\n_.keyBy(books, \"isbn\");\n--- Page 265 ---\n11.6 Search result enrichment in action 237\nJoe And here’s the result.\nListing11.17 The result of keyBy\n{\n\"978-0812981605\": {\n\"available\": false,\n\"isbn\": \"978-0812981605\",\n\"title\": \"The Power of Habit\"\n},\n\"978-1982137274\": {\n\"available\": true,\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\"\n}\n}\nTheo keyBy is awesome!\nJoe Don’t exaggerate, my friend; _.keyBy is quite similar to _.groupBy. The\nonly difference is that _.keyBy assumes that there’s only one element in\neach group.\nTheo I think that, with _.keyBy, I’ll be able to write a generic joinArrays function.\nJoe I’m glad to see you thinking in terms of implementing business logic through\ngeneric data manipulation functions.\nTIP Many parts of the business logic can be implemented through generic data\nmanipulation functions.\nTheo The joinArrays function needs to receive the arrays and the field name for\nwhich we decide the two elements that need to be combined, for instance,\nisbn.\nJoe Remember, in general, it’s not necessarily the same field name for both arrays.\nTheo Right, so joinArrays needs to receive four arguments: two arrays and two\nfield names.\nJoe Go for it! And, please, write a unit test for joinArrays.\nTheo Of course...\nTheo works for a while and produces the code in listing 11.18. He then types the unit test\nin listing 11.19.\nListing11.18 A generic function for joining arrays\nfunction joinArrays(a, b, keyA, keyB) {\nvar mapA = _.keyBy(a, keyA);\nvar mapB = _.keyBy(b, keyB);\nvar mapsMerged = _.merge(mapA, mapB);\nreturn _.values(mapsMerged);\n}\n--- Page 266 ---\n238 CHAPTER 11 Web services\nListing11.19 A unit test for joinArrays\nvar dbBookInfos = [\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true\n},\n{\n\"isbn\": \"978-0812981605\",\n\"title\": \"The Power of Habit\",\n\"available\": false\n}\n];\nvar openLibBookInfos = [\n{\n\"isbn\": \"978-0812981605\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432,\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"The Power of Habit\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n],\n}\n];\nvar joinedArrays = [\n{\n\"available\": true,\n\"isbn\": \"978-1982137274\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\",\n],\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"title\": \"The Power of Habit\",\n},\n{\n\"available\": false,\n\"isbn\": \"978-0812981605\",\n\"number_of_pages\": 432,\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"title\": \"7 Habits of Highly Effective People\",\n},\n]\n--- Page 267 ---\n11.6 Search result enrichment in action 239\n_.isEqual(joinedArrays,\njoinArrays(dbBookInfos, openLibBookInfos, \"isbn\", \"isbn\"));\nJoe Excellent! Now, you are ready to adjust the last piece of the extended search\nresult endpoint.\nTheo That’s quite easy. We fetch data from the database and from Open Library and\njoin them.\nTheo works quite rapidly. He then shows Joe the code.\nListing11.20 Search books and enriched book information\nclass Catalog {\nstatic enrichedSearchBooksByTitle(searchPayload) {\nif(!ajv.validate(searchBooksRequestSchema, searchPayload)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid request:\" + errors;\n}\nvar title = _.get(searchPayload, \"title\");\nvar fields = _.get(searchPayload, \"fields\");\nvar dbBookInfos = CatalogDataSource.matchingBooks(title);\nvar isbns = _.map(dbBookInfos, \"isbn\");\nvar openLibBookInfos =\nOpenLibraryDataSource.multipleBookInfo(isbns, fields);\nvar res = joinArrays(dbBookInfos, openLibBookInfos);\nif(!ajv.validate(searchBooksResponseSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid response:\" + errors;\n}\nreturn res;\n}\n}\nNow comes the tricky part. Theo takes a few moments to meditate about the simplicity of\nthe code that implements the extended search endpoint. He thinks about how classes are\nmuch less complex when we use them only to aggregate stateless functions that operate on\nsimilar domain entities and then goes to work plotting the code.\nListing11.21 Schema for the extended search endpoint (Open Books API part)\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n--- Page 268 ---\n240 CHAPTER 11 Web services\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing11.22 Extended search endpoint (Open Books API part)\nvar ajv = new Ajv({allErrors: true});\nclass OpenLibraryDataSource {\nstatic rawBookInfo(isbn) {\nvar url = `https:/ /openlibrary.org/isbn/${isbn}.json`;\nvar jsonString = fetchResponseBody(url);\nreturn JSON.parse(jsonString);\n}\nstatic bookInfo(isbn, requestedFields) {\nvar relevantFields = [\"title\", \"full_title\",\n\"subtitle\", \"publisher\",\n\"publish_date\", \"weight\",\n--- Page 269 ---\n11.6 Search result enrichment in action 241\n\"physical_dimensions\", \"genre\",\n\"subjects\", \"number_of_pages\"];\nvar rawInfo = rawBookInfo(isbn);\nif(!ajv.validate(bookInfoSchema, rawInfo)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from Open Books API: \" +\nerrors;\n}\nvar relevantInfo = _.pick(\n_.pick(rawInfo, relevantFields),\nrequestedFields);\nreturn _.set(relevantInfo, \"isbn\", isbn);\n}\nstatic multipleBookInfo(isbns, fields) {\nreturn _.map(function(isbn) {\nreturn bookInfo(isbn, fields);\n}, isbns);\n}\n}\nListing11.23 Extended search endpoint (database part)\nvar dbClient;\nvar dbSearchResultSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"isbn\", \"available\"],\n\"properties\": {\n\"isbn\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"}\n}\n}\n};\nclass CatalogDB {\nstatic matchingBooks(title) {\nvar matchingBooksQuery = `\nSELECT isbn, available\nFROM books\nWHERE title = like '%$1%';\n`;\nvar books = dbClient.query(catalogDB, matchingBooksQuery, [title]);\nif(!ajv.validate(dbSearchResultSchema, books)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from the database: \"\n+ errors;\n}\nreturn books;\n}\n}\n--- Page 270 ---\n242 CHAPTER 11 Web services\nListing11.24 Schema for the implementation of the extended search endpoint\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"type\": [\n\"title\",\n\"full_title\",\n\"subtitle\",\n\"publisher\",\n\"publish_date\",\n\"weight\",\n\"physical_dimensions\",\n\"number_of_pages\",\n\"subjects\",\n\"publishers\",\n\"genre\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksResponseSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nListing11.25 Schema for the extended search endpoint (combines the pieces)\nclass Catalog {\nstatic enrichedSearchBooksByTitle(request) {\n--- Page 271 ---\n11.6 Search result enrichment in action 243\nif(!ajv.validate(searchBooksRequestSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid request:\" + errors;\n}\nvar title = _.get(request, \"title\");\nvar fields = _.get(request, \"fields\");\nvar dbBookInfos = CatalogDataSource.matchingBooks(title);\nvar isbns = _.map(dbBookInfos, \"isbn\");\nvar openLibBookInfos =\nOpenLibraryDataSource.multipleBookInfo(isbns, fields);\nvar response = joinArrays(dbBookInfos, openLibBookInfos);\nif(!ajv.validate(searchBooksResponseSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid response:\" + errors;\n}\nreturn response;\n}\n}\nclass Library {\nstatic searchBooksByTitle(payloadBody) {\nvar payloadData = JSON.parse(payloadBody);\nvar results = Catalog.searchBooksByTitle(payloadData);\nreturn JSON.stringify(results);\n}\n}\nTIP Classes are much less complex when we use them as a means to aggregate state-\nless functions that operate on similar domain entities.\nJoe interrupts Theo’s meditation moment. After looking over the code in the previous list-\nings, he congratulates Theo.\nJoe Excellent job, my friend! By the way, after reading The Power of Habit, I quit\nchewing my nails.\nTheo Wow! That’s terrific! Maybe I should read that book to overcome my habit of\ndrinking too much coffee.\nJoe Thanks, and good luck with the coffee habit.\nTheo I was supposed to call Nancy later today with an ETA for the Open Library\nBook milestone. I wonder what her reaction will be when I tell her the feature\nis ready.\nJoe Maybe you should tell her it’ll be ready in a week, which would give you time to\nbegin work on the next milestone.\n--- Page 272 ---\n244 CHAPTER 11 Web services\nDelivering on time\nJoe was right! Theo recalls Joe’s story about the young woodcutter and the old man. Theo\nwas able to learn DOP and deliver the project on time! He’s pleased that he took the time\n“to sharpen his saw and commit to a deeper level of practice.”\n NOTE If you are unable to recall the story or if you missed it, check out the opener\nto part 2.\nThe Klafim project is a success. Nancy is pleased. Theo’s boss is satisfied. Theo got pro-\nmoted. What more can a person ask for?\nTheo remembers his deal with Joe. As he strolls through the stores of the Westfield San\nFrancisco Center to look for a gift for each of Joe’s children, Neriah and Aurelia, he is\nfilled with a sense of purpose and great pleasure. He buys a DJI Mavic Air 2 drone for Ner-\niah, and the latest Apple Airpod Pros for Aurelia. He also takes this opportunity to buy a\nnecklace and a pair of earrings for his wife, Jane. It’s a way for him to thank her for having\nendured his long days at work since the beginning of the Klafim project.\n NOTE The story continues in the opener of part 3.\nSummary\n We build the insides of our systems like we build the outsides.\n Components inside a program communicate via data that is represented as\nimmutable data collections in the same way as components communicate via\ndata over the wire.\n In DOP, the inner components of a program are loosely coupled.\n Many parts of business logic can be implemented through generic data manipu-\nlation functions. We use generic functions to\n– Implement each step of the data flow inside a web service.\n– Parse a request from a client.\n– Apply business logic to the request.\n– Fetch data from external sources (e.g., database and other web services).\n– Apply business logic to the responses from external sources.\n– Serialize response to the client.\n Classes are much less complex when we use them as a means to aggregate\ntogether stateless functions that operate on similar domain entities.\nLodash functions introduced in this chapter\nFunction Description\nkeyBy(coll, f) Creates a map composed of keys generated from the results of running each ele-\nment of coll through f; the corresponding value for each key is the last element\nresponsible for generating the key.\n--- Page 273 ---\nPart 3\nMaintainability\nA\nfter a month, the Klafim project enters what Alabatross calls the mainte-\nnance phase. Small new features need to be added on a weekly basis. Bugs need to be\nfixed; nothing dramatic....\nMonica, Theo’s boss, decides to allocate Dave to the maintenance of the Klafim\nproject. It makes sense. Over the last few months, Dave has demonstrated a great atti-\ntude of curiosity and interest, and he has solid programming skills. Theo sets up a\nmeeting with Joe and Dave, hoping that Joe will be willing to teach DOP to Dave so\nthat he can continue to advance the good work he’s already done on Klafim. Theo\nand Dave place a conference call to Joe.\nTheo Hi, Joe. Will you have time over the next few weeks to teach Dave the\nprinciples of DOP?\nJoe Yes, but I prefer not to.\nDave Why? Is it because I don’t have enough experience in software develop-\nment? I can guarantee you that I’m a fast learner.\nJoe It has nothing to do with your experience, Dave.\nTheo Why not then?\nJoe Theo, I think that you could be a great mentor for Dave.\nTheo But, I don’t even know all the parts of DOP!\nDave Come on! No false modesty between us, my friend.\nJoe Knowledge is never complete. As the great Socrates used to say, “The more\nI know, the more I realize I know nothing.” I’m confident you will be able\nto learn the missing parts by yourself and maybe even invent some.\nTheo How will I be able to invent missing parts?\n--- Page 274 ---\n246 PART 3 Maintainability\nJoe You see, DOP is such a simple paradigm that it’s fertile material for innovation.\nPart of the material I taught you I learned from others, and part of it was an\ninvention of mine. If you keep practicing DOP, I’m quite sure you, too, will\ncome up with some inventions of your own.\nTheo What do you say Dave? Are you willing to learn DOP from me?\nDave Definitely!\nTheo Joe, will you be continue to be available if we need your help from time to time?\nJoe Of course!\n--- Page 275 ---\nAdvanced data\nvalidation\nA self-made gift\nThis chapter covers\n Validating function arguments\n Validating function return values\n Data validation beyond static types\n Automatic generation of data model diagrams\n Automatic generation of schema-based unit tests\nAs the size of a code base grows in a project that follows DOP principles, it becomes\nharder to manipulate functions that receive and return only generic data. It is hard\nto figure out the expected shape of the function arguments, and when we pass\ninvalid data, we don’t get meaningful errors.\nUntil now, we have illustrated how to validate data at system boundaries. In this\nchapter, we will illustrate how to validate data when it flows inside the system by\ndefining data schemas for function arguments and their return values. This allows\nus to make explicit the expected shape of function arguments, and it eases develop-\nment. We gain some additional benefits from this endeavor, such as automatic gen-\neration of data model diagrams and schema-based unit tests.\n247\n--- Page 276 ---\n248 CHAPTER 12 Advanced data validation\n12.1 Function arguments validation\nDave’s first task is to implement a couple of new HTTP endpoints to download the catalog\nas a CSV file, search books by author, and rate the books. Once he is done with the tasks,\nDave calls Theo for a code review.\n NOTE The involvement of Dave in the Klafim project is explained in the opener for\npart 3. Please take a moment to read the opener if you missed it.\nTheo Was it difficult to get your head around the DOP code?\nDave Not so much. I read your notes of the meetings with Joe, and I must admit, the\ncode is quite simple to grasp.\nTheo Cool!\nDave But there is something that I can’t get used to.\nTheo What’s that?\nDave I’m struggling with the fact that all the functions receive and return generic\ndata. In OOP, I know the expected shape of the arguments for each and every\nfunction.\nTheo Did you validate data at system boundaries, like I have done?\nDave Absolutely. I defined a data schema for every additional user request, database\nquery, and external service response.\nTheo Nice!\nDave Indeed, when the system runs in production, it works well. When data is valid,\nthe data flows through the system, and when data is invalid, we are able to dis-\nplay a meaningful error message to the user.\nTheo What’s the problem then?\nDave The problem is that during development, it’s hard to figure out the expected\nshape of the function arguments. And when I pass invalid data by mistake, I\ndon’t get clear error messages.\nTheo I see. I remember that when Joe showed me how to validate data at system\nboundaries, I raised this concern about the development phase. Joe told me\nthen that we validate data as it flows inside the system exactly like we validate data\nat system boundaries: we separate between data schema and data representation.\nDave Are we going to use JSON Schema also?\nTheo Yes.\nDave Cool.... I like JSON Schema.\nTheo The main purpose of data validation at system boundaries is to prevent invalid\ndata from getting into the system, whereas the main purpose of data validation\ninside the system is to make it easier to develop the system. Here, let me draw a\ntable on the whiteboard for you to visualize this (table 12.1).\nTable 12.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\n--- Page 277 ---\n12.1 Function arguments validation 249\nDave By making it easier to develop the system, do you mean to help the developers\nunderstand the expected shape of function arguments as in OOP?\nTheo Exactly.\nDave But I’m impatient.... Will you help me figure out how to validate the argu-\nments of the function that implements a book search?\nTheo Let me see the code of the implementation, and I’ll do my best.\nDave We have two implementations of a book search: one where library data lives\nin memory from the prototype phase and one where library data lives in the\ndatabase.\nTheo I think that the schema for library data in memory is going to be more interest-\ning than the schema for library data in the database, as the book search func-\ntion receives catalog data in addition to the query.\nDave When you say more interesting data schema, you mean more difficult to write?\nTheo More difficult to write, but it’s also more insightful.\nDave Then let’s go with library data in memory. The code for Catalog.search-\nBooksByTitle from the prototype phase would look like this.\nDave pulls up some code on his laptop. He shows it to Theo.\nListing12.1 The implementation of search without data validation\nclass Catalog {\nstatic authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nreturn bookInfo;\n}\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\n--- Page 278 ---\n250 CHAPTER 12 Advanced data validation\nTheo Dave, please remind me of the expected shapes for catalogData and query.\nDave Sure. query should be a string, and catalogData should be a map that con-\nforms to the catalog data model.\nTheo What is the catalog data model?\nDave Let me see. I have seen a diagram of it somewhere.\nDave rummages around a bit in his folder for Klafim’s Library Management System. Find-\ning what he’s looking for, he draws the diagram in figure 12.1 on the whiteboard.\nC Catalog\nbooksByIsbn: {Book}\nauthorsById: {Author}\nC Book\nC Author\ntitle : String\npublicationYear: Number id: String\nisbn: String name: String\nauthorlds: [String] booklsbns: [String]\nbookltems: [Bookltem]\nC Bookltem\nid: String\nlibld: String\npurchaseDate: String\nisLent: Boolean\nFigure 12.1 The catalog data model\n NOTE The schemas for this book use JSON Schema version 2020-12.\nTheo Can you write a JSON Schema for the catalog data model?\nDave Am I allowed to use internal variables for book and author schemas, or do I\nhave to nest all the schemas inside the catalog schema?\nTheo JSON Schema is part of the code. If you feel that using internal variables would\nmake the code more readable, go for it.\nDave OK. Now I need the JSON Schema gift that Joe gave you.\nTheo picks up a well-worn piece of paper that is a bit torn and quite wrinkled. He gives\nDave the JSON Schema cheat sheet.\nListing12.2 JSON Schema cheat sheet\nAt the root level,\n{\ndata is an array.\n\"type\": \"array\",\n\"items\": { Each element of the array is a map.\n\"type\": \"object\",\nThe properties of each field in the map\n\"properties\": {\n--- Page 279 ---\n12.1 Function arguments validation 251\n\"myNumber\": {\"type\": \"number\"},\nmyNumber\n\"myString\": {\"type\": \"string\"}, myEnum is an enumeration\nis a number.\n\"myEnum\": {\"enum\": [\"myVal\", \"yourVal\"]}, value with two possibilities,\nmyString is \"myBool\": {\"type\": \"boolean\"} \"myVal\" and \"yourVal\".\na string. },\n\"required\": [\"myNumber\", \"myString\"], myBool is a boolean.\n\"additionalProperties\": false\n} The mandatory fields in the map\n} We don’t allow fields that are not are myNumber and myString.\nexplicitly mentioned in the schema. Other fields are optional.\nDave I think I’ll start with the author schema. It seems simpler than the book schema.\nQuickly composing the code, Dave shows Theo the author schema. Dave, still new to DOP,\nlooks for Theo’s reaction.\nListing12.3 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"id\", \"name\", \"bookIsbns\"],\n\"properties\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nTheo Well done! Let’s move on to the book schema now.\nDave I think I am going to store the book item schema in a variable.\nListing12.4 The book item schema\nvar bookItemSchema = {\n\"type\": \"object\",\n\"properties\":{\n\"id\": {\"type\": \"string\"},\n\"libId\": {\"type\": \"string\"},\n\"purchaseDate\": {\"type\": \"string\"},\n\"isLent\": {\"type\": \"boolean\"}\n},\n\"required\": [\"id\", \"libId\", \"purchaseDate\", \"isLent\"]\n};\nvar bookSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorIds\", \"bookItems\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publicationYear\": {\"type\": \"integer\"},\n--- Page 280 ---\n252 CHAPTER 12 Advanced data validation\n\"isbn\": {\"type\": \"string\"},\n\"authorIds\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"bookItems\": {\n\"type\": \"array\",\n\"items\": bookItemSchema\n}\n}\n};\nTIP When you define a complex data schema, it is advisable to store nested schemas\nin variables to make the schemas easier to read.\nTheo Why didn’t you include publicationYear in the list of required fields in the\nbook schema?\nDave Because, for some books, the publication year is missing. Unlike in OOP, it will\nthen be easy to deal with nullable fields.\nTheo Excellent! And now, please tackle the final piece, the catalog schema.\nDave Here I have a problem. The catalog should be a map with two fields, books-\nByIsbn and authorsById. Both values should be indexes, represented in the\nmodel diagram with curly braces. I have no idea how to define the schema for\nan index.\nTheo Do you remember how we represent indexes in DOP?\nDave Yes, indexes are represented as maps.\nTheo Right, and what’s the difference between those maps and the maps that we use\nfor records?\nDave For records, we use maps where the names of the fields are known and the val-\nues can have different shapes. For indexes, we use maps where the names of\nthe fields are unknown and the values have a common shape.\nTheo Right. We call the maps for records heterogeneous maps and the maps for\nindexes homogeneous maps.\nTIP In DOP, records are represented as heterogeneous maps, whereas indexes are repre-\nsented as homogeneous maps.\nDave Then how do we define the schema of an homogeneous map in JSON Schema?\nTheo I don’t know. Let’s check the JSON Schema online documentation.\n NOTE See https://json-schema.org/ to access the online documentation for JSON\nSchema version 2020-12.\nAfter a couple of minutes of digging into the JSON Schema online documentation, Theo\nfinds a piece about additionalProperties. He studies the information for a while before\nmaking up his mind.\n--- Page 281 ---\n12.1 Function arguments validation 253\nTheo I think we could use additionalProperties. Here’s the JSON Schema for an\nhomogeneous map where the values are numbers.\nListing12.5 The JSON Schema for an homogeneous map with values as numbers\n{\n\"type\": \"object\",\n\"additionalProperties\": {\"type\": \"number\"}\n}\nDave I thought that additionalProperties was supposed to be a boolean and that\nit was used to allow or forbid properties not mentioned in the schema.\nTheo That’s correct. Usually additionalProperties is a boolean, but the documen-\ntation says it could also be a map that defines a schema. In that case, it means\nproperties not mentioned in the schema should have the value of the schema\nassociated with additionalProperties.\nDave I see. But what does that have to do with homogeneous maps?\nTheo Well, a homogeneous map could be seen as a map with no predefined proper-\nties, where all the additional properties are of an expected type.\nDave Tricky!\nTIP In JSON Schema, homogeneous string maps have type: object with no\nproperties and additionalProperties associated to a schema.\nTheo Indeed. Now, let me show you what the catalog schema looks like.\nTheo types briefly on his laptop. He shows Dave the catalog schema.\nListing12.6 The schema for catalog data\nvar catalogSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"booksByIsbn\": {\n\"type\": \"object\",\n\"additionalProperties\": bookSchema\n},\n\"authorsById\": {\n\"type\": \"object\",\n\"additionalProperties\": authorSchema\n}\n},\n\"required\": [\"booksByIsbn\", \"authorsById\"]\n};\nDave Are we ready to plug the catalog and the query schema into the Catalog\n.searchBooksByTitle implementation?\nTheo We could, but I think we can do better by defining a single schema that com-\nbines both the catalog and query schemas.\nDave How would we combine two schemas into a single schema?\n--- Page 282 ---\n254 CHAPTER 12 Advanced data validation\nTheo Do you know what a tuple is?\nDave I think I know, but I can’t define it formally.\nTheo A tuple is an array where the size is fixed, and the elements can be of different\nshapes.\nDave OK. So, how do we define tuples in JSON Schema?\nOnce again, Theo explores the JSON Schema online documentation. Fortunately, he has\nbookmarked the page, and in no time at all, finds the information he needs.\nTheo I found it! We use prefixItems in the definition of a tuple made of a string\nand a number, for instance.\nTheo types more code on his laptop. When he finishes, he shows Dave the schema for a\ntuple.\nListing12.7 The schema for a tuple made of a string and a number\n{\n\"type\": \"array\",\n\"prefixItems\": [\n{ \"type\": \"string\" },\n{ \"type\": \"number\" }\n]\n}\nDave I see. And how would you define the schema for the arguments of Catalog\n.searchBooksByTitle?\nTheo Well, it’s a tuple of size 2, where the first element is a catalog and the second\nelement is a string.\nDave Something like this schema?\nListing12.8 The schema for the arguments of Catalog.searchBooksByTitle\nvar searchBooksArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\ncatalogSchema,\n{ \"type\": \"string\" },\n]\n};\nTheo Exactly!\nDave Now that we have the schema for the arguments, how do we plug it into the\nimplementation of search books?\nTheo That’s similar to the way we validate data at system boundaries. The main dif-\nference is that the data validation for data that flows inside the system should\nrun only at development time, and it should be disabled when the code runs in\nproduction.\nDave Why?\n--- Page 283 ---\n12.2 Return value validation 255\nTheo Because that data has been already validated up front at a system boundary.\nValidating it again on a function call is superfluous, and it would impact\nperformance.\nDave When you say development time, does that include testing and staging\nenvironments?\nTheo Yes, all the environments besides production.\nDave I see. It’s like assertions in Java. They are disabled in production code.\nTIP Data validation inside the system should be disabled in production.\nTheo Exactly. For now, I am going to assume that we have a dev function that returns\ntrue when the code runs in the development environment and false when it\nruns in production. Having said that, take a look at this code.\nListing12.9 Implementation of search with validation of function arguments\nCatalog.searchBooksByTitle = function(catalogData, query) {\nif(dev()) {\nvar args = [catalogData, query];\nif(!ajv.validate(searchBooksArgsSchema, args)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle called with invalid arguments: \" +\nerrors);\nThe implementation of dev() depends on the run-time\n}\nenvironment: it returns true when the code runs in dev\n}\nenvironments and false when it runs in production.\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nDave Do you think we should validate the arguments of all the functions?\nTheo No. I think we should treat data validation like we treat unit tests. We should\nvalidate function arguments only for functions for whom we would write unit\ntests.\nTIP Treat data validation like unit tests.\n12.2 Return value validation\nDave Do you think it would make sense to also validate the return value of functions?\nTheo Absolutely.\nDave Cool. Let me try to write the JSON Schema for the return value of Catalog\n.searchBooksByTitle.\n--- Page 284 ---\n256 CHAPTER 12 Advanced data validation\nAfter a few minutes, Dave comes up with the schema. Taking a deep breath, then releasing\nit, he shows the code to Theo.\nListing12.10 The schema for the return value of Catalog.searchBooksByTitle\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorNames\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"isbn\": {\"type\": \"string\"},\n\"authorNames\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n};\nTheo Well done! Now, would you like to try adding return value validation to the\ncode of Catalog.searchBooksByTitle?\nDave Sure.\nDave works for a bit in his IDE. A bit more confident this time, he shows the result to Theo.\nListing12.11 Search with data validation for both input and output\nCatalog.searchBooksByTitle = function(catalogData, query) {\nif(dev()) {\nif(!ajv.validate(searchBooksArgsSchema, [catalogData, query])) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle called with invalid arguments: \" +\nerrors);\n}\n}\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nif(dev()) {\nif(!ajv.validate(searchBooksResponseSchema, bookInfos)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle returned an invalid value: \" +\nerrors);\n}\n}\n--- Page 285 ---\n12.3 Advanced data validation 257\nreturn bookInfos;\n};\nTheo Excellent! Now we need to figure out how to deal with advanced data validation.\n12.3 Advanced data validation\nDave What do you mean by advanced data validation?\nTheo I mean going beyond static types.\nDave Could you give me an example?\nTheo Sure. Take, for instance, the publication year of a book. It’s an integer, but\nwhat else could you say about this number?\nDave It has to be positive. It would say it’s a positive integer.\nTheo Come on, Dave! Be courageous, go beyond types.\nDave I don’t know. I would say it’s a number that should be higher than 1900. I\ndon’t think it makes sense to have a book that is published before 1900.\nTheo Exactly. And what about the higher limit?\nDave I’d say that the publication year should be less than the current year.\nTheo Very good! I see that JSON Schema supports number ranges. Here is how we\ncan write the schema for an integer that represents a year and should be\nbetween 1900 and 2021.\nListing12.12 The schema for an integer between 1900 and 2021\nvar publicationYearSchema = {\n\"type\": \"integer\",\n\"minimum\": 1900,\n\"maximum\": 2021\n};\nDave Why isn’t this kind of data validation possible in OOP?\nTheo I’ll let you think about that for a moment.\nDave I think have it! In DOP, data validation is executed at run time, while static\ntype validation in OOP is executed at compile time. At compile time, we only\nhave information about static types; at run time, we have the data itself. That’s\nwhy in DOP data validation, it’s possible to go beyond types.\n NOTE Of course, it’s also possible in traditional OOP to write custom run-time data\nvalidation. Here, though, we are comparing data schema with static types.\nTheo You got it! Now, let me show you how to write the schema for a string that\nshould match a regular expression.\n NOTE See http://mng.bz/OGNP for the JavaScript Guide to regular expressions.\nTheo Let’s take for example the book ID. I am assuming it must be a UUID.\nDave Right.\nTheo Can you write the regular expression for a valid UUID?\n--- Page 286 ---\n258 CHAPTER 12 Advanced data validation\nDave googles “UUID regex” and finds something he thinks just might work. He shows the\nregular expression to Theo.\nListing12.13 The regular expression for a valid UUID\n[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\nDave Now, how do we plug a regular expression into a JSON Schema?\nTheo While you were looking for the UUID regular expression, I read about the\npattern field. Here’s how we can plug the UUID regular expression into a\nJSON Schema.\nListing12.14 The schema for a UUID\nvar uuidSchema = {\n\"type\": \"string\",\n\"pattern\": \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}\" +\n\"-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\n};\nDave Nice! Let me improve the catalog schema and refine the schema for purchase-\nDate, isbn, libId, and authorId with regular expressions.\nTheo Before you do that, though, let me tell you something I read about regular\nexpressions: some of them are predefined. For example, there is a predefined\nregular expression for dates.\nDave How does it work?\nTheo With the help of the format field.\n NOTE According to JSON Schema specification, format is just for annotation and\ndoesn’t affect validation. But in practice, JSON Schema validation libraries use format\nalso for validation.\nTheo moves to his laptop. He inputs the schema for a date and shows it to Dave.\nListing12.15 The schema for a date\n{\n\"type\": \"string\",\n\"format\": \"date\"\n}\nTIP In DOP, data validation goes beyond static types (e.g., number ranges, regular\nexpressions, and so on).\nDave Very cool! Do I have all the information I need in order to refine the catalog\nschema?\nTheo Yes, go for it!\nIt takes Dave a bit of time to write the regular expressions for isbn, authorId, and libId.\nBut with the help of Google (again) and a bit of simplification, Dave comes up with the\nschema in listings 12.16 and 12.17.\n--- Page 287 ---\n12.3 Advanced data validation 259\nListing12.16 The refined schema of the catalog data (Part 1)\nvar isbnSchema = {\n\"type\": \"string\",\n\"pattern\": \"^[0-9-]{10,20}$\"\n};\nvar libIdSchema = {\n\"type\": \"string\",\n\"pattern\": \"^[a-z0-9-]{3,20}$\"\n};\nvar authorIdSchema ={\n\"type\": \"string\",\n\"pattern\": \"[a-z-]{2,50}\"\n};\nvar bookItemSchema = {\n\"type\": \"object\",\n\"additionalProperties\": {\n\"id\": uuidSchema,\n\"libId\": libIdSchema,\n\"purchaseDate\": {\n\"type\": \"string\",\n\"format\": \"date\"\n},\n\"isLent\": {\"type\": \"boolean\"}\n}\n};\nListing12.17 The refined schema of the catalog data (Part 2)\nvar bookSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorIds\", \"bookItems\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publicationYear\": publicationYearSchema,\n\"isbn\": isbnSchema,\n\"publisher\": {\"type\": \"string\"},\n\"authorIds\": {\n\"type\": \"array\",\n\"items\": authorIdSchema\n},\n\"bookItems\": bookItemSchema\n}\n};\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"id\", \"name\", \"bookIsbns\"],\n\"properties\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n--- Page 288 ---\n260 CHAPTER 12 Advanced data validation\n\"bookIsbns\": {\n\"items\": isbnSchema\n}\n}\n};\nvar catalogSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"booksByIsbn\": {\n\"type\": \"object\",\n\"additionalProperties\": bookSchema\n},\n\"authorsById\": {\n\"type\": \"object\",\n\"additionalProperties\": authorSchema\n}\n},\n\"required\": [\"booksByIsbn\", \"authorsById\"]\n};\n12.4 Automatic generation of data model diagrams\nBefore going home, Theo phones Joe to tell him about how he and Dave used data valida-\ntion inside the system. Joe tells Theo that that’s exactly how he recommends doing it and\nsuggests he come and visit Theo and Dave at the office tomorrow. He wants to show them\nsome cool advanced stuff related to data validation. The next day, with coffee in hand, Joe\nstarts the discussion.\nJoe Are you guys starting to feel the power of data validation à la DOP?\nDave Yes, it’s a bit less convenient to validate a JSON Schema than it is to write the\nclass of function arguments, but this drawback is compensated by the fact that\nJSON Schema supports conditions that go beyond static types.\nTheo We also realized that we don’t have to validate data for each and every function.\nJoe Correct. Now, let me show you another cool thing that we can do with JSON\nSchema.\nDave What’s that?\nJoe Generate a data model diagram.\nDave Wow! How does that work?\nJoe There are tools that receive a JSON Schema as input and produce a diagram in\na data model format.\nDave What is a data model format?\nJoe It’s a format that allows you to define a data model in plain text. After that, you\ncan generate an image from the text. My favorite data format is PlantUML.\n NOTE For more on PlantUML, see https://plantuml.com/.\nDave Do you know of other tools that generate data model diagrams?\nJoe I have used JSON Schema Viewer and Malli.\n--- Page 289 ---\n12.4 Automatic generation of data model diagrams 261\n NOTE You can find information on the JSON Schema Viewer at https://navneethg\n.github.io/jsonschemaviewer/ and on Malli at https://github.com/metosin/malli.\nJoe shows Dave and Theo the PlantUML diagram that Malli generated (listing 12.18) from\nthe catalog schema in listings 12.16 and 12.17.\nListing12.18 A PlantUML diagram generated from the catalog data schema\n@startuml\nEntity1 *-- Entity2\nEntity1 *-- Entity4\nEntity2 *-- Entity3\nclass Entity1 {\n+ booksByIsbn: {Entity2}\n+ authorsById: {Entity4}\n}\nclass Entity2 {\n+ title : String\n+ publicationYear: Number\n+ isbn: String\n+ authorIds: [String]\n+ bookItems: [Entity3]\n}\nclass Entity3 {\n+ id: String\n+ libId: String\n+ purchaseDate: String\n+ isLent: Boolean\n}\nclass Entity4 {\n+ id: String\n+ name: String\n+ bookIsbns: [String]\n}\n@enduml\nDave Is it possible to visualize this diagram?\nJoe Absolutely. Let me copy and paste the diagram text into the PlantText online\ntool.\n NOTE See https://www.planttext.com/ for more on the PlantText online tool.\nDave opens his web browser and types the URL for PlantText. After copying and pasting\nthe text, he steps aside so that Theo and Dave can view the diagram that looks like the\nimage in figure 12.2.\n--- Page 290 ---\n262 CHAPTER 12 Advanced data validation\nC Entity1\nbooksByIsbn: {Entity2}\nauthorsById: {Entity3}\nC Entity2 C Entity4\ntitle : String id: String\npublicationYear: Number name: String\nisbn: String booklsbns: [String]\nauthorlds: [String]\nbookltems: [Entity3]\nC Entity3\nid: String\nlibld: String\nFigure 12.2 A visualization of\npurchaseDate: String\nthe PlantUML diagram generated\nisLent: Boolean\nfrom the catalog data schema\nDave That’s cool! But why are the diagram entities named Entity1, Entity2, and\nso on?\nJoe Because in JSON Schema, there’s no way to give a name to a schema. Malli has\nto autogenerate random names for you.\nTheo Also, I see that the extra information we have in the schema, like the number\nrange for publicationYear and string regular expression for isbn, is missing\nfrom the diagram.\nJoe Right, that extra information is not part of the data model. That’s why it’s not\nincluded in the generated data model diagram.\nDave Anyway, it’s very cool!\nJoe If you guys like the data model generation feature, I’m sure you’re going to\nlike the next feature.\nDave What’s it about?\nJoe Automatic generation of unit tests.\nTheo Wow, sounds exciting!\n12.5 Automatic generation of schema-based unit tests\nJoe Once you’ve defined a data schema for function arguments and for its return\nvalue, it’s quite simple to generate a unit test for this function.\nDave How?\nJoe Well, think about it. What’s the essence of a unit test for a function?\nDave A unit test calls a function with some arguments and checks whether the func-\ntion returns the expected value.\nJoe Exactly! Now, let’s adapt it to the context of data schema and DOP. Let’s say you\nhave a function with a schema for their arguments and for their return value.\n--- Page 291 ---\n12.5 Automatic generation of schema-based unit tests 263\nDave OK.\nJoe Here’s the flow of a schema-based unit test. We call the function with random\narguments that conform to the schema of the function arguments. Then, we\ncheck whether the function returns a value that conforms to the schema of the\nreturn value. Here, let me diagram it.\nJoe goes to the whiteboard. He draws the diagram in figure 12.3.\nGeneraterandom datathat conforms toinput schema\nExecute the function The input\nis random.\nYes No\nOutput conforms to output schema\nTest passes Test fails\nFigure 12.3 The flow of\na schema-based unit test\nDave How do you generate random data that conforms to a schema?\nJoe Using a tool like JSON Schema Faker. For example, let’s start with a simple\nschema: the schema for a UUID. Let me show you how to generate random\ndata that conforms to the schema.\n NOTE You’ll find more information about JSON Schema Faker at https://github\n.com/json-schema-faker/json-schema-faker.\nJoe types on the keyboard for a bit. He then shows the code to generate random data to\nDave and Theo.\nListing12.19 Generating random data that conforms to a UUID schema\nvar uuidSchema = {\n\"type\": \"string\",\n\"pattern\": \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}\" +\n\"-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\n};\nJSONSchemaFaker.generate(uuidSchema);\n// → \"7aA8CdF3-14DF-9EF5-1A19-47dacdB16Fa9\"\nDave executes the code snippet a couple of times, and indeed, on each evaluation, it returns\na different UUID.\nDave Very cool! Let me see how it works with more complex schemas like the cata-\nlog schema.\n--- Page 292 ---\n264 CHAPTER 12 Advanced data validation\nWhen Dave calls JSONSchemaFaker.generate with the catalog schema, he gets some\nquite long random data. He’s a bit surprised by the results.\nListing12.20 Generating random data that conforms to the catalog schema\n{\n\"booksByIsbn\": {\n\"Excepteur7\": {\n\"title\": \"elit veniam anim\",\n\"isbn\": \"5419903-3563-7\",\n\"authorIds\": [\n\"vfbzqahmuemgdegkzntfhzcjhjrbgfoljfzogfuqweggchum\",\n\"inxmqh-\",\n],\n\"bookItems\": {\n\"ullamco5\": {\n\"id\": \"f7dac8c3-E59D-bc2E-7B33-C27F3794E2d6\",\n\"libId\": \"4jtbj7q7nrylfu114m\",\n\"purchaseDate\": \"2001-08-01\",\n\"isLent\": false\n},\n\"culpa_3e\": {\n\"id\": \"423DCdDF-CDAe-2CAa-f956-C6cd9dA8054b\",\n\"libId\": \"6wcxbh\",\n\"purchaseDate\": \"1970-06-24\",\n\"isLent\": true\n}\n},\n\"publicationYear\": 1930,\n\"publisher\": \"sunt do nisi\"\n},\n\"aliquip_d7\": {\n\"title\": \"aute\",\n\"isbn\": \"348782167518177\",\n\"authorIds\": [\"owfgtdxjbiidsobfgvjpjlxuabqpjhdcqmmmrjb-ezrsz-u\"],\n\"bookItems\": {\n\"ipsum__0b\": {\n\"id\": \"6DfE93ca-DB23-5856-56Fd-82Ab8CffEFF5\",\n\"libId\": \"bvjh0p2p2666vs7dd\",\n\"purchaseDate\": \"2018-03-30\",\n\"isLent\": false\n}\n},\n\"publisher\": \"ea anim ut ex id\",\n\"publicationYear\": 1928\n}\n},\n\"authorsById\": {\n\"labore_b88\": {\n\"id\": \"adipisicing nulla proident\",\n\"name\": \"culpa in minim\",\n\"bookIsbns\": [\n\"6243029--7\",\n\"5557199424742986\"\n]",
        "sections_found": []
      },
      "accurate_page_range": "262-292"
    },
    {
      "text": "- Summary",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "10 Database operations",
      "raw_line": "- Summary (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 87,
      "chapter_info": {
        "page": 262,
        "title": "Database operations",
        "pattern_matched": "Chapter 10",
        "text_preview": "234 CHAPTER 11 Web services\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physic"
      },
      "chapter_sections": {
        "start_page": 262,
        "end_page": 292,
        "content": "\n--- Page 262 ---\n234 CHAPTER 11 Web services\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nTheo Yes! I think we now have all the pieces to enrich our search results.\n11.6 Search result enrichment in action\nJoe Can you write the steps of the enrichment data flow?\nTheo Sure.\nTheo goes to the whiteboard. He takes a moment to gather his thoughts, and then erases\nenough space so there’s room to list the steps.\nThe steps for the search result enrichment data flow\n1 Receive a request from a client.\n2 Extract from the client’s request the query and the fields to fetch from Open\nLibrary.\n3 Retrieve from the database the books that match the query.\n4 Fetch information from Open Library for each ISBN that match the query.\n5 Extract from Open Library responses for the required fields.\n6 Combine book information from the database with information from Open\nLibrary.\n7 Send the response to the client.\nJoe Perfect! Would you like to try to implement it?\nTheo I think I’ll start with the implementation of the book retrieval from the data-\nbase. It’s quite similar to what we did last month.\n NOTE See chapter 10 for last month’s lesson.\nJoe Actually, it’s even simpler because you don’t need to join tables.\nTheo That’s right, I need values only for the isbn and available columns.\nTheo works for a bit in his IDE. He begins with the book retrieval from the database.\nListing11.14 Retrieving books whose title matches a query\nvar dbSearchResultSchema = {\n\"type\": \"array\",\n\"items\": {\n--- Page 263 ---\n11.6 Search result enrichment in action 235\n\"type\": \"object\",\n\"required\": [\"isbn\", \"available\"],\n\"properties\": {\n\"isbn\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"}\n}\n}\n};\nclass CatalogDB {\nstatic matchingBooks(title) {\nvar matchingBooksQuery = `\nSELECT isbn, available\nFROM books\nWHERE title = like '%$1%';\n`;\nvar books = dbClient.query(catalogDB, matchingBooksQuery, [title]);\nif(!ajv.validate(dbSearchResultSchema, books)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from the database: \" +\nerrors;\n}\nreturn books;\n}\n}\nJoe So far, so good...\nTheo Next, I’ll go with the implementation of the retrieval of book information from\nOpen Library for several books. Unfortunately, the Open Library Books API\ndoesn’t support querying several books at once. I’ll need to send one request\nper book.\nJoe That’s a bit annoying. Let’s make our life easier and pretend that _.map works\nwith asynchronous functions. In real life, you’d need something like Promise\n.all in order to send the requests in parallel and combine the responses.\nTheo OK, then it’s quite straightforward. I’ll take the book retrieval code and add a\nmultipleBookInfo function that maps over bookInfo.\nTheo looks over the book retrieval code in listing 11.9 and then concentrates as he types\ninto his IDE. When he’s done, he shows the result in listing 11.15 to Joe.\nListing11.15 Retrieving book information from Open Library for several books\nclass OpenLibraryDataSource {\nstatic rawBookInfo(isbn) {\nvar url = `https:/ /openlibrary.org/isbn/${isbn}.json`;\nvar jsonString = fetchResponseBody(url);\nreturn JSON.parse(jsonString);\n}\nstatic bookInfo(isbn, requestedFields) {\nvar relevantFields = [\"title\", \"full_title\",\n\"subtitle\", \"publisher\",\n\"publish_date\", \"weight\",\n--- Page 264 ---\n236 CHAPTER 11 Web services\n\"physical_dimensions\", \"genre\",\n\"subjects\", \"number_of_pages\"];\nvar rawInfo = rawBookInfo(isbn);\nif(!ajv.validate(dbSearchResultSchema, bookInfoSchema)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from Open Books API: \" +\nerrors;\n}\nvar relevantInfo =\n_.pick(_.pick(rawInfo, relevantFields), requestedFields);\nreturn _.set(relevantInfo, \"isbn\", isbn);\n}\nstatic multipleBookInfo(isbns, fields) {\nreturn _.map(function(isbn) {\nreturn bookInfo(isbn, fields);\n}, isbns);\n}\n}\nJoe Nice! Now comes the fun part: combining information from several data sources.\nTheo Yeah. I have two arrays in my hands: one with book information from the data-\nbase and one with book information from Open Library. I somehow need to\njoin the arrays, but I’m not sure I can assume that the positions of the book\ninformation are the same in both arrays.\nJoe What would you like to have in your hands?\nTheo I wish I had two hash maps.\nJoe And what would the keys in the hash maps be?\nTheo Book ISBNs.\nJoe Well, I have good news for you: your wish is granted!\nTheo How?\nJoe Lodash provides a function named _.keyBy that transforms an array into a map.\nTheo I can’t believe it. Can you show me an example?\nJoe Sure. Let’s call _.keyBy on an array with two books.\nListing11.16 Transforming an array into a map with _.keyBy\nvar books = [\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"isbn\": \"978-1982137274\",\n\"available\": true\n},\n{\n\"title\": \"The Power of Habit\",\n\"isbn\": \"978-0812981605\",\n\"available\": false\n}\n];\n_.keyBy(books, \"isbn\");\n--- Page 265 ---\n11.6 Search result enrichment in action 237\nJoe And here’s the result.\nListing11.17 The result of keyBy\n{\n\"978-0812981605\": {\n\"available\": false,\n\"isbn\": \"978-0812981605\",\n\"title\": \"The Power of Habit\"\n},\n\"978-1982137274\": {\n\"available\": true,\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\"\n}\n}\nTheo keyBy is awesome!\nJoe Don’t exaggerate, my friend; _.keyBy is quite similar to _.groupBy. The\nonly difference is that _.keyBy assumes that there’s only one element in\neach group.\nTheo I think that, with _.keyBy, I’ll be able to write a generic joinArrays function.\nJoe I’m glad to see you thinking in terms of implementing business logic through\ngeneric data manipulation functions.\nTIP Many parts of the business logic can be implemented through generic data\nmanipulation functions.\nTheo The joinArrays function needs to receive the arrays and the field name for\nwhich we decide the two elements that need to be combined, for instance,\nisbn.\nJoe Remember, in general, it’s not necessarily the same field name for both arrays.\nTheo Right, so joinArrays needs to receive four arguments: two arrays and two\nfield names.\nJoe Go for it! And, please, write a unit test for joinArrays.\nTheo Of course...\nTheo works for a while and produces the code in listing 11.18. He then types the unit test\nin listing 11.19.\nListing11.18 A generic function for joining arrays\nfunction joinArrays(a, b, keyA, keyB) {\nvar mapA = _.keyBy(a, keyA);\nvar mapB = _.keyBy(b, keyB);\nvar mapsMerged = _.merge(mapA, mapB);\nreturn _.values(mapsMerged);\n}\n--- Page 266 ---\n238 CHAPTER 11 Web services\nListing11.19 A unit test for joinArrays\nvar dbBookInfos = [\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true\n},\n{\n\"isbn\": \"978-0812981605\",\n\"title\": \"The Power of Habit\",\n\"available\": false\n}\n];\nvar openLibBookInfos = [\n{\n\"isbn\": \"978-0812981605\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"number_of_pages\": 432,\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"The Power of Habit\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n],\n}\n];\nvar joinedArrays = [\n{\n\"available\": true,\n\"isbn\": \"978-1982137274\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\",\n],\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"title\": \"The Power of Habit\",\n},\n{\n\"available\": false,\n\"isbn\": \"978-0812981605\",\n\"number_of_pages\": 432,\n\"subtitle\": \"Powerful Lessons in Personal Change\",\n\"title\": \"7 Habits of Highly Effective People\",\n},\n]\n--- Page 267 ---\n11.6 Search result enrichment in action 239\n_.isEqual(joinedArrays,\njoinArrays(dbBookInfos, openLibBookInfos, \"isbn\", \"isbn\"));\nJoe Excellent! Now, you are ready to adjust the last piece of the extended search\nresult endpoint.\nTheo That’s quite easy. We fetch data from the database and from Open Library and\njoin them.\nTheo works quite rapidly. He then shows Joe the code.\nListing11.20 Search books and enriched book information\nclass Catalog {\nstatic enrichedSearchBooksByTitle(searchPayload) {\nif(!ajv.validate(searchBooksRequestSchema, searchPayload)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid request:\" + errors;\n}\nvar title = _.get(searchPayload, \"title\");\nvar fields = _.get(searchPayload, \"fields\");\nvar dbBookInfos = CatalogDataSource.matchingBooks(title);\nvar isbns = _.map(dbBookInfos, \"isbn\");\nvar openLibBookInfos =\nOpenLibraryDataSource.multipleBookInfo(isbns, fields);\nvar res = joinArrays(dbBookInfos, openLibBookInfos);\nif(!ajv.validate(searchBooksResponseSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid response:\" + errors;\n}\nreturn res;\n}\n}\nNow comes the tricky part. Theo takes a few moments to meditate about the simplicity of\nthe code that implements the extended search endpoint. He thinks about how classes are\nmuch less complex when we use them only to aggregate stateless functions that operate on\nsimilar domain entities and then goes to work plotting the code.\nListing11.21 Schema for the extended search endpoint (Open Books API part)\nvar basicBookInfoSchema = {\n\"type\": \"object\",\n\"required\": [\"title\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n--- Page 268 ---\n240 CHAPTER 11 Web services\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nvar mandatoryIsbn13 = {\n\"type\": \"object\",\n\"required\": [\"isbn_13\"]\n};\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nListing11.22 Extended search endpoint (Open Books API part)\nvar ajv = new Ajv({allErrors: true});\nclass OpenLibraryDataSource {\nstatic rawBookInfo(isbn) {\nvar url = `https:/ /openlibrary.org/isbn/${isbn}.json`;\nvar jsonString = fetchResponseBody(url);\nreturn JSON.parse(jsonString);\n}\nstatic bookInfo(isbn, requestedFields) {\nvar relevantFields = [\"title\", \"full_title\",\n\"subtitle\", \"publisher\",\n\"publish_date\", \"weight\",\n--- Page 269 ---\n11.6 Search result enrichment in action 241\n\"physical_dimensions\", \"genre\",\n\"subjects\", \"number_of_pages\"];\nvar rawInfo = rawBookInfo(isbn);\nif(!ajv.validate(bookInfoSchema, rawInfo)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from Open Books API: \" +\nerrors;\n}\nvar relevantInfo = _.pick(\n_.pick(rawInfo, relevantFields),\nrequestedFields);\nreturn _.set(relevantInfo, \"isbn\", isbn);\n}\nstatic multipleBookInfo(isbns, fields) {\nreturn _.map(function(isbn) {\nreturn bookInfo(isbn, fields);\n}, isbns);\n}\n}\nListing11.23 Extended search endpoint (database part)\nvar dbClient;\nvar dbSearchResultSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"isbn\", \"available\"],\n\"properties\": {\n\"isbn\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"}\n}\n}\n};\nclass CatalogDB {\nstatic matchingBooks(title) {\nvar matchingBooksQuery = `\nSELECT isbn, available\nFROM books\nWHERE title = like '%$1%';\n`;\nvar books = dbClient.query(catalogDB, matchingBooksQuery, [title]);\nif(!ajv.validate(dbSearchResultSchema, books)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from the database: \"\n+ errors;\n}\nreturn books;\n}\n}\n--- Page 270 ---\n242 CHAPTER 11 Web services\nListing11.24 Schema for the implementation of the extended search endpoint\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"type\": [\n\"title\",\n\"full_title\",\n\"subtitle\",\n\"publisher\",\n\"publish_date\",\n\"weight\",\n\"physical_dimensions\",\n\"number_of_pages\",\n\"subjects\",\n\"publishers\",\n\"genre\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nvar searchBooksResponseSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"available\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"available\": {\"type\": \"boolean\"},\n\"publishers\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nListing11.25 Schema for the extended search endpoint (combines the pieces)\nclass Catalog {\nstatic enrichedSearchBooksByTitle(request) {\n--- Page 271 ---\n11.6 Search result enrichment in action 243\nif(!ajv.validate(searchBooksRequestSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid request:\" + errors;\n}\nvar title = _.get(request, \"title\");\nvar fields = _.get(request, \"fields\");\nvar dbBookInfos = CatalogDataSource.matchingBooks(title);\nvar isbns = _.map(dbBookInfos, \"isbn\");\nvar openLibBookInfos =\nOpenLibraryDataSource.multipleBookInfo(isbns, fields);\nvar response = joinArrays(dbBookInfos, openLibBookInfos);\nif(!ajv.validate(searchBooksResponseSchema, request)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Invalid response:\" + errors;\n}\nreturn response;\n}\n}\nclass Library {\nstatic searchBooksByTitle(payloadBody) {\nvar payloadData = JSON.parse(payloadBody);\nvar results = Catalog.searchBooksByTitle(payloadData);\nreturn JSON.stringify(results);\n}\n}\nTIP Classes are much less complex when we use them as a means to aggregate state-\nless functions that operate on similar domain entities.\nJoe interrupts Theo’s meditation moment. After looking over the code in the previous list-\nings, he congratulates Theo.\nJoe Excellent job, my friend! By the way, after reading The Power of Habit, I quit\nchewing my nails.\nTheo Wow! That’s terrific! Maybe I should read that book to overcome my habit of\ndrinking too much coffee.\nJoe Thanks, and good luck with the coffee habit.\nTheo I was supposed to call Nancy later today with an ETA for the Open Library\nBook milestone. I wonder what her reaction will be when I tell her the feature\nis ready.\nJoe Maybe you should tell her it’ll be ready in a week, which would give you time to\nbegin work on the next milestone.\n--- Page 272 ---\n244 CHAPTER 11 Web services\nDelivering on time\nJoe was right! Theo recalls Joe’s story about the young woodcutter and the old man. Theo\nwas able to learn DOP and deliver the project on time! He’s pleased that he took the time\n“to sharpen his saw and commit to a deeper level of practice.”\n NOTE If you are unable to recall the story or if you missed it, check out the opener\nto part 2.\nThe Klafim project is a success. Nancy is pleased. Theo’s boss is satisfied. Theo got pro-\nmoted. What more can a person ask for?\nTheo remembers his deal with Joe. As he strolls through the stores of the Westfield San\nFrancisco Center to look for a gift for each of Joe’s children, Neriah and Aurelia, he is\nfilled with a sense of purpose and great pleasure. He buys a DJI Mavic Air 2 drone for Ner-\niah, and the latest Apple Airpod Pros for Aurelia. He also takes this opportunity to buy a\nnecklace and a pair of earrings for his wife, Jane. It’s a way for him to thank her for having\nendured his long days at work since the beginning of the Klafim project.\n NOTE The story continues in the opener of part 3.\nSummary\n We build the insides of our systems like we build the outsides.\n Components inside a program communicate via data that is represented as\nimmutable data collections in the same way as components communicate via\ndata over the wire.\n In DOP, the inner components of a program are loosely coupled.\n Many parts of business logic can be implemented through generic data manipu-\nlation functions. We use generic functions to\n– Implement each step of the data flow inside a web service.\n– Parse a request from a client.\n– Apply business logic to the request.\n– Fetch data from external sources (e.g., database and other web services).\n– Apply business logic to the responses from external sources.\n– Serialize response to the client.\n Classes are much less complex when we use them as a means to aggregate\ntogether stateless functions that operate on similar domain entities.\nLodash functions introduced in this chapter\nFunction Description\nkeyBy(coll, f) Creates a map composed of keys generated from the results of running each ele-\nment of coll through f; the corresponding value for each key is the last element\nresponsible for generating the key.\n--- Page 273 ---\nPart 3\nMaintainability\nA\nfter a month, the Klafim project enters what Alabatross calls the mainte-\nnance phase. Small new features need to be added on a weekly basis. Bugs need to be\nfixed; nothing dramatic....\nMonica, Theo’s boss, decides to allocate Dave to the maintenance of the Klafim\nproject. It makes sense. Over the last few months, Dave has demonstrated a great atti-\ntude of curiosity and interest, and he has solid programming skills. Theo sets up a\nmeeting with Joe and Dave, hoping that Joe will be willing to teach DOP to Dave so\nthat he can continue to advance the good work he’s already done on Klafim. Theo\nand Dave place a conference call to Joe.\nTheo Hi, Joe. Will you have time over the next few weeks to teach Dave the\nprinciples of DOP?\nJoe Yes, but I prefer not to.\nDave Why? Is it because I don’t have enough experience in software develop-\nment? I can guarantee you that I’m a fast learner.\nJoe It has nothing to do with your experience, Dave.\nTheo Why not then?\nJoe Theo, I think that you could be a great mentor for Dave.\nTheo But, I don’t even know all the parts of DOP!\nDave Come on! No false modesty between us, my friend.\nJoe Knowledge is never complete. As the great Socrates used to say, “The more\nI know, the more I realize I know nothing.” I’m confident you will be able\nto learn the missing parts by yourself and maybe even invent some.\nTheo How will I be able to invent missing parts?\n--- Page 274 ---\n246 PART 3 Maintainability\nJoe You see, DOP is such a simple paradigm that it’s fertile material for innovation.\nPart of the material I taught you I learned from others, and part of it was an\ninvention of mine. If you keep practicing DOP, I’m quite sure you, too, will\ncome up with some inventions of your own.\nTheo What do you say Dave? Are you willing to learn DOP from me?\nDave Definitely!\nTheo Joe, will you be continue to be available if we need your help from time to time?\nJoe Of course!\n--- Page 275 ---\nAdvanced data\nvalidation\nA self-made gift\nThis chapter covers\n Validating function arguments\n Validating function return values\n Data validation beyond static types\n Automatic generation of data model diagrams\n Automatic generation of schema-based unit tests\nAs the size of a code base grows in a project that follows DOP principles, it becomes\nharder to manipulate functions that receive and return only generic data. It is hard\nto figure out the expected shape of the function arguments, and when we pass\ninvalid data, we don’t get meaningful errors.\nUntil now, we have illustrated how to validate data at system boundaries. In this\nchapter, we will illustrate how to validate data when it flows inside the system by\ndefining data schemas for function arguments and their return values. This allows\nus to make explicit the expected shape of function arguments, and it eases develop-\nment. We gain some additional benefits from this endeavor, such as automatic gen-\neration of data model diagrams and schema-based unit tests.\n247\n--- Page 276 ---\n248 CHAPTER 12 Advanced data validation\n12.1 Function arguments validation\nDave’s first task is to implement a couple of new HTTP endpoints to download the catalog\nas a CSV file, search books by author, and rate the books. Once he is done with the tasks,\nDave calls Theo for a code review.\n NOTE The involvement of Dave in the Klafim project is explained in the opener for\npart 3. Please take a moment to read the opener if you missed it.\nTheo Was it difficult to get your head around the DOP code?\nDave Not so much. I read your notes of the meetings with Joe, and I must admit, the\ncode is quite simple to grasp.\nTheo Cool!\nDave But there is something that I can’t get used to.\nTheo What’s that?\nDave I’m struggling with the fact that all the functions receive and return generic\ndata. In OOP, I know the expected shape of the arguments for each and every\nfunction.\nTheo Did you validate data at system boundaries, like I have done?\nDave Absolutely. I defined a data schema for every additional user request, database\nquery, and external service response.\nTheo Nice!\nDave Indeed, when the system runs in production, it works well. When data is valid,\nthe data flows through the system, and when data is invalid, we are able to dis-\nplay a meaningful error message to the user.\nTheo What’s the problem then?\nDave The problem is that during development, it’s hard to figure out the expected\nshape of the function arguments. And when I pass invalid data by mistake, I\ndon’t get clear error messages.\nTheo I see. I remember that when Joe showed me how to validate data at system\nboundaries, I raised this concern about the development phase. Joe told me\nthen that we validate data as it flows inside the system exactly like we validate data\nat system boundaries: we separate between data schema and data representation.\nDave Are we going to use JSON Schema also?\nTheo Yes.\nDave Cool.... I like JSON Schema.\nTheo The main purpose of data validation at system boundaries is to prevent invalid\ndata from getting into the system, whereas the main purpose of data validation\ninside the system is to make it easier to develop the system. Here, let me draw a\ntable on the whiteboard for you to visualize this (table 12.1).\nTable 12.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\n--- Page 277 ---\n12.1 Function arguments validation 249\nDave By making it easier to develop the system, do you mean to help the developers\nunderstand the expected shape of function arguments as in OOP?\nTheo Exactly.\nDave But I’m impatient.... Will you help me figure out how to validate the argu-\nments of the function that implements a book search?\nTheo Let me see the code of the implementation, and I’ll do my best.\nDave We have two implementations of a book search: one where library data lives\nin memory from the prototype phase and one where library data lives in the\ndatabase.\nTheo I think that the schema for library data in memory is going to be more interest-\ning than the schema for library data in the database, as the book search func-\ntion receives catalog data in addition to the query.\nDave When you say more interesting data schema, you mean more difficult to write?\nTheo More difficult to write, but it’s also more insightful.\nDave Then let’s go with library data in memory. The code for Catalog.search-\nBooksByTitle from the prototype phase would look like this.\nDave pulls up some code on his laptop. He shows it to Theo.\nListing12.1 The implementation of search without data validation\nclass Catalog {\nstatic authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nreturn bookInfo;\n}\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\n--- Page 278 ---\n250 CHAPTER 12 Advanced data validation\nTheo Dave, please remind me of the expected shapes for catalogData and query.\nDave Sure. query should be a string, and catalogData should be a map that con-\nforms to the catalog data model.\nTheo What is the catalog data model?\nDave Let me see. I have seen a diagram of it somewhere.\nDave rummages around a bit in his folder for Klafim’s Library Management System. Find-\ning what he’s looking for, he draws the diagram in figure 12.1 on the whiteboard.\nC Catalog\nbooksByIsbn: {Book}\nauthorsById: {Author}\nC Book\nC Author\ntitle : String\npublicationYear: Number id: String\nisbn: String name: String\nauthorlds: [String] booklsbns: [String]\nbookltems: [Bookltem]\nC Bookltem\nid: String\nlibld: String\npurchaseDate: String\nisLent: Boolean\nFigure 12.1 The catalog data model\n NOTE The schemas for this book use JSON Schema version 2020-12.\nTheo Can you write a JSON Schema for the catalog data model?\nDave Am I allowed to use internal variables for book and author schemas, or do I\nhave to nest all the schemas inside the catalog schema?\nTheo JSON Schema is part of the code. If you feel that using internal variables would\nmake the code more readable, go for it.\nDave OK. Now I need the JSON Schema gift that Joe gave you.\nTheo picks up a well-worn piece of paper that is a bit torn and quite wrinkled. He gives\nDave the JSON Schema cheat sheet.\nListing12.2 JSON Schema cheat sheet\nAt the root level,\n{\ndata is an array.\n\"type\": \"array\",\n\"items\": { Each element of the array is a map.\n\"type\": \"object\",\nThe properties of each field in the map\n\"properties\": {\n--- Page 279 ---\n12.1 Function arguments validation 251\n\"myNumber\": {\"type\": \"number\"},\nmyNumber\n\"myString\": {\"type\": \"string\"}, myEnum is an enumeration\nis a number.\n\"myEnum\": {\"enum\": [\"myVal\", \"yourVal\"]}, value with two possibilities,\nmyString is \"myBool\": {\"type\": \"boolean\"} \"myVal\" and \"yourVal\".\na string. },\n\"required\": [\"myNumber\", \"myString\"], myBool is a boolean.\n\"additionalProperties\": false\n} The mandatory fields in the map\n} We don’t allow fields that are not are myNumber and myString.\nexplicitly mentioned in the schema. Other fields are optional.\nDave I think I’ll start with the author schema. It seems simpler than the book schema.\nQuickly composing the code, Dave shows Theo the author schema. Dave, still new to DOP,\nlooks for Theo’s reaction.\nListing12.3 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"id\", \"name\", \"bookIsbns\"],\n\"properties\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nTheo Well done! Let’s move on to the book schema now.\nDave I think I am going to store the book item schema in a variable.\nListing12.4 The book item schema\nvar bookItemSchema = {\n\"type\": \"object\",\n\"properties\":{\n\"id\": {\"type\": \"string\"},\n\"libId\": {\"type\": \"string\"},\n\"purchaseDate\": {\"type\": \"string\"},\n\"isLent\": {\"type\": \"boolean\"}\n},\n\"required\": [\"id\", \"libId\", \"purchaseDate\", \"isLent\"]\n};\nvar bookSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorIds\", \"bookItems\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publicationYear\": {\"type\": \"integer\"},\n--- Page 280 ---\n252 CHAPTER 12 Advanced data validation\n\"isbn\": {\"type\": \"string\"},\n\"authorIds\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"bookItems\": {\n\"type\": \"array\",\n\"items\": bookItemSchema\n}\n}\n};\nTIP When you define a complex data schema, it is advisable to store nested schemas\nin variables to make the schemas easier to read.\nTheo Why didn’t you include publicationYear in the list of required fields in the\nbook schema?\nDave Because, for some books, the publication year is missing. Unlike in OOP, it will\nthen be easy to deal with nullable fields.\nTheo Excellent! And now, please tackle the final piece, the catalog schema.\nDave Here I have a problem. The catalog should be a map with two fields, books-\nByIsbn and authorsById. Both values should be indexes, represented in the\nmodel diagram with curly braces. I have no idea how to define the schema for\nan index.\nTheo Do you remember how we represent indexes in DOP?\nDave Yes, indexes are represented as maps.\nTheo Right, and what’s the difference between those maps and the maps that we use\nfor records?\nDave For records, we use maps where the names of the fields are known and the val-\nues can have different shapes. For indexes, we use maps where the names of\nthe fields are unknown and the values have a common shape.\nTheo Right. We call the maps for records heterogeneous maps and the maps for\nindexes homogeneous maps.\nTIP In DOP, records are represented as heterogeneous maps, whereas indexes are repre-\nsented as homogeneous maps.\nDave Then how do we define the schema of an homogeneous map in JSON Schema?\nTheo I don’t know. Let’s check the JSON Schema online documentation.\n NOTE See https://json-schema.org/ to access the online documentation for JSON\nSchema version 2020-12.\nAfter a couple of minutes of digging into the JSON Schema online documentation, Theo\nfinds a piece about additionalProperties. He studies the information for a while before\nmaking up his mind.\n--- Page 281 ---\n12.1 Function arguments validation 253\nTheo I think we could use additionalProperties. Here’s the JSON Schema for an\nhomogeneous map where the values are numbers.\nListing12.5 The JSON Schema for an homogeneous map with values as numbers\n{\n\"type\": \"object\",\n\"additionalProperties\": {\"type\": \"number\"}\n}\nDave I thought that additionalProperties was supposed to be a boolean and that\nit was used to allow or forbid properties not mentioned in the schema.\nTheo That’s correct. Usually additionalProperties is a boolean, but the documen-\ntation says it could also be a map that defines a schema. In that case, it means\nproperties not mentioned in the schema should have the value of the schema\nassociated with additionalProperties.\nDave I see. But what does that have to do with homogeneous maps?\nTheo Well, a homogeneous map could be seen as a map with no predefined proper-\nties, where all the additional properties are of an expected type.\nDave Tricky!\nTIP In JSON Schema, homogeneous string maps have type: object with no\nproperties and additionalProperties associated to a schema.\nTheo Indeed. Now, let me show you what the catalog schema looks like.\nTheo types briefly on his laptop. He shows Dave the catalog schema.\nListing12.6 The schema for catalog data\nvar catalogSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"booksByIsbn\": {\n\"type\": \"object\",\n\"additionalProperties\": bookSchema\n},\n\"authorsById\": {\n\"type\": \"object\",\n\"additionalProperties\": authorSchema\n}\n},\n\"required\": [\"booksByIsbn\", \"authorsById\"]\n};\nDave Are we ready to plug the catalog and the query schema into the Catalog\n.searchBooksByTitle implementation?\nTheo We could, but I think we can do better by defining a single schema that com-\nbines both the catalog and query schemas.\nDave How would we combine two schemas into a single schema?\n--- Page 282 ---\n254 CHAPTER 12 Advanced data validation\nTheo Do you know what a tuple is?\nDave I think I know, but I can’t define it formally.\nTheo A tuple is an array where the size is fixed, and the elements can be of different\nshapes.\nDave OK. So, how do we define tuples in JSON Schema?\nOnce again, Theo explores the JSON Schema online documentation. Fortunately, he has\nbookmarked the page, and in no time at all, finds the information he needs.\nTheo I found it! We use prefixItems in the definition of a tuple made of a string\nand a number, for instance.\nTheo types more code on his laptop. When he finishes, he shows Dave the schema for a\ntuple.\nListing12.7 The schema for a tuple made of a string and a number\n{\n\"type\": \"array\",\n\"prefixItems\": [\n{ \"type\": \"string\" },\n{ \"type\": \"number\" }\n]\n}\nDave I see. And how would you define the schema for the arguments of Catalog\n.searchBooksByTitle?\nTheo Well, it’s a tuple of size 2, where the first element is a catalog and the second\nelement is a string.\nDave Something like this schema?\nListing12.8 The schema for the arguments of Catalog.searchBooksByTitle\nvar searchBooksArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\ncatalogSchema,\n{ \"type\": \"string\" },\n]\n};\nTheo Exactly!\nDave Now that we have the schema for the arguments, how do we plug it into the\nimplementation of search books?\nTheo That’s similar to the way we validate data at system boundaries. The main dif-\nference is that the data validation for data that flows inside the system should\nrun only at development time, and it should be disabled when the code runs in\nproduction.\nDave Why?\n--- Page 283 ---\n12.2 Return value validation 255\nTheo Because that data has been already validated up front at a system boundary.\nValidating it again on a function call is superfluous, and it would impact\nperformance.\nDave When you say development time, does that include testing and staging\nenvironments?\nTheo Yes, all the environments besides production.\nDave I see. It’s like assertions in Java. They are disabled in production code.\nTIP Data validation inside the system should be disabled in production.\nTheo Exactly. For now, I am going to assume that we have a dev function that returns\ntrue when the code runs in the development environment and false when it\nruns in production. Having said that, take a look at this code.\nListing12.9 Implementation of search with validation of function arguments\nCatalog.searchBooksByTitle = function(catalogData, query) {\nif(dev()) {\nvar args = [catalogData, query];\nif(!ajv.validate(searchBooksArgsSchema, args)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle called with invalid arguments: \" +\nerrors);\nThe implementation of dev() depends on the run-time\n}\nenvironment: it returns true when the code runs in dev\n}\nenvironments and false when it runs in production.\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nDave Do you think we should validate the arguments of all the functions?\nTheo No. I think we should treat data validation like we treat unit tests. We should\nvalidate function arguments only for functions for whom we would write unit\ntests.\nTIP Treat data validation like unit tests.\n12.2 Return value validation\nDave Do you think it would make sense to also validate the return value of functions?\nTheo Absolutely.\nDave Cool. Let me try to write the JSON Schema for the return value of Catalog\n.searchBooksByTitle.\n--- Page 284 ---\n256 CHAPTER 12 Advanced data validation\nAfter a few minutes, Dave comes up with the schema. Taking a deep breath, then releasing\nit, he shows the code to Theo.\nListing12.10 The schema for the return value of Catalog.searchBooksByTitle\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorNames\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"isbn\": {\"type\": \"string\"},\n\"authorNames\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n};\nTheo Well done! Now, would you like to try adding return value validation to the\ncode of Catalog.searchBooksByTitle?\nDave Sure.\nDave works for a bit in his IDE. A bit more confident this time, he shows the result to Theo.\nListing12.11 Search with data validation for both input and output\nCatalog.searchBooksByTitle = function(catalogData, query) {\nif(dev()) {\nif(!ajv.validate(searchBooksArgsSchema, [catalogData, query])) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle called with invalid arguments: \" +\nerrors);\n}\n}\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nif(dev()) {\nif(!ajv.validate(searchBooksResponseSchema, bookInfos)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle returned an invalid value: \" +\nerrors);\n}\n}\n--- Page 285 ---\n12.3 Advanced data validation 257\nreturn bookInfos;\n};\nTheo Excellent! Now we need to figure out how to deal with advanced data validation.\n12.3 Advanced data validation\nDave What do you mean by advanced data validation?\nTheo I mean going beyond static types.\nDave Could you give me an example?\nTheo Sure. Take, for instance, the publication year of a book. It’s an integer, but\nwhat else could you say about this number?\nDave It has to be positive. It would say it’s a positive integer.\nTheo Come on, Dave! Be courageous, go beyond types.\nDave I don’t know. I would say it’s a number that should be higher than 1900. I\ndon’t think it makes sense to have a book that is published before 1900.\nTheo Exactly. And what about the higher limit?\nDave I’d say that the publication year should be less than the current year.\nTheo Very good! I see that JSON Schema supports number ranges. Here is how we\ncan write the schema for an integer that represents a year and should be\nbetween 1900 and 2021.\nListing12.12 The schema for an integer between 1900 and 2021\nvar publicationYearSchema = {\n\"type\": \"integer\",\n\"minimum\": 1900,\n\"maximum\": 2021\n};\nDave Why isn’t this kind of data validation possible in OOP?\nTheo I’ll let you think about that for a moment.\nDave I think have it! In DOP, data validation is executed at run time, while static\ntype validation in OOP is executed at compile time. At compile time, we only\nhave information about static types; at run time, we have the data itself. That’s\nwhy in DOP data validation, it’s possible to go beyond types.\n NOTE Of course, it’s also possible in traditional OOP to write custom run-time data\nvalidation. Here, though, we are comparing data schema with static types.\nTheo You got it! Now, let me show you how to write the schema for a string that\nshould match a regular expression.\n NOTE See http://mng.bz/OGNP for the JavaScript Guide to regular expressions.\nTheo Let’s take for example the book ID. I am assuming it must be a UUID.\nDave Right.\nTheo Can you write the regular expression for a valid UUID?\n--- Page 286 ---\n258 CHAPTER 12 Advanced data validation\nDave googles “UUID regex” and finds something he thinks just might work. He shows the\nregular expression to Theo.\nListing12.13 The regular expression for a valid UUID\n[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\nDave Now, how do we plug a regular expression into a JSON Schema?\nTheo While you were looking for the UUID regular expression, I read about the\npattern field. Here’s how we can plug the UUID regular expression into a\nJSON Schema.\nListing12.14 The schema for a UUID\nvar uuidSchema = {\n\"type\": \"string\",\n\"pattern\": \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}\" +\n\"-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\n};\nDave Nice! Let me improve the catalog schema and refine the schema for purchase-\nDate, isbn, libId, and authorId with regular expressions.\nTheo Before you do that, though, let me tell you something I read about regular\nexpressions: some of them are predefined. For example, there is a predefined\nregular expression for dates.\nDave How does it work?\nTheo With the help of the format field.\n NOTE According to JSON Schema specification, format is just for annotation and\ndoesn’t affect validation. But in practice, JSON Schema validation libraries use format\nalso for validation.\nTheo moves to his laptop. He inputs the schema for a date and shows it to Dave.\nListing12.15 The schema for a date\n{\n\"type\": \"string\",\n\"format\": \"date\"\n}\nTIP In DOP, data validation goes beyond static types (e.g., number ranges, regular\nexpressions, and so on).\nDave Very cool! Do I have all the information I need in order to refine the catalog\nschema?\nTheo Yes, go for it!\nIt takes Dave a bit of time to write the regular expressions for isbn, authorId, and libId.\nBut with the help of Google (again) and a bit of simplification, Dave comes up with the\nschema in listings 12.16 and 12.17.\n--- Page 287 ---\n12.3 Advanced data validation 259\nListing12.16 The refined schema of the catalog data (Part 1)\nvar isbnSchema = {\n\"type\": \"string\",\n\"pattern\": \"^[0-9-]{10,20}$\"\n};\nvar libIdSchema = {\n\"type\": \"string\",\n\"pattern\": \"^[a-z0-9-]{3,20}$\"\n};\nvar authorIdSchema ={\n\"type\": \"string\",\n\"pattern\": \"[a-z-]{2,50}\"\n};\nvar bookItemSchema = {\n\"type\": \"object\",\n\"additionalProperties\": {\n\"id\": uuidSchema,\n\"libId\": libIdSchema,\n\"purchaseDate\": {\n\"type\": \"string\",\n\"format\": \"date\"\n},\n\"isLent\": {\"type\": \"boolean\"}\n}\n};\nListing12.17 The refined schema of the catalog data (Part 2)\nvar bookSchema = {\n\"type\": \"object\",\n\"required\": [\"title\", \"isbn\", \"authorIds\", \"bookItems\"],\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"publicationYear\": publicationYearSchema,\n\"isbn\": isbnSchema,\n\"publisher\": {\"type\": \"string\"},\n\"authorIds\": {\n\"type\": \"array\",\n\"items\": authorIdSchema\n},\n\"bookItems\": bookItemSchema\n}\n};\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"id\", \"name\", \"bookIsbns\"],\n\"properties\": {\n\"id\": {\"type\": \"string\"},\n\"name\": {\"type\": \"string\"},\n--- Page 288 ---\n260 CHAPTER 12 Advanced data validation\n\"bookIsbns\": {\n\"items\": isbnSchema\n}\n}\n};\nvar catalogSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"booksByIsbn\": {\n\"type\": \"object\",\n\"additionalProperties\": bookSchema\n},\n\"authorsById\": {\n\"type\": \"object\",\n\"additionalProperties\": authorSchema\n}\n},\n\"required\": [\"booksByIsbn\", \"authorsById\"]\n};\n12.4 Automatic generation of data model diagrams\nBefore going home, Theo phones Joe to tell him about how he and Dave used data valida-\ntion inside the system. Joe tells Theo that that’s exactly how he recommends doing it and\nsuggests he come and visit Theo and Dave at the office tomorrow. He wants to show them\nsome cool advanced stuff related to data validation. The next day, with coffee in hand, Joe\nstarts the discussion.\nJoe Are you guys starting to feel the power of data validation à la DOP?\nDave Yes, it’s a bit less convenient to validate a JSON Schema than it is to write the\nclass of function arguments, but this drawback is compensated by the fact that\nJSON Schema supports conditions that go beyond static types.\nTheo We also realized that we don’t have to validate data for each and every function.\nJoe Correct. Now, let me show you another cool thing that we can do with JSON\nSchema.\nDave What’s that?\nJoe Generate a data model diagram.\nDave Wow! How does that work?\nJoe There are tools that receive a JSON Schema as input and produce a diagram in\na data model format.\nDave What is a data model format?\nJoe It’s a format that allows you to define a data model in plain text. After that, you\ncan generate an image from the text. My favorite data format is PlantUML.\n NOTE For more on PlantUML, see https://plantuml.com/.\nDave Do you know of other tools that generate data model diagrams?\nJoe I have used JSON Schema Viewer and Malli.\n--- Page 289 ---\n12.4 Automatic generation of data model diagrams 261\n NOTE You can find information on the JSON Schema Viewer at https://navneethg\n.github.io/jsonschemaviewer/ and on Malli at https://github.com/metosin/malli.\nJoe shows Dave and Theo the PlantUML diagram that Malli generated (listing 12.18) from\nthe catalog schema in listings 12.16 and 12.17.\nListing12.18 A PlantUML diagram generated from the catalog data schema\n@startuml\nEntity1 *-- Entity2\nEntity1 *-- Entity4\nEntity2 *-- Entity3\nclass Entity1 {\n+ booksByIsbn: {Entity2}\n+ authorsById: {Entity4}\n}\nclass Entity2 {\n+ title : String\n+ publicationYear: Number\n+ isbn: String\n+ authorIds: [String]\n+ bookItems: [Entity3]\n}\nclass Entity3 {\n+ id: String\n+ libId: String\n+ purchaseDate: String\n+ isLent: Boolean\n}\nclass Entity4 {\n+ id: String\n+ name: String\n+ bookIsbns: [String]\n}\n@enduml\nDave Is it possible to visualize this diagram?\nJoe Absolutely. Let me copy and paste the diagram text into the PlantText online\ntool.\n NOTE See https://www.planttext.com/ for more on the PlantText online tool.\nDave opens his web browser and types the URL for PlantText. After copying and pasting\nthe text, he steps aside so that Theo and Dave can view the diagram that looks like the\nimage in figure 12.2.\n--- Page 290 ---\n262 CHAPTER 12 Advanced data validation\nC Entity1\nbooksByIsbn: {Entity2}\nauthorsById: {Entity3}\nC Entity2 C Entity4\ntitle : String id: String\npublicationYear: Number name: String\nisbn: String booklsbns: [String]\nauthorlds: [String]\nbookltems: [Entity3]\nC Entity3\nid: String\nlibld: String\nFigure 12.2 A visualization of\npurchaseDate: String\nthe PlantUML diagram generated\nisLent: Boolean\nfrom the catalog data schema\nDave That’s cool! But why are the diagram entities named Entity1, Entity2, and\nso on?\nJoe Because in JSON Schema, there’s no way to give a name to a schema. Malli has\nto autogenerate random names for you.\nTheo Also, I see that the extra information we have in the schema, like the number\nrange for publicationYear and string regular expression for isbn, is missing\nfrom the diagram.\nJoe Right, that extra information is not part of the data model. That’s why it’s not\nincluded in the generated data model diagram.\nDave Anyway, it’s very cool!\nJoe If you guys like the data model generation feature, I’m sure you’re going to\nlike the next feature.\nDave What’s it about?\nJoe Automatic generation of unit tests.\nTheo Wow, sounds exciting!\n12.5 Automatic generation of schema-based unit tests\nJoe Once you’ve defined a data schema for function arguments and for its return\nvalue, it’s quite simple to generate a unit test for this function.\nDave How?\nJoe Well, think about it. What’s the essence of a unit test for a function?\nDave A unit test calls a function with some arguments and checks whether the func-\ntion returns the expected value.\nJoe Exactly! Now, let’s adapt it to the context of data schema and DOP. Let’s say you\nhave a function with a schema for their arguments and for their return value.\n--- Page 291 ---\n12.5 Automatic generation of schema-based unit tests 263\nDave OK.\nJoe Here’s the flow of a schema-based unit test. We call the function with random\narguments that conform to the schema of the function arguments. Then, we\ncheck whether the function returns a value that conforms to the schema of the\nreturn value. Here, let me diagram it.\nJoe goes to the whiteboard. He draws the diagram in figure 12.3.\nGeneraterandom datathat conforms toinput schema\nExecute the function The input\nis random.\nYes No\nOutput conforms to output schema\nTest passes Test fails\nFigure 12.3 The flow of\na schema-based unit test\nDave How do you generate random data that conforms to a schema?\nJoe Using a tool like JSON Schema Faker. For example, let’s start with a simple\nschema: the schema for a UUID. Let me show you how to generate random\ndata that conforms to the schema.\n NOTE You’ll find more information about JSON Schema Faker at https://github\n.com/json-schema-faker/json-schema-faker.\nJoe types on the keyboard for a bit. He then shows the code to generate random data to\nDave and Theo.\nListing12.19 Generating random data that conforms to a UUID schema\nvar uuidSchema = {\n\"type\": \"string\",\n\"pattern\": \"[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}\" +\n\"-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\"\n};\nJSONSchemaFaker.generate(uuidSchema);\n// → \"7aA8CdF3-14DF-9EF5-1A19-47dacdB16Fa9\"\nDave executes the code snippet a couple of times, and indeed, on each evaluation, it returns\na different UUID.\nDave Very cool! Let me see how it works with more complex schemas like the cata-\nlog schema.\n--- Page 292 ---\n264 CHAPTER 12 Advanced data validation\nWhen Dave calls JSONSchemaFaker.generate with the catalog schema, he gets some\nquite long random data. He’s a bit surprised by the results.\nListing12.20 Generating random data that conforms to the catalog schema\n{\n\"booksByIsbn\": {\n\"Excepteur7\": {\n\"title\": \"elit veniam anim\",\n\"isbn\": \"5419903-3563-7\",\n\"authorIds\": [\n\"vfbzqahmuemgdegkzntfhzcjhjrbgfoljfzogfuqweggchum\",\n\"inxmqh-\",\n],\n\"bookItems\": {\n\"ullamco5\": {\n\"id\": \"f7dac8c3-E59D-bc2E-7B33-C27F3794E2d6\",\n\"libId\": \"4jtbj7q7nrylfu114m\",\n\"purchaseDate\": \"2001-08-01\",\n\"isLent\": false\n},\n\"culpa_3e\": {\n\"id\": \"423DCdDF-CDAe-2CAa-f956-C6cd9dA8054b\",\n\"libId\": \"6wcxbh\",\n\"purchaseDate\": \"1970-06-24\",\n\"isLent\": true\n}\n},\n\"publicationYear\": 1930,\n\"publisher\": \"sunt do nisi\"\n},\n\"aliquip_d7\": {\n\"title\": \"aute\",\n\"isbn\": \"348782167518177\",\n\"authorIds\": [\"owfgtdxjbiidsobfgvjpjlxuabqpjhdcqmmmrjb-ezrsz-u\"],\n\"bookItems\": {\n\"ipsum__0b\": {\n\"id\": \"6DfE93ca-DB23-5856-56Fd-82Ab8CffEFF5\",\n\"libId\": \"bvjh0p2p2666vs7dd\",\n\"purchaseDate\": \"2018-03-30\",\n\"isLent\": false\n}\n},\n\"publisher\": \"ea anim ut ex id\",\n\"publicationYear\": 1928\n}\n},\n\"authorsById\": {\n\"labore_b88\": {\n\"id\": \"adipisicing nulla proident\",\n\"name\": \"culpa in minim\",\n\"bookIsbns\": [\n\"6243029--7\",\n\"5557199424742986\"\n]",
        "sections_found": []
      },
      "accurate_page_range": "262-292"
    },
    {
      "text": "- 11.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "raw_line": "- 11.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 88
    },
    {
      "text": "- 11.1 Another feature request",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "raw_line": "- 11.1 Another feature request (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 89
    },
    {
      "text": "- 11.2 Building the insides like the outsides",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "raw_line": "- 11.2 Building the insides like the outsides (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 90
    },
    {
      "text": "- 11.3 Representing a client request as a map",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "raw_line": "- 11.3 Representing a client request as a map (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 91
    },
    {
      "text": "- 11.4 Representing a server response as a map",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "raw_line": "- 11.4 Representing a server response as a map (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 92
    },
    {
      "text": "- 11.5 Passing information forward",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "raw_line": "- 11.5 Passing information forward (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 93
    },
    {
      "text": "- 11.6 Search result enrichment in action",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "raw_line": "- 11.6 Search result enrichment in action (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 94
    },
    {
      "text": "- Delivering on time",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "raw_line": "- Delivering on time (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 95
    },
    {
      "text": "- Summary",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "raw_line": "- Summary (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 96
    },
    {
      "text": "- 12.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "raw_line": "- 12.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 98,
      "chapter_info": {
        "page": 303,
        "title": "Advanced data validation",
        "pattern_matched": "Chapter 12",
        "text_preview": "13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with "
      },
      "chapter_sections": {
        "start_page": 303,
        "end_page": 333,
        "content": "\n--- Page 303 ---\n13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with maps\nvar myDog = {\n\"type\": \"dog\",\n\"name\": \"Fido\"\n};\nvar myCat = {\n\"type\": \"cat\",\n\"name\": \"Milo\"\n};\nvar myCow = {\n\"type\": \"cow\",\n\"name\": \"Clarabelle\"\n};\nDave Could you have given another name to the field that holds the animal type?\nTheo Absolutely. It could be anything.\nDave I see. You’re asking me the fundamental difference between your code with a\nswitch statement and my code with an interface and three classes?\nTheo Exactly.\nDave First of all, if you pass an invalid map to your greet function, bad things will\nhappen.\nTheo You’re right. Let me fix that and validate input data.\nListing13.4 Data validation\nvar animalSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nSee chapter 12 about\ndata validation for\nfunction greet(animal) {\ndetails.\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\n--- Page 304 ---\n276 CHAPTER 13 Polymorphism\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\nbreak;\ncase \"cat\":\nconsole.log(\"Meow! I am: \" + animal.name);\nbreak;\ncase \"cow\":\nconsole.log(\"Moo! Call me \" + animal.name);\nbreak;\n};\n}\n NOTE You should not use switch statements like this in your production code.\nWe use them here for didactic purposes only as a step towards distilling the essence of\npolymorphism.\nDave Another drawback of your approach is that when you want to modify the\nimplementation of greet for a specific animal, you have to change the code\nthat deals with all the animals, while in my approach, you would change only a\nspecific animal class.\nTheo I agree, and I could also fix that by having a separate function for each animal,\nsomething like this.\nListing13.5 Different implementations in different functions\nfunction greetDog(animal) {\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\n}\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am: \" + animal.name);\n}\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\nfunction greet(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\ngreetDog(animal);\nbreak;\ncase \"cat\":\ngreetCat(animal);\nbreak;\ncase \"cow\":\ngreetCow(animal);\n--- Page 305 ---\n13.2 Multimethods with single dispatch 277\nbreak;\n};\n}\nDave But what if you want to extend the functionality of greet and add a new animal?\nTheo Now you got me. I admit that with a switch statement, I can’t add a new animal\nwithout modifying the original code, whereas in OOP, I can add a new class\nwithout having to modify the original code.\nDave Yeah, but you helped me to realize that the main benefit of polymorphism is\nthat it makes the code easily extensible.\nTIP The main benefit of polymorphism is extensibility.\nTheo I’m going to ask Joe if there’s a way to benefit from polymorphism without\nobjects.\nTheo sends a message to Joe and asks him about polymorphism in DOP. Joe answers that\nhe doesn’t have time to get into a deep response because he is in a tech conference where\nhe is about to give a talk about DOP. The only thing he has time to tell Theo is that he\nshould take a look at multimethods.\nTheo and Dave read some online material about multimethods. It doesn’t look too\ncomplicated. They decide that after lunch they will give multimethods a try.\n13.2 Multimethods with single dispatch\nDuring lunch, Theo asks Dave how it feels to have grown up in the country. Dave starts\nwith an enthusiastic description about being in direct contact with nature and living a sim-\npler life than in the city. He’s grateful for the experience, but he admits that country life\ncan sometimes be hard without the conveniences of the city. But who said simple was easy?\nAfter lunch, they decide to have coffee. Dave asks Theo if he’d like to grind the coffee\nbeans himself. Theo accepts with joy. Next, Dave explains how to use a French press coffee\nmaker to get the ideal tradeoff between bitterness and rich taste. While savoring their\nFrench press coffee in the garden, Theo and Dave continue their exploration of polymor-\nphism à la DOP.\nTheo From what I read before lunch, it seems that multimethods are a software con-\nstruct that provide polymorphism without the need for objects.\nDave I don’t get how that’s possible.\nTheo Multimethods have two parts: a dispatch function and a set of methods that\nprovide an implementation for each dispatched value.\nDave I’m not sure I’m clear on that. Is a dispatch function like an interface?\nTheo It’s like an interface in the sense that it defines the way the function needs to\nbe called, but it goes beyond that. It also dispatches a value that differentiates\nbetween the different implementations.\nDave That’s a bit abstract for me.\nTheo I think I understand how to implement the animal greeting capabilities. If we\nuse a multimethod called greet, we need a dispatch function and three\nmethods. Let’s call the dispatch function greetDispatch. It dispatches the\nanimal type, either \"dog\", \"cat\", or \"cow\". Then, each dispatch value is\n--- Page 306 ---\n278 CHAPTER 13 Polymorphism\nhandled by a specific method: \"dog\" by greetDog, \"cat\" by greetCat, and\n\"cow\" by greetCow.\nTheo takes out his notebook and opens it to a blank piece of paper. He draws a diagram\nlike the one in figure 13.1.\n\"dog\" greetDog\nGreet as a dog\ngreetDispatch \"cat\" greetCat\nEmit the animal type Greet as a cat\nanimal\ntype, name \"cow\" greetCow\nGreet as a cow\nFigure 13.1 The logic flow\nof the greet multimethod\nDave Why is there an arrow between animal and the methods, in addition to the\narrows between animal and the dispatch functions?\nTheo Because the arguments of a multimethod are passed to the dispatch function\nand to the methods.\nTIP The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\nDave Arguments plural?... I see only a single argument.\nTheo You’re right. Right now our multimethod only receives a single argument, but\nsoon it will receive several arguments.\nDave I see. Could you show me how to write the code for the greet multimethod?\nTheo For that, we need a library. For instance, in JavaScript, the arrows/multi-\nmethod library provides an implementation of multimethods. Basically, we call\nmulti to create a multimethod called method to add a method.\n NOTE See http://mng.bz/nY9v for examples and documentation about this library.\nDave Where should we start?\nTheo We’ll start with multimethod initialization by creating a dispatch function\ngreetDispatch that defines the signature of the multimethod, validates the\narguments, and emits the type of the animal. Then we’ll pass greetDispatch\nto multi in order to create the greet multimethod. Our dispatch function\nwould then look like this.\nListing13.6 The dispatch function for greet multimethod\nfunction greetDispatch(animal) {\nSignature definition\nif(dev()) {\n--- Page 307 ---\n13.2 Multimethods with single dispatch 279\nif(!ajv.validate(animalSchema, animal)) {\nArgument validation\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nDispatch value\nreturn animal.type;\n}\nMultimethod\ninitialization\nvar greet = multi(greetDispatch);\nTIP A multimethod dispatch function is responsible for three things: it defines the sig-\nnature of the multimethod, it validates the arguments, and it emits a dispatch value.\nDave What’s next?\nTheo Now we need to implement a method for each dispatched value. Let’s start\nwith the method that deals with dogs. We create a greetDog function that\nreceives an animal and then add a dog method to the greet multimethod\nusing the method function from the arrows/multimethod library. The method\nfunction receives two arguments: the dispatched value and a function that cor-\nresponds to the dispatch value.\nListing13.7 Implementation of greet method for dogs\nfunction greetDog(animal) {\nMethod\nconsole.log(\"Woof woof! My name is \" + animal.name);\nimplementation\n}\ngreet = method(\"dog\", greetDog)(greet);\nMethod declaration\nDave Does the method implementation have to be in the same module as the multi-\nmethod initialization?\nTheo No, not at all! Method declarations are decoupled from multimethod initializa-\ntion exactly like class definitions are decoupled from the interface definition.\nThat’s what make multimethods extensible.\nTIP Multimethods provides extensibility by decoupling between multimethod initial-\nization and method implementations.\nDave What about cats and cows?\nTheo We add their method implementations like we did for dogs.\nTheo takes a moment to envision the implementation. Then he codes up two more greet\nmethods for cats and cows.\nListing13.8 Implementation of greet method for cats\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ngreet = method(\"cat\", greetCat)(greet);\n--- Page 308 ---\n280 CHAPTER 13 Polymorphism\nListing13.9 Implementation of greet method for cows\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ngreet = method(\"cow\", greetCow)(greet);\nTIP In the context of multimethods, a method is a function that provides an imple-\nmentation for a dispatch value.\nDave Are the names of dispatch functions and methods important?\nTheo According to what I read, not really, but I like to follow a simple naming con-\nvention: use the name of the multimethod (for example, greet) as a prefix for\nthe dispatch function (for example, greetDispatch) and the methods. Then\nI’d have the Dispatch suffix for the dispatch function and a specific suffix for\neach method (for example, greetDog, greetCat, and greetCow).\nDave How does the multimethod mechanism work under the hood?\nTheo Internally, a multimethod maintains a hash map where the keys are the dis-\npatched values, and the values are the methods. When we add a method, an\nentry is added to the hash map, and when we call the multimethod, we query the\nhash map to find the implementation that corresponds to the dispatched value.\nDave I don’t think you’ve told me yet how to call a multimethod.\nTheo We call it as a regular function. Give me a minute, and I’ll show you an exam-\nple that calls a multimethod.\nListing13.10 Calling a multimethod like a regular function\ngreet(myDog);\n// → \"Woof woof! My name is Fido\"\ngreet(myCat);\n// → \"Meow! I am Milo\"\ngreet(myCow);\n// → \"Moo! Call me Clarabelle\"\nTIP Multimethods are called like regular functions.\nDave You told me earlier that in the dispatch function, we should validate the argu-\nments. Is that mandatory or is it a best practice?\nTheo It’s a best practice.\nDave What happens if the dispatch function doesn’t validate the arguments, and we\npass an invalid argument?\nTheo Like when an animal has no corresponding method?\nDave Exactly!\nTheo In that case, you’ll get an error. For instance, the arrows/multimethods library\nthrows a NoMethodError exception.\nDave That’s annoying. Is there a way to provide a default implementation?\n--- Page 309 ---\n13.3 Multimethods with multiple dispatch 281\nTheo Absolutely! In order to define a default implementation, you pass to method—\nas a single argument—the function that provides the default implementation.\nTheo writes the code and shows it to Dave. Dave then tests Theo’s code and seems satisfied\nwith the result.\nListing13.11 Defining a default implementation\nfunction greetDefault(animal) {\nconsole.log(\"My name is \" + animal.name);\n}\ngreet = method(greetDefault)(greet);\nListing13.12 Calling a multimethod when no method fits the dispatch value\nvar myHorse = {\n\"type\": \"horse\",\n\"name\": \"Horace\"\n};\ngreet(myHorse);\n// → \"My name is Horace\"\nTIP Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\nDave Cool!\n13.3 Multimethods with multiple dispatch\nTheo So far, we’ve mimicked OOP by having the type of the multimethod argument\nas a dispatch value. But if you think again about the flow of a multimethod,\nyou’ll discover something interesting. Would you like to try and draw a dia-\ngram that describes the flow of a multimethod in general?\nDave Let me get a fresh napkin. The one under my glass is a bit wet.\nTheo Uh, Dave, you can use my notebook.\nIt takes Dave a few minutes to draw a diagram like the one in figure 13.2. He pushes the\nnotebook back to Theo.\nValue1 Method1\nHandle case 1\nDispatch function Value3 Method3\nEmit a dispatch value Handle case 3\nargs\nValue2 Method2\nHandle case 2\nFigure 13.2 The logic flow\nof multimethods\n--- Page 310 ---\n282 CHAPTER 13 Polymorphism\nTheo Excellent! I hope you see that the dispatch function can emit any value.\nDave Like what?\nTheo Like emitting the type of two arguments!\nDave What do you mean?\nTheo Imagine that our animals are polyglot.\nDave Poly what?\nTheo Polyglot comes from the Greek polús, meaning much, and from glôssa, meaning\nlanguage. A polyglot is a person who can speak many languages.\nDave What languages would our animals speak?\nTheo I don’t know. Let’s say English and French.\nDave OK, and how would we represent a language in our program?\nTheo With a map, of course!\nDave What fields would we have in a language map?\nTheo Let’s keep things simple and have two fields: type and name.\nDave Like an animal map?\nTheo Not exactly. In a language map, the type field must be either fr for French or en\nfor English, whereas in the animal map, the type field is either dog, cat, or cow.\nDave Let me try to write the language map schema and the two language maps.\nTheo gladly consents; his French press coffee is getting cold! Dave writes his implementa-\ntion of the code and shows Theo.\nListing13.13 The schema of a language map\nvar languageSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nListing13.14 Two language maps\nvar french = {\n\"type\": \"fr\",\n\"name\": \"Français\"\n};\nvar english = {\n\"type\": \"en\",\n\"name\": \"English\"\n};\nTheo Excellent! Now, let’s write the code for the dispatch function and the methods\nfor our polyglot animals. Let’s call our multimethod, greetLang. We have one\ndispatch function and six methods.\n--- Page 311 ---\n13.3 Multimethods with multiple dispatch 283\nDave Right, three animals (dog, cat, and cow) times two languages (en and fr).\nBefore the implementation, I’d like to draw a flow diagram. It will help me to\nmake things crystal clear.\nTheo You need my notebook again?\nNot waiting for Dave to respond, Theo pushes his notebook across the table to Dave. Dave\ndraws a diagram like the one in figure 13.3 and slides the notebook back to Theo.\n[\"dog\", \"en\"] greetLangDogEn\nGreet as a dog in English\n[\"cat\", \"en\"] greetLangCatEn\nGreet as a cat in English\n[\"cow\", \"en\"] greetLangCowEn\nGreet as a cow in English\nargs greetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", \"fr\"] greetLangDogFr\nGreet as a dog in French\n[\"cat\", \"fr\"] greetLangCatFr\nGreet as a cat in French\n[\"cow\", \"fr\"] greetLangCowFr\nGreet as a cow in French\nFigure 13.3 The logic flow of the greetLang multimethod\nTheo Why did you omit the arrow between the arguments and the methods?\nDave In order to keep the diagram readable. Otherwise, there would be too many\narrows.\nTheo OK, I see. Are you ready for coding?\nDave Yes!\nTheo The dispatch function needs to validate its arguments and return an array with\ntwo elements: the type of animal and the type of language.\nDave types for a bit on his laptop. He initializes the multimethod with a dispatch function\nthat returns the type of its arguments and then shows the code to Theo.\nListing13.15 Initializing a multimethod with a dispatch function\nvar greetLangArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [animalSchema, languageSchema]\n};\nfunction greetLangDispatch(animal, language) {\nif(dev()) {\n--- Page 312 ---\n284 CHAPTER 13 Polymorphism\nif(!ajv.validate(greetLangArgsSchema, [animal, language])) {\nthrow (\"greetLang called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [animal.type, language.type];\n};\nvar greetLang = multi(greetLangDispatch);\nDave Does the order of the elements in the array matter?\nTheo It doesn’t matter, but it needs to be consistent with the wiring of the methods.\nThe implementation of greetLang would therefore look like this.\nListing13.16 The implementation of greetLang methods\nfunction greetLangDogEn(animal, language) {\nconsole.log(\"Woof woof! My name is \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"en\"], greetLangDogEn)(greetLang);\nfunction greetLangDogFr(animal, language) {\nconsole.log(\"Ouaf Ouaf! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"fr\"], greetLangDogFr)(greetLang);\nfunction greetLangCatEn(animal, language) {\nconsole.log(\"Meow! I am \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"en\"], greetLangCatEn)(greetLang);\nfunction greetLangCatFr(animal, language) {\nconsole.log(\"Miaou! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"fr\"], greetLangCatFr)(greetLang);\nfunction greetLangCowEn(animal, language) {\nconsole.log(\"Moo! Call me \" +\nanimal.name +\n\" and I speak \" +\n--- Page 313 ---\n13.3 Multimethods with multiple dispatch 285\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"en\"], greetLangCowEn)(greetLang);\nfunction greetLangCowFr(animal, language) {\nconsole.log(\"Meuh! Appelle moi \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"fr\"], greetLangCowFr)(greetLang);\nDave looks at the code for the methods that deal with French. He is surprised to see Ouaf\nOuaf instead of Woof Woof for dogs, Miaou instead of Meow for cats, and Meuh instead of\nMoo for cows.\nDave I didn’t know that animal onomatopoeia were different in French than in\nEnglish!\nTheo Ono what?\nDave Onomatopoeia, from the Greek ónoma that means name and poiéo– that means to\nproduce. It is the property of words that sound like what they represent; for\ninstance, Woof, Meow, and Moo.\nTheo Yeah, for some reason in French, dogs Ouaf, cats Miaou, and cows Meuh.\nDave I see that in the array the animal type is always before the language type.\nTheo Right! As I told you before, in a multimethod that features multiple dispatch,\nthe order doesn’t really matter, but it has to be consistent.\nTIP Multiple dispatch is when a dispatch function emits a value that depends on more\nthan one argument. In a multimethod that features multiple dispatch, the order of\nthe elements in the array emitted by the dispatch function has to be consistent with\nthe order of the elements in the wiring of the methods.\nDave Now let me see if I can figure out how to use a multimethod that features mul-\ntiple dispatch.\nDave remembers that Theo told him earlier that multimethods are used like regular func-\ntions. With that in mind, he comes up with the code for a multimethod that features multi-\nple dispatch.\nListing13.17 Calling a multimethod that features multiple dispatch\ngreetLang(myDog, french);\n// → \"Ouaf Ouaf! Je m\\'appelle Fido et je parle Français\"\ngreetLang(myDog, english);\n// → \"Woof woof! My name is Fido and I speak English\"\ngreetLang(myCat, french);\n// → \"Miaou! Je m\\'appelle Milo et je parle Français\"\n--- Page 314 ---\n286 CHAPTER 13 Polymorphism\ngreetLang(myCat, english);\n// → \"Meow! I am Milo and I speak English\"\ngreetLang(myCow, french);\n// → \"Meuh! Appelle moi Clarabelle et je parle Français\"\ngreetLang(myCow, english);\n// → \"Moo! Call me Clarabelle and I speak English\"\nTheo Now do you agree that multimethods with multiple dispatch offer a more pow-\nerful polymorphism that OOP polymorphism?\nDave Indeed, I do.\nTheo Let me show you an even more powerful polymorphism called dynamic dis-\npatch. But first, let’s get some more of that wonderful French press coffee.\nDave Great idea! While we’re in the kitchen, I think my mom made an orange Bundt\ncake using the oranges from the grove.\n13.4 Multimethods with dynamic dispatch\nDave refills their coffee cups as Theo takes two slices from the cake and dishes them up.\nThey take their coffee and cake outside to enjoy more of the fresh country air before\nresuming their conversation.\nDave What is dynamic dispatch?\nTheo It’s when the dispatch function of a multimethod returns a value that goes\nbeyond the static type of its arguments.\nDave Like what, for example?\nTheo Like a number or a Boolean, for instance.\nDave Why would such a thing be useful?\nTheo Imagine that instead of being polyglot, our animals would suffer from\ndysmakrylexia.\nDave Suffering from what?\nTheo Dysmakrylexia. It comes from the Greek dus, expressing the idea of difficulty,\nmakrýs meaning long, and léxis meaning diction. Therefore, dysmakrylexia is dif-\nficulty pronouncing long words.\nDave I’ve never heard of that.\nTheo That’s because I just invented it.\nDave Funny. What’s considered a long word for our animals?\nTheo Let’s say that when their name has more than five letters, they’re not able to\nsay it.\nDave A bit weird, but OK.\nTheo Let’s call our multimethod dysGreet. Its dispatch function returns an array\nwith two elements: the animal type and a Boolean about whether the name is\nlong or not. Take a look at this multimethod initialization.\n--- Page 315 ---\n13.4 Multimethods with dynamic dispatch 287\nListing13.18 A multimethod using a dispatch function with dynamic dispatch\nfunction dysGreetDispatch(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"dysGreet called with invalid arguments: \" + errors);\n}\n}\nvar hasLongName = animal.name.length > 5;\nreturn [animal.type, hasLongName];\n};\nvar dysGreet = multi(dysGreetDispatch);\nDave Writing the dysGreet methods doesn’t seem too complicated.\nAs Theo reaches over to pass Dave his notebook, he accidently hits his coffee cup. Now Theo’s\nnotebook is completely wet, and all the diagrams are soggy! Fortunately, Dave brought an\nextra napkin from the kitchen, and it’s still clean. He draws a flow diagram as in figure 13.4\nand then grabs his laptop and writes the implementation of the dysGreet methods.\n[\"dog\", true] dysGreetDogLong\nGreet as a dog mentioning name\n[\"cat\", true] dysGreetCatLong\nGreet as a cat mentioning name\n[\"cow\", true] dysGreetCowLong\nGreet as a cow mentioning name\nargs dysGreetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", false] dysGreetDogShort\nGreet as a dog omitting name\n[\"cat\", false] dysGreetCatShort\nGreet as a cat omitting name\n[\"cow\", false] dysGreetCowShort\nGreet as a cow omitting name\nFigure 13.4 The logic flow of the dysGreet multimethod\nListing13.19 The dysGreet methods\nfunction dysGreetDogLong(animal) {\nconsole.log(\"Woof woof! My name is \" + animal.name);\n}\ndysGreet = method([\"dog\", true], dysGreetDogLong)(dysGreet);\n--- Page 316 ---\n288 CHAPTER 13 Polymorphism\nfunction dysGreetDogShort(animal) {\nconsole.log(\"Woof woof!\");\n}\ndysGreet = method([\"dog\", false], dysGreetDogShort)(dysGreet);\nfunction dysGreetCatLong(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ndysGreet = method([\"cat\", true], dysGreetCatLong)(dysGreet);\nfunction dysGreetCatShort(animal) {\nconsole.log(\"Meow!\");\n}\ndysGreet = method([\"cat\", false], dysGreetCatShort)(dysGreet);\nfunction dysGreetCowLong(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ndysGreet = method([\"cow\", true], dysGreetCowLong)(dysGreet);\nfunction dysGreetCowShort(animal) {\nconsole.log(\"Moo!\");\n}\ndysGreet = method([\"cow\", false], dysGreetCowShort)(dysGreet);\nTheo checks that the code works as expected. He compliments Dave, not only on the\nmethod implementation but also for having the foresight to grab an extra napkin.\nListing13.20 Testing dysGreet\ndysGreet(myDog);\ndysGreet(myCow);\ndysGreet(myCat);\n//\"Woof woof!\"\n//\"Moo! Call me Clarabelle\"\n//\"Meow!\"\nTheo Well done, my friend! Our exploration of multimethods has come to an end. I\nthink it’s time for me to drive back if I want to get home before dark and beat\nthe rush hour traffic.\nDave Before you leave, let’s check if multimethods are available in programming\nlanguages other than JavaScript.\nTheo That’s a question for Joe.\nDave Do you think it’s OK if I call him now?\nTheo I think it’s probably better if you send him an email. He’s in a tech conference,\nand I’m not sure if it’s all day. Thank you for this beautiful day in the country\nand the wonderful refreshments.\nDave I enjoyed it, also, especially our discussions about etymology. I think there are\nsome oranges for you to take home and enjoy later.\nTheo Great! I can’t wait until my wife tries one.\n--- Page 317 ---\n13.5 Integrating multimethods in a production system 289\nAfter Theo leaves, Dave sends Joe an email. A few minutes later, Dave receives an email\nfrom Joe with the subject, “Support for multimethods in different languages.”\nSupport for multimethods in different languages\nPython has a library called multimethods (https://github.com/weissjeffm/multimeth-\nods), and Ruby has one called Ruby multimethods (https://github.com/psantacl/\nruby-multimethods). Both seem to work quite like the JavaScript arrows/multi-\nmethod library.\nIn Java, there is the Java Multimethod Framework (http://igm.univ-mlv.fr/~forax/\nworks/jmmf/), and C# supports multimethods natively via the dynamic keyword.\nHowever, in both Java and C#, multimethods work only with static data types and not\nwith generic data structures.\nGeneric data structure\nLanguage URL\nsupport\nJavaScript https://github.com/caderek/arrows/tree/master/ Yes\npackages/multimethod\nJava http://igm.univ-mlv.fr/~forax/works/jmmf/ No\nC# Native support No\nPython https://github.com/weissjeffm/multimethods Yes\nRuby https://github.com/psantacl/ruby-multimethods Yes\n13.5 Integrating multimethods in a production system\nWhile Theo is driving back home, his thoughts take him back to the fresh air of the coun-\ntry. This pleasant moment is interrupted by a phone call from Nancy at Klafim.\nNancy How are you doing?\nTheo Fine. I’m driving back from the countryside.\nNancy Cool. Are you available to talk about work?\nTheo Sure.\nNancy I’d like to add a tiny feature to the catalog.\nIn the past, when Nancy qualified a feature as tiny, it scared Theo because tiny turned into\nhuge. What seemed easy to her always took him a surprising amount of time to develop.\nBut after refactoring the system according to DOP principles, now what seems tiny to\nNancy is usually quite easy to implement.\nTheo What feature?\nNancy I’d like to allow librarians to view the list of authors, ordered by last name, in\ntwo formats: HTML and Markdown.\n--- Page 318 ---\n290 CHAPTER 13 Polymorphism\nTheo It doesn’t sound too complicated.\nNancy Also, I need a bit of text formatting.\nTheo What kind of text formatting?\nNancy Depending on the number of books an author has written, their name should\nbe in bold and italic fonts.\nTheo Could you send me an email with all the details. I’ll take a look at it tomorrow\nmorning.\nNancy Perfect. Have a safe drive!\nBefore going to bed, Theo reflects about today’s etymology lessons. He realizes that he\nnever looked for the etymology of the word etymology itself! He searches for the term etymol-\nogy online and learns that the word etymology derives from the Greek étumon, meaning true\nsense, and the suffix logia, denoting the study of. During the night, Theo dreams of dogs,\ncats, and cows programming on their laptops in a field of grass.\nWhen Theo arrives at the office the next day, he opens Nancy’s email with the details\nabout the text formatting feature. The details are summarized in table 13.1.\nTable 13.1 Text formatting for author names according to the number of books\nthey have written\nNumber of books Italic Bold\n10 or fewer Yes No\nBetween 11 and 50 No Yes\n51 or more Yes Yes\nTheo forwards Nancy’s email to Dave and asks him to take care of this task. Delegating\nresponsibility, after all, is the trait of a great manager.\nDave thinks the most difficult part of the feature lies in implementing an Author\n.myName(author, format) function that receives two arguments: the author data and the\ntext format. He asks himself whether he can implement this function as a multimethod\nand use what he learned yesterday with Theo at his parents’ home in the country. It seems\nthat this feature is quite similar to the one that dealt with dysmakrylexia. Instead of check-\ning the length of a string, he needs to check the length of an array.\nFirst, Dave needs a data schema for the text format. He could represent a format as a\nmap with a type field like Theo did yesterday for languages, but at the moment, it seems\nsimpler to represent a format as a string that could be either markdown or html. He comes\nup with the text format schema in listing 13.21. He already wrote the author schema with\nTheo last week. It’s in listing 13.22.\nListing13.21 The text format schema\nvar textFormatSchema = {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"enum\": [\"markdown\", \"html\"]}\n};\n--- Page 319 ---\n13.5 Integrating multimethods in a production system 291\nListing13.22 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"name\", \"bookIsbns\"],\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nNow, Dave needs to write a dispatch function and initialize the multimethod. Remember-\ning that Theo had no qualms about creating the word dysmakrylexia, he decides that he\nprefers his own neologism, prolificity, over the existing nominal form prolificness. He finds it\nuseful to have an Author.prolificityLevel helper function that returns the level of\nprolificity of the author: either low, medium, or high. Now he’s ready to code the author-\nNameDispatch function.\nListing13.23 Author.myName multimethod initialization\nAuthor.prolificityLevel = function(author) {\nvar books = _.size(_.get(author, \"bookIsbns\"));\nif (books <= 10) {\nreturn \"low\";\n};\nif (books >= 51) {\nreturn \"high\";\n}\nreturn \"medium\";\n};\nvar authorNameArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\nauthorSchema,\n{\"enum\": [\"markdown\", \"html\"]}\n]\n};\nfunction authorNameDispatch(author, format) {\nif(dev()) {\nif(!ajv.validate(authorNameArgsSchema, [author, format])) {\nthrow (\"Author.myName called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [Author.prolificityLevel(author), format];\n};\nAuthor.myName = multi(authorNameDispatch);\n--- Page 320 ---\n292 CHAPTER 13 Polymorphism\nThen Dave works on the methods: first, the HTML format methods. In HTML, bold text is\nwrapped inside a <b> tag, and italic text is wrapped in a <i> tag. For instance, in HTML,\nthree authors with different levels of prolificity would be written like this.\nListing13.24 Examples of bold and italic in HTML\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n<i>Yehonathan Sharvit<i>\nBold and italic formatting\n<b>Stephen Covey</b>\nfor highly prolific authors\n<b><i>Isaac Asimov</i></b>\nWith this information in hand, Dave writes the three methods that deal with HTML for-\nmatting. Easy!\nListing13.25 The methods that deal with HTML formatting\nfunction authorNameLowHtml(author, format) {\nreturn \"<i>\" + _.get(author, \"name\") + \"</i>\";\n}\nAuthor.myName = method([\"low\", \"html\"], authorNameLowHtml)(Author.myName);\nfunction authorNameMediumHtml(author, format) {\nreturn \"<b>\" + _.get(author, \"name\") + \"</b>\";\n}\nAuthor.myName =\nmethod([\"medium\", \"html\"], authorNameMediumHtml)(Author.myName);\nfunction authorNameHighHtml(author, format) {\nreturn \"<b><i>\" + _.get(author, \"name\") + \"</i></b>\";\n}\nAuthor.myName =\nmethod([\"high\", \"html\"], authorNameHighHtml)(Author.myName);\nThen, Dave moves on to the three methods that deal with Markdown formatting. In\nMarkdown, bold text is wrapped in two asterisks, and italic text is wrapped in a single\nasterisk. For instance, in Markdown, three authors with different levels of prolificity\nwould be written like the code in listing 13.26. The code for the Markdown methods is in\nlisting 13.27.\nListing13.26 Examples of bold and italic in Markdown\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n*Yehonathan Sharvit*\nBold and italic formatting\n**Stephen Covey**\nfor highly prolific authors\n***Isaac Asimov***\n--- Page 321 ---\n13.5 Integrating multimethods in a production system 293\nListing13.27 The methods that deal with Markdown formatting\nfunction authorNameLowMarkdown(author, format) {\nreturn \"*\" + _.get(author, \"name\") + \"*\";\n}\nAuthor.myName =\nmethod([\"low\", \"markdown\"], authorNameLowMarkdown)(Author.myName);\nfunction authorNameMediumMarkdown(author, format) {\nreturn \"**\" + _.get(author, \"name\") + \"**\";\n}\nAuthor.myName =\nmethod([\"medium\", \"markdown\"], authorNameMediumMarkdown)(Author.myName);\nfunction authorNameHighMarkdown(author, format) {\nreturn \"***\" + _.get(author, \"name\") + \"***\";\n}\nAuthor.myName =\nmethod([\"high\", \"markdown\"], authorNameHighMarkdown)(Author.myName);\nDave decides to test his code by involving a mysterious author. Listing 13.28 and listing 13.29\nshow the tests.\nListing13.28 Testing HTML formatting\nvar yehonathan = {\n\"name\": \"Yehonathan Sharvit\",\n\"bookIsbns\": [\"9781617298578\"]\n};\nAuthor.myName(yehonathan, \"html\");\n// → \"<i>Yehonathan Sharvit</i>\"\nListing13.29 Testing Markdown formatting\nAuthor.myName(yehonathan, \"markdown\");\n// → \"*Yehonathan Sharvit*\"\nTheo shows up at Dave’s desk and asks to review Dave’s implementation of the list of\nauthors feature. Curious, Theo asks Dave about the author that appears in the test of\nAuthor.myName.\nTheo Who is Yehonathan Sharvit?\nDave I don’t really know. The name appeared when I googled “data-oriented pro-\ngramming” yesterday. He wrote a book on the topic. I thought it would be cool\nto use its ISBN in my test.\n--- Page 322 ---\n294 CHAPTER 13 Polymorphism\nSummary\n The main benefit of polymorphism is extensibility.\n Multimethods make it possible to benefit from polymorphism when data is repre-\nsented with generic maps.\n A multimethod is made of a dispatch function and multiple methods.\n The dispatch function of a multimethod emits a dispatch value.\n Each of the methods used in a multimethod provides an implementation for a\nspecific dispatch value.\n Multimethods can mimic OOP class inheritance via single dispatch.\n In single dispatch, a multimethod receives a single map that contains a type field,\nand the dispatch function of the multimethod emits the value of the type field.\n In addition to single dispatch, multimethods provide two kinds of advanced\npolymorphisms: multiple dispatch and dynamic dispatch.\n Multiple dispatch is used when the behavior of the multimethod depends on\nmultiple arguments.\n Dynamic dispatch is used when the behavior of the multimethod depends on run-\ntime arguments.\n The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\n A multimethod dispatch function is responsible for\n– Defining the signature.\n– Validating the arguments.\n– Emitting a dispatch value.\n Multimethods provides extensibility by decoupling between multimethod ini-\ntialization and method implementations.\n Multimethods are called like regular functions.\n Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\n In a multimethod that features multiple dispatch, the order of the elements in\nthe array emitted by the dispatch function has to be consistent with the order of\nthe elements in the wiring of the methods.\nLodash functions introduced in this chapter\nFunction Description\nsize(coll) Gets the size of coll\n--- Page 323 ---\nAdvanced data\nmanipulation\nWhatever is well-conceived\nis clearly said\nThis chapter covers\n Manipulating nested data\n Writing clear and concise code for business\nlogic\n Separating business logic and generic data\nmanipulation\n Building custom data manipulation tools\n Using the best tool for the job\nWhen our business logic involves advanced data processing, the generic data manip-\nulation functions provided by the language run time and by third-party libraries\nmight not be sufficient. Instead of mixing the details of data manipulation with\nbusiness logic, we can write our own generic data manipulation functions and imple-\nment our custom business logic using them. Separating business logic from the inter-\nnal details of data manipulation makes the business logic code concise and easy to\nread for other developers.\n295\n--- Page 324 ---\n296 CHAPTER 14 Advanced data manipulation\n14.1 Updating a value in a map with eloquence\nDave is more and more autonomous on the Klafim project. He can implement most fea-\ntures on his own, typically turning to Theo only for code reviews. Dave’s code quality stan-\ndards are quite high. Even when his code is functionally solid, he tends to be unsatisfied\nwith its readability. Today, he asks for Theo’s help in improving the readability of the code\nthat fixes a bug Theo introduced a long time ago.\nDave I think I have a found a bug in the code that returns book information from\nthe Open Library API.\nTheo What bug?\nDave Sometimes, the API returns duplicate author names, and we pass the dupli-\ncates through to the client.\nTheo It doesn’t sound like a complicated bug to fix.\nDave Right, I fixed it, but I’m not satisfied with the readability of the code I wrote.\nTheo Being critical of our own code is an important quality for a developer to prog-\nress. What is it exactly that you don’t like?\nDave Take a look at this code.\nListing14.1 Removing duplicates in a straightforward but tedious way\nfunction removeAuthorDuplicates(book) {\nvar authors = _.get(book, \"authors\");\nvar uniqAuthors = _.uniq(authors);\nreturn _.set(book,\"authors\", uniqAuthors);\n}\nDave I’m using _.get to retrieve the array with the author names, then _.uniq to\ncreate a duplicate-free version of the array, and finally, _.set to create a new\nversion of the book with no duplicate author names.\nTheo The code is tedious because the next value of authorNames needs to be based\non its current value.\nDave But it’s a common use case! Isn’t there a simpler way to write this kind of code?\nTheo Your astonishment definitely honors you as a developer, Dave. I agree with you\nthat there must be a simpler way. Let me phone Joe and see if he’s available for\na conference call.\nJoe How’s it going, Theo?\nTheo Great! Are you back from your tech conference?\nJoe I just landed. I’m on my way home now in a taxi.\nTheo How was your talk about DOP?\nJoe Pretty good. At the beginning people were a bit suspicious, but when I told\nthem the story of Albatross and Klafim, it was quite convincing.\nTheo Yeah, adults are like children in that way; they love stories.\nJoe What about you? Did you manage to achieve polymorphism with multimethods?\nTheo Yes! Dave even managed to implement a feature in Klafim with multimethods.\nJoe Cool!\n--- Page 325 ---\n14.1 Updating a value in a map with eloquence 297\nTheo Do you have time to help Dave with a question about programming?\nJoe Sure.\nDave Hi Joe. How are you doing?\nJoe Hello Dave. Not bad. What kind of help do you need?\nDave I’m wondering if there’s a simpler way to remove duplicates inside an array\nvalue in a map. Using _.get, _.uniq, and _.set looks quite tedious.\nJoe You should build your own data manipulation tools.\nDave What do you mean?\nJoe You should write a generic update function that updates a value in a map,\napplying a calculation based on its current value.1\nDave What would the arguments of update be in your opinion?\nJoe Put the cart before the horse.\nDave What?!\nJoe Rewrite your business logic as if update were already implemented, and you’ll\ndiscover what the arguments of update should be.\nDave I see what you mean: the horse is the implementation of update, and the cart is\nthe usage of update.\nJoe Exactly. But remember, it’s better if you keep your update function generic.\nDave How?\nJoe By not limiting it to your specific use case.\nDave I see. The implementation of update should not deal with removing duplicate\nelements. Instead, it should receive the updating function—in my case,\n_.uniq—as an argument.\nJoe Exactly! Uh, sorry Dave, I gotta go, I just got home. Good luck!\nDave Take care, Joe, and thanks!\nDave ends the conference call. Looking at Theo, he reiterates the conversation with Joe.\nDave Joe advised me to write my own update function. For that purpose, he told me\nto start by rewriting removeAuthorDuplicates as if update were already\nimplemented. That will allow us to make sure we get the signature of update\nright.\nTheo Sounds like a plan.\nDave Joe called it “putting the cart before the horse.”\nTheo Joe and his funny analogies...\nTIP The best way to find the signature of a custom data manipulation function is to\nthink about the most convenient way to use it.\nDave Anyway, the way I’d like to use update inside removeAuthorDuplicates is\nlike this.\n1 Lodash provides an implementation of update, but for the sake of teaching, we are writing our own imple-\nmentation.\n--- Page 326 ---\n298 CHAPTER 14 Advanced data manipulation\nListing14.2 The code that removes duplicates in an elegant way\nfunction removeAuthorDuplicates(book) {\nreturn update(book, \"authors\", _.uniq);\n}\nTheo Looks good to me!\nDave Wow! Now the code with update is much more elegant than the code with\n_.get and _.set!\nTheo Before you implement update, I suggest that you write down in plain English\nexactly what the function does.\nDave It’s quite easy: update receives a map called map, a path called path, and a\nfunction called fun. It returns a new version of map, where path is associated\nwith fun(currentValue), and currentValue is the value associated with\npath in map.\nThinking out loud, Dave simultaneously draws a diagram like that in figure 14.1. Theo is\nbecoming more and more impressed with his young protegé as he studies the figure.\n{\n\"position\" : \"manager\", \"income\"\n\"income\" : 100000\n} map fun path\nupdate\n{\n\"position\" : \"manager\",\n\"income\" : fun(100000)\nres Figure 14.1 The\n}\nbehavior of update\nTIP Before implementing a custom data manipulation function, formulate in plain\nEnglish exactly what the function does.\nTheo With such a clear definition, it’s going to be a piece of cake to implement\nupdate!\nAfter a few minutes, Dave comes up with the code. It doesn’t take long because the plain-\nEnglish diagram helps him to organize the code.\nListing14.3 A generic update function\nfunction update(map, path, fun) {\nvar currentValue = _.get(map, path);\nvar nextValue = fun(currentValue);\nreturn _.set(map, path, nextValue);\n}\n--- Page 327 ---\n14.2 Manipulating nested data 299\nTheo Why don’t you see if it works with a simple case such as incrementing a number\nin a map?\nDave Good idea! I’ll try multiplying a value in a map by 2 with update. How’s this\nlook?\nListing14.4 Multiplying a value in a map by 2\nvar m = {\n\"position\": \"manager\",\n\"income\": 100000\n};\nupdate(m, \"income\", function(x) {\nreturn x * 2;\n});\n// → {\"position\": \"manager\", \"income\": 200000}\nTheo Great! It seems to work.\n14.2 Manipulating nested data\nThe next Monday, during Theo and Dave’s weekly sync meeting, they discuss the upcom-\ning features for Klafim. Theo fondly remembers another Monday where they met at Dave’s\nfamily home in the country. Coming back to the present moment, Theo begins.\nTheo Recently, Nancy has been asking for more and more administrative features.\nDave Like what?\nTheo I’ll give you a few examples.... Let me find the email I got from Nancy yesterday.\nDave OK.\nTheo Here it is. There are three feature requests for now: listing all the book author\nIDs, calculating the book lending ratio, and grouping books by a physical library.\nDave What feature should I tackle first?\nTheo It doesn’t matter, but you should deliver the three of these before the end of\nthe week. Good luck, and don’t hesitate to call me if you need help.\nOn Tuesday, Dave asks for Theo’s help. Dave is not pleased with how his code looks.\nDave I started to work on the three admin features, but I don’t like the code I wrote.\nLet me show you the code for retrieving the list of author IDs from the list of\nbooks returned from the database.\nTheo Can you remind me what an element in a book list returned from the database\nlooks like?\nDave Each book is a map with an authorIds array field.\nTheo OK, so it sounds like a map over the books should do it.\nDave This is what I did, but it doesn’t work as expected. Here’s my code for listing\nthe book author IDs.\n--- Page 328 ---\n300 CHAPTER 14 Advanced data manipulation\nListing14.5 Retrieving the author IDs in books as an array of arrays\nfunction authorIdsInBooks(books) {\nreturn _.map(books, \"authorIds\");\n}\nTheo What’s the problem?\nDave The problem is that it returns an array of arrays of author IDs instead of an\narray of author IDs. For instance, when I run authorIdsInBooks on a catalog\nwith two books, I get this result.\nListing14.6 The author IDs in an array of arrays\n[\n[\"sean-covey\", \"stephen-covey\"],\n[\"alan-moore\", \"dave-gibbons\"]\n]\nTheo That’s not a big problem. You can flatten an array of arrays with _.flatten,\nand you should get the result you expect.\nDave Nice! This is exactly what I need! Give me a moment to fix the code of\nauthorIdsInBooks. . . here you go.\nListing14.7 Retrieving the author IDs in books as an array of strings\nfunction authorIdsInBooks(books) {\nreturn _.flatten(_.map(books, \"authorIds\"));\n}\nTheo Don’t you think that mapping and then flattening deserves a function of its own?\nDave Maybe. It’s quite easy to implement a flatMap function.2 How about this?\nListing14.8 The implementation of flatMap\nfunction flatMap(coll, f) {\nreturn _.flatten(_.map(coll,f));\n}\nTheo Nice!\nDave I don’t know.... It’s kind of weird to have such a small function.\nTheo I don’t think that code size is what matters here.\nDave What do you mean?\nTheo See what happens when you rewrite authorIdsInBooks using flatMap.\nDave OK, here’s how I’d use flatMap to list the author IDs.\n2 Lodash provides an implementation of flatMap, but for the sake of teaching, we are writing our own\nimplementation.\n--- Page 329 ---\n14.3 Using the best tool for the job 301\nListing14.9 Retrieving the author IDs as an array of strings using flatMap\nfunction authorIdsInBooks(books) {\nreturn flatMap(books, \"authorIds\");\n}\nTheo What implementation do you prefer, the one with flatten and map (in listing\n14.7) or the one with flatMap (in listing 14.9)?\nDave I don’t know. To me, they look quite similar.\nTheo Right, but which implementation is more readable?\nDave Well, assuming I know what flatMap does, I would say the implementation\nwith flatMap. Because it’s more concise, it is a bit more readable.\nTheo Again, it’s not about the size of the code. It’s about the clarity of intent and the\npower of naming things.\nDave I don’t get that.\nTheo Let me give you an example from our day-to-day language.\nDave OK.\nTheo Could you pass me that thing on your desk that’s used for writing?\nIt takes Dave a few seconds to get that Theo has asked him to pass the pen on the desk.\nAfter he passes Theo the pen, he asks:\nDave Why didn’t you simply ask for the pen?\nTheo I wanted you to experience how it feels when we use descriptions instead of\nnames to convey our intent.\nDave Oh, I see. You mean that once we use a name for the operation that maps and\nflattens, the code becomes clearer.\nTheo Exactly.\nDave Let’s move on to the second admin feature: calculating the book lending ratio.\nTheo Before that, I think we deserve a short period for rest and refreshments, where\nwe drink a beverage made by percolation from roasted and ground seeds.\nDave A coffee break!\n14.3 Using the best tool for the job\nAfter the coffee break, Dave shows Theo his implementation of the book lending ratio cal-\nculation. This time, he seems to like the code he wrote.\nDave I’m quite proud of the code I wrote to calculate the book lending ratio.\nTheo Show me the money!\nDave My function receives a list of books from the database like this.\nListing14.10 A list of two books with bookItems\n[\n{\n\"isbn\": \"978-1779501127\",\n--- Page 330 ---\n302 CHAPTER 14 Advanced data manipulation\n\"title\": \"Watchmen\",\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n}\n]\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"bookItems\": [\n{\n\"id\": \"book-item-123\",\n\"libId\": \"hudson-park-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-17\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n]\nTheo Quite a nested piece of data!\nDave Yeah, but now that I’m using flatMap, calculating the lending ratio is quite\neasy. I’m going over all the book items with forEach and incrementing either\nthe lent or the notLent counter. At the end, I return the ratio between lent\nand (lent + notLent). Here’s how I do that.\nListing14.11 Calculating the book lending ratio using forEach\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar lent = 0;\nvar notLent = 0;\n_.forEach(bookItems, function(item) {\nif(_.get(item, \"isLent\")) {\nlent = lent + 1;\n} else {\nnotLent = notLent + 1;\n}\n});\nreturn lent/(lent + notLent);\n}\nTheo Would you allow me to tell you frankly what I think of your code?\nDave If you are asking this question, it means that you don’t like it. Right?\nTheo It’s nothing against you; I don’t like any piece of code with forEach.\n--- Page 331 ---\n14.3 Using the best tool for the job 303\nDave What’s wrong with forEach?\nTheo It’s too generic!\nDave I thought that genericity was a positive thing in programming.\nTheo It is when we build a utility function, but when we use a utility function, we\nshould use the least generic function that solves our problem.\nDave Why?\nTheo Because we ought to choose the right tool for the job, like in the real life.\nDave What do you mean?\nTheo Let me give you an example. Yesterday, I had to clean my drone from the\ninside. Do you think that I used a screwdriver or a Swiss army knife to unscrew\nthe drone cover?\nDave A screwdriver, of course! It’s much more convenient to manipulate.\nTheo Right. Also, imagine that someone looks at me using a screwdriver. It’s quite\nclear to them that I am turning a screw. It conveys my intent clearly.\nDave Are you saying that forEach is like the Swiss army knife of data manipulation?\nTheo That’s a good way to put it.\nTIP Pick the least generic utility function that solves your problem.\nDave What function should I use then, to iterate over the book item collection?\nTheo You could use _.reduce.\nDave I thought reduce was about returning data from a collection. Here, I don’t\nneed to return data; I need to update two variables, lent and notLent.\nTheo You could represent those two values in a map with two keys.\nDave Can you show me how to rewrite my lendingRatio function using reduce?\nTheo Sure. The initial value passed to reduce is the map, {\"lent\": 0, \"notLent\": 0},\nand inside each iteration, we update one of the two keys, like this.\nListing14.12 Calculating the book lending ratio using reduce\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = _.reduce(bookItems, function(res, item) {\nif(_.get(item, \"isLent\")) {\nres.lent = res.lent + 1;\n} else {\nres.notLent = res.notLent + 1;\n}\nreturn res;\n}, {notLent: 0, lent:0});\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nDave Instead of updating the variables lent and notLent, now we are updating lent\nand notLent map fields. What’s the difference?\n--- Page 332 ---\n304 CHAPTER 14 Advanced data manipulation\nTheo Dealing with map fields instead of variables allows us to get rid of reduce in\nour business logic code.\nDave How could you iterate over a collection without forEach and without reduce?\nTheo I can’t avoid the iteration over a collection, but I can hide reduce behind a\nutility function. Take a look at the way reduce is used inside the code of\nlendingRatio. What is the meaning of the reduce call?\nDave looks at the code in listing 14.12. He thinks for a long moment before he answers.\nDave I think it’s counting the number of times isLent is true and false.\nTheo Right. Now, let’s use Joe’s advice about building our own data manipulation\ntool.\nDave How exactly?\nTheo I suggest that you write a countByBoolField utility function that counts the\nnumber of times a field is true and false.\nDave OK, but before implementing this function, let me first rewrite the code of\nlendingRatio, assuming this function already exists.\nTheo You are definitely a fast learner, Dave!\nDave Thanks! I think that by using countByBoolField, the code for calculating the\nlending ratio using a custom utility function would be something like this.\nListing14.13 Calculating the book lending ratio\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = countByBoolField(bookItems, \"isLent\", \"lent\", \"notLent\");\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nTIP Don’t use _.reduce or any other low-level data manipulation function inside\ncode that deals with business logic. Instead, write a utility function—with a proper\nname—that hides _.reduce.\nTheo Perfect. Don’t you think that this code is clearer than the code using _.reduce?\nDave I do! The code is both more concise and the intent is clearer. Let me see if I\ncan implement countByBoolField now.\nTheo I suggest that you write a unit test first.\nDave Good idea.\nDave types for a bit. When he’s satisfied, he shows Theo the result.\nListing14.14 A unit test for countByBoolField\nvar input = [\n{\"a\": true},\n{\"a\": false},\n{\"a\": true},\n--- Page 333 ---\n14.4 Unwinding at ease 305\n{\"a\": true}\n];\nvar expectedRes = {\n\"aTrue\": 3,\n\"aFalse\": 1\n};\n_.isEqual(countByBoolField(input, \"a\", \"aTrue\", \"aFalse\"), expectedRes);\nTheo Looks good to me. Now, for the implementation of countByBoolField, I\nthink you are going to need our update function.\nDave I think you’re right. On each iteration, I need to increment the value of either\naTrue or aFalse using update and a function that increments a number by 1.\nAfter a few minutes of trial and error, Dave comes up with the piece of code that uses\nreduce, update, and inc. He shows Theo the code for countByBoolField.\nListing14.15 The implementation of countByBoolField\nfunction inc (n) {\nreturn n + 1;\n}\nfunction countByBoolField(coll, field, keyTrue, keyFalse) {\nreturn _.reduce(coll, function(res, item) {\nif (_.get(item, field)) {\nreturn update(res, keyTrue, inc);\n}\nreturn update(res, keyFalse, inc);\n}, {[keyTrue]: 0,\nCreates a map with\n[keyFalse]: 0});\nkeyTrue and keyFalse\n}\nassociated to 0\nTheo Well done! Shall we move on and review the third admin feature?\nDave The third feature is more complicated. I would like to use the teachings from\nthe first two features for the implementation of the third feature.\nTheo OK. Call me when you’re ready for the code review.\n14.4 Unwinding at ease\nDave really struggled with the implementation of the last admin feature, grouping books\nby a physical library. After a couple of hours of frustration, Dave calls Theo for a rescue.\nDave I really had a hard time implementing the grouping by library feature.\nTheo I only have a couple of minutes before my next meeting, but I can try to help\nyou. What’s the exact definition of grouping by library?\nDave Let me show you the unit test I wrote.",
        "sections_found": []
      },
      "accurate_page_range": "303-333"
    },
    {
      "text": "- 12.1 Function arguments validation",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "raw_line": "- 12.1 Function arguments validation (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 99,
      "chapter_info": {
        "page": 303,
        "title": "Advanced data validation",
        "pattern_matched": "Chapter 12",
        "text_preview": "13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with "
      },
      "chapter_sections": {
        "start_page": 303,
        "end_page": 333,
        "content": "\n--- Page 303 ---\n13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with maps\nvar myDog = {\n\"type\": \"dog\",\n\"name\": \"Fido\"\n};\nvar myCat = {\n\"type\": \"cat\",\n\"name\": \"Milo\"\n};\nvar myCow = {\n\"type\": \"cow\",\n\"name\": \"Clarabelle\"\n};\nDave Could you have given another name to the field that holds the animal type?\nTheo Absolutely. It could be anything.\nDave I see. You’re asking me the fundamental difference between your code with a\nswitch statement and my code with an interface and three classes?\nTheo Exactly.\nDave First of all, if you pass an invalid map to your greet function, bad things will\nhappen.\nTheo You’re right. Let me fix that and validate input data.\nListing13.4 Data validation\nvar animalSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nSee chapter 12 about\ndata validation for\nfunction greet(animal) {\ndetails.\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\n--- Page 304 ---\n276 CHAPTER 13 Polymorphism\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\nbreak;\ncase \"cat\":\nconsole.log(\"Meow! I am: \" + animal.name);\nbreak;\ncase \"cow\":\nconsole.log(\"Moo! Call me \" + animal.name);\nbreak;\n};\n}\n NOTE You should not use switch statements like this in your production code.\nWe use them here for didactic purposes only as a step towards distilling the essence of\npolymorphism.\nDave Another drawback of your approach is that when you want to modify the\nimplementation of greet for a specific animal, you have to change the code\nthat deals with all the animals, while in my approach, you would change only a\nspecific animal class.\nTheo I agree, and I could also fix that by having a separate function for each animal,\nsomething like this.\nListing13.5 Different implementations in different functions\nfunction greetDog(animal) {\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\n}\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am: \" + animal.name);\n}\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\nfunction greet(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\ngreetDog(animal);\nbreak;\ncase \"cat\":\ngreetCat(animal);\nbreak;\ncase \"cow\":\ngreetCow(animal);\n--- Page 305 ---\n13.2 Multimethods with single dispatch 277\nbreak;\n};\n}\nDave But what if you want to extend the functionality of greet and add a new animal?\nTheo Now you got me. I admit that with a switch statement, I can’t add a new animal\nwithout modifying the original code, whereas in OOP, I can add a new class\nwithout having to modify the original code.\nDave Yeah, but you helped me to realize that the main benefit of polymorphism is\nthat it makes the code easily extensible.\nTIP The main benefit of polymorphism is extensibility.\nTheo I’m going to ask Joe if there’s a way to benefit from polymorphism without\nobjects.\nTheo sends a message to Joe and asks him about polymorphism in DOP. Joe answers that\nhe doesn’t have time to get into a deep response because he is in a tech conference where\nhe is about to give a talk about DOP. The only thing he has time to tell Theo is that he\nshould take a look at multimethods.\nTheo and Dave read some online material about multimethods. It doesn’t look too\ncomplicated. They decide that after lunch they will give multimethods a try.\n13.2 Multimethods with single dispatch\nDuring lunch, Theo asks Dave how it feels to have grown up in the country. Dave starts\nwith an enthusiastic description about being in direct contact with nature and living a sim-\npler life than in the city. He’s grateful for the experience, but he admits that country life\ncan sometimes be hard without the conveniences of the city. But who said simple was easy?\nAfter lunch, they decide to have coffee. Dave asks Theo if he’d like to grind the coffee\nbeans himself. Theo accepts with joy. Next, Dave explains how to use a French press coffee\nmaker to get the ideal tradeoff between bitterness and rich taste. While savoring their\nFrench press coffee in the garden, Theo and Dave continue their exploration of polymor-\nphism à la DOP.\nTheo From what I read before lunch, it seems that multimethods are a software con-\nstruct that provide polymorphism without the need for objects.\nDave I don’t get how that’s possible.\nTheo Multimethods have two parts: a dispatch function and a set of methods that\nprovide an implementation for each dispatched value.\nDave I’m not sure I’m clear on that. Is a dispatch function like an interface?\nTheo It’s like an interface in the sense that it defines the way the function needs to\nbe called, but it goes beyond that. It also dispatches a value that differentiates\nbetween the different implementations.\nDave That’s a bit abstract for me.\nTheo I think I understand how to implement the animal greeting capabilities. If we\nuse a multimethod called greet, we need a dispatch function and three\nmethods. Let’s call the dispatch function greetDispatch. It dispatches the\nanimal type, either \"dog\", \"cat\", or \"cow\". Then, each dispatch value is\n--- Page 306 ---\n278 CHAPTER 13 Polymorphism\nhandled by a specific method: \"dog\" by greetDog, \"cat\" by greetCat, and\n\"cow\" by greetCow.\nTheo takes out his notebook and opens it to a blank piece of paper. He draws a diagram\nlike the one in figure 13.1.\n\"dog\" greetDog\nGreet as a dog\ngreetDispatch \"cat\" greetCat\nEmit the animal type Greet as a cat\nanimal\ntype, name \"cow\" greetCow\nGreet as a cow\nFigure 13.1 The logic flow\nof the greet multimethod\nDave Why is there an arrow between animal and the methods, in addition to the\narrows between animal and the dispatch functions?\nTheo Because the arguments of a multimethod are passed to the dispatch function\nand to the methods.\nTIP The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\nDave Arguments plural?... I see only a single argument.\nTheo You’re right. Right now our multimethod only receives a single argument, but\nsoon it will receive several arguments.\nDave I see. Could you show me how to write the code for the greet multimethod?\nTheo For that, we need a library. For instance, in JavaScript, the arrows/multi-\nmethod library provides an implementation of multimethods. Basically, we call\nmulti to create a multimethod called method to add a method.\n NOTE See http://mng.bz/nY9v for examples and documentation about this library.\nDave Where should we start?\nTheo We’ll start with multimethod initialization by creating a dispatch function\ngreetDispatch that defines the signature of the multimethod, validates the\narguments, and emits the type of the animal. Then we’ll pass greetDispatch\nto multi in order to create the greet multimethod. Our dispatch function\nwould then look like this.\nListing13.6 The dispatch function for greet multimethod\nfunction greetDispatch(animal) {\nSignature definition\nif(dev()) {\n--- Page 307 ---\n13.2 Multimethods with single dispatch 279\nif(!ajv.validate(animalSchema, animal)) {\nArgument validation\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nDispatch value\nreturn animal.type;\n}\nMultimethod\ninitialization\nvar greet = multi(greetDispatch);\nTIP A multimethod dispatch function is responsible for three things: it defines the sig-\nnature of the multimethod, it validates the arguments, and it emits a dispatch value.\nDave What’s next?\nTheo Now we need to implement a method for each dispatched value. Let’s start\nwith the method that deals with dogs. We create a greetDog function that\nreceives an animal and then add a dog method to the greet multimethod\nusing the method function from the arrows/multimethod library. The method\nfunction receives two arguments: the dispatched value and a function that cor-\nresponds to the dispatch value.\nListing13.7 Implementation of greet method for dogs\nfunction greetDog(animal) {\nMethod\nconsole.log(\"Woof woof! My name is \" + animal.name);\nimplementation\n}\ngreet = method(\"dog\", greetDog)(greet);\nMethod declaration\nDave Does the method implementation have to be in the same module as the multi-\nmethod initialization?\nTheo No, not at all! Method declarations are decoupled from multimethod initializa-\ntion exactly like class definitions are decoupled from the interface definition.\nThat’s what make multimethods extensible.\nTIP Multimethods provides extensibility by decoupling between multimethod initial-\nization and method implementations.\nDave What about cats and cows?\nTheo We add their method implementations like we did for dogs.\nTheo takes a moment to envision the implementation. Then he codes up two more greet\nmethods for cats and cows.\nListing13.8 Implementation of greet method for cats\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ngreet = method(\"cat\", greetCat)(greet);\n--- Page 308 ---\n280 CHAPTER 13 Polymorphism\nListing13.9 Implementation of greet method for cows\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ngreet = method(\"cow\", greetCow)(greet);\nTIP In the context of multimethods, a method is a function that provides an imple-\nmentation for a dispatch value.\nDave Are the names of dispatch functions and methods important?\nTheo According to what I read, not really, but I like to follow a simple naming con-\nvention: use the name of the multimethod (for example, greet) as a prefix for\nthe dispatch function (for example, greetDispatch) and the methods. Then\nI’d have the Dispatch suffix for the dispatch function and a specific suffix for\neach method (for example, greetDog, greetCat, and greetCow).\nDave How does the multimethod mechanism work under the hood?\nTheo Internally, a multimethod maintains a hash map where the keys are the dis-\npatched values, and the values are the methods. When we add a method, an\nentry is added to the hash map, and when we call the multimethod, we query the\nhash map to find the implementation that corresponds to the dispatched value.\nDave I don’t think you’ve told me yet how to call a multimethod.\nTheo We call it as a regular function. Give me a minute, and I’ll show you an exam-\nple that calls a multimethod.\nListing13.10 Calling a multimethod like a regular function\ngreet(myDog);\n// → \"Woof woof! My name is Fido\"\ngreet(myCat);\n// → \"Meow! I am Milo\"\ngreet(myCow);\n// → \"Moo! Call me Clarabelle\"\nTIP Multimethods are called like regular functions.\nDave You told me earlier that in the dispatch function, we should validate the argu-\nments. Is that mandatory or is it a best practice?\nTheo It’s a best practice.\nDave What happens if the dispatch function doesn’t validate the arguments, and we\npass an invalid argument?\nTheo Like when an animal has no corresponding method?\nDave Exactly!\nTheo In that case, you’ll get an error. For instance, the arrows/multimethods library\nthrows a NoMethodError exception.\nDave That’s annoying. Is there a way to provide a default implementation?\n--- Page 309 ---\n13.3 Multimethods with multiple dispatch 281\nTheo Absolutely! In order to define a default implementation, you pass to method—\nas a single argument—the function that provides the default implementation.\nTheo writes the code and shows it to Dave. Dave then tests Theo’s code and seems satisfied\nwith the result.\nListing13.11 Defining a default implementation\nfunction greetDefault(animal) {\nconsole.log(\"My name is \" + animal.name);\n}\ngreet = method(greetDefault)(greet);\nListing13.12 Calling a multimethod when no method fits the dispatch value\nvar myHorse = {\n\"type\": \"horse\",\n\"name\": \"Horace\"\n};\ngreet(myHorse);\n// → \"My name is Horace\"\nTIP Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\nDave Cool!\n13.3 Multimethods with multiple dispatch\nTheo So far, we’ve mimicked OOP by having the type of the multimethod argument\nas a dispatch value. But if you think again about the flow of a multimethod,\nyou’ll discover something interesting. Would you like to try and draw a dia-\ngram that describes the flow of a multimethod in general?\nDave Let me get a fresh napkin. The one under my glass is a bit wet.\nTheo Uh, Dave, you can use my notebook.\nIt takes Dave a few minutes to draw a diagram like the one in figure 13.2. He pushes the\nnotebook back to Theo.\nValue1 Method1\nHandle case 1\nDispatch function Value3 Method3\nEmit a dispatch value Handle case 3\nargs\nValue2 Method2\nHandle case 2\nFigure 13.2 The logic flow\nof multimethods\n--- Page 310 ---\n282 CHAPTER 13 Polymorphism\nTheo Excellent! I hope you see that the dispatch function can emit any value.\nDave Like what?\nTheo Like emitting the type of two arguments!\nDave What do you mean?\nTheo Imagine that our animals are polyglot.\nDave Poly what?\nTheo Polyglot comes from the Greek polús, meaning much, and from glôssa, meaning\nlanguage. A polyglot is a person who can speak many languages.\nDave What languages would our animals speak?\nTheo I don’t know. Let’s say English and French.\nDave OK, and how would we represent a language in our program?\nTheo With a map, of course!\nDave What fields would we have in a language map?\nTheo Let’s keep things simple and have two fields: type and name.\nDave Like an animal map?\nTheo Not exactly. In a language map, the type field must be either fr for French or en\nfor English, whereas in the animal map, the type field is either dog, cat, or cow.\nDave Let me try to write the language map schema and the two language maps.\nTheo gladly consents; his French press coffee is getting cold! Dave writes his implementa-\ntion of the code and shows Theo.\nListing13.13 The schema of a language map\nvar languageSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nListing13.14 Two language maps\nvar french = {\n\"type\": \"fr\",\n\"name\": \"Français\"\n};\nvar english = {\n\"type\": \"en\",\n\"name\": \"English\"\n};\nTheo Excellent! Now, let’s write the code for the dispatch function and the methods\nfor our polyglot animals. Let’s call our multimethod, greetLang. We have one\ndispatch function and six methods.\n--- Page 311 ---\n13.3 Multimethods with multiple dispatch 283\nDave Right, three animals (dog, cat, and cow) times two languages (en and fr).\nBefore the implementation, I’d like to draw a flow diagram. It will help me to\nmake things crystal clear.\nTheo You need my notebook again?\nNot waiting for Dave to respond, Theo pushes his notebook across the table to Dave. Dave\ndraws a diagram like the one in figure 13.3 and slides the notebook back to Theo.\n[\"dog\", \"en\"] greetLangDogEn\nGreet as a dog in English\n[\"cat\", \"en\"] greetLangCatEn\nGreet as a cat in English\n[\"cow\", \"en\"] greetLangCowEn\nGreet as a cow in English\nargs greetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", \"fr\"] greetLangDogFr\nGreet as a dog in French\n[\"cat\", \"fr\"] greetLangCatFr\nGreet as a cat in French\n[\"cow\", \"fr\"] greetLangCowFr\nGreet as a cow in French\nFigure 13.3 The logic flow of the greetLang multimethod\nTheo Why did you omit the arrow between the arguments and the methods?\nDave In order to keep the diagram readable. Otherwise, there would be too many\narrows.\nTheo OK, I see. Are you ready for coding?\nDave Yes!\nTheo The dispatch function needs to validate its arguments and return an array with\ntwo elements: the type of animal and the type of language.\nDave types for a bit on his laptop. He initializes the multimethod with a dispatch function\nthat returns the type of its arguments and then shows the code to Theo.\nListing13.15 Initializing a multimethod with a dispatch function\nvar greetLangArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [animalSchema, languageSchema]\n};\nfunction greetLangDispatch(animal, language) {\nif(dev()) {\n--- Page 312 ---\n284 CHAPTER 13 Polymorphism\nif(!ajv.validate(greetLangArgsSchema, [animal, language])) {\nthrow (\"greetLang called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [animal.type, language.type];\n};\nvar greetLang = multi(greetLangDispatch);\nDave Does the order of the elements in the array matter?\nTheo It doesn’t matter, but it needs to be consistent with the wiring of the methods.\nThe implementation of greetLang would therefore look like this.\nListing13.16 The implementation of greetLang methods\nfunction greetLangDogEn(animal, language) {\nconsole.log(\"Woof woof! My name is \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"en\"], greetLangDogEn)(greetLang);\nfunction greetLangDogFr(animal, language) {\nconsole.log(\"Ouaf Ouaf! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"fr\"], greetLangDogFr)(greetLang);\nfunction greetLangCatEn(animal, language) {\nconsole.log(\"Meow! I am \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"en\"], greetLangCatEn)(greetLang);\nfunction greetLangCatFr(animal, language) {\nconsole.log(\"Miaou! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"fr\"], greetLangCatFr)(greetLang);\nfunction greetLangCowEn(animal, language) {\nconsole.log(\"Moo! Call me \" +\nanimal.name +\n\" and I speak \" +\n--- Page 313 ---\n13.3 Multimethods with multiple dispatch 285\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"en\"], greetLangCowEn)(greetLang);\nfunction greetLangCowFr(animal, language) {\nconsole.log(\"Meuh! Appelle moi \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"fr\"], greetLangCowFr)(greetLang);\nDave looks at the code for the methods that deal with French. He is surprised to see Ouaf\nOuaf instead of Woof Woof for dogs, Miaou instead of Meow for cats, and Meuh instead of\nMoo for cows.\nDave I didn’t know that animal onomatopoeia were different in French than in\nEnglish!\nTheo Ono what?\nDave Onomatopoeia, from the Greek ónoma that means name and poiéo– that means to\nproduce. It is the property of words that sound like what they represent; for\ninstance, Woof, Meow, and Moo.\nTheo Yeah, for some reason in French, dogs Ouaf, cats Miaou, and cows Meuh.\nDave I see that in the array the animal type is always before the language type.\nTheo Right! As I told you before, in a multimethod that features multiple dispatch,\nthe order doesn’t really matter, but it has to be consistent.\nTIP Multiple dispatch is when a dispatch function emits a value that depends on more\nthan one argument. In a multimethod that features multiple dispatch, the order of\nthe elements in the array emitted by the dispatch function has to be consistent with\nthe order of the elements in the wiring of the methods.\nDave Now let me see if I can figure out how to use a multimethod that features mul-\ntiple dispatch.\nDave remembers that Theo told him earlier that multimethods are used like regular func-\ntions. With that in mind, he comes up with the code for a multimethod that features multi-\nple dispatch.\nListing13.17 Calling a multimethod that features multiple dispatch\ngreetLang(myDog, french);\n// → \"Ouaf Ouaf! Je m\\'appelle Fido et je parle Français\"\ngreetLang(myDog, english);\n// → \"Woof woof! My name is Fido and I speak English\"\ngreetLang(myCat, french);\n// → \"Miaou! Je m\\'appelle Milo et je parle Français\"\n--- Page 314 ---\n286 CHAPTER 13 Polymorphism\ngreetLang(myCat, english);\n// → \"Meow! I am Milo and I speak English\"\ngreetLang(myCow, french);\n// → \"Meuh! Appelle moi Clarabelle et je parle Français\"\ngreetLang(myCow, english);\n// → \"Moo! Call me Clarabelle and I speak English\"\nTheo Now do you agree that multimethods with multiple dispatch offer a more pow-\nerful polymorphism that OOP polymorphism?\nDave Indeed, I do.\nTheo Let me show you an even more powerful polymorphism called dynamic dis-\npatch. But first, let’s get some more of that wonderful French press coffee.\nDave Great idea! While we’re in the kitchen, I think my mom made an orange Bundt\ncake using the oranges from the grove.\n13.4 Multimethods with dynamic dispatch\nDave refills their coffee cups as Theo takes two slices from the cake and dishes them up.\nThey take their coffee and cake outside to enjoy more of the fresh country air before\nresuming their conversation.\nDave What is dynamic dispatch?\nTheo It’s when the dispatch function of a multimethod returns a value that goes\nbeyond the static type of its arguments.\nDave Like what, for example?\nTheo Like a number or a Boolean, for instance.\nDave Why would such a thing be useful?\nTheo Imagine that instead of being polyglot, our animals would suffer from\ndysmakrylexia.\nDave Suffering from what?\nTheo Dysmakrylexia. It comes from the Greek dus, expressing the idea of difficulty,\nmakrýs meaning long, and léxis meaning diction. Therefore, dysmakrylexia is dif-\nficulty pronouncing long words.\nDave I’ve never heard of that.\nTheo That’s because I just invented it.\nDave Funny. What’s considered a long word for our animals?\nTheo Let’s say that when their name has more than five letters, they’re not able to\nsay it.\nDave A bit weird, but OK.\nTheo Let’s call our multimethod dysGreet. Its dispatch function returns an array\nwith two elements: the animal type and a Boolean about whether the name is\nlong or not. Take a look at this multimethod initialization.\n--- Page 315 ---\n13.4 Multimethods with dynamic dispatch 287\nListing13.18 A multimethod using a dispatch function with dynamic dispatch\nfunction dysGreetDispatch(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"dysGreet called with invalid arguments: \" + errors);\n}\n}\nvar hasLongName = animal.name.length > 5;\nreturn [animal.type, hasLongName];\n};\nvar dysGreet = multi(dysGreetDispatch);\nDave Writing the dysGreet methods doesn’t seem too complicated.\nAs Theo reaches over to pass Dave his notebook, he accidently hits his coffee cup. Now Theo’s\nnotebook is completely wet, and all the diagrams are soggy! Fortunately, Dave brought an\nextra napkin from the kitchen, and it’s still clean. He draws a flow diagram as in figure 13.4\nand then grabs his laptop and writes the implementation of the dysGreet methods.\n[\"dog\", true] dysGreetDogLong\nGreet as a dog mentioning name\n[\"cat\", true] dysGreetCatLong\nGreet as a cat mentioning name\n[\"cow\", true] dysGreetCowLong\nGreet as a cow mentioning name\nargs dysGreetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", false] dysGreetDogShort\nGreet as a dog omitting name\n[\"cat\", false] dysGreetCatShort\nGreet as a cat omitting name\n[\"cow\", false] dysGreetCowShort\nGreet as a cow omitting name\nFigure 13.4 The logic flow of the dysGreet multimethod\nListing13.19 The dysGreet methods\nfunction dysGreetDogLong(animal) {\nconsole.log(\"Woof woof! My name is \" + animal.name);\n}\ndysGreet = method([\"dog\", true], dysGreetDogLong)(dysGreet);\n--- Page 316 ---\n288 CHAPTER 13 Polymorphism\nfunction dysGreetDogShort(animal) {\nconsole.log(\"Woof woof!\");\n}\ndysGreet = method([\"dog\", false], dysGreetDogShort)(dysGreet);\nfunction dysGreetCatLong(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ndysGreet = method([\"cat\", true], dysGreetCatLong)(dysGreet);\nfunction dysGreetCatShort(animal) {\nconsole.log(\"Meow!\");\n}\ndysGreet = method([\"cat\", false], dysGreetCatShort)(dysGreet);\nfunction dysGreetCowLong(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ndysGreet = method([\"cow\", true], dysGreetCowLong)(dysGreet);\nfunction dysGreetCowShort(animal) {\nconsole.log(\"Moo!\");\n}\ndysGreet = method([\"cow\", false], dysGreetCowShort)(dysGreet);\nTheo checks that the code works as expected. He compliments Dave, not only on the\nmethod implementation but also for having the foresight to grab an extra napkin.\nListing13.20 Testing dysGreet\ndysGreet(myDog);\ndysGreet(myCow);\ndysGreet(myCat);\n//\"Woof woof!\"\n//\"Moo! Call me Clarabelle\"\n//\"Meow!\"\nTheo Well done, my friend! Our exploration of multimethods has come to an end. I\nthink it’s time for me to drive back if I want to get home before dark and beat\nthe rush hour traffic.\nDave Before you leave, let’s check if multimethods are available in programming\nlanguages other than JavaScript.\nTheo That’s a question for Joe.\nDave Do you think it’s OK if I call him now?\nTheo I think it’s probably better if you send him an email. He’s in a tech conference,\nand I’m not sure if it’s all day. Thank you for this beautiful day in the country\nand the wonderful refreshments.\nDave I enjoyed it, also, especially our discussions about etymology. I think there are\nsome oranges for you to take home and enjoy later.\nTheo Great! I can’t wait until my wife tries one.\n--- Page 317 ---\n13.5 Integrating multimethods in a production system 289\nAfter Theo leaves, Dave sends Joe an email. A few minutes later, Dave receives an email\nfrom Joe with the subject, “Support for multimethods in different languages.”\nSupport for multimethods in different languages\nPython has a library called multimethods (https://github.com/weissjeffm/multimeth-\nods), and Ruby has one called Ruby multimethods (https://github.com/psantacl/\nruby-multimethods). Both seem to work quite like the JavaScript arrows/multi-\nmethod library.\nIn Java, there is the Java Multimethod Framework (http://igm.univ-mlv.fr/~forax/\nworks/jmmf/), and C# supports multimethods natively via the dynamic keyword.\nHowever, in both Java and C#, multimethods work only with static data types and not\nwith generic data structures.\nGeneric data structure\nLanguage URL\nsupport\nJavaScript https://github.com/caderek/arrows/tree/master/ Yes\npackages/multimethod\nJava http://igm.univ-mlv.fr/~forax/works/jmmf/ No\nC# Native support No\nPython https://github.com/weissjeffm/multimethods Yes\nRuby https://github.com/psantacl/ruby-multimethods Yes\n13.5 Integrating multimethods in a production system\nWhile Theo is driving back home, his thoughts take him back to the fresh air of the coun-\ntry. This pleasant moment is interrupted by a phone call from Nancy at Klafim.\nNancy How are you doing?\nTheo Fine. I’m driving back from the countryside.\nNancy Cool. Are you available to talk about work?\nTheo Sure.\nNancy I’d like to add a tiny feature to the catalog.\nIn the past, when Nancy qualified a feature as tiny, it scared Theo because tiny turned into\nhuge. What seemed easy to her always took him a surprising amount of time to develop.\nBut after refactoring the system according to DOP principles, now what seems tiny to\nNancy is usually quite easy to implement.\nTheo What feature?\nNancy I’d like to allow librarians to view the list of authors, ordered by last name, in\ntwo formats: HTML and Markdown.\n--- Page 318 ---\n290 CHAPTER 13 Polymorphism\nTheo It doesn’t sound too complicated.\nNancy Also, I need a bit of text formatting.\nTheo What kind of text formatting?\nNancy Depending on the number of books an author has written, their name should\nbe in bold and italic fonts.\nTheo Could you send me an email with all the details. I’ll take a look at it tomorrow\nmorning.\nNancy Perfect. Have a safe drive!\nBefore going to bed, Theo reflects about today’s etymology lessons. He realizes that he\nnever looked for the etymology of the word etymology itself! He searches for the term etymol-\nogy online and learns that the word etymology derives from the Greek étumon, meaning true\nsense, and the suffix logia, denoting the study of. During the night, Theo dreams of dogs,\ncats, and cows programming on their laptops in a field of grass.\nWhen Theo arrives at the office the next day, he opens Nancy’s email with the details\nabout the text formatting feature. The details are summarized in table 13.1.\nTable 13.1 Text formatting for author names according to the number of books\nthey have written\nNumber of books Italic Bold\n10 or fewer Yes No\nBetween 11 and 50 No Yes\n51 or more Yes Yes\nTheo forwards Nancy’s email to Dave and asks him to take care of this task. Delegating\nresponsibility, after all, is the trait of a great manager.\nDave thinks the most difficult part of the feature lies in implementing an Author\n.myName(author, format) function that receives two arguments: the author data and the\ntext format. He asks himself whether he can implement this function as a multimethod\nand use what he learned yesterday with Theo at his parents’ home in the country. It seems\nthat this feature is quite similar to the one that dealt with dysmakrylexia. Instead of check-\ning the length of a string, he needs to check the length of an array.\nFirst, Dave needs a data schema for the text format. He could represent a format as a\nmap with a type field like Theo did yesterday for languages, but at the moment, it seems\nsimpler to represent a format as a string that could be either markdown or html. He comes\nup with the text format schema in listing 13.21. He already wrote the author schema with\nTheo last week. It’s in listing 13.22.\nListing13.21 The text format schema\nvar textFormatSchema = {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"enum\": [\"markdown\", \"html\"]}\n};\n--- Page 319 ---\n13.5 Integrating multimethods in a production system 291\nListing13.22 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"name\", \"bookIsbns\"],\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nNow, Dave needs to write a dispatch function and initialize the multimethod. Remember-\ning that Theo had no qualms about creating the word dysmakrylexia, he decides that he\nprefers his own neologism, prolificity, over the existing nominal form prolificness. He finds it\nuseful to have an Author.prolificityLevel helper function that returns the level of\nprolificity of the author: either low, medium, or high. Now he’s ready to code the author-\nNameDispatch function.\nListing13.23 Author.myName multimethod initialization\nAuthor.prolificityLevel = function(author) {\nvar books = _.size(_.get(author, \"bookIsbns\"));\nif (books <= 10) {\nreturn \"low\";\n};\nif (books >= 51) {\nreturn \"high\";\n}\nreturn \"medium\";\n};\nvar authorNameArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\nauthorSchema,\n{\"enum\": [\"markdown\", \"html\"]}\n]\n};\nfunction authorNameDispatch(author, format) {\nif(dev()) {\nif(!ajv.validate(authorNameArgsSchema, [author, format])) {\nthrow (\"Author.myName called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [Author.prolificityLevel(author), format];\n};\nAuthor.myName = multi(authorNameDispatch);\n--- Page 320 ---\n292 CHAPTER 13 Polymorphism\nThen Dave works on the methods: first, the HTML format methods. In HTML, bold text is\nwrapped inside a <b> tag, and italic text is wrapped in a <i> tag. For instance, in HTML,\nthree authors with different levels of prolificity would be written like this.\nListing13.24 Examples of bold and italic in HTML\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n<i>Yehonathan Sharvit<i>\nBold and italic formatting\n<b>Stephen Covey</b>\nfor highly prolific authors\n<b><i>Isaac Asimov</i></b>\nWith this information in hand, Dave writes the three methods that deal with HTML for-\nmatting. Easy!\nListing13.25 The methods that deal with HTML formatting\nfunction authorNameLowHtml(author, format) {\nreturn \"<i>\" + _.get(author, \"name\") + \"</i>\";\n}\nAuthor.myName = method([\"low\", \"html\"], authorNameLowHtml)(Author.myName);\nfunction authorNameMediumHtml(author, format) {\nreturn \"<b>\" + _.get(author, \"name\") + \"</b>\";\n}\nAuthor.myName =\nmethod([\"medium\", \"html\"], authorNameMediumHtml)(Author.myName);\nfunction authorNameHighHtml(author, format) {\nreturn \"<b><i>\" + _.get(author, \"name\") + \"</i></b>\";\n}\nAuthor.myName =\nmethod([\"high\", \"html\"], authorNameHighHtml)(Author.myName);\nThen, Dave moves on to the three methods that deal with Markdown formatting. In\nMarkdown, bold text is wrapped in two asterisks, and italic text is wrapped in a single\nasterisk. For instance, in Markdown, three authors with different levels of prolificity\nwould be written like the code in listing 13.26. The code for the Markdown methods is in\nlisting 13.27.\nListing13.26 Examples of bold and italic in Markdown\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n*Yehonathan Sharvit*\nBold and italic formatting\n**Stephen Covey**\nfor highly prolific authors\n***Isaac Asimov***\n--- Page 321 ---\n13.5 Integrating multimethods in a production system 293\nListing13.27 The methods that deal with Markdown formatting\nfunction authorNameLowMarkdown(author, format) {\nreturn \"*\" + _.get(author, \"name\") + \"*\";\n}\nAuthor.myName =\nmethod([\"low\", \"markdown\"], authorNameLowMarkdown)(Author.myName);\nfunction authorNameMediumMarkdown(author, format) {\nreturn \"**\" + _.get(author, \"name\") + \"**\";\n}\nAuthor.myName =\nmethod([\"medium\", \"markdown\"], authorNameMediumMarkdown)(Author.myName);\nfunction authorNameHighMarkdown(author, format) {\nreturn \"***\" + _.get(author, \"name\") + \"***\";\n}\nAuthor.myName =\nmethod([\"high\", \"markdown\"], authorNameHighMarkdown)(Author.myName);\nDave decides to test his code by involving a mysterious author. Listing 13.28 and listing 13.29\nshow the tests.\nListing13.28 Testing HTML formatting\nvar yehonathan = {\n\"name\": \"Yehonathan Sharvit\",\n\"bookIsbns\": [\"9781617298578\"]\n};\nAuthor.myName(yehonathan, \"html\");\n// → \"<i>Yehonathan Sharvit</i>\"\nListing13.29 Testing Markdown formatting\nAuthor.myName(yehonathan, \"markdown\");\n// → \"*Yehonathan Sharvit*\"\nTheo shows up at Dave’s desk and asks to review Dave’s implementation of the list of\nauthors feature. Curious, Theo asks Dave about the author that appears in the test of\nAuthor.myName.\nTheo Who is Yehonathan Sharvit?\nDave I don’t really know. The name appeared when I googled “data-oriented pro-\ngramming” yesterday. He wrote a book on the topic. I thought it would be cool\nto use its ISBN in my test.\n--- Page 322 ---\n294 CHAPTER 13 Polymorphism\nSummary\n The main benefit of polymorphism is extensibility.\n Multimethods make it possible to benefit from polymorphism when data is repre-\nsented with generic maps.\n A multimethod is made of a dispatch function and multiple methods.\n The dispatch function of a multimethod emits a dispatch value.\n Each of the methods used in a multimethod provides an implementation for a\nspecific dispatch value.\n Multimethods can mimic OOP class inheritance via single dispatch.\n In single dispatch, a multimethod receives a single map that contains a type field,\nand the dispatch function of the multimethod emits the value of the type field.\n In addition to single dispatch, multimethods provide two kinds of advanced\npolymorphisms: multiple dispatch and dynamic dispatch.\n Multiple dispatch is used when the behavior of the multimethod depends on\nmultiple arguments.\n Dynamic dispatch is used when the behavior of the multimethod depends on run-\ntime arguments.\n The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\n A multimethod dispatch function is responsible for\n– Defining the signature.\n– Validating the arguments.\n– Emitting a dispatch value.\n Multimethods provides extensibility by decoupling between multimethod ini-\ntialization and method implementations.\n Multimethods are called like regular functions.\n Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\n In a multimethod that features multiple dispatch, the order of the elements in\nthe array emitted by the dispatch function has to be consistent with the order of\nthe elements in the wiring of the methods.\nLodash functions introduced in this chapter\nFunction Description\nsize(coll) Gets the size of coll\n--- Page 323 ---\nAdvanced data\nmanipulation\nWhatever is well-conceived\nis clearly said\nThis chapter covers\n Manipulating nested data\n Writing clear and concise code for business\nlogic\n Separating business logic and generic data\nmanipulation\n Building custom data manipulation tools\n Using the best tool for the job\nWhen our business logic involves advanced data processing, the generic data manip-\nulation functions provided by the language run time and by third-party libraries\nmight not be sufficient. Instead of mixing the details of data manipulation with\nbusiness logic, we can write our own generic data manipulation functions and imple-\nment our custom business logic using them. Separating business logic from the inter-\nnal details of data manipulation makes the business logic code concise and easy to\nread for other developers.\n295\n--- Page 324 ---\n296 CHAPTER 14 Advanced data manipulation\n14.1 Updating a value in a map with eloquence\nDave is more and more autonomous on the Klafim project. He can implement most fea-\ntures on his own, typically turning to Theo only for code reviews. Dave’s code quality stan-\ndards are quite high. Even when his code is functionally solid, he tends to be unsatisfied\nwith its readability. Today, he asks for Theo’s help in improving the readability of the code\nthat fixes a bug Theo introduced a long time ago.\nDave I think I have a found a bug in the code that returns book information from\nthe Open Library API.\nTheo What bug?\nDave Sometimes, the API returns duplicate author names, and we pass the dupli-\ncates through to the client.\nTheo It doesn’t sound like a complicated bug to fix.\nDave Right, I fixed it, but I’m not satisfied with the readability of the code I wrote.\nTheo Being critical of our own code is an important quality for a developer to prog-\nress. What is it exactly that you don’t like?\nDave Take a look at this code.\nListing14.1 Removing duplicates in a straightforward but tedious way\nfunction removeAuthorDuplicates(book) {\nvar authors = _.get(book, \"authors\");\nvar uniqAuthors = _.uniq(authors);\nreturn _.set(book,\"authors\", uniqAuthors);\n}\nDave I’m using _.get to retrieve the array with the author names, then _.uniq to\ncreate a duplicate-free version of the array, and finally, _.set to create a new\nversion of the book with no duplicate author names.\nTheo The code is tedious because the next value of authorNames needs to be based\non its current value.\nDave But it’s a common use case! Isn’t there a simpler way to write this kind of code?\nTheo Your astonishment definitely honors you as a developer, Dave. I agree with you\nthat there must be a simpler way. Let me phone Joe and see if he’s available for\na conference call.\nJoe How’s it going, Theo?\nTheo Great! Are you back from your tech conference?\nJoe I just landed. I’m on my way home now in a taxi.\nTheo How was your talk about DOP?\nJoe Pretty good. At the beginning people were a bit suspicious, but when I told\nthem the story of Albatross and Klafim, it was quite convincing.\nTheo Yeah, adults are like children in that way; they love stories.\nJoe What about you? Did you manage to achieve polymorphism with multimethods?\nTheo Yes! Dave even managed to implement a feature in Klafim with multimethods.\nJoe Cool!\n--- Page 325 ---\n14.1 Updating a value in a map with eloquence 297\nTheo Do you have time to help Dave with a question about programming?\nJoe Sure.\nDave Hi Joe. How are you doing?\nJoe Hello Dave. Not bad. What kind of help do you need?\nDave I’m wondering if there’s a simpler way to remove duplicates inside an array\nvalue in a map. Using _.get, _.uniq, and _.set looks quite tedious.\nJoe You should build your own data manipulation tools.\nDave What do you mean?\nJoe You should write a generic update function that updates a value in a map,\napplying a calculation based on its current value.1\nDave What would the arguments of update be in your opinion?\nJoe Put the cart before the horse.\nDave What?!\nJoe Rewrite your business logic as if update were already implemented, and you’ll\ndiscover what the arguments of update should be.\nDave I see what you mean: the horse is the implementation of update, and the cart is\nthe usage of update.\nJoe Exactly. But remember, it’s better if you keep your update function generic.\nDave How?\nJoe By not limiting it to your specific use case.\nDave I see. The implementation of update should not deal with removing duplicate\nelements. Instead, it should receive the updating function—in my case,\n_.uniq—as an argument.\nJoe Exactly! Uh, sorry Dave, I gotta go, I just got home. Good luck!\nDave Take care, Joe, and thanks!\nDave ends the conference call. Looking at Theo, he reiterates the conversation with Joe.\nDave Joe advised me to write my own update function. For that purpose, he told me\nto start by rewriting removeAuthorDuplicates as if update were already\nimplemented. That will allow us to make sure we get the signature of update\nright.\nTheo Sounds like a plan.\nDave Joe called it “putting the cart before the horse.”\nTheo Joe and his funny analogies...\nTIP The best way to find the signature of a custom data manipulation function is to\nthink about the most convenient way to use it.\nDave Anyway, the way I’d like to use update inside removeAuthorDuplicates is\nlike this.\n1 Lodash provides an implementation of update, but for the sake of teaching, we are writing our own imple-\nmentation.\n--- Page 326 ---\n298 CHAPTER 14 Advanced data manipulation\nListing14.2 The code that removes duplicates in an elegant way\nfunction removeAuthorDuplicates(book) {\nreturn update(book, \"authors\", _.uniq);\n}\nTheo Looks good to me!\nDave Wow! Now the code with update is much more elegant than the code with\n_.get and _.set!\nTheo Before you implement update, I suggest that you write down in plain English\nexactly what the function does.\nDave It’s quite easy: update receives a map called map, a path called path, and a\nfunction called fun. It returns a new version of map, where path is associated\nwith fun(currentValue), and currentValue is the value associated with\npath in map.\nThinking out loud, Dave simultaneously draws a diagram like that in figure 14.1. Theo is\nbecoming more and more impressed with his young protegé as he studies the figure.\n{\n\"position\" : \"manager\", \"income\"\n\"income\" : 100000\n} map fun path\nupdate\n{\n\"position\" : \"manager\",\n\"income\" : fun(100000)\nres Figure 14.1 The\n}\nbehavior of update\nTIP Before implementing a custom data manipulation function, formulate in plain\nEnglish exactly what the function does.\nTheo With such a clear definition, it’s going to be a piece of cake to implement\nupdate!\nAfter a few minutes, Dave comes up with the code. It doesn’t take long because the plain-\nEnglish diagram helps him to organize the code.\nListing14.3 A generic update function\nfunction update(map, path, fun) {\nvar currentValue = _.get(map, path);\nvar nextValue = fun(currentValue);\nreturn _.set(map, path, nextValue);\n}\n--- Page 327 ---\n14.2 Manipulating nested data 299\nTheo Why don’t you see if it works with a simple case such as incrementing a number\nin a map?\nDave Good idea! I’ll try multiplying a value in a map by 2 with update. How’s this\nlook?\nListing14.4 Multiplying a value in a map by 2\nvar m = {\n\"position\": \"manager\",\n\"income\": 100000\n};\nupdate(m, \"income\", function(x) {\nreturn x * 2;\n});\n// → {\"position\": \"manager\", \"income\": 200000}\nTheo Great! It seems to work.\n14.2 Manipulating nested data\nThe next Monday, during Theo and Dave’s weekly sync meeting, they discuss the upcom-\ning features for Klafim. Theo fondly remembers another Monday where they met at Dave’s\nfamily home in the country. Coming back to the present moment, Theo begins.\nTheo Recently, Nancy has been asking for more and more administrative features.\nDave Like what?\nTheo I’ll give you a few examples.... Let me find the email I got from Nancy yesterday.\nDave OK.\nTheo Here it is. There are three feature requests for now: listing all the book author\nIDs, calculating the book lending ratio, and grouping books by a physical library.\nDave What feature should I tackle first?\nTheo It doesn’t matter, but you should deliver the three of these before the end of\nthe week. Good luck, and don’t hesitate to call me if you need help.\nOn Tuesday, Dave asks for Theo’s help. Dave is not pleased with how his code looks.\nDave I started to work on the three admin features, but I don’t like the code I wrote.\nLet me show you the code for retrieving the list of author IDs from the list of\nbooks returned from the database.\nTheo Can you remind me what an element in a book list returned from the database\nlooks like?\nDave Each book is a map with an authorIds array field.\nTheo OK, so it sounds like a map over the books should do it.\nDave This is what I did, but it doesn’t work as expected. Here’s my code for listing\nthe book author IDs.\n--- Page 328 ---\n300 CHAPTER 14 Advanced data manipulation\nListing14.5 Retrieving the author IDs in books as an array of arrays\nfunction authorIdsInBooks(books) {\nreturn _.map(books, \"authorIds\");\n}\nTheo What’s the problem?\nDave The problem is that it returns an array of arrays of author IDs instead of an\narray of author IDs. For instance, when I run authorIdsInBooks on a catalog\nwith two books, I get this result.\nListing14.6 The author IDs in an array of arrays\n[\n[\"sean-covey\", \"stephen-covey\"],\n[\"alan-moore\", \"dave-gibbons\"]\n]\nTheo That’s not a big problem. You can flatten an array of arrays with _.flatten,\nand you should get the result you expect.\nDave Nice! This is exactly what I need! Give me a moment to fix the code of\nauthorIdsInBooks. . . here you go.\nListing14.7 Retrieving the author IDs in books as an array of strings\nfunction authorIdsInBooks(books) {\nreturn _.flatten(_.map(books, \"authorIds\"));\n}\nTheo Don’t you think that mapping and then flattening deserves a function of its own?\nDave Maybe. It’s quite easy to implement a flatMap function.2 How about this?\nListing14.8 The implementation of flatMap\nfunction flatMap(coll, f) {\nreturn _.flatten(_.map(coll,f));\n}\nTheo Nice!\nDave I don’t know.... It’s kind of weird to have such a small function.\nTheo I don’t think that code size is what matters here.\nDave What do you mean?\nTheo See what happens when you rewrite authorIdsInBooks using flatMap.\nDave OK, here’s how I’d use flatMap to list the author IDs.\n2 Lodash provides an implementation of flatMap, but for the sake of teaching, we are writing our own\nimplementation.\n--- Page 329 ---\n14.3 Using the best tool for the job 301\nListing14.9 Retrieving the author IDs as an array of strings using flatMap\nfunction authorIdsInBooks(books) {\nreturn flatMap(books, \"authorIds\");\n}\nTheo What implementation do you prefer, the one with flatten and map (in listing\n14.7) or the one with flatMap (in listing 14.9)?\nDave I don’t know. To me, they look quite similar.\nTheo Right, but which implementation is more readable?\nDave Well, assuming I know what flatMap does, I would say the implementation\nwith flatMap. Because it’s more concise, it is a bit more readable.\nTheo Again, it’s not about the size of the code. It’s about the clarity of intent and the\npower of naming things.\nDave I don’t get that.\nTheo Let me give you an example from our day-to-day language.\nDave OK.\nTheo Could you pass me that thing on your desk that’s used for writing?\nIt takes Dave a few seconds to get that Theo has asked him to pass the pen on the desk.\nAfter he passes Theo the pen, he asks:\nDave Why didn’t you simply ask for the pen?\nTheo I wanted you to experience how it feels when we use descriptions instead of\nnames to convey our intent.\nDave Oh, I see. You mean that once we use a name for the operation that maps and\nflattens, the code becomes clearer.\nTheo Exactly.\nDave Let’s move on to the second admin feature: calculating the book lending ratio.\nTheo Before that, I think we deserve a short period for rest and refreshments, where\nwe drink a beverage made by percolation from roasted and ground seeds.\nDave A coffee break!\n14.3 Using the best tool for the job\nAfter the coffee break, Dave shows Theo his implementation of the book lending ratio cal-\nculation. This time, he seems to like the code he wrote.\nDave I’m quite proud of the code I wrote to calculate the book lending ratio.\nTheo Show me the money!\nDave My function receives a list of books from the database like this.\nListing14.10 A list of two books with bookItems\n[\n{\n\"isbn\": \"978-1779501127\",\n--- Page 330 ---\n302 CHAPTER 14 Advanced data manipulation\n\"title\": \"Watchmen\",\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n}\n]\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"bookItems\": [\n{\n\"id\": \"book-item-123\",\n\"libId\": \"hudson-park-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-17\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n]\nTheo Quite a nested piece of data!\nDave Yeah, but now that I’m using flatMap, calculating the lending ratio is quite\neasy. I’m going over all the book items with forEach and incrementing either\nthe lent or the notLent counter. At the end, I return the ratio between lent\nand (lent + notLent). Here’s how I do that.\nListing14.11 Calculating the book lending ratio using forEach\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar lent = 0;\nvar notLent = 0;\n_.forEach(bookItems, function(item) {\nif(_.get(item, \"isLent\")) {\nlent = lent + 1;\n} else {\nnotLent = notLent + 1;\n}\n});\nreturn lent/(lent + notLent);\n}\nTheo Would you allow me to tell you frankly what I think of your code?\nDave If you are asking this question, it means that you don’t like it. Right?\nTheo It’s nothing against you; I don’t like any piece of code with forEach.\n--- Page 331 ---\n14.3 Using the best tool for the job 303\nDave What’s wrong with forEach?\nTheo It’s too generic!\nDave I thought that genericity was a positive thing in programming.\nTheo It is when we build a utility function, but when we use a utility function, we\nshould use the least generic function that solves our problem.\nDave Why?\nTheo Because we ought to choose the right tool for the job, like in the real life.\nDave What do you mean?\nTheo Let me give you an example. Yesterday, I had to clean my drone from the\ninside. Do you think that I used a screwdriver or a Swiss army knife to unscrew\nthe drone cover?\nDave A screwdriver, of course! It’s much more convenient to manipulate.\nTheo Right. Also, imagine that someone looks at me using a screwdriver. It’s quite\nclear to them that I am turning a screw. It conveys my intent clearly.\nDave Are you saying that forEach is like the Swiss army knife of data manipulation?\nTheo That’s a good way to put it.\nTIP Pick the least generic utility function that solves your problem.\nDave What function should I use then, to iterate over the book item collection?\nTheo You could use _.reduce.\nDave I thought reduce was about returning data from a collection. Here, I don’t\nneed to return data; I need to update two variables, lent and notLent.\nTheo You could represent those two values in a map with two keys.\nDave Can you show me how to rewrite my lendingRatio function using reduce?\nTheo Sure. The initial value passed to reduce is the map, {\"lent\": 0, \"notLent\": 0},\nand inside each iteration, we update one of the two keys, like this.\nListing14.12 Calculating the book lending ratio using reduce\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = _.reduce(bookItems, function(res, item) {\nif(_.get(item, \"isLent\")) {\nres.lent = res.lent + 1;\n} else {\nres.notLent = res.notLent + 1;\n}\nreturn res;\n}, {notLent: 0, lent:0});\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nDave Instead of updating the variables lent and notLent, now we are updating lent\nand notLent map fields. What’s the difference?\n--- Page 332 ---\n304 CHAPTER 14 Advanced data manipulation\nTheo Dealing with map fields instead of variables allows us to get rid of reduce in\nour business logic code.\nDave How could you iterate over a collection without forEach and without reduce?\nTheo I can’t avoid the iteration over a collection, but I can hide reduce behind a\nutility function. Take a look at the way reduce is used inside the code of\nlendingRatio. What is the meaning of the reduce call?\nDave looks at the code in listing 14.12. He thinks for a long moment before he answers.\nDave I think it’s counting the number of times isLent is true and false.\nTheo Right. Now, let’s use Joe’s advice about building our own data manipulation\ntool.\nDave How exactly?\nTheo I suggest that you write a countByBoolField utility function that counts the\nnumber of times a field is true and false.\nDave OK, but before implementing this function, let me first rewrite the code of\nlendingRatio, assuming this function already exists.\nTheo You are definitely a fast learner, Dave!\nDave Thanks! I think that by using countByBoolField, the code for calculating the\nlending ratio using a custom utility function would be something like this.\nListing14.13 Calculating the book lending ratio\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = countByBoolField(bookItems, \"isLent\", \"lent\", \"notLent\");\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nTIP Don’t use _.reduce or any other low-level data manipulation function inside\ncode that deals with business logic. Instead, write a utility function—with a proper\nname—that hides _.reduce.\nTheo Perfect. Don’t you think that this code is clearer than the code using _.reduce?\nDave I do! The code is both more concise and the intent is clearer. Let me see if I\ncan implement countByBoolField now.\nTheo I suggest that you write a unit test first.\nDave Good idea.\nDave types for a bit. When he’s satisfied, he shows Theo the result.\nListing14.14 A unit test for countByBoolField\nvar input = [\n{\"a\": true},\n{\"a\": false},\n{\"a\": true},\n--- Page 333 ---\n14.4 Unwinding at ease 305\n{\"a\": true}\n];\nvar expectedRes = {\n\"aTrue\": 3,\n\"aFalse\": 1\n};\n_.isEqual(countByBoolField(input, \"a\", \"aTrue\", \"aFalse\"), expectedRes);\nTheo Looks good to me. Now, for the implementation of countByBoolField, I\nthink you are going to need our update function.\nDave I think you’re right. On each iteration, I need to increment the value of either\naTrue or aFalse using update and a function that increments a number by 1.\nAfter a few minutes of trial and error, Dave comes up with the piece of code that uses\nreduce, update, and inc. He shows Theo the code for countByBoolField.\nListing14.15 The implementation of countByBoolField\nfunction inc (n) {\nreturn n + 1;\n}\nfunction countByBoolField(coll, field, keyTrue, keyFalse) {\nreturn _.reduce(coll, function(res, item) {\nif (_.get(item, field)) {\nreturn update(res, keyTrue, inc);\n}\nreturn update(res, keyFalse, inc);\n}, {[keyTrue]: 0,\nCreates a map with\n[keyFalse]: 0});\nkeyTrue and keyFalse\n}\nassociated to 0\nTheo Well done! Shall we move on and review the third admin feature?\nDave The third feature is more complicated. I would like to use the teachings from\nthe first two features for the implementation of the third feature.\nTheo OK. Call me when you’re ready for the code review.\n14.4 Unwinding at ease\nDave really struggled with the implementation of the last admin feature, grouping books\nby a physical library. After a couple of hours of frustration, Dave calls Theo for a rescue.\nDave I really had a hard time implementing the grouping by library feature.\nTheo I only have a couple of minutes before my next meeting, but I can try to help\nyou. What’s the exact definition of grouping by library?\nDave Let me show you the unit test I wrote.",
        "sections_found": []
      },
      "accurate_page_range": "303-333"
    },
    {
      "text": "- 12.2 Return value validation",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "raw_line": "- 12.2 Return value validation (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 100,
      "chapter_info": {
        "page": 303,
        "title": "Advanced data validation",
        "pattern_matched": "Chapter 12",
        "text_preview": "13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with "
      },
      "chapter_sections": {
        "start_page": 303,
        "end_page": 333,
        "content": "\n--- Page 303 ---\n13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with maps\nvar myDog = {\n\"type\": \"dog\",\n\"name\": \"Fido\"\n};\nvar myCat = {\n\"type\": \"cat\",\n\"name\": \"Milo\"\n};\nvar myCow = {\n\"type\": \"cow\",\n\"name\": \"Clarabelle\"\n};\nDave Could you have given another name to the field that holds the animal type?\nTheo Absolutely. It could be anything.\nDave I see. You’re asking me the fundamental difference between your code with a\nswitch statement and my code with an interface and three classes?\nTheo Exactly.\nDave First of all, if you pass an invalid map to your greet function, bad things will\nhappen.\nTheo You’re right. Let me fix that and validate input data.\nListing13.4 Data validation\nvar animalSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nSee chapter 12 about\ndata validation for\nfunction greet(animal) {\ndetails.\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\n--- Page 304 ---\n276 CHAPTER 13 Polymorphism\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\nbreak;\ncase \"cat\":\nconsole.log(\"Meow! I am: \" + animal.name);\nbreak;\ncase \"cow\":\nconsole.log(\"Moo! Call me \" + animal.name);\nbreak;\n};\n}\n NOTE You should not use switch statements like this in your production code.\nWe use them here for didactic purposes only as a step towards distilling the essence of\npolymorphism.\nDave Another drawback of your approach is that when you want to modify the\nimplementation of greet for a specific animal, you have to change the code\nthat deals with all the animals, while in my approach, you would change only a\nspecific animal class.\nTheo I agree, and I could also fix that by having a separate function for each animal,\nsomething like this.\nListing13.5 Different implementations in different functions\nfunction greetDog(animal) {\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\n}\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am: \" + animal.name);\n}\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\nfunction greet(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\ngreetDog(animal);\nbreak;\ncase \"cat\":\ngreetCat(animal);\nbreak;\ncase \"cow\":\ngreetCow(animal);\n--- Page 305 ---\n13.2 Multimethods with single dispatch 277\nbreak;\n};\n}\nDave But what if you want to extend the functionality of greet and add a new animal?\nTheo Now you got me. I admit that with a switch statement, I can’t add a new animal\nwithout modifying the original code, whereas in OOP, I can add a new class\nwithout having to modify the original code.\nDave Yeah, but you helped me to realize that the main benefit of polymorphism is\nthat it makes the code easily extensible.\nTIP The main benefit of polymorphism is extensibility.\nTheo I’m going to ask Joe if there’s a way to benefit from polymorphism without\nobjects.\nTheo sends a message to Joe and asks him about polymorphism in DOP. Joe answers that\nhe doesn’t have time to get into a deep response because he is in a tech conference where\nhe is about to give a talk about DOP. The only thing he has time to tell Theo is that he\nshould take a look at multimethods.\nTheo and Dave read some online material about multimethods. It doesn’t look too\ncomplicated. They decide that after lunch they will give multimethods a try.\n13.2 Multimethods with single dispatch\nDuring lunch, Theo asks Dave how it feels to have grown up in the country. Dave starts\nwith an enthusiastic description about being in direct contact with nature and living a sim-\npler life than in the city. He’s grateful for the experience, but he admits that country life\ncan sometimes be hard without the conveniences of the city. But who said simple was easy?\nAfter lunch, they decide to have coffee. Dave asks Theo if he’d like to grind the coffee\nbeans himself. Theo accepts with joy. Next, Dave explains how to use a French press coffee\nmaker to get the ideal tradeoff between bitterness and rich taste. While savoring their\nFrench press coffee in the garden, Theo and Dave continue their exploration of polymor-\nphism à la DOP.\nTheo From what I read before lunch, it seems that multimethods are a software con-\nstruct that provide polymorphism without the need for objects.\nDave I don’t get how that’s possible.\nTheo Multimethods have two parts: a dispatch function and a set of methods that\nprovide an implementation for each dispatched value.\nDave I’m not sure I’m clear on that. Is a dispatch function like an interface?\nTheo It’s like an interface in the sense that it defines the way the function needs to\nbe called, but it goes beyond that. It also dispatches a value that differentiates\nbetween the different implementations.\nDave That’s a bit abstract for me.\nTheo I think I understand how to implement the animal greeting capabilities. If we\nuse a multimethod called greet, we need a dispatch function and three\nmethods. Let’s call the dispatch function greetDispatch. It dispatches the\nanimal type, either \"dog\", \"cat\", or \"cow\". Then, each dispatch value is\n--- Page 306 ---\n278 CHAPTER 13 Polymorphism\nhandled by a specific method: \"dog\" by greetDog, \"cat\" by greetCat, and\n\"cow\" by greetCow.\nTheo takes out his notebook and opens it to a blank piece of paper. He draws a diagram\nlike the one in figure 13.1.\n\"dog\" greetDog\nGreet as a dog\ngreetDispatch \"cat\" greetCat\nEmit the animal type Greet as a cat\nanimal\ntype, name \"cow\" greetCow\nGreet as a cow\nFigure 13.1 The logic flow\nof the greet multimethod\nDave Why is there an arrow between animal and the methods, in addition to the\narrows between animal and the dispatch functions?\nTheo Because the arguments of a multimethod are passed to the dispatch function\nand to the methods.\nTIP The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\nDave Arguments plural?... I see only a single argument.\nTheo You’re right. Right now our multimethod only receives a single argument, but\nsoon it will receive several arguments.\nDave I see. Could you show me how to write the code for the greet multimethod?\nTheo For that, we need a library. For instance, in JavaScript, the arrows/multi-\nmethod library provides an implementation of multimethods. Basically, we call\nmulti to create a multimethod called method to add a method.\n NOTE See http://mng.bz/nY9v for examples and documentation about this library.\nDave Where should we start?\nTheo We’ll start with multimethod initialization by creating a dispatch function\ngreetDispatch that defines the signature of the multimethod, validates the\narguments, and emits the type of the animal. Then we’ll pass greetDispatch\nto multi in order to create the greet multimethod. Our dispatch function\nwould then look like this.\nListing13.6 The dispatch function for greet multimethod\nfunction greetDispatch(animal) {\nSignature definition\nif(dev()) {\n--- Page 307 ---\n13.2 Multimethods with single dispatch 279\nif(!ajv.validate(animalSchema, animal)) {\nArgument validation\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nDispatch value\nreturn animal.type;\n}\nMultimethod\ninitialization\nvar greet = multi(greetDispatch);\nTIP A multimethod dispatch function is responsible for three things: it defines the sig-\nnature of the multimethod, it validates the arguments, and it emits a dispatch value.\nDave What’s next?\nTheo Now we need to implement a method for each dispatched value. Let’s start\nwith the method that deals with dogs. We create a greetDog function that\nreceives an animal and then add a dog method to the greet multimethod\nusing the method function from the arrows/multimethod library. The method\nfunction receives two arguments: the dispatched value and a function that cor-\nresponds to the dispatch value.\nListing13.7 Implementation of greet method for dogs\nfunction greetDog(animal) {\nMethod\nconsole.log(\"Woof woof! My name is \" + animal.name);\nimplementation\n}\ngreet = method(\"dog\", greetDog)(greet);\nMethod declaration\nDave Does the method implementation have to be in the same module as the multi-\nmethod initialization?\nTheo No, not at all! Method declarations are decoupled from multimethod initializa-\ntion exactly like class definitions are decoupled from the interface definition.\nThat’s what make multimethods extensible.\nTIP Multimethods provides extensibility by decoupling between multimethod initial-\nization and method implementations.\nDave What about cats and cows?\nTheo We add their method implementations like we did for dogs.\nTheo takes a moment to envision the implementation. Then he codes up two more greet\nmethods for cats and cows.\nListing13.8 Implementation of greet method for cats\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ngreet = method(\"cat\", greetCat)(greet);\n--- Page 308 ---\n280 CHAPTER 13 Polymorphism\nListing13.9 Implementation of greet method for cows\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ngreet = method(\"cow\", greetCow)(greet);\nTIP In the context of multimethods, a method is a function that provides an imple-\nmentation for a dispatch value.\nDave Are the names of dispatch functions and methods important?\nTheo According to what I read, not really, but I like to follow a simple naming con-\nvention: use the name of the multimethod (for example, greet) as a prefix for\nthe dispatch function (for example, greetDispatch) and the methods. Then\nI’d have the Dispatch suffix for the dispatch function and a specific suffix for\neach method (for example, greetDog, greetCat, and greetCow).\nDave How does the multimethod mechanism work under the hood?\nTheo Internally, a multimethod maintains a hash map where the keys are the dis-\npatched values, and the values are the methods. When we add a method, an\nentry is added to the hash map, and when we call the multimethod, we query the\nhash map to find the implementation that corresponds to the dispatched value.\nDave I don’t think you’ve told me yet how to call a multimethod.\nTheo We call it as a regular function. Give me a minute, and I’ll show you an exam-\nple that calls a multimethod.\nListing13.10 Calling a multimethod like a regular function\ngreet(myDog);\n// → \"Woof woof! My name is Fido\"\ngreet(myCat);\n// → \"Meow! I am Milo\"\ngreet(myCow);\n// → \"Moo! Call me Clarabelle\"\nTIP Multimethods are called like regular functions.\nDave You told me earlier that in the dispatch function, we should validate the argu-\nments. Is that mandatory or is it a best practice?\nTheo It’s a best practice.\nDave What happens if the dispatch function doesn’t validate the arguments, and we\npass an invalid argument?\nTheo Like when an animal has no corresponding method?\nDave Exactly!\nTheo In that case, you’ll get an error. For instance, the arrows/multimethods library\nthrows a NoMethodError exception.\nDave That’s annoying. Is there a way to provide a default implementation?\n--- Page 309 ---\n13.3 Multimethods with multiple dispatch 281\nTheo Absolutely! In order to define a default implementation, you pass to method—\nas a single argument—the function that provides the default implementation.\nTheo writes the code and shows it to Dave. Dave then tests Theo’s code and seems satisfied\nwith the result.\nListing13.11 Defining a default implementation\nfunction greetDefault(animal) {\nconsole.log(\"My name is \" + animal.name);\n}\ngreet = method(greetDefault)(greet);\nListing13.12 Calling a multimethod when no method fits the dispatch value\nvar myHorse = {\n\"type\": \"horse\",\n\"name\": \"Horace\"\n};\ngreet(myHorse);\n// → \"My name is Horace\"\nTIP Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\nDave Cool!\n13.3 Multimethods with multiple dispatch\nTheo So far, we’ve mimicked OOP by having the type of the multimethod argument\nas a dispatch value. But if you think again about the flow of a multimethod,\nyou’ll discover something interesting. Would you like to try and draw a dia-\ngram that describes the flow of a multimethod in general?\nDave Let me get a fresh napkin. The one under my glass is a bit wet.\nTheo Uh, Dave, you can use my notebook.\nIt takes Dave a few minutes to draw a diagram like the one in figure 13.2. He pushes the\nnotebook back to Theo.\nValue1 Method1\nHandle case 1\nDispatch function Value3 Method3\nEmit a dispatch value Handle case 3\nargs\nValue2 Method2\nHandle case 2\nFigure 13.2 The logic flow\nof multimethods\n--- Page 310 ---\n282 CHAPTER 13 Polymorphism\nTheo Excellent! I hope you see that the dispatch function can emit any value.\nDave Like what?\nTheo Like emitting the type of two arguments!\nDave What do you mean?\nTheo Imagine that our animals are polyglot.\nDave Poly what?\nTheo Polyglot comes from the Greek polús, meaning much, and from glôssa, meaning\nlanguage. A polyglot is a person who can speak many languages.\nDave What languages would our animals speak?\nTheo I don’t know. Let’s say English and French.\nDave OK, and how would we represent a language in our program?\nTheo With a map, of course!\nDave What fields would we have in a language map?\nTheo Let’s keep things simple and have two fields: type and name.\nDave Like an animal map?\nTheo Not exactly. In a language map, the type field must be either fr for French or en\nfor English, whereas in the animal map, the type field is either dog, cat, or cow.\nDave Let me try to write the language map schema and the two language maps.\nTheo gladly consents; his French press coffee is getting cold! Dave writes his implementa-\ntion of the code and shows Theo.\nListing13.13 The schema of a language map\nvar languageSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nListing13.14 Two language maps\nvar french = {\n\"type\": \"fr\",\n\"name\": \"Français\"\n};\nvar english = {\n\"type\": \"en\",\n\"name\": \"English\"\n};\nTheo Excellent! Now, let’s write the code for the dispatch function and the methods\nfor our polyglot animals. Let’s call our multimethod, greetLang. We have one\ndispatch function and six methods.\n--- Page 311 ---\n13.3 Multimethods with multiple dispatch 283\nDave Right, three animals (dog, cat, and cow) times two languages (en and fr).\nBefore the implementation, I’d like to draw a flow diagram. It will help me to\nmake things crystal clear.\nTheo You need my notebook again?\nNot waiting for Dave to respond, Theo pushes his notebook across the table to Dave. Dave\ndraws a diagram like the one in figure 13.3 and slides the notebook back to Theo.\n[\"dog\", \"en\"] greetLangDogEn\nGreet as a dog in English\n[\"cat\", \"en\"] greetLangCatEn\nGreet as a cat in English\n[\"cow\", \"en\"] greetLangCowEn\nGreet as a cow in English\nargs greetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", \"fr\"] greetLangDogFr\nGreet as a dog in French\n[\"cat\", \"fr\"] greetLangCatFr\nGreet as a cat in French\n[\"cow\", \"fr\"] greetLangCowFr\nGreet as a cow in French\nFigure 13.3 The logic flow of the greetLang multimethod\nTheo Why did you omit the arrow between the arguments and the methods?\nDave In order to keep the diagram readable. Otherwise, there would be too many\narrows.\nTheo OK, I see. Are you ready for coding?\nDave Yes!\nTheo The dispatch function needs to validate its arguments and return an array with\ntwo elements: the type of animal and the type of language.\nDave types for a bit on his laptop. He initializes the multimethod with a dispatch function\nthat returns the type of its arguments and then shows the code to Theo.\nListing13.15 Initializing a multimethod with a dispatch function\nvar greetLangArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [animalSchema, languageSchema]\n};\nfunction greetLangDispatch(animal, language) {\nif(dev()) {\n--- Page 312 ---\n284 CHAPTER 13 Polymorphism\nif(!ajv.validate(greetLangArgsSchema, [animal, language])) {\nthrow (\"greetLang called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [animal.type, language.type];\n};\nvar greetLang = multi(greetLangDispatch);\nDave Does the order of the elements in the array matter?\nTheo It doesn’t matter, but it needs to be consistent with the wiring of the methods.\nThe implementation of greetLang would therefore look like this.\nListing13.16 The implementation of greetLang methods\nfunction greetLangDogEn(animal, language) {\nconsole.log(\"Woof woof! My name is \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"en\"], greetLangDogEn)(greetLang);\nfunction greetLangDogFr(animal, language) {\nconsole.log(\"Ouaf Ouaf! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"fr\"], greetLangDogFr)(greetLang);\nfunction greetLangCatEn(animal, language) {\nconsole.log(\"Meow! I am \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"en\"], greetLangCatEn)(greetLang);\nfunction greetLangCatFr(animal, language) {\nconsole.log(\"Miaou! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"fr\"], greetLangCatFr)(greetLang);\nfunction greetLangCowEn(animal, language) {\nconsole.log(\"Moo! Call me \" +\nanimal.name +\n\" and I speak \" +\n--- Page 313 ---\n13.3 Multimethods with multiple dispatch 285\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"en\"], greetLangCowEn)(greetLang);\nfunction greetLangCowFr(animal, language) {\nconsole.log(\"Meuh! Appelle moi \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"fr\"], greetLangCowFr)(greetLang);\nDave looks at the code for the methods that deal with French. He is surprised to see Ouaf\nOuaf instead of Woof Woof for dogs, Miaou instead of Meow for cats, and Meuh instead of\nMoo for cows.\nDave I didn’t know that animal onomatopoeia were different in French than in\nEnglish!\nTheo Ono what?\nDave Onomatopoeia, from the Greek ónoma that means name and poiéo– that means to\nproduce. It is the property of words that sound like what they represent; for\ninstance, Woof, Meow, and Moo.\nTheo Yeah, for some reason in French, dogs Ouaf, cats Miaou, and cows Meuh.\nDave I see that in the array the animal type is always before the language type.\nTheo Right! As I told you before, in a multimethod that features multiple dispatch,\nthe order doesn’t really matter, but it has to be consistent.\nTIP Multiple dispatch is when a dispatch function emits a value that depends on more\nthan one argument. In a multimethod that features multiple dispatch, the order of\nthe elements in the array emitted by the dispatch function has to be consistent with\nthe order of the elements in the wiring of the methods.\nDave Now let me see if I can figure out how to use a multimethod that features mul-\ntiple dispatch.\nDave remembers that Theo told him earlier that multimethods are used like regular func-\ntions. With that in mind, he comes up with the code for a multimethod that features multi-\nple dispatch.\nListing13.17 Calling a multimethod that features multiple dispatch\ngreetLang(myDog, french);\n// → \"Ouaf Ouaf! Je m\\'appelle Fido et je parle Français\"\ngreetLang(myDog, english);\n// → \"Woof woof! My name is Fido and I speak English\"\ngreetLang(myCat, french);\n// → \"Miaou! Je m\\'appelle Milo et je parle Français\"\n--- Page 314 ---\n286 CHAPTER 13 Polymorphism\ngreetLang(myCat, english);\n// → \"Meow! I am Milo and I speak English\"\ngreetLang(myCow, french);\n// → \"Meuh! Appelle moi Clarabelle et je parle Français\"\ngreetLang(myCow, english);\n// → \"Moo! Call me Clarabelle and I speak English\"\nTheo Now do you agree that multimethods with multiple dispatch offer a more pow-\nerful polymorphism that OOP polymorphism?\nDave Indeed, I do.\nTheo Let me show you an even more powerful polymorphism called dynamic dis-\npatch. But first, let’s get some more of that wonderful French press coffee.\nDave Great idea! While we’re in the kitchen, I think my mom made an orange Bundt\ncake using the oranges from the grove.\n13.4 Multimethods with dynamic dispatch\nDave refills their coffee cups as Theo takes two slices from the cake and dishes them up.\nThey take their coffee and cake outside to enjoy more of the fresh country air before\nresuming their conversation.\nDave What is dynamic dispatch?\nTheo It’s when the dispatch function of a multimethod returns a value that goes\nbeyond the static type of its arguments.\nDave Like what, for example?\nTheo Like a number or a Boolean, for instance.\nDave Why would such a thing be useful?\nTheo Imagine that instead of being polyglot, our animals would suffer from\ndysmakrylexia.\nDave Suffering from what?\nTheo Dysmakrylexia. It comes from the Greek dus, expressing the idea of difficulty,\nmakrýs meaning long, and léxis meaning diction. Therefore, dysmakrylexia is dif-\nficulty pronouncing long words.\nDave I’ve never heard of that.\nTheo That’s because I just invented it.\nDave Funny. What’s considered a long word for our animals?\nTheo Let’s say that when their name has more than five letters, they’re not able to\nsay it.\nDave A bit weird, but OK.\nTheo Let’s call our multimethod dysGreet. Its dispatch function returns an array\nwith two elements: the animal type and a Boolean about whether the name is\nlong or not. Take a look at this multimethod initialization.\n--- Page 315 ---\n13.4 Multimethods with dynamic dispatch 287\nListing13.18 A multimethod using a dispatch function with dynamic dispatch\nfunction dysGreetDispatch(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"dysGreet called with invalid arguments: \" + errors);\n}\n}\nvar hasLongName = animal.name.length > 5;\nreturn [animal.type, hasLongName];\n};\nvar dysGreet = multi(dysGreetDispatch);\nDave Writing the dysGreet methods doesn’t seem too complicated.\nAs Theo reaches over to pass Dave his notebook, he accidently hits his coffee cup. Now Theo’s\nnotebook is completely wet, and all the diagrams are soggy! Fortunately, Dave brought an\nextra napkin from the kitchen, and it’s still clean. He draws a flow diagram as in figure 13.4\nand then grabs his laptop and writes the implementation of the dysGreet methods.\n[\"dog\", true] dysGreetDogLong\nGreet as a dog mentioning name\n[\"cat\", true] dysGreetCatLong\nGreet as a cat mentioning name\n[\"cow\", true] dysGreetCowLong\nGreet as a cow mentioning name\nargs dysGreetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", false] dysGreetDogShort\nGreet as a dog omitting name\n[\"cat\", false] dysGreetCatShort\nGreet as a cat omitting name\n[\"cow\", false] dysGreetCowShort\nGreet as a cow omitting name\nFigure 13.4 The logic flow of the dysGreet multimethod\nListing13.19 The dysGreet methods\nfunction dysGreetDogLong(animal) {\nconsole.log(\"Woof woof! My name is \" + animal.name);\n}\ndysGreet = method([\"dog\", true], dysGreetDogLong)(dysGreet);\n--- Page 316 ---\n288 CHAPTER 13 Polymorphism\nfunction dysGreetDogShort(animal) {\nconsole.log(\"Woof woof!\");\n}\ndysGreet = method([\"dog\", false], dysGreetDogShort)(dysGreet);\nfunction dysGreetCatLong(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ndysGreet = method([\"cat\", true], dysGreetCatLong)(dysGreet);\nfunction dysGreetCatShort(animal) {\nconsole.log(\"Meow!\");\n}\ndysGreet = method([\"cat\", false], dysGreetCatShort)(dysGreet);\nfunction dysGreetCowLong(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ndysGreet = method([\"cow\", true], dysGreetCowLong)(dysGreet);\nfunction dysGreetCowShort(animal) {\nconsole.log(\"Moo!\");\n}\ndysGreet = method([\"cow\", false], dysGreetCowShort)(dysGreet);\nTheo checks that the code works as expected. He compliments Dave, not only on the\nmethod implementation but also for having the foresight to grab an extra napkin.\nListing13.20 Testing dysGreet\ndysGreet(myDog);\ndysGreet(myCow);\ndysGreet(myCat);\n//\"Woof woof!\"\n//\"Moo! Call me Clarabelle\"\n//\"Meow!\"\nTheo Well done, my friend! Our exploration of multimethods has come to an end. I\nthink it’s time for me to drive back if I want to get home before dark and beat\nthe rush hour traffic.\nDave Before you leave, let’s check if multimethods are available in programming\nlanguages other than JavaScript.\nTheo That’s a question for Joe.\nDave Do you think it’s OK if I call him now?\nTheo I think it’s probably better if you send him an email. He’s in a tech conference,\nand I’m not sure if it’s all day. Thank you for this beautiful day in the country\nand the wonderful refreshments.\nDave I enjoyed it, also, especially our discussions about etymology. I think there are\nsome oranges for you to take home and enjoy later.\nTheo Great! I can’t wait until my wife tries one.\n--- Page 317 ---\n13.5 Integrating multimethods in a production system 289\nAfter Theo leaves, Dave sends Joe an email. A few minutes later, Dave receives an email\nfrom Joe with the subject, “Support for multimethods in different languages.”\nSupport for multimethods in different languages\nPython has a library called multimethods (https://github.com/weissjeffm/multimeth-\nods), and Ruby has one called Ruby multimethods (https://github.com/psantacl/\nruby-multimethods). Both seem to work quite like the JavaScript arrows/multi-\nmethod library.\nIn Java, there is the Java Multimethod Framework (http://igm.univ-mlv.fr/~forax/\nworks/jmmf/), and C# supports multimethods natively via the dynamic keyword.\nHowever, in both Java and C#, multimethods work only with static data types and not\nwith generic data structures.\nGeneric data structure\nLanguage URL\nsupport\nJavaScript https://github.com/caderek/arrows/tree/master/ Yes\npackages/multimethod\nJava http://igm.univ-mlv.fr/~forax/works/jmmf/ No\nC# Native support No\nPython https://github.com/weissjeffm/multimethods Yes\nRuby https://github.com/psantacl/ruby-multimethods Yes\n13.5 Integrating multimethods in a production system\nWhile Theo is driving back home, his thoughts take him back to the fresh air of the coun-\ntry. This pleasant moment is interrupted by a phone call from Nancy at Klafim.\nNancy How are you doing?\nTheo Fine. I’m driving back from the countryside.\nNancy Cool. Are you available to talk about work?\nTheo Sure.\nNancy I’d like to add a tiny feature to the catalog.\nIn the past, when Nancy qualified a feature as tiny, it scared Theo because tiny turned into\nhuge. What seemed easy to her always took him a surprising amount of time to develop.\nBut after refactoring the system according to DOP principles, now what seems tiny to\nNancy is usually quite easy to implement.\nTheo What feature?\nNancy I’d like to allow librarians to view the list of authors, ordered by last name, in\ntwo formats: HTML and Markdown.\n--- Page 318 ---\n290 CHAPTER 13 Polymorphism\nTheo It doesn’t sound too complicated.\nNancy Also, I need a bit of text formatting.\nTheo What kind of text formatting?\nNancy Depending on the number of books an author has written, their name should\nbe in bold and italic fonts.\nTheo Could you send me an email with all the details. I’ll take a look at it tomorrow\nmorning.\nNancy Perfect. Have a safe drive!\nBefore going to bed, Theo reflects about today’s etymology lessons. He realizes that he\nnever looked for the etymology of the word etymology itself! He searches for the term etymol-\nogy online and learns that the word etymology derives from the Greek étumon, meaning true\nsense, and the suffix logia, denoting the study of. During the night, Theo dreams of dogs,\ncats, and cows programming on their laptops in a field of grass.\nWhen Theo arrives at the office the next day, he opens Nancy’s email with the details\nabout the text formatting feature. The details are summarized in table 13.1.\nTable 13.1 Text formatting for author names according to the number of books\nthey have written\nNumber of books Italic Bold\n10 or fewer Yes No\nBetween 11 and 50 No Yes\n51 or more Yes Yes\nTheo forwards Nancy’s email to Dave and asks him to take care of this task. Delegating\nresponsibility, after all, is the trait of a great manager.\nDave thinks the most difficult part of the feature lies in implementing an Author\n.myName(author, format) function that receives two arguments: the author data and the\ntext format. He asks himself whether he can implement this function as a multimethod\nand use what he learned yesterday with Theo at his parents’ home in the country. It seems\nthat this feature is quite similar to the one that dealt with dysmakrylexia. Instead of check-\ning the length of a string, he needs to check the length of an array.\nFirst, Dave needs a data schema for the text format. He could represent a format as a\nmap with a type field like Theo did yesterday for languages, but at the moment, it seems\nsimpler to represent a format as a string that could be either markdown or html. He comes\nup with the text format schema in listing 13.21. He already wrote the author schema with\nTheo last week. It’s in listing 13.22.\nListing13.21 The text format schema\nvar textFormatSchema = {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"enum\": [\"markdown\", \"html\"]}\n};\n--- Page 319 ---\n13.5 Integrating multimethods in a production system 291\nListing13.22 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"name\", \"bookIsbns\"],\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nNow, Dave needs to write a dispatch function and initialize the multimethod. Remember-\ning that Theo had no qualms about creating the word dysmakrylexia, he decides that he\nprefers his own neologism, prolificity, over the existing nominal form prolificness. He finds it\nuseful to have an Author.prolificityLevel helper function that returns the level of\nprolificity of the author: either low, medium, or high. Now he’s ready to code the author-\nNameDispatch function.\nListing13.23 Author.myName multimethod initialization\nAuthor.prolificityLevel = function(author) {\nvar books = _.size(_.get(author, \"bookIsbns\"));\nif (books <= 10) {\nreturn \"low\";\n};\nif (books >= 51) {\nreturn \"high\";\n}\nreturn \"medium\";\n};\nvar authorNameArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\nauthorSchema,\n{\"enum\": [\"markdown\", \"html\"]}\n]\n};\nfunction authorNameDispatch(author, format) {\nif(dev()) {\nif(!ajv.validate(authorNameArgsSchema, [author, format])) {\nthrow (\"Author.myName called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [Author.prolificityLevel(author), format];\n};\nAuthor.myName = multi(authorNameDispatch);\n--- Page 320 ---\n292 CHAPTER 13 Polymorphism\nThen Dave works on the methods: first, the HTML format methods. In HTML, bold text is\nwrapped inside a <b> tag, and italic text is wrapped in a <i> tag. For instance, in HTML,\nthree authors with different levels of prolificity would be written like this.\nListing13.24 Examples of bold and italic in HTML\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n<i>Yehonathan Sharvit<i>\nBold and italic formatting\n<b>Stephen Covey</b>\nfor highly prolific authors\n<b><i>Isaac Asimov</i></b>\nWith this information in hand, Dave writes the three methods that deal with HTML for-\nmatting. Easy!\nListing13.25 The methods that deal with HTML formatting\nfunction authorNameLowHtml(author, format) {\nreturn \"<i>\" + _.get(author, \"name\") + \"</i>\";\n}\nAuthor.myName = method([\"low\", \"html\"], authorNameLowHtml)(Author.myName);\nfunction authorNameMediumHtml(author, format) {\nreturn \"<b>\" + _.get(author, \"name\") + \"</b>\";\n}\nAuthor.myName =\nmethod([\"medium\", \"html\"], authorNameMediumHtml)(Author.myName);\nfunction authorNameHighHtml(author, format) {\nreturn \"<b><i>\" + _.get(author, \"name\") + \"</i></b>\";\n}\nAuthor.myName =\nmethod([\"high\", \"html\"], authorNameHighHtml)(Author.myName);\nThen, Dave moves on to the three methods that deal with Markdown formatting. In\nMarkdown, bold text is wrapped in two asterisks, and italic text is wrapped in a single\nasterisk. For instance, in Markdown, three authors with different levels of prolificity\nwould be written like the code in listing 13.26. The code for the Markdown methods is in\nlisting 13.27.\nListing13.26 Examples of bold and italic in Markdown\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n*Yehonathan Sharvit*\nBold and italic formatting\n**Stephen Covey**\nfor highly prolific authors\n***Isaac Asimov***\n--- Page 321 ---\n13.5 Integrating multimethods in a production system 293\nListing13.27 The methods that deal with Markdown formatting\nfunction authorNameLowMarkdown(author, format) {\nreturn \"*\" + _.get(author, \"name\") + \"*\";\n}\nAuthor.myName =\nmethod([\"low\", \"markdown\"], authorNameLowMarkdown)(Author.myName);\nfunction authorNameMediumMarkdown(author, format) {\nreturn \"**\" + _.get(author, \"name\") + \"**\";\n}\nAuthor.myName =\nmethod([\"medium\", \"markdown\"], authorNameMediumMarkdown)(Author.myName);\nfunction authorNameHighMarkdown(author, format) {\nreturn \"***\" + _.get(author, \"name\") + \"***\";\n}\nAuthor.myName =\nmethod([\"high\", \"markdown\"], authorNameHighMarkdown)(Author.myName);\nDave decides to test his code by involving a mysterious author. Listing 13.28 and listing 13.29\nshow the tests.\nListing13.28 Testing HTML formatting\nvar yehonathan = {\n\"name\": \"Yehonathan Sharvit\",\n\"bookIsbns\": [\"9781617298578\"]\n};\nAuthor.myName(yehonathan, \"html\");\n// → \"<i>Yehonathan Sharvit</i>\"\nListing13.29 Testing Markdown formatting\nAuthor.myName(yehonathan, \"markdown\");\n// → \"*Yehonathan Sharvit*\"\nTheo shows up at Dave’s desk and asks to review Dave’s implementation of the list of\nauthors feature. Curious, Theo asks Dave about the author that appears in the test of\nAuthor.myName.\nTheo Who is Yehonathan Sharvit?\nDave I don’t really know. The name appeared when I googled “data-oriented pro-\ngramming” yesterday. He wrote a book on the topic. I thought it would be cool\nto use its ISBN in my test.\n--- Page 322 ---\n294 CHAPTER 13 Polymorphism\nSummary\n The main benefit of polymorphism is extensibility.\n Multimethods make it possible to benefit from polymorphism when data is repre-\nsented with generic maps.\n A multimethod is made of a dispatch function and multiple methods.\n The dispatch function of a multimethod emits a dispatch value.\n Each of the methods used in a multimethod provides an implementation for a\nspecific dispatch value.\n Multimethods can mimic OOP class inheritance via single dispatch.\n In single dispatch, a multimethod receives a single map that contains a type field,\nand the dispatch function of the multimethod emits the value of the type field.\n In addition to single dispatch, multimethods provide two kinds of advanced\npolymorphisms: multiple dispatch and dynamic dispatch.\n Multiple dispatch is used when the behavior of the multimethod depends on\nmultiple arguments.\n Dynamic dispatch is used when the behavior of the multimethod depends on run-\ntime arguments.\n The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\n A multimethod dispatch function is responsible for\n– Defining the signature.\n– Validating the arguments.\n– Emitting a dispatch value.\n Multimethods provides extensibility by decoupling between multimethod ini-\ntialization and method implementations.\n Multimethods are called like regular functions.\n Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\n In a multimethod that features multiple dispatch, the order of the elements in\nthe array emitted by the dispatch function has to be consistent with the order of\nthe elements in the wiring of the methods.\nLodash functions introduced in this chapter\nFunction Description\nsize(coll) Gets the size of coll\n--- Page 323 ---\nAdvanced data\nmanipulation\nWhatever is well-conceived\nis clearly said\nThis chapter covers\n Manipulating nested data\n Writing clear and concise code for business\nlogic\n Separating business logic and generic data\nmanipulation\n Building custom data manipulation tools\n Using the best tool for the job\nWhen our business logic involves advanced data processing, the generic data manip-\nulation functions provided by the language run time and by third-party libraries\nmight not be sufficient. Instead of mixing the details of data manipulation with\nbusiness logic, we can write our own generic data manipulation functions and imple-\nment our custom business logic using them. Separating business logic from the inter-\nnal details of data manipulation makes the business logic code concise and easy to\nread for other developers.\n295\n--- Page 324 ---\n296 CHAPTER 14 Advanced data manipulation\n14.1 Updating a value in a map with eloquence\nDave is more and more autonomous on the Klafim project. He can implement most fea-\ntures on his own, typically turning to Theo only for code reviews. Dave’s code quality stan-\ndards are quite high. Even when his code is functionally solid, he tends to be unsatisfied\nwith its readability. Today, he asks for Theo’s help in improving the readability of the code\nthat fixes a bug Theo introduced a long time ago.\nDave I think I have a found a bug in the code that returns book information from\nthe Open Library API.\nTheo What bug?\nDave Sometimes, the API returns duplicate author names, and we pass the dupli-\ncates through to the client.\nTheo It doesn’t sound like a complicated bug to fix.\nDave Right, I fixed it, but I’m not satisfied with the readability of the code I wrote.\nTheo Being critical of our own code is an important quality for a developer to prog-\nress. What is it exactly that you don’t like?\nDave Take a look at this code.\nListing14.1 Removing duplicates in a straightforward but tedious way\nfunction removeAuthorDuplicates(book) {\nvar authors = _.get(book, \"authors\");\nvar uniqAuthors = _.uniq(authors);\nreturn _.set(book,\"authors\", uniqAuthors);\n}\nDave I’m using _.get to retrieve the array with the author names, then _.uniq to\ncreate a duplicate-free version of the array, and finally, _.set to create a new\nversion of the book with no duplicate author names.\nTheo The code is tedious because the next value of authorNames needs to be based\non its current value.\nDave But it’s a common use case! Isn’t there a simpler way to write this kind of code?\nTheo Your astonishment definitely honors you as a developer, Dave. I agree with you\nthat there must be a simpler way. Let me phone Joe and see if he’s available for\na conference call.\nJoe How’s it going, Theo?\nTheo Great! Are you back from your tech conference?\nJoe I just landed. I’m on my way home now in a taxi.\nTheo How was your talk about DOP?\nJoe Pretty good. At the beginning people were a bit suspicious, but when I told\nthem the story of Albatross and Klafim, it was quite convincing.\nTheo Yeah, adults are like children in that way; they love stories.\nJoe What about you? Did you manage to achieve polymorphism with multimethods?\nTheo Yes! Dave even managed to implement a feature in Klafim with multimethods.\nJoe Cool!\n--- Page 325 ---\n14.1 Updating a value in a map with eloquence 297\nTheo Do you have time to help Dave with a question about programming?\nJoe Sure.\nDave Hi Joe. How are you doing?\nJoe Hello Dave. Not bad. What kind of help do you need?\nDave I’m wondering if there’s a simpler way to remove duplicates inside an array\nvalue in a map. Using _.get, _.uniq, and _.set looks quite tedious.\nJoe You should build your own data manipulation tools.\nDave What do you mean?\nJoe You should write a generic update function that updates a value in a map,\napplying a calculation based on its current value.1\nDave What would the arguments of update be in your opinion?\nJoe Put the cart before the horse.\nDave What?!\nJoe Rewrite your business logic as if update were already implemented, and you’ll\ndiscover what the arguments of update should be.\nDave I see what you mean: the horse is the implementation of update, and the cart is\nthe usage of update.\nJoe Exactly. But remember, it’s better if you keep your update function generic.\nDave How?\nJoe By not limiting it to your specific use case.\nDave I see. The implementation of update should not deal with removing duplicate\nelements. Instead, it should receive the updating function—in my case,\n_.uniq—as an argument.\nJoe Exactly! Uh, sorry Dave, I gotta go, I just got home. Good luck!\nDave Take care, Joe, and thanks!\nDave ends the conference call. Looking at Theo, he reiterates the conversation with Joe.\nDave Joe advised me to write my own update function. For that purpose, he told me\nto start by rewriting removeAuthorDuplicates as if update were already\nimplemented. That will allow us to make sure we get the signature of update\nright.\nTheo Sounds like a plan.\nDave Joe called it “putting the cart before the horse.”\nTheo Joe and his funny analogies...\nTIP The best way to find the signature of a custom data manipulation function is to\nthink about the most convenient way to use it.\nDave Anyway, the way I’d like to use update inside removeAuthorDuplicates is\nlike this.\n1 Lodash provides an implementation of update, but for the sake of teaching, we are writing our own imple-\nmentation.\n--- Page 326 ---\n298 CHAPTER 14 Advanced data manipulation\nListing14.2 The code that removes duplicates in an elegant way\nfunction removeAuthorDuplicates(book) {\nreturn update(book, \"authors\", _.uniq);\n}\nTheo Looks good to me!\nDave Wow! Now the code with update is much more elegant than the code with\n_.get and _.set!\nTheo Before you implement update, I suggest that you write down in plain English\nexactly what the function does.\nDave It’s quite easy: update receives a map called map, a path called path, and a\nfunction called fun. It returns a new version of map, where path is associated\nwith fun(currentValue), and currentValue is the value associated with\npath in map.\nThinking out loud, Dave simultaneously draws a diagram like that in figure 14.1. Theo is\nbecoming more and more impressed with his young protegé as he studies the figure.\n{\n\"position\" : \"manager\", \"income\"\n\"income\" : 100000\n} map fun path\nupdate\n{\n\"position\" : \"manager\",\n\"income\" : fun(100000)\nres Figure 14.1 The\n}\nbehavior of update\nTIP Before implementing a custom data manipulation function, formulate in plain\nEnglish exactly what the function does.\nTheo With such a clear definition, it’s going to be a piece of cake to implement\nupdate!\nAfter a few minutes, Dave comes up with the code. It doesn’t take long because the plain-\nEnglish diagram helps him to organize the code.\nListing14.3 A generic update function\nfunction update(map, path, fun) {\nvar currentValue = _.get(map, path);\nvar nextValue = fun(currentValue);\nreturn _.set(map, path, nextValue);\n}\n--- Page 327 ---\n14.2 Manipulating nested data 299\nTheo Why don’t you see if it works with a simple case such as incrementing a number\nin a map?\nDave Good idea! I’ll try multiplying a value in a map by 2 with update. How’s this\nlook?\nListing14.4 Multiplying a value in a map by 2\nvar m = {\n\"position\": \"manager\",\n\"income\": 100000\n};\nupdate(m, \"income\", function(x) {\nreturn x * 2;\n});\n// → {\"position\": \"manager\", \"income\": 200000}\nTheo Great! It seems to work.\n14.2 Manipulating nested data\nThe next Monday, during Theo and Dave’s weekly sync meeting, they discuss the upcom-\ning features for Klafim. Theo fondly remembers another Monday where they met at Dave’s\nfamily home in the country. Coming back to the present moment, Theo begins.\nTheo Recently, Nancy has been asking for more and more administrative features.\nDave Like what?\nTheo I’ll give you a few examples.... Let me find the email I got from Nancy yesterday.\nDave OK.\nTheo Here it is. There are three feature requests for now: listing all the book author\nIDs, calculating the book lending ratio, and grouping books by a physical library.\nDave What feature should I tackle first?\nTheo It doesn’t matter, but you should deliver the three of these before the end of\nthe week. Good luck, and don’t hesitate to call me if you need help.\nOn Tuesday, Dave asks for Theo’s help. Dave is not pleased with how his code looks.\nDave I started to work on the three admin features, but I don’t like the code I wrote.\nLet me show you the code for retrieving the list of author IDs from the list of\nbooks returned from the database.\nTheo Can you remind me what an element in a book list returned from the database\nlooks like?\nDave Each book is a map with an authorIds array field.\nTheo OK, so it sounds like a map over the books should do it.\nDave This is what I did, but it doesn’t work as expected. Here’s my code for listing\nthe book author IDs.\n--- Page 328 ---\n300 CHAPTER 14 Advanced data manipulation\nListing14.5 Retrieving the author IDs in books as an array of arrays\nfunction authorIdsInBooks(books) {\nreturn _.map(books, \"authorIds\");\n}\nTheo What’s the problem?\nDave The problem is that it returns an array of arrays of author IDs instead of an\narray of author IDs. For instance, when I run authorIdsInBooks on a catalog\nwith two books, I get this result.\nListing14.6 The author IDs in an array of arrays\n[\n[\"sean-covey\", \"stephen-covey\"],\n[\"alan-moore\", \"dave-gibbons\"]\n]\nTheo That’s not a big problem. You can flatten an array of arrays with _.flatten,\nand you should get the result you expect.\nDave Nice! This is exactly what I need! Give me a moment to fix the code of\nauthorIdsInBooks. . . here you go.\nListing14.7 Retrieving the author IDs in books as an array of strings\nfunction authorIdsInBooks(books) {\nreturn _.flatten(_.map(books, \"authorIds\"));\n}\nTheo Don’t you think that mapping and then flattening deserves a function of its own?\nDave Maybe. It’s quite easy to implement a flatMap function.2 How about this?\nListing14.8 The implementation of flatMap\nfunction flatMap(coll, f) {\nreturn _.flatten(_.map(coll,f));\n}\nTheo Nice!\nDave I don’t know.... It’s kind of weird to have such a small function.\nTheo I don’t think that code size is what matters here.\nDave What do you mean?\nTheo See what happens when you rewrite authorIdsInBooks using flatMap.\nDave OK, here’s how I’d use flatMap to list the author IDs.\n2 Lodash provides an implementation of flatMap, but for the sake of teaching, we are writing our own\nimplementation.\n--- Page 329 ---\n14.3 Using the best tool for the job 301\nListing14.9 Retrieving the author IDs as an array of strings using flatMap\nfunction authorIdsInBooks(books) {\nreturn flatMap(books, \"authorIds\");\n}\nTheo What implementation do you prefer, the one with flatten and map (in listing\n14.7) or the one with flatMap (in listing 14.9)?\nDave I don’t know. To me, they look quite similar.\nTheo Right, but which implementation is more readable?\nDave Well, assuming I know what flatMap does, I would say the implementation\nwith flatMap. Because it’s more concise, it is a bit more readable.\nTheo Again, it’s not about the size of the code. It’s about the clarity of intent and the\npower of naming things.\nDave I don’t get that.\nTheo Let me give you an example from our day-to-day language.\nDave OK.\nTheo Could you pass me that thing on your desk that’s used for writing?\nIt takes Dave a few seconds to get that Theo has asked him to pass the pen on the desk.\nAfter he passes Theo the pen, he asks:\nDave Why didn’t you simply ask for the pen?\nTheo I wanted you to experience how it feels when we use descriptions instead of\nnames to convey our intent.\nDave Oh, I see. You mean that once we use a name for the operation that maps and\nflattens, the code becomes clearer.\nTheo Exactly.\nDave Let’s move on to the second admin feature: calculating the book lending ratio.\nTheo Before that, I think we deserve a short period for rest and refreshments, where\nwe drink a beverage made by percolation from roasted and ground seeds.\nDave A coffee break!\n14.3 Using the best tool for the job\nAfter the coffee break, Dave shows Theo his implementation of the book lending ratio cal-\nculation. This time, he seems to like the code he wrote.\nDave I’m quite proud of the code I wrote to calculate the book lending ratio.\nTheo Show me the money!\nDave My function receives a list of books from the database like this.\nListing14.10 A list of two books with bookItems\n[\n{\n\"isbn\": \"978-1779501127\",\n--- Page 330 ---\n302 CHAPTER 14 Advanced data manipulation\n\"title\": \"Watchmen\",\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n}\n]\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"bookItems\": [\n{\n\"id\": \"book-item-123\",\n\"libId\": \"hudson-park-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-17\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n]\nTheo Quite a nested piece of data!\nDave Yeah, but now that I’m using flatMap, calculating the lending ratio is quite\neasy. I’m going over all the book items with forEach and incrementing either\nthe lent or the notLent counter. At the end, I return the ratio between lent\nand (lent + notLent). Here’s how I do that.\nListing14.11 Calculating the book lending ratio using forEach\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar lent = 0;\nvar notLent = 0;\n_.forEach(bookItems, function(item) {\nif(_.get(item, \"isLent\")) {\nlent = lent + 1;\n} else {\nnotLent = notLent + 1;\n}\n});\nreturn lent/(lent + notLent);\n}\nTheo Would you allow me to tell you frankly what I think of your code?\nDave If you are asking this question, it means that you don’t like it. Right?\nTheo It’s nothing against you; I don’t like any piece of code with forEach.\n--- Page 331 ---\n14.3 Using the best tool for the job 303\nDave What’s wrong with forEach?\nTheo It’s too generic!\nDave I thought that genericity was a positive thing in programming.\nTheo It is when we build a utility function, but when we use a utility function, we\nshould use the least generic function that solves our problem.\nDave Why?\nTheo Because we ought to choose the right tool for the job, like in the real life.\nDave What do you mean?\nTheo Let me give you an example. Yesterday, I had to clean my drone from the\ninside. Do you think that I used a screwdriver or a Swiss army knife to unscrew\nthe drone cover?\nDave A screwdriver, of course! It’s much more convenient to manipulate.\nTheo Right. Also, imagine that someone looks at me using a screwdriver. It’s quite\nclear to them that I am turning a screw. It conveys my intent clearly.\nDave Are you saying that forEach is like the Swiss army knife of data manipulation?\nTheo That’s a good way to put it.\nTIP Pick the least generic utility function that solves your problem.\nDave What function should I use then, to iterate over the book item collection?\nTheo You could use _.reduce.\nDave I thought reduce was about returning data from a collection. Here, I don’t\nneed to return data; I need to update two variables, lent and notLent.\nTheo You could represent those two values in a map with two keys.\nDave Can you show me how to rewrite my lendingRatio function using reduce?\nTheo Sure. The initial value passed to reduce is the map, {\"lent\": 0, \"notLent\": 0},\nand inside each iteration, we update one of the two keys, like this.\nListing14.12 Calculating the book lending ratio using reduce\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = _.reduce(bookItems, function(res, item) {\nif(_.get(item, \"isLent\")) {\nres.lent = res.lent + 1;\n} else {\nres.notLent = res.notLent + 1;\n}\nreturn res;\n}, {notLent: 0, lent:0});\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nDave Instead of updating the variables lent and notLent, now we are updating lent\nand notLent map fields. What’s the difference?\n--- Page 332 ---\n304 CHAPTER 14 Advanced data manipulation\nTheo Dealing with map fields instead of variables allows us to get rid of reduce in\nour business logic code.\nDave How could you iterate over a collection without forEach and without reduce?\nTheo I can’t avoid the iteration over a collection, but I can hide reduce behind a\nutility function. Take a look at the way reduce is used inside the code of\nlendingRatio. What is the meaning of the reduce call?\nDave looks at the code in listing 14.12. He thinks for a long moment before he answers.\nDave I think it’s counting the number of times isLent is true and false.\nTheo Right. Now, let’s use Joe’s advice about building our own data manipulation\ntool.\nDave How exactly?\nTheo I suggest that you write a countByBoolField utility function that counts the\nnumber of times a field is true and false.\nDave OK, but before implementing this function, let me first rewrite the code of\nlendingRatio, assuming this function already exists.\nTheo You are definitely a fast learner, Dave!\nDave Thanks! I think that by using countByBoolField, the code for calculating the\nlending ratio using a custom utility function would be something like this.\nListing14.13 Calculating the book lending ratio\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = countByBoolField(bookItems, \"isLent\", \"lent\", \"notLent\");\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nTIP Don’t use _.reduce or any other low-level data manipulation function inside\ncode that deals with business logic. Instead, write a utility function—with a proper\nname—that hides _.reduce.\nTheo Perfect. Don’t you think that this code is clearer than the code using _.reduce?\nDave I do! The code is both more concise and the intent is clearer. Let me see if I\ncan implement countByBoolField now.\nTheo I suggest that you write a unit test first.\nDave Good idea.\nDave types for a bit. When he’s satisfied, he shows Theo the result.\nListing14.14 A unit test for countByBoolField\nvar input = [\n{\"a\": true},\n{\"a\": false},\n{\"a\": true},\n--- Page 333 ---\n14.4 Unwinding at ease 305\n{\"a\": true}\n];\nvar expectedRes = {\n\"aTrue\": 3,\n\"aFalse\": 1\n};\n_.isEqual(countByBoolField(input, \"a\", \"aTrue\", \"aFalse\"), expectedRes);\nTheo Looks good to me. Now, for the implementation of countByBoolField, I\nthink you are going to need our update function.\nDave I think you’re right. On each iteration, I need to increment the value of either\naTrue or aFalse using update and a function that increments a number by 1.\nAfter a few minutes of trial and error, Dave comes up with the piece of code that uses\nreduce, update, and inc. He shows Theo the code for countByBoolField.\nListing14.15 The implementation of countByBoolField\nfunction inc (n) {\nreturn n + 1;\n}\nfunction countByBoolField(coll, field, keyTrue, keyFalse) {\nreturn _.reduce(coll, function(res, item) {\nif (_.get(item, field)) {\nreturn update(res, keyTrue, inc);\n}\nreturn update(res, keyFalse, inc);\n}, {[keyTrue]: 0,\nCreates a map with\n[keyFalse]: 0});\nkeyTrue and keyFalse\n}\nassociated to 0\nTheo Well done! Shall we move on and review the third admin feature?\nDave The third feature is more complicated. I would like to use the teachings from\nthe first two features for the implementation of the third feature.\nTheo OK. Call me when you’re ready for the code review.\n14.4 Unwinding at ease\nDave really struggled with the implementation of the last admin feature, grouping books\nby a physical library. After a couple of hours of frustration, Dave calls Theo for a rescue.\nDave I really had a hard time implementing the grouping by library feature.\nTheo I only have a couple of minutes before my next meeting, but I can try to help\nyou. What’s the exact definition of grouping by library?\nDave Let me show you the unit test I wrote.",
        "sections_found": []
      },
      "accurate_page_range": "303-333"
    },
    {
      "text": "- 12.3 Advanced data validation",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "raw_line": "- 12.3 Advanced data validation (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 101,
      "chapter_info": {
        "page": 303,
        "title": "Advanced data validation",
        "pattern_matched": "Chapter 12",
        "text_preview": "13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with "
      },
      "chapter_sections": {
        "start_page": 303,
        "end_page": 333,
        "content": "\n--- Page 303 ---\n13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with maps\nvar myDog = {\n\"type\": \"dog\",\n\"name\": \"Fido\"\n};\nvar myCat = {\n\"type\": \"cat\",\n\"name\": \"Milo\"\n};\nvar myCow = {\n\"type\": \"cow\",\n\"name\": \"Clarabelle\"\n};\nDave Could you have given another name to the field that holds the animal type?\nTheo Absolutely. It could be anything.\nDave I see. You’re asking me the fundamental difference between your code with a\nswitch statement and my code with an interface and three classes?\nTheo Exactly.\nDave First of all, if you pass an invalid map to your greet function, bad things will\nhappen.\nTheo You’re right. Let me fix that and validate input data.\nListing13.4 Data validation\nvar animalSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nSee chapter 12 about\ndata validation for\nfunction greet(animal) {\ndetails.\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\n--- Page 304 ---\n276 CHAPTER 13 Polymorphism\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\nbreak;\ncase \"cat\":\nconsole.log(\"Meow! I am: \" + animal.name);\nbreak;\ncase \"cow\":\nconsole.log(\"Moo! Call me \" + animal.name);\nbreak;\n};\n}\n NOTE You should not use switch statements like this in your production code.\nWe use them here for didactic purposes only as a step towards distilling the essence of\npolymorphism.\nDave Another drawback of your approach is that when you want to modify the\nimplementation of greet for a specific animal, you have to change the code\nthat deals with all the animals, while in my approach, you would change only a\nspecific animal class.\nTheo I agree, and I could also fix that by having a separate function for each animal,\nsomething like this.\nListing13.5 Different implementations in different functions\nfunction greetDog(animal) {\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\n}\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am: \" + animal.name);\n}\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\nfunction greet(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\ngreetDog(animal);\nbreak;\ncase \"cat\":\ngreetCat(animal);\nbreak;\ncase \"cow\":\ngreetCow(animal);\n--- Page 305 ---\n13.2 Multimethods with single dispatch 277\nbreak;\n};\n}\nDave But what if you want to extend the functionality of greet and add a new animal?\nTheo Now you got me. I admit that with a switch statement, I can’t add a new animal\nwithout modifying the original code, whereas in OOP, I can add a new class\nwithout having to modify the original code.\nDave Yeah, but you helped me to realize that the main benefit of polymorphism is\nthat it makes the code easily extensible.\nTIP The main benefit of polymorphism is extensibility.\nTheo I’m going to ask Joe if there’s a way to benefit from polymorphism without\nobjects.\nTheo sends a message to Joe and asks him about polymorphism in DOP. Joe answers that\nhe doesn’t have time to get into a deep response because he is in a tech conference where\nhe is about to give a talk about DOP. The only thing he has time to tell Theo is that he\nshould take a look at multimethods.\nTheo and Dave read some online material about multimethods. It doesn’t look too\ncomplicated. They decide that after lunch they will give multimethods a try.\n13.2 Multimethods with single dispatch\nDuring lunch, Theo asks Dave how it feels to have grown up in the country. Dave starts\nwith an enthusiastic description about being in direct contact with nature and living a sim-\npler life than in the city. He’s grateful for the experience, but he admits that country life\ncan sometimes be hard without the conveniences of the city. But who said simple was easy?\nAfter lunch, they decide to have coffee. Dave asks Theo if he’d like to grind the coffee\nbeans himself. Theo accepts with joy. Next, Dave explains how to use a French press coffee\nmaker to get the ideal tradeoff between bitterness and rich taste. While savoring their\nFrench press coffee in the garden, Theo and Dave continue their exploration of polymor-\nphism à la DOP.\nTheo From what I read before lunch, it seems that multimethods are a software con-\nstruct that provide polymorphism without the need for objects.\nDave I don’t get how that’s possible.\nTheo Multimethods have two parts: a dispatch function and a set of methods that\nprovide an implementation for each dispatched value.\nDave I’m not sure I’m clear on that. Is a dispatch function like an interface?\nTheo It’s like an interface in the sense that it defines the way the function needs to\nbe called, but it goes beyond that. It also dispatches a value that differentiates\nbetween the different implementations.\nDave That’s a bit abstract for me.\nTheo I think I understand how to implement the animal greeting capabilities. If we\nuse a multimethod called greet, we need a dispatch function and three\nmethods. Let’s call the dispatch function greetDispatch. It dispatches the\nanimal type, either \"dog\", \"cat\", or \"cow\". Then, each dispatch value is\n--- Page 306 ---\n278 CHAPTER 13 Polymorphism\nhandled by a specific method: \"dog\" by greetDog, \"cat\" by greetCat, and\n\"cow\" by greetCow.\nTheo takes out his notebook and opens it to a blank piece of paper. He draws a diagram\nlike the one in figure 13.1.\n\"dog\" greetDog\nGreet as a dog\ngreetDispatch \"cat\" greetCat\nEmit the animal type Greet as a cat\nanimal\ntype, name \"cow\" greetCow\nGreet as a cow\nFigure 13.1 The logic flow\nof the greet multimethod\nDave Why is there an arrow between animal and the methods, in addition to the\narrows between animal and the dispatch functions?\nTheo Because the arguments of a multimethod are passed to the dispatch function\nand to the methods.\nTIP The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\nDave Arguments plural?... I see only a single argument.\nTheo You’re right. Right now our multimethod only receives a single argument, but\nsoon it will receive several arguments.\nDave I see. Could you show me how to write the code for the greet multimethod?\nTheo For that, we need a library. For instance, in JavaScript, the arrows/multi-\nmethod library provides an implementation of multimethods. Basically, we call\nmulti to create a multimethod called method to add a method.\n NOTE See http://mng.bz/nY9v for examples and documentation about this library.\nDave Where should we start?\nTheo We’ll start with multimethod initialization by creating a dispatch function\ngreetDispatch that defines the signature of the multimethod, validates the\narguments, and emits the type of the animal. Then we’ll pass greetDispatch\nto multi in order to create the greet multimethod. Our dispatch function\nwould then look like this.\nListing13.6 The dispatch function for greet multimethod\nfunction greetDispatch(animal) {\nSignature definition\nif(dev()) {\n--- Page 307 ---\n13.2 Multimethods with single dispatch 279\nif(!ajv.validate(animalSchema, animal)) {\nArgument validation\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nDispatch value\nreturn animal.type;\n}\nMultimethod\ninitialization\nvar greet = multi(greetDispatch);\nTIP A multimethod dispatch function is responsible for three things: it defines the sig-\nnature of the multimethod, it validates the arguments, and it emits a dispatch value.\nDave What’s next?\nTheo Now we need to implement a method for each dispatched value. Let’s start\nwith the method that deals with dogs. We create a greetDog function that\nreceives an animal and then add a dog method to the greet multimethod\nusing the method function from the arrows/multimethod library. The method\nfunction receives two arguments: the dispatched value and a function that cor-\nresponds to the dispatch value.\nListing13.7 Implementation of greet method for dogs\nfunction greetDog(animal) {\nMethod\nconsole.log(\"Woof woof! My name is \" + animal.name);\nimplementation\n}\ngreet = method(\"dog\", greetDog)(greet);\nMethod declaration\nDave Does the method implementation have to be in the same module as the multi-\nmethod initialization?\nTheo No, not at all! Method declarations are decoupled from multimethod initializa-\ntion exactly like class definitions are decoupled from the interface definition.\nThat’s what make multimethods extensible.\nTIP Multimethods provides extensibility by decoupling between multimethod initial-\nization and method implementations.\nDave What about cats and cows?\nTheo We add their method implementations like we did for dogs.\nTheo takes a moment to envision the implementation. Then he codes up two more greet\nmethods for cats and cows.\nListing13.8 Implementation of greet method for cats\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ngreet = method(\"cat\", greetCat)(greet);\n--- Page 308 ---\n280 CHAPTER 13 Polymorphism\nListing13.9 Implementation of greet method for cows\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ngreet = method(\"cow\", greetCow)(greet);\nTIP In the context of multimethods, a method is a function that provides an imple-\nmentation for a dispatch value.\nDave Are the names of dispatch functions and methods important?\nTheo According to what I read, not really, but I like to follow a simple naming con-\nvention: use the name of the multimethod (for example, greet) as a prefix for\nthe dispatch function (for example, greetDispatch) and the methods. Then\nI’d have the Dispatch suffix for the dispatch function and a specific suffix for\neach method (for example, greetDog, greetCat, and greetCow).\nDave How does the multimethod mechanism work under the hood?\nTheo Internally, a multimethod maintains a hash map where the keys are the dis-\npatched values, and the values are the methods. When we add a method, an\nentry is added to the hash map, and when we call the multimethod, we query the\nhash map to find the implementation that corresponds to the dispatched value.\nDave I don’t think you’ve told me yet how to call a multimethod.\nTheo We call it as a regular function. Give me a minute, and I’ll show you an exam-\nple that calls a multimethod.\nListing13.10 Calling a multimethod like a regular function\ngreet(myDog);\n// → \"Woof woof! My name is Fido\"\ngreet(myCat);\n// → \"Meow! I am Milo\"\ngreet(myCow);\n// → \"Moo! Call me Clarabelle\"\nTIP Multimethods are called like regular functions.\nDave You told me earlier that in the dispatch function, we should validate the argu-\nments. Is that mandatory or is it a best practice?\nTheo It’s a best practice.\nDave What happens if the dispatch function doesn’t validate the arguments, and we\npass an invalid argument?\nTheo Like when an animal has no corresponding method?\nDave Exactly!\nTheo In that case, you’ll get an error. For instance, the arrows/multimethods library\nthrows a NoMethodError exception.\nDave That’s annoying. Is there a way to provide a default implementation?\n--- Page 309 ---\n13.3 Multimethods with multiple dispatch 281\nTheo Absolutely! In order to define a default implementation, you pass to method—\nas a single argument—the function that provides the default implementation.\nTheo writes the code and shows it to Dave. Dave then tests Theo’s code and seems satisfied\nwith the result.\nListing13.11 Defining a default implementation\nfunction greetDefault(animal) {\nconsole.log(\"My name is \" + animal.name);\n}\ngreet = method(greetDefault)(greet);\nListing13.12 Calling a multimethod when no method fits the dispatch value\nvar myHorse = {\n\"type\": \"horse\",\n\"name\": \"Horace\"\n};\ngreet(myHorse);\n// → \"My name is Horace\"\nTIP Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\nDave Cool!\n13.3 Multimethods with multiple dispatch\nTheo So far, we’ve mimicked OOP by having the type of the multimethod argument\nas a dispatch value. But if you think again about the flow of a multimethod,\nyou’ll discover something interesting. Would you like to try and draw a dia-\ngram that describes the flow of a multimethod in general?\nDave Let me get a fresh napkin. The one under my glass is a bit wet.\nTheo Uh, Dave, you can use my notebook.\nIt takes Dave a few minutes to draw a diagram like the one in figure 13.2. He pushes the\nnotebook back to Theo.\nValue1 Method1\nHandle case 1\nDispatch function Value3 Method3\nEmit a dispatch value Handle case 3\nargs\nValue2 Method2\nHandle case 2\nFigure 13.2 The logic flow\nof multimethods\n--- Page 310 ---\n282 CHAPTER 13 Polymorphism\nTheo Excellent! I hope you see that the dispatch function can emit any value.\nDave Like what?\nTheo Like emitting the type of two arguments!\nDave What do you mean?\nTheo Imagine that our animals are polyglot.\nDave Poly what?\nTheo Polyglot comes from the Greek polús, meaning much, and from glôssa, meaning\nlanguage. A polyglot is a person who can speak many languages.\nDave What languages would our animals speak?\nTheo I don’t know. Let’s say English and French.\nDave OK, and how would we represent a language in our program?\nTheo With a map, of course!\nDave What fields would we have in a language map?\nTheo Let’s keep things simple and have two fields: type and name.\nDave Like an animal map?\nTheo Not exactly. In a language map, the type field must be either fr for French or en\nfor English, whereas in the animal map, the type field is either dog, cat, or cow.\nDave Let me try to write the language map schema and the two language maps.\nTheo gladly consents; his French press coffee is getting cold! Dave writes his implementa-\ntion of the code and shows Theo.\nListing13.13 The schema of a language map\nvar languageSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nListing13.14 Two language maps\nvar french = {\n\"type\": \"fr\",\n\"name\": \"Français\"\n};\nvar english = {\n\"type\": \"en\",\n\"name\": \"English\"\n};\nTheo Excellent! Now, let’s write the code for the dispatch function and the methods\nfor our polyglot animals. Let’s call our multimethod, greetLang. We have one\ndispatch function and six methods.\n--- Page 311 ---\n13.3 Multimethods with multiple dispatch 283\nDave Right, three animals (dog, cat, and cow) times two languages (en and fr).\nBefore the implementation, I’d like to draw a flow diagram. It will help me to\nmake things crystal clear.\nTheo You need my notebook again?\nNot waiting for Dave to respond, Theo pushes his notebook across the table to Dave. Dave\ndraws a diagram like the one in figure 13.3 and slides the notebook back to Theo.\n[\"dog\", \"en\"] greetLangDogEn\nGreet as a dog in English\n[\"cat\", \"en\"] greetLangCatEn\nGreet as a cat in English\n[\"cow\", \"en\"] greetLangCowEn\nGreet as a cow in English\nargs greetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", \"fr\"] greetLangDogFr\nGreet as a dog in French\n[\"cat\", \"fr\"] greetLangCatFr\nGreet as a cat in French\n[\"cow\", \"fr\"] greetLangCowFr\nGreet as a cow in French\nFigure 13.3 The logic flow of the greetLang multimethod\nTheo Why did you omit the arrow between the arguments and the methods?\nDave In order to keep the diagram readable. Otherwise, there would be too many\narrows.\nTheo OK, I see. Are you ready for coding?\nDave Yes!\nTheo The dispatch function needs to validate its arguments and return an array with\ntwo elements: the type of animal and the type of language.\nDave types for a bit on his laptop. He initializes the multimethod with a dispatch function\nthat returns the type of its arguments and then shows the code to Theo.\nListing13.15 Initializing a multimethod with a dispatch function\nvar greetLangArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [animalSchema, languageSchema]\n};\nfunction greetLangDispatch(animal, language) {\nif(dev()) {\n--- Page 312 ---\n284 CHAPTER 13 Polymorphism\nif(!ajv.validate(greetLangArgsSchema, [animal, language])) {\nthrow (\"greetLang called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [animal.type, language.type];\n};\nvar greetLang = multi(greetLangDispatch);\nDave Does the order of the elements in the array matter?\nTheo It doesn’t matter, but it needs to be consistent with the wiring of the methods.\nThe implementation of greetLang would therefore look like this.\nListing13.16 The implementation of greetLang methods\nfunction greetLangDogEn(animal, language) {\nconsole.log(\"Woof woof! My name is \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"en\"], greetLangDogEn)(greetLang);\nfunction greetLangDogFr(animal, language) {\nconsole.log(\"Ouaf Ouaf! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"fr\"], greetLangDogFr)(greetLang);\nfunction greetLangCatEn(animal, language) {\nconsole.log(\"Meow! I am \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"en\"], greetLangCatEn)(greetLang);\nfunction greetLangCatFr(animal, language) {\nconsole.log(\"Miaou! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"fr\"], greetLangCatFr)(greetLang);\nfunction greetLangCowEn(animal, language) {\nconsole.log(\"Moo! Call me \" +\nanimal.name +\n\" and I speak \" +\n--- Page 313 ---\n13.3 Multimethods with multiple dispatch 285\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"en\"], greetLangCowEn)(greetLang);\nfunction greetLangCowFr(animal, language) {\nconsole.log(\"Meuh! Appelle moi \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"fr\"], greetLangCowFr)(greetLang);\nDave looks at the code for the methods that deal with French. He is surprised to see Ouaf\nOuaf instead of Woof Woof for dogs, Miaou instead of Meow for cats, and Meuh instead of\nMoo for cows.\nDave I didn’t know that animal onomatopoeia were different in French than in\nEnglish!\nTheo Ono what?\nDave Onomatopoeia, from the Greek ónoma that means name and poiéo– that means to\nproduce. It is the property of words that sound like what they represent; for\ninstance, Woof, Meow, and Moo.\nTheo Yeah, for some reason in French, dogs Ouaf, cats Miaou, and cows Meuh.\nDave I see that in the array the animal type is always before the language type.\nTheo Right! As I told you before, in a multimethod that features multiple dispatch,\nthe order doesn’t really matter, but it has to be consistent.\nTIP Multiple dispatch is when a dispatch function emits a value that depends on more\nthan one argument. In a multimethod that features multiple dispatch, the order of\nthe elements in the array emitted by the dispatch function has to be consistent with\nthe order of the elements in the wiring of the methods.\nDave Now let me see if I can figure out how to use a multimethod that features mul-\ntiple dispatch.\nDave remembers that Theo told him earlier that multimethods are used like regular func-\ntions. With that in mind, he comes up with the code for a multimethod that features multi-\nple dispatch.\nListing13.17 Calling a multimethod that features multiple dispatch\ngreetLang(myDog, french);\n// → \"Ouaf Ouaf! Je m\\'appelle Fido et je parle Français\"\ngreetLang(myDog, english);\n// → \"Woof woof! My name is Fido and I speak English\"\ngreetLang(myCat, french);\n// → \"Miaou! Je m\\'appelle Milo et je parle Français\"\n--- Page 314 ---\n286 CHAPTER 13 Polymorphism\ngreetLang(myCat, english);\n// → \"Meow! I am Milo and I speak English\"\ngreetLang(myCow, french);\n// → \"Meuh! Appelle moi Clarabelle et je parle Français\"\ngreetLang(myCow, english);\n// → \"Moo! Call me Clarabelle and I speak English\"\nTheo Now do you agree that multimethods with multiple dispatch offer a more pow-\nerful polymorphism that OOP polymorphism?\nDave Indeed, I do.\nTheo Let me show you an even more powerful polymorphism called dynamic dis-\npatch. But first, let’s get some more of that wonderful French press coffee.\nDave Great idea! While we’re in the kitchen, I think my mom made an orange Bundt\ncake using the oranges from the grove.\n13.4 Multimethods with dynamic dispatch\nDave refills their coffee cups as Theo takes two slices from the cake and dishes them up.\nThey take their coffee and cake outside to enjoy more of the fresh country air before\nresuming their conversation.\nDave What is dynamic dispatch?\nTheo It’s when the dispatch function of a multimethod returns a value that goes\nbeyond the static type of its arguments.\nDave Like what, for example?\nTheo Like a number or a Boolean, for instance.\nDave Why would such a thing be useful?\nTheo Imagine that instead of being polyglot, our animals would suffer from\ndysmakrylexia.\nDave Suffering from what?\nTheo Dysmakrylexia. It comes from the Greek dus, expressing the idea of difficulty,\nmakrýs meaning long, and léxis meaning diction. Therefore, dysmakrylexia is dif-\nficulty pronouncing long words.\nDave I’ve never heard of that.\nTheo That’s because I just invented it.\nDave Funny. What’s considered a long word for our animals?\nTheo Let’s say that when their name has more than five letters, they’re not able to\nsay it.\nDave A bit weird, but OK.\nTheo Let’s call our multimethod dysGreet. Its dispatch function returns an array\nwith two elements: the animal type and a Boolean about whether the name is\nlong or not. Take a look at this multimethod initialization.\n--- Page 315 ---\n13.4 Multimethods with dynamic dispatch 287\nListing13.18 A multimethod using a dispatch function with dynamic dispatch\nfunction dysGreetDispatch(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"dysGreet called with invalid arguments: \" + errors);\n}\n}\nvar hasLongName = animal.name.length > 5;\nreturn [animal.type, hasLongName];\n};\nvar dysGreet = multi(dysGreetDispatch);\nDave Writing the dysGreet methods doesn’t seem too complicated.\nAs Theo reaches over to pass Dave his notebook, he accidently hits his coffee cup. Now Theo’s\nnotebook is completely wet, and all the diagrams are soggy! Fortunately, Dave brought an\nextra napkin from the kitchen, and it’s still clean. He draws a flow diagram as in figure 13.4\nand then grabs his laptop and writes the implementation of the dysGreet methods.\n[\"dog\", true] dysGreetDogLong\nGreet as a dog mentioning name\n[\"cat\", true] dysGreetCatLong\nGreet as a cat mentioning name\n[\"cow\", true] dysGreetCowLong\nGreet as a cow mentioning name\nargs dysGreetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", false] dysGreetDogShort\nGreet as a dog omitting name\n[\"cat\", false] dysGreetCatShort\nGreet as a cat omitting name\n[\"cow\", false] dysGreetCowShort\nGreet as a cow omitting name\nFigure 13.4 The logic flow of the dysGreet multimethod\nListing13.19 The dysGreet methods\nfunction dysGreetDogLong(animal) {\nconsole.log(\"Woof woof! My name is \" + animal.name);\n}\ndysGreet = method([\"dog\", true], dysGreetDogLong)(dysGreet);\n--- Page 316 ---\n288 CHAPTER 13 Polymorphism\nfunction dysGreetDogShort(animal) {\nconsole.log(\"Woof woof!\");\n}\ndysGreet = method([\"dog\", false], dysGreetDogShort)(dysGreet);\nfunction dysGreetCatLong(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ndysGreet = method([\"cat\", true], dysGreetCatLong)(dysGreet);\nfunction dysGreetCatShort(animal) {\nconsole.log(\"Meow!\");\n}\ndysGreet = method([\"cat\", false], dysGreetCatShort)(dysGreet);\nfunction dysGreetCowLong(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ndysGreet = method([\"cow\", true], dysGreetCowLong)(dysGreet);\nfunction dysGreetCowShort(animal) {\nconsole.log(\"Moo!\");\n}\ndysGreet = method([\"cow\", false], dysGreetCowShort)(dysGreet);\nTheo checks that the code works as expected. He compliments Dave, not only on the\nmethod implementation but also for having the foresight to grab an extra napkin.\nListing13.20 Testing dysGreet\ndysGreet(myDog);\ndysGreet(myCow);\ndysGreet(myCat);\n//\"Woof woof!\"\n//\"Moo! Call me Clarabelle\"\n//\"Meow!\"\nTheo Well done, my friend! Our exploration of multimethods has come to an end. I\nthink it’s time for me to drive back if I want to get home before dark and beat\nthe rush hour traffic.\nDave Before you leave, let’s check if multimethods are available in programming\nlanguages other than JavaScript.\nTheo That’s a question for Joe.\nDave Do you think it’s OK if I call him now?\nTheo I think it’s probably better if you send him an email. He’s in a tech conference,\nand I’m not sure if it’s all day. Thank you for this beautiful day in the country\nand the wonderful refreshments.\nDave I enjoyed it, also, especially our discussions about etymology. I think there are\nsome oranges for you to take home and enjoy later.\nTheo Great! I can’t wait until my wife tries one.\n--- Page 317 ---\n13.5 Integrating multimethods in a production system 289\nAfter Theo leaves, Dave sends Joe an email. A few minutes later, Dave receives an email\nfrom Joe with the subject, “Support for multimethods in different languages.”\nSupport for multimethods in different languages\nPython has a library called multimethods (https://github.com/weissjeffm/multimeth-\nods), and Ruby has one called Ruby multimethods (https://github.com/psantacl/\nruby-multimethods). Both seem to work quite like the JavaScript arrows/multi-\nmethod library.\nIn Java, there is the Java Multimethod Framework (http://igm.univ-mlv.fr/~forax/\nworks/jmmf/), and C# supports multimethods natively via the dynamic keyword.\nHowever, in both Java and C#, multimethods work only with static data types and not\nwith generic data structures.\nGeneric data structure\nLanguage URL\nsupport\nJavaScript https://github.com/caderek/arrows/tree/master/ Yes\npackages/multimethod\nJava http://igm.univ-mlv.fr/~forax/works/jmmf/ No\nC# Native support No\nPython https://github.com/weissjeffm/multimethods Yes\nRuby https://github.com/psantacl/ruby-multimethods Yes\n13.5 Integrating multimethods in a production system\nWhile Theo is driving back home, his thoughts take him back to the fresh air of the coun-\ntry. This pleasant moment is interrupted by a phone call from Nancy at Klafim.\nNancy How are you doing?\nTheo Fine. I’m driving back from the countryside.\nNancy Cool. Are you available to talk about work?\nTheo Sure.\nNancy I’d like to add a tiny feature to the catalog.\nIn the past, when Nancy qualified a feature as tiny, it scared Theo because tiny turned into\nhuge. What seemed easy to her always took him a surprising amount of time to develop.\nBut after refactoring the system according to DOP principles, now what seems tiny to\nNancy is usually quite easy to implement.\nTheo What feature?\nNancy I’d like to allow librarians to view the list of authors, ordered by last name, in\ntwo formats: HTML and Markdown.\n--- Page 318 ---\n290 CHAPTER 13 Polymorphism\nTheo It doesn’t sound too complicated.\nNancy Also, I need a bit of text formatting.\nTheo What kind of text formatting?\nNancy Depending on the number of books an author has written, their name should\nbe in bold and italic fonts.\nTheo Could you send me an email with all the details. I’ll take a look at it tomorrow\nmorning.\nNancy Perfect. Have a safe drive!\nBefore going to bed, Theo reflects about today’s etymology lessons. He realizes that he\nnever looked for the etymology of the word etymology itself! He searches for the term etymol-\nogy online and learns that the word etymology derives from the Greek étumon, meaning true\nsense, and the suffix logia, denoting the study of. During the night, Theo dreams of dogs,\ncats, and cows programming on their laptops in a field of grass.\nWhen Theo arrives at the office the next day, he opens Nancy’s email with the details\nabout the text formatting feature. The details are summarized in table 13.1.\nTable 13.1 Text formatting for author names according to the number of books\nthey have written\nNumber of books Italic Bold\n10 or fewer Yes No\nBetween 11 and 50 No Yes\n51 or more Yes Yes\nTheo forwards Nancy’s email to Dave and asks him to take care of this task. Delegating\nresponsibility, after all, is the trait of a great manager.\nDave thinks the most difficult part of the feature lies in implementing an Author\n.myName(author, format) function that receives two arguments: the author data and the\ntext format. He asks himself whether he can implement this function as a multimethod\nand use what he learned yesterday with Theo at his parents’ home in the country. It seems\nthat this feature is quite similar to the one that dealt with dysmakrylexia. Instead of check-\ning the length of a string, he needs to check the length of an array.\nFirst, Dave needs a data schema for the text format. He could represent a format as a\nmap with a type field like Theo did yesterday for languages, but at the moment, it seems\nsimpler to represent a format as a string that could be either markdown or html. He comes\nup with the text format schema in listing 13.21. He already wrote the author schema with\nTheo last week. It’s in listing 13.22.\nListing13.21 The text format schema\nvar textFormatSchema = {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"enum\": [\"markdown\", \"html\"]}\n};\n--- Page 319 ---\n13.5 Integrating multimethods in a production system 291\nListing13.22 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"name\", \"bookIsbns\"],\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nNow, Dave needs to write a dispatch function and initialize the multimethod. Remember-\ning that Theo had no qualms about creating the word dysmakrylexia, he decides that he\nprefers his own neologism, prolificity, over the existing nominal form prolificness. He finds it\nuseful to have an Author.prolificityLevel helper function that returns the level of\nprolificity of the author: either low, medium, or high. Now he’s ready to code the author-\nNameDispatch function.\nListing13.23 Author.myName multimethod initialization\nAuthor.prolificityLevel = function(author) {\nvar books = _.size(_.get(author, \"bookIsbns\"));\nif (books <= 10) {\nreturn \"low\";\n};\nif (books >= 51) {\nreturn \"high\";\n}\nreturn \"medium\";\n};\nvar authorNameArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\nauthorSchema,\n{\"enum\": [\"markdown\", \"html\"]}\n]\n};\nfunction authorNameDispatch(author, format) {\nif(dev()) {\nif(!ajv.validate(authorNameArgsSchema, [author, format])) {\nthrow (\"Author.myName called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [Author.prolificityLevel(author), format];\n};\nAuthor.myName = multi(authorNameDispatch);\n--- Page 320 ---\n292 CHAPTER 13 Polymorphism\nThen Dave works on the methods: first, the HTML format methods. In HTML, bold text is\nwrapped inside a <b> tag, and italic text is wrapped in a <i> tag. For instance, in HTML,\nthree authors with different levels of prolificity would be written like this.\nListing13.24 Examples of bold and italic in HTML\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n<i>Yehonathan Sharvit<i>\nBold and italic formatting\n<b>Stephen Covey</b>\nfor highly prolific authors\n<b><i>Isaac Asimov</i></b>\nWith this information in hand, Dave writes the three methods that deal with HTML for-\nmatting. Easy!\nListing13.25 The methods that deal with HTML formatting\nfunction authorNameLowHtml(author, format) {\nreturn \"<i>\" + _.get(author, \"name\") + \"</i>\";\n}\nAuthor.myName = method([\"low\", \"html\"], authorNameLowHtml)(Author.myName);\nfunction authorNameMediumHtml(author, format) {\nreturn \"<b>\" + _.get(author, \"name\") + \"</b>\";\n}\nAuthor.myName =\nmethod([\"medium\", \"html\"], authorNameMediumHtml)(Author.myName);\nfunction authorNameHighHtml(author, format) {\nreturn \"<b><i>\" + _.get(author, \"name\") + \"</i></b>\";\n}\nAuthor.myName =\nmethod([\"high\", \"html\"], authorNameHighHtml)(Author.myName);\nThen, Dave moves on to the three methods that deal with Markdown formatting. In\nMarkdown, bold text is wrapped in two asterisks, and italic text is wrapped in a single\nasterisk. For instance, in Markdown, three authors with different levels of prolificity\nwould be written like the code in listing 13.26. The code for the Markdown methods is in\nlisting 13.27.\nListing13.26 Examples of bold and italic in Markdown\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n*Yehonathan Sharvit*\nBold and italic formatting\n**Stephen Covey**\nfor highly prolific authors\n***Isaac Asimov***\n--- Page 321 ---\n13.5 Integrating multimethods in a production system 293\nListing13.27 The methods that deal with Markdown formatting\nfunction authorNameLowMarkdown(author, format) {\nreturn \"*\" + _.get(author, \"name\") + \"*\";\n}\nAuthor.myName =\nmethod([\"low\", \"markdown\"], authorNameLowMarkdown)(Author.myName);\nfunction authorNameMediumMarkdown(author, format) {\nreturn \"**\" + _.get(author, \"name\") + \"**\";\n}\nAuthor.myName =\nmethod([\"medium\", \"markdown\"], authorNameMediumMarkdown)(Author.myName);\nfunction authorNameHighMarkdown(author, format) {\nreturn \"***\" + _.get(author, \"name\") + \"***\";\n}\nAuthor.myName =\nmethod([\"high\", \"markdown\"], authorNameHighMarkdown)(Author.myName);\nDave decides to test his code by involving a mysterious author. Listing 13.28 and listing 13.29\nshow the tests.\nListing13.28 Testing HTML formatting\nvar yehonathan = {\n\"name\": \"Yehonathan Sharvit\",\n\"bookIsbns\": [\"9781617298578\"]\n};\nAuthor.myName(yehonathan, \"html\");\n// → \"<i>Yehonathan Sharvit</i>\"\nListing13.29 Testing Markdown formatting\nAuthor.myName(yehonathan, \"markdown\");\n// → \"*Yehonathan Sharvit*\"\nTheo shows up at Dave’s desk and asks to review Dave’s implementation of the list of\nauthors feature. Curious, Theo asks Dave about the author that appears in the test of\nAuthor.myName.\nTheo Who is Yehonathan Sharvit?\nDave I don’t really know. The name appeared when I googled “data-oriented pro-\ngramming” yesterday. He wrote a book on the topic. I thought it would be cool\nto use its ISBN in my test.\n--- Page 322 ---\n294 CHAPTER 13 Polymorphism\nSummary\n The main benefit of polymorphism is extensibility.\n Multimethods make it possible to benefit from polymorphism when data is repre-\nsented with generic maps.\n A multimethod is made of a dispatch function and multiple methods.\n The dispatch function of a multimethod emits a dispatch value.\n Each of the methods used in a multimethod provides an implementation for a\nspecific dispatch value.\n Multimethods can mimic OOP class inheritance via single dispatch.\n In single dispatch, a multimethod receives a single map that contains a type field,\nand the dispatch function of the multimethod emits the value of the type field.\n In addition to single dispatch, multimethods provide two kinds of advanced\npolymorphisms: multiple dispatch and dynamic dispatch.\n Multiple dispatch is used when the behavior of the multimethod depends on\nmultiple arguments.\n Dynamic dispatch is used when the behavior of the multimethod depends on run-\ntime arguments.\n The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\n A multimethod dispatch function is responsible for\n– Defining the signature.\n– Validating the arguments.\n– Emitting a dispatch value.\n Multimethods provides extensibility by decoupling between multimethod ini-\ntialization and method implementations.\n Multimethods are called like regular functions.\n Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\n In a multimethod that features multiple dispatch, the order of the elements in\nthe array emitted by the dispatch function has to be consistent with the order of\nthe elements in the wiring of the methods.\nLodash functions introduced in this chapter\nFunction Description\nsize(coll) Gets the size of coll\n--- Page 323 ---\nAdvanced data\nmanipulation\nWhatever is well-conceived\nis clearly said\nThis chapter covers\n Manipulating nested data\n Writing clear and concise code for business\nlogic\n Separating business logic and generic data\nmanipulation\n Building custom data manipulation tools\n Using the best tool for the job\nWhen our business logic involves advanced data processing, the generic data manip-\nulation functions provided by the language run time and by third-party libraries\nmight not be sufficient. Instead of mixing the details of data manipulation with\nbusiness logic, we can write our own generic data manipulation functions and imple-\nment our custom business logic using them. Separating business logic from the inter-\nnal details of data manipulation makes the business logic code concise and easy to\nread for other developers.\n295\n--- Page 324 ---\n296 CHAPTER 14 Advanced data manipulation\n14.1 Updating a value in a map with eloquence\nDave is more and more autonomous on the Klafim project. He can implement most fea-\ntures on his own, typically turning to Theo only for code reviews. Dave’s code quality stan-\ndards are quite high. Even when his code is functionally solid, he tends to be unsatisfied\nwith its readability. Today, he asks for Theo’s help in improving the readability of the code\nthat fixes a bug Theo introduced a long time ago.\nDave I think I have a found a bug in the code that returns book information from\nthe Open Library API.\nTheo What bug?\nDave Sometimes, the API returns duplicate author names, and we pass the dupli-\ncates through to the client.\nTheo It doesn’t sound like a complicated bug to fix.\nDave Right, I fixed it, but I’m not satisfied with the readability of the code I wrote.\nTheo Being critical of our own code is an important quality for a developer to prog-\nress. What is it exactly that you don’t like?\nDave Take a look at this code.\nListing14.1 Removing duplicates in a straightforward but tedious way\nfunction removeAuthorDuplicates(book) {\nvar authors = _.get(book, \"authors\");\nvar uniqAuthors = _.uniq(authors);\nreturn _.set(book,\"authors\", uniqAuthors);\n}\nDave I’m using _.get to retrieve the array with the author names, then _.uniq to\ncreate a duplicate-free version of the array, and finally, _.set to create a new\nversion of the book with no duplicate author names.\nTheo The code is tedious because the next value of authorNames needs to be based\non its current value.\nDave But it’s a common use case! Isn’t there a simpler way to write this kind of code?\nTheo Your astonishment definitely honors you as a developer, Dave. I agree with you\nthat there must be a simpler way. Let me phone Joe and see if he’s available for\na conference call.\nJoe How’s it going, Theo?\nTheo Great! Are you back from your tech conference?\nJoe I just landed. I’m on my way home now in a taxi.\nTheo How was your talk about DOP?\nJoe Pretty good. At the beginning people were a bit suspicious, but when I told\nthem the story of Albatross and Klafim, it was quite convincing.\nTheo Yeah, adults are like children in that way; they love stories.\nJoe What about you? Did you manage to achieve polymorphism with multimethods?\nTheo Yes! Dave even managed to implement a feature in Klafim with multimethods.\nJoe Cool!\n--- Page 325 ---\n14.1 Updating a value in a map with eloquence 297\nTheo Do you have time to help Dave with a question about programming?\nJoe Sure.\nDave Hi Joe. How are you doing?\nJoe Hello Dave. Not bad. What kind of help do you need?\nDave I’m wondering if there’s a simpler way to remove duplicates inside an array\nvalue in a map. Using _.get, _.uniq, and _.set looks quite tedious.\nJoe You should build your own data manipulation tools.\nDave What do you mean?\nJoe You should write a generic update function that updates a value in a map,\napplying a calculation based on its current value.1\nDave What would the arguments of update be in your opinion?\nJoe Put the cart before the horse.\nDave What?!\nJoe Rewrite your business logic as if update were already implemented, and you’ll\ndiscover what the arguments of update should be.\nDave I see what you mean: the horse is the implementation of update, and the cart is\nthe usage of update.\nJoe Exactly. But remember, it’s better if you keep your update function generic.\nDave How?\nJoe By not limiting it to your specific use case.\nDave I see. The implementation of update should not deal with removing duplicate\nelements. Instead, it should receive the updating function—in my case,\n_.uniq—as an argument.\nJoe Exactly! Uh, sorry Dave, I gotta go, I just got home. Good luck!\nDave Take care, Joe, and thanks!\nDave ends the conference call. Looking at Theo, he reiterates the conversation with Joe.\nDave Joe advised me to write my own update function. For that purpose, he told me\nto start by rewriting removeAuthorDuplicates as if update were already\nimplemented. That will allow us to make sure we get the signature of update\nright.\nTheo Sounds like a plan.\nDave Joe called it “putting the cart before the horse.”\nTheo Joe and his funny analogies...\nTIP The best way to find the signature of a custom data manipulation function is to\nthink about the most convenient way to use it.\nDave Anyway, the way I’d like to use update inside removeAuthorDuplicates is\nlike this.\n1 Lodash provides an implementation of update, but for the sake of teaching, we are writing our own imple-\nmentation.\n--- Page 326 ---\n298 CHAPTER 14 Advanced data manipulation\nListing14.2 The code that removes duplicates in an elegant way\nfunction removeAuthorDuplicates(book) {\nreturn update(book, \"authors\", _.uniq);\n}\nTheo Looks good to me!\nDave Wow! Now the code with update is much more elegant than the code with\n_.get and _.set!\nTheo Before you implement update, I suggest that you write down in plain English\nexactly what the function does.\nDave It’s quite easy: update receives a map called map, a path called path, and a\nfunction called fun. It returns a new version of map, where path is associated\nwith fun(currentValue), and currentValue is the value associated with\npath in map.\nThinking out loud, Dave simultaneously draws a diagram like that in figure 14.1. Theo is\nbecoming more and more impressed with his young protegé as he studies the figure.\n{\n\"position\" : \"manager\", \"income\"\n\"income\" : 100000\n} map fun path\nupdate\n{\n\"position\" : \"manager\",\n\"income\" : fun(100000)\nres Figure 14.1 The\n}\nbehavior of update\nTIP Before implementing a custom data manipulation function, formulate in plain\nEnglish exactly what the function does.\nTheo With such a clear definition, it’s going to be a piece of cake to implement\nupdate!\nAfter a few minutes, Dave comes up with the code. It doesn’t take long because the plain-\nEnglish diagram helps him to organize the code.\nListing14.3 A generic update function\nfunction update(map, path, fun) {\nvar currentValue = _.get(map, path);\nvar nextValue = fun(currentValue);\nreturn _.set(map, path, nextValue);\n}\n--- Page 327 ---\n14.2 Manipulating nested data 299\nTheo Why don’t you see if it works with a simple case such as incrementing a number\nin a map?\nDave Good idea! I’ll try multiplying a value in a map by 2 with update. How’s this\nlook?\nListing14.4 Multiplying a value in a map by 2\nvar m = {\n\"position\": \"manager\",\n\"income\": 100000\n};\nupdate(m, \"income\", function(x) {\nreturn x * 2;\n});\n// → {\"position\": \"manager\", \"income\": 200000}\nTheo Great! It seems to work.\n14.2 Manipulating nested data\nThe next Monday, during Theo and Dave’s weekly sync meeting, they discuss the upcom-\ning features for Klafim. Theo fondly remembers another Monday where they met at Dave’s\nfamily home in the country. Coming back to the present moment, Theo begins.\nTheo Recently, Nancy has been asking for more and more administrative features.\nDave Like what?\nTheo I’ll give you a few examples.... Let me find the email I got from Nancy yesterday.\nDave OK.\nTheo Here it is. There are three feature requests for now: listing all the book author\nIDs, calculating the book lending ratio, and grouping books by a physical library.\nDave What feature should I tackle first?\nTheo It doesn’t matter, but you should deliver the three of these before the end of\nthe week. Good luck, and don’t hesitate to call me if you need help.\nOn Tuesday, Dave asks for Theo’s help. Dave is not pleased with how his code looks.\nDave I started to work on the three admin features, but I don’t like the code I wrote.\nLet me show you the code for retrieving the list of author IDs from the list of\nbooks returned from the database.\nTheo Can you remind me what an element in a book list returned from the database\nlooks like?\nDave Each book is a map with an authorIds array field.\nTheo OK, so it sounds like a map over the books should do it.\nDave This is what I did, but it doesn’t work as expected. Here’s my code for listing\nthe book author IDs.\n--- Page 328 ---\n300 CHAPTER 14 Advanced data manipulation\nListing14.5 Retrieving the author IDs in books as an array of arrays\nfunction authorIdsInBooks(books) {\nreturn _.map(books, \"authorIds\");\n}\nTheo What’s the problem?\nDave The problem is that it returns an array of arrays of author IDs instead of an\narray of author IDs. For instance, when I run authorIdsInBooks on a catalog\nwith two books, I get this result.\nListing14.6 The author IDs in an array of arrays\n[\n[\"sean-covey\", \"stephen-covey\"],\n[\"alan-moore\", \"dave-gibbons\"]\n]\nTheo That’s not a big problem. You can flatten an array of arrays with _.flatten,\nand you should get the result you expect.\nDave Nice! This is exactly what I need! Give me a moment to fix the code of\nauthorIdsInBooks. . . here you go.\nListing14.7 Retrieving the author IDs in books as an array of strings\nfunction authorIdsInBooks(books) {\nreturn _.flatten(_.map(books, \"authorIds\"));\n}\nTheo Don’t you think that mapping and then flattening deserves a function of its own?\nDave Maybe. It’s quite easy to implement a flatMap function.2 How about this?\nListing14.8 The implementation of flatMap\nfunction flatMap(coll, f) {\nreturn _.flatten(_.map(coll,f));\n}\nTheo Nice!\nDave I don’t know.... It’s kind of weird to have such a small function.\nTheo I don’t think that code size is what matters here.\nDave What do you mean?\nTheo See what happens when you rewrite authorIdsInBooks using flatMap.\nDave OK, here’s how I’d use flatMap to list the author IDs.\n2 Lodash provides an implementation of flatMap, but for the sake of teaching, we are writing our own\nimplementation.\n--- Page 329 ---\n14.3 Using the best tool for the job 301\nListing14.9 Retrieving the author IDs as an array of strings using flatMap\nfunction authorIdsInBooks(books) {\nreturn flatMap(books, \"authorIds\");\n}\nTheo What implementation do you prefer, the one with flatten and map (in listing\n14.7) or the one with flatMap (in listing 14.9)?\nDave I don’t know. To me, they look quite similar.\nTheo Right, but which implementation is more readable?\nDave Well, assuming I know what flatMap does, I would say the implementation\nwith flatMap. Because it’s more concise, it is a bit more readable.\nTheo Again, it’s not about the size of the code. It’s about the clarity of intent and the\npower of naming things.\nDave I don’t get that.\nTheo Let me give you an example from our day-to-day language.\nDave OK.\nTheo Could you pass me that thing on your desk that’s used for writing?\nIt takes Dave a few seconds to get that Theo has asked him to pass the pen on the desk.\nAfter he passes Theo the pen, he asks:\nDave Why didn’t you simply ask for the pen?\nTheo I wanted you to experience how it feels when we use descriptions instead of\nnames to convey our intent.\nDave Oh, I see. You mean that once we use a name for the operation that maps and\nflattens, the code becomes clearer.\nTheo Exactly.\nDave Let’s move on to the second admin feature: calculating the book lending ratio.\nTheo Before that, I think we deserve a short period for rest and refreshments, where\nwe drink a beverage made by percolation from roasted and ground seeds.\nDave A coffee break!\n14.3 Using the best tool for the job\nAfter the coffee break, Dave shows Theo his implementation of the book lending ratio cal-\nculation. This time, he seems to like the code he wrote.\nDave I’m quite proud of the code I wrote to calculate the book lending ratio.\nTheo Show me the money!\nDave My function receives a list of books from the database like this.\nListing14.10 A list of two books with bookItems\n[\n{\n\"isbn\": \"978-1779501127\",\n--- Page 330 ---\n302 CHAPTER 14 Advanced data manipulation\n\"title\": \"Watchmen\",\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n}\n]\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"bookItems\": [\n{\n\"id\": \"book-item-123\",\n\"libId\": \"hudson-park-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-17\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n]\nTheo Quite a nested piece of data!\nDave Yeah, but now that I’m using flatMap, calculating the lending ratio is quite\neasy. I’m going over all the book items with forEach and incrementing either\nthe lent or the notLent counter. At the end, I return the ratio between lent\nand (lent + notLent). Here’s how I do that.\nListing14.11 Calculating the book lending ratio using forEach\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar lent = 0;\nvar notLent = 0;\n_.forEach(bookItems, function(item) {\nif(_.get(item, \"isLent\")) {\nlent = lent + 1;\n} else {\nnotLent = notLent + 1;\n}\n});\nreturn lent/(lent + notLent);\n}\nTheo Would you allow me to tell you frankly what I think of your code?\nDave If you are asking this question, it means that you don’t like it. Right?\nTheo It’s nothing against you; I don’t like any piece of code with forEach.\n--- Page 331 ---\n14.3 Using the best tool for the job 303\nDave What’s wrong with forEach?\nTheo It’s too generic!\nDave I thought that genericity was a positive thing in programming.\nTheo It is when we build a utility function, but when we use a utility function, we\nshould use the least generic function that solves our problem.\nDave Why?\nTheo Because we ought to choose the right tool for the job, like in the real life.\nDave What do you mean?\nTheo Let me give you an example. Yesterday, I had to clean my drone from the\ninside. Do you think that I used a screwdriver or a Swiss army knife to unscrew\nthe drone cover?\nDave A screwdriver, of course! It’s much more convenient to manipulate.\nTheo Right. Also, imagine that someone looks at me using a screwdriver. It’s quite\nclear to them that I am turning a screw. It conveys my intent clearly.\nDave Are you saying that forEach is like the Swiss army knife of data manipulation?\nTheo That’s a good way to put it.\nTIP Pick the least generic utility function that solves your problem.\nDave What function should I use then, to iterate over the book item collection?\nTheo You could use _.reduce.\nDave I thought reduce was about returning data from a collection. Here, I don’t\nneed to return data; I need to update two variables, lent and notLent.\nTheo You could represent those two values in a map with two keys.\nDave Can you show me how to rewrite my lendingRatio function using reduce?\nTheo Sure. The initial value passed to reduce is the map, {\"lent\": 0, \"notLent\": 0},\nand inside each iteration, we update one of the two keys, like this.\nListing14.12 Calculating the book lending ratio using reduce\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = _.reduce(bookItems, function(res, item) {\nif(_.get(item, \"isLent\")) {\nres.lent = res.lent + 1;\n} else {\nres.notLent = res.notLent + 1;\n}\nreturn res;\n}, {notLent: 0, lent:0});\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nDave Instead of updating the variables lent and notLent, now we are updating lent\nand notLent map fields. What’s the difference?\n--- Page 332 ---\n304 CHAPTER 14 Advanced data manipulation\nTheo Dealing with map fields instead of variables allows us to get rid of reduce in\nour business logic code.\nDave How could you iterate over a collection without forEach and without reduce?\nTheo I can’t avoid the iteration over a collection, but I can hide reduce behind a\nutility function. Take a look at the way reduce is used inside the code of\nlendingRatio. What is the meaning of the reduce call?\nDave looks at the code in listing 14.12. He thinks for a long moment before he answers.\nDave I think it’s counting the number of times isLent is true and false.\nTheo Right. Now, let’s use Joe’s advice about building our own data manipulation\ntool.\nDave How exactly?\nTheo I suggest that you write a countByBoolField utility function that counts the\nnumber of times a field is true and false.\nDave OK, but before implementing this function, let me first rewrite the code of\nlendingRatio, assuming this function already exists.\nTheo You are definitely a fast learner, Dave!\nDave Thanks! I think that by using countByBoolField, the code for calculating the\nlending ratio using a custom utility function would be something like this.\nListing14.13 Calculating the book lending ratio\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = countByBoolField(bookItems, \"isLent\", \"lent\", \"notLent\");\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nTIP Don’t use _.reduce or any other low-level data manipulation function inside\ncode that deals with business logic. Instead, write a utility function—with a proper\nname—that hides _.reduce.\nTheo Perfect. Don’t you think that this code is clearer than the code using _.reduce?\nDave I do! The code is both more concise and the intent is clearer. Let me see if I\ncan implement countByBoolField now.\nTheo I suggest that you write a unit test first.\nDave Good idea.\nDave types for a bit. When he’s satisfied, he shows Theo the result.\nListing14.14 A unit test for countByBoolField\nvar input = [\n{\"a\": true},\n{\"a\": false},\n{\"a\": true},\n--- Page 333 ---\n14.4 Unwinding at ease 305\n{\"a\": true}\n];\nvar expectedRes = {\n\"aTrue\": 3,\n\"aFalse\": 1\n};\n_.isEqual(countByBoolField(input, \"a\", \"aTrue\", \"aFalse\"), expectedRes);\nTheo Looks good to me. Now, for the implementation of countByBoolField, I\nthink you are going to need our update function.\nDave I think you’re right. On each iteration, I need to increment the value of either\naTrue or aFalse using update and a function that increments a number by 1.\nAfter a few minutes of trial and error, Dave comes up with the piece of code that uses\nreduce, update, and inc. He shows Theo the code for countByBoolField.\nListing14.15 The implementation of countByBoolField\nfunction inc (n) {\nreturn n + 1;\n}\nfunction countByBoolField(coll, field, keyTrue, keyFalse) {\nreturn _.reduce(coll, function(res, item) {\nif (_.get(item, field)) {\nreturn update(res, keyTrue, inc);\n}\nreturn update(res, keyFalse, inc);\n}, {[keyTrue]: 0,\nCreates a map with\n[keyFalse]: 0});\nkeyTrue and keyFalse\n}\nassociated to 0\nTheo Well done! Shall we move on and review the third admin feature?\nDave The third feature is more complicated. I would like to use the teachings from\nthe first two features for the implementation of the third feature.\nTheo OK. Call me when you’re ready for the code review.\n14.4 Unwinding at ease\nDave really struggled with the implementation of the last admin feature, grouping books\nby a physical library. After a couple of hours of frustration, Dave calls Theo for a rescue.\nDave I really had a hard time implementing the grouping by library feature.\nTheo I only have a couple of minutes before my next meeting, but I can try to help\nyou. What’s the exact definition of grouping by library?\nDave Let me show you the unit test I wrote.",
        "sections_found": []
      },
      "accurate_page_range": "303-333"
    },
    {
      "text": "- 12.4 Automatic generation of data model diagrams",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "raw_line": "- 12.4 Automatic generation of data model diagrams (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 102,
      "chapter_info": {
        "page": 303,
        "title": "Advanced data validation",
        "pattern_matched": "Chapter 12",
        "text_preview": "13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with "
      },
      "chapter_sections": {
        "start_page": 303,
        "end_page": 333,
        "content": "\n--- Page 303 ---\n13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with maps\nvar myDog = {\n\"type\": \"dog\",\n\"name\": \"Fido\"\n};\nvar myCat = {\n\"type\": \"cat\",\n\"name\": \"Milo\"\n};\nvar myCow = {\n\"type\": \"cow\",\n\"name\": \"Clarabelle\"\n};\nDave Could you have given another name to the field that holds the animal type?\nTheo Absolutely. It could be anything.\nDave I see. You’re asking me the fundamental difference between your code with a\nswitch statement and my code with an interface and three classes?\nTheo Exactly.\nDave First of all, if you pass an invalid map to your greet function, bad things will\nhappen.\nTheo You’re right. Let me fix that and validate input data.\nListing13.4 Data validation\nvar animalSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nSee chapter 12 about\ndata validation for\nfunction greet(animal) {\ndetails.\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\n--- Page 304 ---\n276 CHAPTER 13 Polymorphism\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\nbreak;\ncase \"cat\":\nconsole.log(\"Meow! I am: \" + animal.name);\nbreak;\ncase \"cow\":\nconsole.log(\"Moo! Call me \" + animal.name);\nbreak;\n};\n}\n NOTE You should not use switch statements like this in your production code.\nWe use them here for didactic purposes only as a step towards distilling the essence of\npolymorphism.\nDave Another drawback of your approach is that when you want to modify the\nimplementation of greet for a specific animal, you have to change the code\nthat deals with all the animals, while in my approach, you would change only a\nspecific animal class.\nTheo I agree, and I could also fix that by having a separate function for each animal,\nsomething like this.\nListing13.5 Different implementations in different functions\nfunction greetDog(animal) {\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\n}\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am: \" + animal.name);\n}\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\nfunction greet(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\ngreetDog(animal);\nbreak;\ncase \"cat\":\ngreetCat(animal);\nbreak;\ncase \"cow\":\ngreetCow(animal);\n--- Page 305 ---\n13.2 Multimethods with single dispatch 277\nbreak;\n};\n}\nDave But what if you want to extend the functionality of greet and add a new animal?\nTheo Now you got me. I admit that with a switch statement, I can’t add a new animal\nwithout modifying the original code, whereas in OOP, I can add a new class\nwithout having to modify the original code.\nDave Yeah, but you helped me to realize that the main benefit of polymorphism is\nthat it makes the code easily extensible.\nTIP The main benefit of polymorphism is extensibility.\nTheo I’m going to ask Joe if there’s a way to benefit from polymorphism without\nobjects.\nTheo sends a message to Joe and asks him about polymorphism in DOP. Joe answers that\nhe doesn’t have time to get into a deep response because he is in a tech conference where\nhe is about to give a talk about DOP. The only thing he has time to tell Theo is that he\nshould take a look at multimethods.\nTheo and Dave read some online material about multimethods. It doesn’t look too\ncomplicated. They decide that after lunch they will give multimethods a try.\n13.2 Multimethods with single dispatch\nDuring lunch, Theo asks Dave how it feels to have grown up in the country. Dave starts\nwith an enthusiastic description about being in direct contact with nature and living a sim-\npler life than in the city. He’s grateful for the experience, but he admits that country life\ncan sometimes be hard without the conveniences of the city. But who said simple was easy?\nAfter lunch, they decide to have coffee. Dave asks Theo if he’d like to grind the coffee\nbeans himself. Theo accepts with joy. Next, Dave explains how to use a French press coffee\nmaker to get the ideal tradeoff between bitterness and rich taste. While savoring their\nFrench press coffee in the garden, Theo and Dave continue their exploration of polymor-\nphism à la DOP.\nTheo From what I read before lunch, it seems that multimethods are a software con-\nstruct that provide polymorphism without the need for objects.\nDave I don’t get how that’s possible.\nTheo Multimethods have two parts: a dispatch function and a set of methods that\nprovide an implementation for each dispatched value.\nDave I’m not sure I’m clear on that. Is a dispatch function like an interface?\nTheo It’s like an interface in the sense that it defines the way the function needs to\nbe called, but it goes beyond that. It also dispatches a value that differentiates\nbetween the different implementations.\nDave That’s a bit abstract for me.\nTheo I think I understand how to implement the animal greeting capabilities. If we\nuse a multimethod called greet, we need a dispatch function and three\nmethods. Let’s call the dispatch function greetDispatch. It dispatches the\nanimal type, either \"dog\", \"cat\", or \"cow\". Then, each dispatch value is\n--- Page 306 ---\n278 CHAPTER 13 Polymorphism\nhandled by a specific method: \"dog\" by greetDog, \"cat\" by greetCat, and\n\"cow\" by greetCow.\nTheo takes out his notebook and opens it to a blank piece of paper. He draws a diagram\nlike the one in figure 13.1.\n\"dog\" greetDog\nGreet as a dog\ngreetDispatch \"cat\" greetCat\nEmit the animal type Greet as a cat\nanimal\ntype, name \"cow\" greetCow\nGreet as a cow\nFigure 13.1 The logic flow\nof the greet multimethod\nDave Why is there an arrow between animal and the methods, in addition to the\narrows between animal and the dispatch functions?\nTheo Because the arguments of a multimethod are passed to the dispatch function\nand to the methods.\nTIP The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\nDave Arguments plural?... I see only a single argument.\nTheo You’re right. Right now our multimethod only receives a single argument, but\nsoon it will receive several arguments.\nDave I see. Could you show me how to write the code for the greet multimethod?\nTheo For that, we need a library. For instance, in JavaScript, the arrows/multi-\nmethod library provides an implementation of multimethods. Basically, we call\nmulti to create a multimethod called method to add a method.\n NOTE See http://mng.bz/nY9v for examples and documentation about this library.\nDave Where should we start?\nTheo We’ll start with multimethod initialization by creating a dispatch function\ngreetDispatch that defines the signature of the multimethod, validates the\narguments, and emits the type of the animal. Then we’ll pass greetDispatch\nto multi in order to create the greet multimethod. Our dispatch function\nwould then look like this.\nListing13.6 The dispatch function for greet multimethod\nfunction greetDispatch(animal) {\nSignature definition\nif(dev()) {\n--- Page 307 ---\n13.2 Multimethods with single dispatch 279\nif(!ajv.validate(animalSchema, animal)) {\nArgument validation\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nDispatch value\nreturn animal.type;\n}\nMultimethod\ninitialization\nvar greet = multi(greetDispatch);\nTIP A multimethod dispatch function is responsible for three things: it defines the sig-\nnature of the multimethod, it validates the arguments, and it emits a dispatch value.\nDave What’s next?\nTheo Now we need to implement a method for each dispatched value. Let’s start\nwith the method that deals with dogs. We create a greetDog function that\nreceives an animal and then add a dog method to the greet multimethod\nusing the method function from the arrows/multimethod library. The method\nfunction receives two arguments: the dispatched value and a function that cor-\nresponds to the dispatch value.\nListing13.7 Implementation of greet method for dogs\nfunction greetDog(animal) {\nMethod\nconsole.log(\"Woof woof! My name is \" + animal.name);\nimplementation\n}\ngreet = method(\"dog\", greetDog)(greet);\nMethod declaration\nDave Does the method implementation have to be in the same module as the multi-\nmethod initialization?\nTheo No, not at all! Method declarations are decoupled from multimethod initializa-\ntion exactly like class definitions are decoupled from the interface definition.\nThat’s what make multimethods extensible.\nTIP Multimethods provides extensibility by decoupling between multimethod initial-\nization and method implementations.\nDave What about cats and cows?\nTheo We add their method implementations like we did for dogs.\nTheo takes a moment to envision the implementation. Then he codes up two more greet\nmethods for cats and cows.\nListing13.8 Implementation of greet method for cats\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ngreet = method(\"cat\", greetCat)(greet);\n--- Page 308 ---\n280 CHAPTER 13 Polymorphism\nListing13.9 Implementation of greet method for cows\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ngreet = method(\"cow\", greetCow)(greet);\nTIP In the context of multimethods, a method is a function that provides an imple-\nmentation for a dispatch value.\nDave Are the names of dispatch functions and methods important?\nTheo According to what I read, not really, but I like to follow a simple naming con-\nvention: use the name of the multimethod (for example, greet) as a prefix for\nthe dispatch function (for example, greetDispatch) and the methods. Then\nI’d have the Dispatch suffix for the dispatch function and a specific suffix for\neach method (for example, greetDog, greetCat, and greetCow).\nDave How does the multimethod mechanism work under the hood?\nTheo Internally, a multimethod maintains a hash map where the keys are the dis-\npatched values, and the values are the methods. When we add a method, an\nentry is added to the hash map, and when we call the multimethod, we query the\nhash map to find the implementation that corresponds to the dispatched value.\nDave I don’t think you’ve told me yet how to call a multimethod.\nTheo We call it as a regular function. Give me a minute, and I’ll show you an exam-\nple that calls a multimethod.\nListing13.10 Calling a multimethod like a regular function\ngreet(myDog);\n// → \"Woof woof! My name is Fido\"\ngreet(myCat);\n// → \"Meow! I am Milo\"\ngreet(myCow);\n// → \"Moo! Call me Clarabelle\"\nTIP Multimethods are called like regular functions.\nDave You told me earlier that in the dispatch function, we should validate the argu-\nments. Is that mandatory or is it a best practice?\nTheo It’s a best practice.\nDave What happens if the dispatch function doesn’t validate the arguments, and we\npass an invalid argument?\nTheo Like when an animal has no corresponding method?\nDave Exactly!\nTheo In that case, you’ll get an error. For instance, the arrows/multimethods library\nthrows a NoMethodError exception.\nDave That’s annoying. Is there a way to provide a default implementation?\n--- Page 309 ---\n13.3 Multimethods with multiple dispatch 281\nTheo Absolutely! In order to define a default implementation, you pass to method—\nas a single argument—the function that provides the default implementation.\nTheo writes the code and shows it to Dave. Dave then tests Theo’s code and seems satisfied\nwith the result.\nListing13.11 Defining a default implementation\nfunction greetDefault(animal) {\nconsole.log(\"My name is \" + animal.name);\n}\ngreet = method(greetDefault)(greet);\nListing13.12 Calling a multimethod when no method fits the dispatch value\nvar myHorse = {\n\"type\": \"horse\",\n\"name\": \"Horace\"\n};\ngreet(myHorse);\n// → \"My name is Horace\"\nTIP Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\nDave Cool!\n13.3 Multimethods with multiple dispatch\nTheo So far, we’ve mimicked OOP by having the type of the multimethod argument\nas a dispatch value. But if you think again about the flow of a multimethod,\nyou’ll discover something interesting. Would you like to try and draw a dia-\ngram that describes the flow of a multimethod in general?\nDave Let me get a fresh napkin. The one under my glass is a bit wet.\nTheo Uh, Dave, you can use my notebook.\nIt takes Dave a few minutes to draw a diagram like the one in figure 13.2. He pushes the\nnotebook back to Theo.\nValue1 Method1\nHandle case 1\nDispatch function Value3 Method3\nEmit a dispatch value Handle case 3\nargs\nValue2 Method2\nHandle case 2\nFigure 13.2 The logic flow\nof multimethods\n--- Page 310 ---\n282 CHAPTER 13 Polymorphism\nTheo Excellent! I hope you see that the dispatch function can emit any value.\nDave Like what?\nTheo Like emitting the type of two arguments!\nDave What do you mean?\nTheo Imagine that our animals are polyglot.\nDave Poly what?\nTheo Polyglot comes from the Greek polús, meaning much, and from glôssa, meaning\nlanguage. A polyglot is a person who can speak many languages.\nDave What languages would our animals speak?\nTheo I don’t know. Let’s say English and French.\nDave OK, and how would we represent a language in our program?\nTheo With a map, of course!\nDave What fields would we have in a language map?\nTheo Let’s keep things simple and have two fields: type and name.\nDave Like an animal map?\nTheo Not exactly. In a language map, the type field must be either fr for French or en\nfor English, whereas in the animal map, the type field is either dog, cat, or cow.\nDave Let me try to write the language map schema and the two language maps.\nTheo gladly consents; his French press coffee is getting cold! Dave writes his implementa-\ntion of the code and shows Theo.\nListing13.13 The schema of a language map\nvar languageSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nListing13.14 Two language maps\nvar french = {\n\"type\": \"fr\",\n\"name\": \"Français\"\n};\nvar english = {\n\"type\": \"en\",\n\"name\": \"English\"\n};\nTheo Excellent! Now, let’s write the code for the dispatch function and the methods\nfor our polyglot animals. Let’s call our multimethod, greetLang. We have one\ndispatch function and six methods.\n--- Page 311 ---\n13.3 Multimethods with multiple dispatch 283\nDave Right, three animals (dog, cat, and cow) times two languages (en and fr).\nBefore the implementation, I’d like to draw a flow diagram. It will help me to\nmake things crystal clear.\nTheo You need my notebook again?\nNot waiting for Dave to respond, Theo pushes his notebook across the table to Dave. Dave\ndraws a diagram like the one in figure 13.3 and slides the notebook back to Theo.\n[\"dog\", \"en\"] greetLangDogEn\nGreet as a dog in English\n[\"cat\", \"en\"] greetLangCatEn\nGreet as a cat in English\n[\"cow\", \"en\"] greetLangCowEn\nGreet as a cow in English\nargs greetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", \"fr\"] greetLangDogFr\nGreet as a dog in French\n[\"cat\", \"fr\"] greetLangCatFr\nGreet as a cat in French\n[\"cow\", \"fr\"] greetLangCowFr\nGreet as a cow in French\nFigure 13.3 The logic flow of the greetLang multimethod\nTheo Why did you omit the arrow between the arguments and the methods?\nDave In order to keep the diagram readable. Otherwise, there would be too many\narrows.\nTheo OK, I see. Are you ready for coding?\nDave Yes!\nTheo The dispatch function needs to validate its arguments and return an array with\ntwo elements: the type of animal and the type of language.\nDave types for a bit on his laptop. He initializes the multimethod with a dispatch function\nthat returns the type of its arguments and then shows the code to Theo.\nListing13.15 Initializing a multimethod with a dispatch function\nvar greetLangArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [animalSchema, languageSchema]\n};\nfunction greetLangDispatch(animal, language) {\nif(dev()) {\n--- Page 312 ---\n284 CHAPTER 13 Polymorphism\nif(!ajv.validate(greetLangArgsSchema, [animal, language])) {\nthrow (\"greetLang called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [animal.type, language.type];\n};\nvar greetLang = multi(greetLangDispatch);\nDave Does the order of the elements in the array matter?\nTheo It doesn’t matter, but it needs to be consistent with the wiring of the methods.\nThe implementation of greetLang would therefore look like this.\nListing13.16 The implementation of greetLang methods\nfunction greetLangDogEn(animal, language) {\nconsole.log(\"Woof woof! My name is \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"en\"], greetLangDogEn)(greetLang);\nfunction greetLangDogFr(animal, language) {\nconsole.log(\"Ouaf Ouaf! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"fr\"], greetLangDogFr)(greetLang);\nfunction greetLangCatEn(animal, language) {\nconsole.log(\"Meow! I am \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"en\"], greetLangCatEn)(greetLang);\nfunction greetLangCatFr(animal, language) {\nconsole.log(\"Miaou! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"fr\"], greetLangCatFr)(greetLang);\nfunction greetLangCowEn(animal, language) {\nconsole.log(\"Moo! Call me \" +\nanimal.name +\n\" and I speak \" +\n--- Page 313 ---\n13.3 Multimethods with multiple dispatch 285\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"en\"], greetLangCowEn)(greetLang);\nfunction greetLangCowFr(animal, language) {\nconsole.log(\"Meuh! Appelle moi \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"fr\"], greetLangCowFr)(greetLang);\nDave looks at the code for the methods that deal with French. He is surprised to see Ouaf\nOuaf instead of Woof Woof for dogs, Miaou instead of Meow for cats, and Meuh instead of\nMoo for cows.\nDave I didn’t know that animal onomatopoeia were different in French than in\nEnglish!\nTheo Ono what?\nDave Onomatopoeia, from the Greek ónoma that means name and poiéo– that means to\nproduce. It is the property of words that sound like what they represent; for\ninstance, Woof, Meow, and Moo.\nTheo Yeah, for some reason in French, dogs Ouaf, cats Miaou, and cows Meuh.\nDave I see that in the array the animal type is always before the language type.\nTheo Right! As I told you before, in a multimethod that features multiple dispatch,\nthe order doesn’t really matter, but it has to be consistent.\nTIP Multiple dispatch is when a dispatch function emits a value that depends on more\nthan one argument. In a multimethod that features multiple dispatch, the order of\nthe elements in the array emitted by the dispatch function has to be consistent with\nthe order of the elements in the wiring of the methods.\nDave Now let me see if I can figure out how to use a multimethod that features mul-\ntiple dispatch.\nDave remembers that Theo told him earlier that multimethods are used like regular func-\ntions. With that in mind, he comes up with the code for a multimethod that features multi-\nple dispatch.\nListing13.17 Calling a multimethod that features multiple dispatch\ngreetLang(myDog, french);\n// → \"Ouaf Ouaf! Je m\\'appelle Fido et je parle Français\"\ngreetLang(myDog, english);\n// → \"Woof woof! My name is Fido and I speak English\"\ngreetLang(myCat, french);\n// → \"Miaou! Je m\\'appelle Milo et je parle Français\"\n--- Page 314 ---\n286 CHAPTER 13 Polymorphism\ngreetLang(myCat, english);\n// → \"Meow! I am Milo and I speak English\"\ngreetLang(myCow, french);\n// → \"Meuh! Appelle moi Clarabelle et je parle Français\"\ngreetLang(myCow, english);\n// → \"Moo! Call me Clarabelle and I speak English\"\nTheo Now do you agree that multimethods with multiple dispatch offer a more pow-\nerful polymorphism that OOP polymorphism?\nDave Indeed, I do.\nTheo Let me show you an even more powerful polymorphism called dynamic dis-\npatch. But first, let’s get some more of that wonderful French press coffee.\nDave Great idea! While we’re in the kitchen, I think my mom made an orange Bundt\ncake using the oranges from the grove.\n13.4 Multimethods with dynamic dispatch\nDave refills their coffee cups as Theo takes two slices from the cake and dishes them up.\nThey take their coffee and cake outside to enjoy more of the fresh country air before\nresuming their conversation.\nDave What is dynamic dispatch?\nTheo It’s when the dispatch function of a multimethod returns a value that goes\nbeyond the static type of its arguments.\nDave Like what, for example?\nTheo Like a number or a Boolean, for instance.\nDave Why would such a thing be useful?\nTheo Imagine that instead of being polyglot, our animals would suffer from\ndysmakrylexia.\nDave Suffering from what?\nTheo Dysmakrylexia. It comes from the Greek dus, expressing the idea of difficulty,\nmakrýs meaning long, and léxis meaning diction. Therefore, dysmakrylexia is dif-\nficulty pronouncing long words.\nDave I’ve never heard of that.\nTheo That’s because I just invented it.\nDave Funny. What’s considered a long word for our animals?\nTheo Let’s say that when their name has more than five letters, they’re not able to\nsay it.\nDave A bit weird, but OK.\nTheo Let’s call our multimethod dysGreet. Its dispatch function returns an array\nwith two elements: the animal type and a Boolean about whether the name is\nlong or not. Take a look at this multimethod initialization.\n--- Page 315 ---\n13.4 Multimethods with dynamic dispatch 287\nListing13.18 A multimethod using a dispatch function with dynamic dispatch\nfunction dysGreetDispatch(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"dysGreet called with invalid arguments: \" + errors);\n}\n}\nvar hasLongName = animal.name.length > 5;\nreturn [animal.type, hasLongName];\n};\nvar dysGreet = multi(dysGreetDispatch);\nDave Writing the dysGreet methods doesn’t seem too complicated.\nAs Theo reaches over to pass Dave his notebook, he accidently hits his coffee cup. Now Theo’s\nnotebook is completely wet, and all the diagrams are soggy! Fortunately, Dave brought an\nextra napkin from the kitchen, and it’s still clean. He draws a flow diagram as in figure 13.4\nand then grabs his laptop and writes the implementation of the dysGreet methods.\n[\"dog\", true] dysGreetDogLong\nGreet as a dog mentioning name\n[\"cat\", true] dysGreetCatLong\nGreet as a cat mentioning name\n[\"cow\", true] dysGreetCowLong\nGreet as a cow mentioning name\nargs dysGreetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", false] dysGreetDogShort\nGreet as a dog omitting name\n[\"cat\", false] dysGreetCatShort\nGreet as a cat omitting name\n[\"cow\", false] dysGreetCowShort\nGreet as a cow omitting name\nFigure 13.4 The logic flow of the dysGreet multimethod\nListing13.19 The dysGreet methods\nfunction dysGreetDogLong(animal) {\nconsole.log(\"Woof woof! My name is \" + animal.name);\n}\ndysGreet = method([\"dog\", true], dysGreetDogLong)(dysGreet);\n--- Page 316 ---\n288 CHAPTER 13 Polymorphism\nfunction dysGreetDogShort(animal) {\nconsole.log(\"Woof woof!\");\n}\ndysGreet = method([\"dog\", false], dysGreetDogShort)(dysGreet);\nfunction dysGreetCatLong(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ndysGreet = method([\"cat\", true], dysGreetCatLong)(dysGreet);\nfunction dysGreetCatShort(animal) {\nconsole.log(\"Meow!\");\n}\ndysGreet = method([\"cat\", false], dysGreetCatShort)(dysGreet);\nfunction dysGreetCowLong(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ndysGreet = method([\"cow\", true], dysGreetCowLong)(dysGreet);\nfunction dysGreetCowShort(animal) {\nconsole.log(\"Moo!\");\n}\ndysGreet = method([\"cow\", false], dysGreetCowShort)(dysGreet);\nTheo checks that the code works as expected. He compliments Dave, not only on the\nmethod implementation but also for having the foresight to grab an extra napkin.\nListing13.20 Testing dysGreet\ndysGreet(myDog);\ndysGreet(myCow);\ndysGreet(myCat);\n//\"Woof woof!\"\n//\"Moo! Call me Clarabelle\"\n//\"Meow!\"\nTheo Well done, my friend! Our exploration of multimethods has come to an end. I\nthink it’s time for me to drive back if I want to get home before dark and beat\nthe rush hour traffic.\nDave Before you leave, let’s check if multimethods are available in programming\nlanguages other than JavaScript.\nTheo That’s a question for Joe.\nDave Do you think it’s OK if I call him now?\nTheo I think it’s probably better if you send him an email. He’s in a tech conference,\nand I’m not sure if it’s all day. Thank you for this beautiful day in the country\nand the wonderful refreshments.\nDave I enjoyed it, also, especially our discussions about etymology. I think there are\nsome oranges for you to take home and enjoy later.\nTheo Great! I can’t wait until my wife tries one.\n--- Page 317 ---\n13.5 Integrating multimethods in a production system 289\nAfter Theo leaves, Dave sends Joe an email. A few minutes later, Dave receives an email\nfrom Joe with the subject, “Support for multimethods in different languages.”\nSupport for multimethods in different languages\nPython has a library called multimethods (https://github.com/weissjeffm/multimeth-\nods), and Ruby has one called Ruby multimethods (https://github.com/psantacl/\nruby-multimethods). Both seem to work quite like the JavaScript arrows/multi-\nmethod library.\nIn Java, there is the Java Multimethod Framework (http://igm.univ-mlv.fr/~forax/\nworks/jmmf/), and C# supports multimethods natively via the dynamic keyword.\nHowever, in both Java and C#, multimethods work only with static data types and not\nwith generic data structures.\nGeneric data structure\nLanguage URL\nsupport\nJavaScript https://github.com/caderek/arrows/tree/master/ Yes\npackages/multimethod\nJava http://igm.univ-mlv.fr/~forax/works/jmmf/ No\nC# Native support No\nPython https://github.com/weissjeffm/multimethods Yes\nRuby https://github.com/psantacl/ruby-multimethods Yes\n13.5 Integrating multimethods in a production system\nWhile Theo is driving back home, his thoughts take him back to the fresh air of the coun-\ntry. This pleasant moment is interrupted by a phone call from Nancy at Klafim.\nNancy How are you doing?\nTheo Fine. I’m driving back from the countryside.\nNancy Cool. Are you available to talk about work?\nTheo Sure.\nNancy I’d like to add a tiny feature to the catalog.\nIn the past, when Nancy qualified a feature as tiny, it scared Theo because tiny turned into\nhuge. What seemed easy to her always took him a surprising amount of time to develop.\nBut after refactoring the system according to DOP principles, now what seems tiny to\nNancy is usually quite easy to implement.\nTheo What feature?\nNancy I’d like to allow librarians to view the list of authors, ordered by last name, in\ntwo formats: HTML and Markdown.\n--- Page 318 ---\n290 CHAPTER 13 Polymorphism\nTheo It doesn’t sound too complicated.\nNancy Also, I need a bit of text formatting.\nTheo What kind of text formatting?\nNancy Depending on the number of books an author has written, their name should\nbe in bold and italic fonts.\nTheo Could you send me an email with all the details. I’ll take a look at it tomorrow\nmorning.\nNancy Perfect. Have a safe drive!\nBefore going to bed, Theo reflects about today’s etymology lessons. He realizes that he\nnever looked for the etymology of the word etymology itself! He searches for the term etymol-\nogy online and learns that the word etymology derives from the Greek étumon, meaning true\nsense, and the suffix logia, denoting the study of. During the night, Theo dreams of dogs,\ncats, and cows programming on their laptops in a field of grass.\nWhen Theo arrives at the office the next day, he opens Nancy’s email with the details\nabout the text formatting feature. The details are summarized in table 13.1.\nTable 13.1 Text formatting for author names according to the number of books\nthey have written\nNumber of books Italic Bold\n10 or fewer Yes No\nBetween 11 and 50 No Yes\n51 or more Yes Yes\nTheo forwards Nancy’s email to Dave and asks him to take care of this task. Delegating\nresponsibility, after all, is the trait of a great manager.\nDave thinks the most difficult part of the feature lies in implementing an Author\n.myName(author, format) function that receives two arguments: the author data and the\ntext format. He asks himself whether he can implement this function as a multimethod\nand use what he learned yesterday with Theo at his parents’ home in the country. It seems\nthat this feature is quite similar to the one that dealt with dysmakrylexia. Instead of check-\ning the length of a string, he needs to check the length of an array.\nFirst, Dave needs a data schema for the text format. He could represent a format as a\nmap with a type field like Theo did yesterday for languages, but at the moment, it seems\nsimpler to represent a format as a string that could be either markdown or html. He comes\nup with the text format schema in listing 13.21. He already wrote the author schema with\nTheo last week. It’s in listing 13.22.\nListing13.21 The text format schema\nvar textFormatSchema = {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"enum\": [\"markdown\", \"html\"]}\n};\n--- Page 319 ---\n13.5 Integrating multimethods in a production system 291\nListing13.22 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"name\", \"bookIsbns\"],\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nNow, Dave needs to write a dispatch function and initialize the multimethod. Remember-\ning that Theo had no qualms about creating the word dysmakrylexia, he decides that he\nprefers his own neologism, prolificity, over the existing nominal form prolificness. He finds it\nuseful to have an Author.prolificityLevel helper function that returns the level of\nprolificity of the author: either low, medium, or high. Now he’s ready to code the author-\nNameDispatch function.\nListing13.23 Author.myName multimethod initialization\nAuthor.prolificityLevel = function(author) {\nvar books = _.size(_.get(author, \"bookIsbns\"));\nif (books <= 10) {\nreturn \"low\";\n};\nif (books >= 51) {\nreturn \"high\";\n}\nreturn \"medium\";\n};\nvar authorNameArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\nauthorSchema,\n{\"enum\": [\"markdown\", \"html\"]}\n]\n};\nfunction authorNameDispatch(author, format) {\nif(dev()) {\nif(!ajv.validate(authorNameArgsSchema, [author, format])) {\nthrow (\"Author.myName called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [Author.prolificityLevel(author), format];\n};\nAuthor.myName = multi(authorNameDispatch);\n--- Page 320 ---\n292 CHAPTER 13 Polymorphism\nThen Dave works on the methods: first, the HTML format methods. In HTML, bold text is\nwrapped inside a <b> tag, and italic text is wrapped in a <i> tag. For instance, in HTML,\nthree authors with different levels of prolificity would be written like this.\nListing13.24 Examples of bold and italic in HTML\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n<i>Yehonathan Sharvit<i>\nBold and italic formatting\n<b>Stephen Covey</b>\nfor highly prolific authors\n<b><i>Isaac Asimov</i></b>\nWith this information in hand, Dave writes the three methods that deal with HTML for-\nmatting. Easy!\nListing13.25 The methods that deal with HTML formatting\nfunction authorNameLowHtml(author, format) {\nreturn \"<i>\" + _.get(author, \"name\") + \"</i>\";\n}\nAuthor.myName = method([\"low\", \"html\"], authorNameLowHtml)(Author.myName);\nfunction authorNameMediumHtml(author, format) {\nreturn \"<b>\" + _.get(author, \"name\") + \"</b>\";\n}\nAuthor.myName =\nmethod([\"medium\", \"html\"], authorNameMediumHtml)(Author.myName);\nfunction authorNameHighHtml(author, format) {\nreturn \"<b><i>\" + _.get(author, \"name\") + \"</i></b>\";\n}\nAuthor.myName =\nmethod([\"high\", \"html\"], authorNameHighHtml)(Author.myName);\nThen, Dave moves on to the three methods that deal with Markdown formatting. In\nMarkdown, bold text is wrapped in two asterisks, and italic text is wrapped in a single\nasterisk. For instance, in Markdown, three authors with different levels of prolificity\nwould be written like the code in listing 13.26. The code for the Markdown methods is in\nlisting 13.27.\nListing13.26 Examples of bold and italic in Markdown\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n*Yehonathan Sharvit*\nBold and italic formatting\n**Stephen Covey**\nfor highly prolific authors\n***Isaac Asimov***\n--- Page 321 ---\n13.5 Integrating multimethods in a production system 293\nListing13.27 The methods that deal with Markdown formatting\nfunction authorNameLowMarkdown(author, format) {\nreturn \"*\" + _.get(author, \"name\") + \"*\";\n}\nAuthor.myName =\nmethod([\"low\", \"markdown\"], authorNameLowMarkdown)(Author.myName);\nfunction authorNameMediumMarkdown(author, format) {\nreturn \"**\" + _.get(author, \"name\") + \"**\";\n}\nAuthor.myName =\nmethod([\"medium\", \"markdown\"], authorNameMediumMarkdown)(Author.myName);\nfunction authorNameHighMarkdown(author, format) {\nreturn \"***\" + _.get(author, \"name\") + \"***\";\n}\nAuthor.myName =\nmethod([\"high\", \"markdown\"], authorNameHighMarkdown)(Author.myName);\nDave decides to test his code by involving a mysterious author. Listing 13.28 and listing 13.29\nshow the tests.\nListing13.28 Testing HTML formatting\nvar yehonathan = {\n\"name\": \"Yehonathan Sharvit\",\n\"bookIsbns\": [\"9781617298578\"]\n};\nAuthor.myName(yehonathan, \"html\");\n// → \"<i>Yehonathan Sharvit</i>\"\nListing13.29 Testing Markdown formatting\nAuthor.myName(yehonathan, \"markdown\");\n// → \"*Yehonathan Sharvit*\"\nTheo shows up at Dave’s desk and asks to review Dave’s implementation of the list of\nauthors feature. Curious, Theo asks Dave about the author that appears in the test of\nAuthor.myName.\nTheo Who is Yehonathan Sharvit?\nDave I don’t really know. The name appeared when I googled “data-oriented pro-\ngramming” yesterday. He wrote a book on the topic. I thought it would be cool\nto use its ISBN in my test.\n--- Page 322 ---\n294 CHAPTER 13 Polymorphism\nSummary\n The main benefit of polymorphism is extensibility.\n Multimethods make it possible to benefit from polymorphism when data is repre-\nsented with generic maps.\n A multimethod is made of a dispatch function and multiple methods.\n The dispatch function of a multimethod emits a dispatch value.\n Each of the methods used in a multimethod provides an implementation for a\nspecific dispatch value.\n Multimethods can mimic OOP class inheritance via single dispatch.\n In single dispatch, a multimethod receives a single map that contains a type field,\nand the dispatch function of the multimethod emits the value of the type field.\n In addition to single dispatch, multimethods provide two kinds of advanced\npolymorphisms: multiple dispatch and dynamic dispatch.\n Multiple dispatch is used when the behavior of the multimethod depends on\nmultiple arguments.\n Dynamic dispatch is used when the behavior of the multimethod depends on run-\ntime arguments.\n The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\n A multimethod dispatch function is responsible for\n– Defining the signature.\n– Validating the arguments.\n– Emitting a dispatch value.\n Multimethods provides extensibility by decoupling between multimethod ini-\ntialization and method implementations.\n Multimethods are called like regular functions.\n Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\n In a multimethod that features multiple dispatch, the order of the elements in\nthe array emitted by the dispatch function has to be consistent with the order of\nthe elements in the wiring of the methods.\nLodash functions introduced in this chapter\nFunction Description\nsize(coll) Gets the size of coll\n--- Page 323 ---\nAdvanced data\nmanipulation\nWhatever is well-conceived\nis clearly said\nThis chapter covers\n Manipulating nested data\n Writing clear and concise code for business\nlogic\n Separating business logic and generic data\nmanipulation\n Building custom data manipulation tools\n Using the best tool for the job\nWhen our business logic involves advanced data processing, the generic data manip-\nulation functions provided by the language run time and by third-party libraries\nmight not be sufficient. Instead of mixing the details of data manipulation with\nbusiness logic, we can write our own generic data manipulation functions and imple-\nment our custom business logic using them. Separating business logic from the inter-\nnal details of data manipulation makes the business logic code concise and easy to\nread for other developers.\n295\n--- Page 324 ---\n296 CHAPTER 14 Advanced data manipulation\n14.1 Updating a value in a map with eloquence\nDave is more and more autonomous on the Klafim project. He can implement most fea-\ntures on his own, typically turning to Theo only for code reviews. Dave’s code quality stan-\ndards are quite high. Even when his code is functionally solid, he tends to be unsatisfied\nwith its readability. Today, he asks for Theo’s help in improving the readability of the code\nthat fixes a bug Theo introduced a long time ago.\nDave I think I have a found a bug in the code that returns book information from\nthe Open Library API.\nTheo What bug?\nDave Sometimes, the API returns duplicate author names, and we pass the dupli-\ncates through to the client.\nTheo It doesn’t sound like a complicated bug to fix.\nDave Right, I fixed it, but I’m not satisfied with the readability of the code I wrote.\nTheo Being critical of our own code is an important quality for a developer to prog-\nress. What is it exactly that you don’t like?\nDave Take a look at this code.\nListing14.1 Removing duplicates in a straightforward but tedious way\nfunction removeAuthorDuplicates(book) {\nvar authors = _.get(book, \"authors\");\nvar uniqAuthors = _.uniq(authors);\nreturn _.set(book,\"authors\", uniqAuthors);\n}\nDave I’m using _.get to retrieve the array with the author names, then _.uniq to\ncreate a duplicate-free version of the array, and finally, _.set to create a new\nversion of the book with no duplicate author names.\nTheo The code is tedious because the next value of authorNames needs to be based\non its current value.\nDave But it’s a common use case! Isn’t there a simpler way to write this kind of code?\nTheo Your astonishment definitely honors you as a developer, Dave. I agree with you\nthat there must be a simpler way. Let me phone Joe and see if he’s available for\na conference call.\nJoe How’s it going, Theo?\nTheo Great! Are you back from your tech conference?\nJoe I just landed. I’m on my way home now in a taxi.\nTheo How was your talk about DOP?\nJoe Pretty good. At the beginning people were a bit suspicious, but when I told\nthem the story of Albatross and Klafim, it was quite convincing.\nTheo Yeah, adults are like children in that way; they love stories.\nJoe What about you? Did you manage to achieve polymorphism with multimethods?\nTheo Yes! Dave even managed to implement a feature in Klafim with multimethods.\nJoe Cool!\n--- Page 325 ---\n14.1 Updating a value in a map with eloquence 297\nTheo Do you have time to help Dave with a question about programming?\nJoe Sure.\nDave Hi Joe. How are you doing?\nJoe Hello Dave. Not bad. What kind of help do you need?\nDave I’m wondering if there’s a simpler way to remove duplicates inside an array\nvalue in a map. Using _.get, _.uniq, and _.set looks quite tedious.\nJoe You should build your own data manipulation tools.\nDave What do you mean?\nJoe You should write a generic update function that updates a value in a map,\napplying a calculation based on its current value.1\nDave What would the arguments of update be in your opinion?\nJoe Put the cart before the horse.\nDave What?!\nJoe Rewrite your business logic as if update were already implemented, and you’ll\ndiscover what the arguments of update should be.\nDave I see what you mean: the horse is the implementation of update, and the cart is\nthe usage of update.\nJoe Exactly. But remember, it’s better if you keep your update function generic.\nDave How?\nJoe By not limiting it to your specific use case.\nDave I see. The implementation of update should not deal with removing duplicate\nelements. Instead, it should receive the updating function—in my case,\n_.uniq—as an argument.\nJoe Exactly! Uh, sorry Dave, I gotta go, I just got home. Good luck!\nDave Take care, Joe, and thanks!\nDave ends the conference call. Looking at Theo, he reiterates the conversation with Joe.\nDave Joe advised me to write my own update function. For that purpose, he told me\nto start by rewriting removeAuthorDuplicates as if update were already\nimplemented. That will allow us to make sure we get the signature of update\nright.\nTheo Sounds like a plan.\nDave Joe called it “putting the cart before the horse.”\nTheo Joe and his funny analogies...\nTIP The best way to find the signature of a custom data manipulation function is to\nthink about the most convenient way to use it.\nDave Anyway, the way I’d like to use update inside removeAuthorDuplicates is\nlike this.\n1 Lodash provides an implementation of update, but for the sake of teaching, we are writing our own imple-\nmentation.\n--- Page 326 ---\n298 CHAPTER 14 Advanced data manipulation\nListing14.2 The code that removes duplicates in an elegant way\nfunction removeAuthorDuplicates(book) {\nreturn update(book, \"authors\", _.uniq);\n}\nTheo Looks good to me!\nDave Wow! Now the code with update is much more elegant than the code with\n_.get and _.set!\nTheo Before you implement update, I suggest that you write down in plain English\nexactly what the function does.\nDave It’s quite easy: update receives a map called map, a path called path, and a\nfunction called fun. It returns a new version of map, where path is associated\nwith fun(currentValue), and currentValue is the value associated with\npath in map.\nThinking out loud, Dave simultaneously draws a diagram like that in figure 14.1. Theo is\nbecoming more and more impressed with his young protegé as he studies the figure.\n{\n\"position\" : \"manager\", \"income\"\n\"income\" : 100000\n} map fun path\nupdate\n{\n\"position\" : \"manager\",\n\"income\" : fun(100000)\nres Figure 14.1 The\n}\nbehavior of update\nTIP Before implementing a custom data manipulation function, formulate in plain\nEnglish exactly what the function does.\nTheo With such a clear definition, it’s going to be a piece of cake to implement\nupdate!\nAfter a few minutes, Dave comes up with the code. It doesn’t take long because the plain-\nEnglish diagram helps him to organize the code.\nListing14.3 A generic update function\nfunction update(map, path, fun) {\nvar currentValue = _.get(map, path);\nvar nextValue = fun(currentValue);\nreturn _.set(map, path, nextValue);\n}\n--- Page 327 ---\n14.2 Manipulating nested data 299\nTheo Why don’t you see if it works with a simple case such as incrementing a number\nin a map?\nDave Good idea! I’ll try multiplying a value in a map by 2 with update. How’s this\nlook?\nListing14.4 Multiplying a value in a map by 2\nvar m = {\n\"position\": \"manager\",\n\"income\": 100000\n};\nupdate(m, \"income\", function(x) {\nreturn x * 2;\n});\n// → {\"position\": \"manager\", \"income\": 200000}\nTheo Great! It seems to work.\n14.2 Manipulating nested data\nThe next Monday, during Theo and Dave’s weekly sync meeting, they discuss the upcom-\ning features for Klafim. Theo fondly remembers another Monday where they met at Dave’s\nfamily home in the country. Coming back to the present moment, Theo begins.\nTheo Recently, Nancy has been asking for more and more administrative features.\nDave Like what?\nTheo I’ll give you a few examples.... Let me find the email I got from Nancy yesterday.\nDave OK.\nTheo Here it is. There are three feature requests for now: listing all the book author\nIDs, calculating the book lending ratio, and grouping books by a physical library.\nDave What feature should I tackle first?\nTheo It doesn’t matter, but you should deliver the three of these before the end of\nthe week. Good luck, and don’t hesitate to call me if you need help.\nOn Tuesday, Dave asks for Theo’s help. Dave is not pleased with how his code looks.\nDave I started to work on the three admin features, but I don’t like the code I wrote.\nLet me show you the code for retrieving the list of author IDs from the list of\nbooks returned from the database.\nTheo Can you remind me what an element in a book list returned from the database\nlooks like?\nDave Each book is a map with an authorIds array field.\nTheo OK, so it sounds like a map over the books should do it.\nDave This is what I did, but it doesn’t work as expected. Here’s my code for listing\nthe book author IDs.\n--- Page 328 ---\n300 CHAPTER 14 Advanced data manipulation\nListing14.5 Retrieving the author IDs in books as an array of arrays\nfunction authorIdsInBooks(books) {\nreturn _.map(books, \"authorIds\");\n}\nTheo What’s the problem?\nDave The problem is that it returns an array of arrays of author IDs instead of an\narray of author IDs. For instance, when I run authorIdsInBooks on a catalog\nwith two books, I get this result.\nListing14.6 The author IDs in an array of arrays\n[\n[\"sean-covey\", \"stephen-covey\"],\n[\"alan-moore\", \"dave-gibbons\"]\n]\nTheo That’s not a big problem. You can flatten an array of arrays with _.flatten,\nand you should get the result you expect.\nDave Nice! This is exactly what I need! Give me a moment to fix the code of\nauthorIdsInBooks. . . here you go.\nListing14.7 Retrieving the author IDs in books as an array of strings\nfunction authorIdsInBooks(books) {\nreturn _.flatten(_.map(books, \"authorIds\"));\n}\nTheo Don’t you think that mapping and then flattening deserves a function of its own?\nDave Maybe. It’s quite easy to implement a flatMap function.2 How about this?\nListing14.8 The implementation of flatMap\nfunction flatMap(coll, f) {\nreturn _.flatten(_.map(coll,f));\n}\nTheo Nice!\nDave I don’t know.... It’s kind of weird to have such a small function.\nTheo I don’t think that code size is what matters here.\nDave What do you mean?\nTheo See what happens when you rewrite authorIdsInBooks using flatMap.\nDave OK, here’s how I’d use flatMap to list the author IDs.\n2 Lodash provides an implementation of flatMap, but for the sake of teaching, we are writing our own\nimplementation.\n--- Page 329 ---\n14.3 Using the best tool for the job 301\nListing14.9 Retrieving the author IDs as an array of strings using flatMap\nfunction authorIdsInBooks(books) {\nreturn flatMap(books, \"authorIds\");\n}\nTheo What implementation do you prefer, the one with flatten and map (in listing\n14.7) or the one with flatMap (in listing 14.9)?\nDave I don’t know. To me, they look quite similar.\nTheo Right, but which implementation is more readable?\nDave Well, assuming I know what flatMap does, I would say the implementation\nwith flatMap. Because it’s more concise, it is a bit more readable.\nTheo Again, it’s not about the size of the code. It’s about the clarity of intent and the\npower of naming things.\nDave I don’t get that.\nTheo Let me give you an example from our day-to-day language.\nDave OK.\nTheo Could you pass me that thing on your desk that’s used for writing?\nIt takes Dave a few seconds to get that Theo has asked him to pass the pen on the desk.\nAfter he passes Theo the pen, he asks:\nDave Why didn’t you simply ask for the pen?\nTheo I wanted you to experience how it feels when we use descriptions instead of\nnames to convey our intent.\nDave Oh, I see. You mean that once we use a name for the operation that maps and\nflattens, the code becomes clearer.\nTheo Exactly.\nDave Let’s move on to the second admin feature: calculating the book lending ratio.\nTheo Before that, I think we deserve a short period for rest and refreshments, where\nwe drink a beverage made by percolation from roasted and ground seeds.\nDave A coffee break!\n14.3 Using the best tool for the job\nAfter the coffee break, Dave shows Theo his implementation of the book lending ratio cal-\nculation. This time, he seems to like the code he wrote.\nDave I’m quite proud of the code I wrote to calculate the book lending ratio.\nTheo Show me the money!\nDave My function receives a list of books from the database like this.\nListing14.10 A list of two books with bookItems\n[\n{\n\"isbn\": \"978-1779501127\",\n--- Page 330 ---\n302 CHAPTER 14 Advanced data manipulation\n\"title\": \"Watchmen\",\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n}\n]\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"bookItems\": [\n{\n\"id\": \"book-item-123\",\n\"libId\": \"hudson-park-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-17\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n]\nTheo Quite a nested piece of data!\nDave Yeah, but now that I’m using flatMap, calculating the lending ratio is quite\neasy. I’m going over all the book items with forEach and incrementing either\nthe lent or the notLent counter. At the end, I return the ratio between lent\nand (lent + notLent). Here’s how I do that.\nListing14.11 Calculating the book lending ratio using forEach\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar lent = 0;\nvar notLent = 0;\n_.forEach(bookItems, function(item) {\nif(_.get(item, \"isLent\")) {\nlent = lent + 1;\n} else {\nnotLent = notLent + 1;\n}\n});\nreturn lent/(lent + notLent);\n}\nTheo Would you allow me to tell you frankly what I think of your code?\nDave If you are asking this question, it means that you don’t like it. Right?\nTheo It’s nothing against you; I don’t like any piece of code with forEach.\n--- Page 331 ---\n14.3 Using the best tool for the job 303\nDave What’s wrong with forEach?\nTheo It’s too generic!\nDave I thought that genericity was a positive thing in programming.\nTheo It is when we build a utility function, but when we use a utility function, we\nshould use the least generic function that solves our problem.\nDave Why?\nTheo Because we ought to choose the right tool for the job, like in the real life.\nDave What do you mean?\nTheo Let me give you an example. Yesterday, I had to clean my drone from the\ninside. Do you think that I used a screwdriver or a Swiss army knife to unscrew\nthe drone cover?\nDave A screwdriver, of course! It’s much more convenient to manipulate.\nTheo Right. Also, imagine that someone looks at me using a screwdriver. It’s quite\nclear to them that I am turning a screw. It conveys my intent clearly.\nDave Are you saying that forEach is like the Swiss army knife of data manipulation?\nTheo That’s a good way to put it.\nTIP Pick the least generic utility function that solves your problem.\nDave What function should I use then, to iterate over the book item collection?\nTheo You could use _.reduce.\nDave I thought reduce was about returning data from a collection. Here, I don’t\nneed to return data; I need to update two variables, lent and notLent.\nTheo You could represent those two values in a map with two keys.\nDave Can you show me how to rewrite my lendingRatio function using reduce?\nTheo Sure. The initial value passed to reduce is the map, {\"lent\": 0, \"notLent\": 0},\nand inside each iteration, we update one of the two keys, like this.\nListing14.12 Calculating the book lending ratio using reduce\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = _.reduce(bookItems, function(res, item) {\nif(_.get(item, \"isLent\")) {\nres.lent = res.lent + 1;\n} else {\nres.notLent = res.notLent + 1;\n}\nreturn res;\n}, {notLent: 0, lent:0});\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nDave Instead of updating the variables lent and notLent, now we are updating lent\nand notLent map fields. What’s the difference?\n--- Page 332 ---\n304 CHAPTER 14 Advanced data manipulation\nTheo Dealing with map fields instead of variables allows us to get rid of reduce in\nour business logic code.\nDave How could you iterate over a collection without forEach and without reduce?\nTheo I can’t avoid the iteration over a collection, but I can hide reduce behind a\nutility function. Take a look at the way reduce is used inside the code of\nlendingRatio. What is the meaning of the reduce call?\nDave looks at the code in listing 14.12. He thinks for a long moment before he answers.\nDave I think it’s counting the number of times isLent is true and false.\nTheo Right. Now, let’s use Joe’s advice about building our own data manipulation\ntool.\nDave How exactly?\nTheo I suggest that you write a countByBoolField utility function that counts the\nnumber of times a field is true and false.\nDave OK, but before implementing this function, let me first rewrite the code of\nlendingRatio, assuming this function already exists.\nTheo You are definitely a fast learner, Dave!\nDave Thanks! I think that by using countByBoolField, the code for calculating the\nlending ratio using a custom utility function would be something like this.\nListing14.13 Calculating the book lending ratio\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = countByBoolField(bookItems, \"isLent\", \"lent\", \"notLent\");\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nTIP Don’t use _.reduce or any other low-level data manipulation function inside\ncode that deals with business logic. Instead, write a utility function—with a proper\nname—that hides _.reduce.\nTheo Perfect. Don’t you think that this code is clearer than the code using _.reduce?\nDave I do! The code is both more concise and the intent is clearer. Let me see if I\ncan implement countByBoolField now.\nTheo I suggest that you write a unit test first.\nDave Good idea.\nDave types for a bit. When he’s satisfied, he shows Theo the result.\nListing14.14 A unit test for countByBoolField\nvar input = [\n{\"a\": true},\n{\"a\": false},\n{\"a\": true},\n--- Page 333 ---\n14.4 Unwinding at ease 305\n{\"a\": true}\n];\nvar expectedRes = {\n\"aTrue\": 3,\n\"aFalse\": 1\n};\n_.isEqual(countByBoolField(input, \"a\", \"aTrue\", \"aFalse\"), expectedRes);\nTheo Looks good to me. Now, for the implementation of countByBoolField, I\nthink you are going to need our update function.\nDave I think you’re right. On each iteration, I need to increment the value of either\naTrue or aFalse using update and a function that increments a number by 1.\nAfter a few minutes of trial and error, Dave comes up with the piece of code that uses\nreduce, update, and inc. He shows Theo the code for countByBoolField.\nListing14.15 The implementation of countByBoolField\nfunction inc (n) {\nreturn n + 1;\n}\nfunction countByBoolField(coll, field, keyTrue, keyFalse) {\nreturn _.reduce(coll, function(res, item) {\nif (_.get(item, field)) {\nreturn update(res, keyTrue, inc);\n}\nreturn update(res, keyFalse, inc);\n}, {[keyTrue]: 0,\nCreates a map with\n[keyFalse]: 0});\nkeyTrue and keyFalse\n}\nassociated to 0\nTheo Well done! Shall we move on and review the third admin feature?\nDave The third feature is more complicated. I would like to use the teachings from\nthe first two features for the implementation of the third feature.\nTheo OK. Call me when you’re ready for the code review.\n14.4 Unwinding at ease\nDave really struggled with the implementation of the last admin feature, grouping books\nby a physical library. After a couple of hours of frustration, Dave calls Theo for a rescue.\nDave I really had a hard time implementing the grouping by library feature.\nTheo I only have a couple of minutes before my next meeting, but I can try to help\nyou. What’s the exact definition of grouping by library?\nDave Let me show you the unit test I wrote.",
        "sections_found": []
      },
      "accurate_page_range": "303-333"
    },
    {
      "text": "- 12.5 Automatic generation of schema-based unit tests",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "raw_line": "- 12.5 Automatic generation of schema-based unit tests (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 103,
      "chapter_info": {
        "page": 303,
        "title": "Advanced data validation",
        "pattern_matched": "Chapter 12",
        "text_preview": "13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with "
      },
      "chapter_sections": {
        "start_page": 303,
        "end_page": 333,
        "content": "\n--- Page 303 ---\n13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with maps\nvar myDog = {\n\"type\": \"dog\",\n\"name\": \"Fido\"\n};\nvar myCat = {\n\"type\": \"cat\",\n\"name\": \"Milo\"\n};\nvar myCow = {\n\"type\": \"cow\",\n\"name\": \"Clarabelle\"\n};\nDave Could you have given another name to the field that holds the animal type?\nTheo Absolutely. It could be anything.\nDave I see. You’re asking me the fundamental difference between your code with a\nswitch statement and my code with an interface and three classes?\nTheo Exactly.\nDave First of all, if you pass an invalid map to your greet function, bad things will\nhappen.\nTheo You’re right. Let me fix that and validate input data.\nListing13.4 Data validation\nvar animalSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nSee chapter 12 about\ndata validation for\nfunction greet(animal) {\ndetails.\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\n--- Page 304 ---\n276 CHAPTER 13 Polymorphism\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\nbreak;\ncase \"cat\":\nconsole.log(\"Meow! I am: \" + animal.name);\nbreak;\ncase \"cow\":\nconsole.log(\"Moo! Call me \" + animal.name);\nbreak;\n};\n}\n NOTE You should not use switch statements like this in your production code.\nWe use them here for didactic purposes only as a step towards distilling the essence of\npolymorphism.\nDave Another drawback of your approach is that when you want to modify the\nimplementation of greet for a specific animal, you have to change the code\nthat deals with all the animals, while in my approach, you would change only a\nspecific animal class.\nTheo I agree, and I could also fix that by having a separate function for each animal,\nsomething like this.\nListing13.5 Different implementations in different functions\nfunction greetDog(animal) {\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\n}\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am: \" + animal.name);\n}\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\nfunction greet(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\ngreetDog(animal);\nbreak;\ncase \"cat\":\ngreetCat(animal);\nbreak;\ncase \"cow\":\ngreetCow(animal);\n--- Page 305 ---\n13.2 Multimethods with single dispatch 277\nbreak;\n};\n}\nDave But what if you want to extend the functionality of greet and add a new animal?\nTheo Now you got me. I admit that with a switch statement, I can’t add a new animal\nwithout modifying the original code, whereas in OOP, I can add a new class\nwithout having to modify the original code.\nDave Yeah, but you helped me to realize that the main benefit of polymorphism is\nthat it makes the code easily extensible.\nTIP The main benefit of polymorphism is extensibility.\nTheo I’m going to ask Joe if there’s a way to benefit from polymorphism without\nobjects.\nTheo sends a message to Joe and asks him about polymorphism in DOP. Joe answers that\nhe doesn’t have time to get into a deep response because he is in a tech conference where\nhe is about to give a talk about DOP. The only thing he has time to tell Theo is that he\nshould take a look at multimethods.\nTheo and Dave read some online material about multimethods. It doesn’t look too\ncomplicated. They decide that after lunch they will give multimethods a try.\n13.2 Multimethods with single dispatch\nDuring lunch, Theo asks Dave how it feels to have grown up in the country. Dave starts\nwith an enthusiastic description about being in direct contact with nature and living a sim-\npler life than in the city. He’s grateful for the experience, but he admits that country life\ncan sometimes be hard without the conveniences of the city. But who said simple was easy?\nAfter lunch, they decide to have coffee. Dave asks Theo if he’d like to grind the coffee\nbeans himself. Theo accepts with joy. Next, Dave explains how to use a French press coffee\nmaker to get the ideal tradeoff between bitterness and rich taste. While savoring their\nFrench press coffee in the garden, Theo and Dave continue their exploration of polymor-\nphism à la DOP.\nTheo From what I read before lunch, it seems that multimethods are a software con-\nstruct that provide polymorphism without the need for objects.\nDave I don’t get how that’s possible.\nTheo Multimethods have two parts: a dispatch function and a set of methods that\nprovide an implementation for each dispatched value.\nDave I’m not sure I’m clear on that. Is a dispatch function like an interface?\nTheo It’s like an interface in the sense that it defines the way the function needs to\nbe called, but it goes beyond that. It also dispatches a value that differentiates\nbetween the different implementations.\nDave That’s a bit abstract for me.\nTheo I think I understand how to implement the animal greeting capabilities. If we\nuse a multimethod called greet, we need a dispatch function and three\nmethods. Let’s call the dispatch function greetDispatch. It dispatches the\nanimal type, either \"dog\", \"cat\", or \"cow\". Then, each dispatch value is\n--- Page 306 ---\n278 CHAPTER 13 Polymorphism\nhandled by a specific method: \"dog\" by greetDog, \"cat\" by greetCat, and\n\"cow\" by greetCow.\nTheo takes out his notebook and opens it to a blank piece of paper. He draws a diagram\nlike the one in figure 13.1.\n\"dog\" greetDog\nGreet as a dog\ngreetDispatch \"cat\" greetCat\nEmit the animal type Greet as a cat\nanimal\ntype, name \"cow\" greetCow\nGreet as a cow\nFigure 13.1 The logic flow\nof the greet multimethod\nDave Why is there an arrow between animal and the methods, in addition to the\narrows between animal and the dispatch functions?\nTheo Because the arguments of a multimethod are passed to the dispatch function\nand to the methods.\nTIP The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\nDave Arguments plural?... I see only a single argument.\nTheo You’re right. Right now our multimethod only receives a single argument, but\nsoon it will receive several arguments.\nDave I see. Could you show me how to write the code for the greet multimethod?\nTheo For that, we need a library. For instance, in JavaScript, the arrows/multi-\nmethod library provides an implementation of multimethods. Basically, we call\nmulti to create a multimethod called method to add a method.\n NOTE See http://mng.bz/nY9v for examples and documentation about this library.\nDave Where should we start?\nTheo We’ll start with multimethod initialization by creating a dispatch function\ngreetDispatch that defines the signature of the multimethod, validates the\narguments, and emits the type of the animal. Then we’ll pass greetDispatch\nto multi in order to create the greet multimethod. Our dispatch function\nwould then look like this.\nListing13.6 The dispatch function for greet multimethod\nfunction greetDispatch(animal) {\nSignature definition\nif(dev()) {\n--- Page 307 ---\n13.2 Multimethods with single dispatch 279\nif(!ajv.validate(animalSchema, animal)) {\nArgument validation\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nDispatch value\nreturn animal.type;\n}\nMultimethod\ninitialization\nvar greet = multi(greetDispatch);\nTIP A multimethod dispatch function is responsible for three things: it defines the sig-\nnature of the multimethod, it validates the arguments, and it emits a dispatch value.\nDave What’s next?\nTheo Now we need to implement a method for each dispatched value. Let’s start\nwith the method that deals with dogs. We create a greetDog function that\nreceives an animal and then add a dog method to the greet multimethod\nusing the method function from the arrows/multimethod library. The method\nfunction receives two arguments: the dispatched value and a function that cor-\nresponds to the dispatch value.\nListing13.7 Implementation of greet method for dogs\nfunction greetDog(animal) {\nMethod\nconsole.log(\"Woof woof! My name is \" + animal.name);\nimplementation\n}\ngreet = method(\"dog\", greetDog)(greet);\nMethod declaration\nDave Does the method implementation have to be in the same module as the multi-\nmethod initialization?\nTheo No, not at all! Method declarations are decoupled from multimethod initializa-\ntion exactly like class definitions are decoupled from the interface definition.\nThat’s what make multimethods extensible.\nTIP Multimethods provides extensibility by decoupling between multimethod initial-\nization and method implementations.\nDave What about cats and cows?\nTheo We add their method implementations like we did for dogs.\nTheo takes a moment to envision the implementation. Then he codes up two more greet\nmethods for cats and cows.\nListing13.8 Implementation of greet method for cats\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ngreet = method(\"cat\", greetCat)(greet);\n--- Page 308 ---\n280 CHAPTER 13 Polymorphism\nListing13.9 Implementation of greet method for cows\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ngreet = method(\"cow\", greetCow)(greet);\nTIP In the context of multimethods, a method is a function that provides an imple-\nmentation for a dispatch value.\nDave Are the names of dispatch functions and methods important?\nTheo According to what I read, not really, but I like to follow a simple naming con-\nvention: use the name of the multimethod (for example, greet) as a prefix for\nthe dispatch function (for example, greetDispatch) and the methods. Then\nI’d have the Dispatch suffix for the dispatch function and a specific suffix for\neach method (for example, greetDog, greetCat, and greetCow).\nDave How does the multimethod mechanism work under the hood?\nTheo Internally, a multimethod maintains a hash map where the keys are the dis-\npatched values, and the values are the methods. When we add a method, an\nentry is added to the hash map, and when we call the multimethod, we query the\nhash map to find the implementation that corresponds to the dispatched value.\nDave I don’t think you’ve told me yet how to call a multimethod.\nTheo We call it as a regular function. Give me a minute, and I’ll show you an exam-\nple that calls a multimethod.\nListing13.10 Calling a multimethod like a regular function\ngreet(myDog);\n// → \"Woof woof! My name is Fido\"\ngreet(myCat);\n// → \"Meow! I am Milo\"\ngreet(myCow);\n// → \"Moo! Call me Clarabelle\"\nTIP Multimethods are called like regular functions.\nDave You told me earlier that in the dispatch function, we should validate the argu-\nments. Is that mandatory or is it a best practice?\nTheo It’s a best practice.\nDave What happens if the dispatch function doesn’t validate the arguments, and we\npass an invalid argument?\nTheo Like when an animal has no corresponding method?\nDave Exactly!\nTheo In that case, you’ll get an error. For instance, the arrows/multimethods library\nthrows a NoMethodError exception.\nDave That’s annoying. Is there a way to provide a default implementation?\n--- Page 309 ---\n13.3 Multimethods with multiple dispatch 281\nTheo Absolutely! In order to define a default implementation, you pass to method—\nas a single argument—the function that provides the default implementation.\nTheo writes the code and shows it to Dave. Dave then tests Theo’s code and seems satisfied\nwith the result.\nListing13.11 Defining a default implementation\nfunction greetDefault(animal) {\nconsole.log(\"My name is \" + animal.name);\n}\ngreet = method(greetDefault)(greet);\nListing13.12 Calling a multimethod when no method fits the dispatch value\nvar myHorse = {\n\"type\": \"horse\",\n\"name\": \"Horace\"\n};\ngreet(myHorse);\n// → \"My name is Horace\"\nTIP Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\nDave Cool!\n13.3 Multimethods with multiple dispatch\nTheo So far, we’ve mimicked OOP by having the type of the multimethod argument\nas a dispatch value. But if you think again about the flow of a multimethod,\nyou’ll discover something interesting. Would you like to try and draw a dia-\ngram that describes the flow of a multimethod in general?\nDave Let me get a fresh napkin. The one under my glass is a bit wet.\nTheo Uh, Dave, you can use my notebook.\nIt takes Dave a few minutes to draw a diagram like the one in figure 13.2. He pushes the\nnotebook back to Theo.\nValue1 Method1\nHandle case 1\nDispatch function Value3 Method3\nEmit a dispatch value Handle case 3\nargs\nValue2 Method2\nHandle case 2\nFigure 13.2 The logic flow\nof multimethods\n--- Page 310 ---\n282 CHAPTER 13 Polymorphism\nTheo Excellent! I hope you see that the dispatch function can emit any value.\nDave Like what?\nTheo Like emitting the type of two arguments!\nDave What do you mean?\nTheo Imagine that our animals are polyglot.\nDave Poly what?\nTheo Polyglot comes from the Greek polús, meaning much, and from glôssa, meaning\nlanguage. A polyglot is a person who can speak many languages.\nDave What languages would our animals speak?\nTheo I don’t know. Let’s say English and French.\nDave OK, and how would we represent a language in our program?\nTheo With a map, of course!\nDave What fields would we have in a language map?\nTheo Let’s keep things simple and have two fields: type and name.\nDave Like an animal map?\nTheo Not exactly. In a language map, the type field must be either fr for French or en\nfor English, whereas in the animal map, the type field is either dog, cat, or cow.\nDave Let me try to write the language map schema and the two language maps.\nTheo gladly consents; his French press coffee is getting cold! Dave writes his implementa-\ntion of the code and shows Theo.\nListing13.13 The schema of a language map\nvar languageSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nListing13.14 Two language maps\nvar french = {\n\"type\": \"fr\",\n\"name\": \"Français\"\n};\nvar english = {\n\"type\": \"en\",\n\"name\": \"English\"\n};\nTheo Excellent! Now, let’s write the code for the dispatch function and the methods\nfor our polyglot animals. Let’s call our multimethod, greetLang. We have one\ndispatch function and six methods.\n--- Page 311 ---\n13.3 Multimethods with multiple dispatch 283\nDave Right, three animals (dog, cat, and cow) times two languages (en and fr).\nBefore the implementation, I’d like to draw a flow diagram. It will help me to\nmake things crystal clear.\nTheo You need my notebook again?\nNot waiting for Dave to respond, Theo pushes his notebook across the table to Dave. Dave\ndraws a diagram like the one in figure 13.3 and slides the notebook back to Theo.\n[\"dog\", \"en\"] greetLangDogEn\nGreet as a dog in English\n[\"cat\", \"en\"] greetLangCatEn\nGreet as a cat in English\n[\"cow\", \"en\"] greetLangCowEn\nGreet as a cow in English\nargs greetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", \"fr\"] greetLangDogFr\nGreet as a dog in French\n[\"cat\", \"fr\"] greetLangCatFr\nGreet as a cat in French\n[\"cow\", \"fr\"] greetLangCowFr\nGreet as a cow in French\nFigure 13.3 The logic flow of the greetLang multimethod\nTheo Why did you omit the arrow between the arguments and the methods?\nDave In order to keep the diagram readable. Otherwise, there would be too many\narrows.\nTheo OK, I see. Are you ready for coding?\nDave Yes!\nTheo The dispatch function needs to validate its arguments and return an array with\ntwo elements: the type of animal and the type of language.\nDave types for a bit on his laptop. He initializes the multimethod with a dispatch function\nthat returns the type of its arguments and then shows the code to Theo.\nListing13.15 Initializing a multimethod with a dispatch function\nvar greetLangArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [animalSchema, languageSchema]\n};\nfunction greetLangDispatch(animal, language) {\nif(dev()) {\n--- Page 312 ---\n284 CHAPTER 13 Polymorphism\nif(!ajv.validate(greetLangArgsSchema, [animal, language])) {\nthrow (\"greetLang called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [animal.type, language.type];\n};\nvar greetLang = multi(greetLangDispatch);\nDave Does the order of the elements in the array matter?\nTheo It doesn’t matter, but it needs to be consistent with the wiring of the methods.\nThe implementation of greetLang would therefore look like this.\nListing13.16 The implementation of greetLang methods\nfunction greetLangDogEn(animal, language) {\nconsole.log(\"Woof woof! My name is \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"en\"], greetLangDogEn)(greetLang);\nfunction greetLangDogFr(animal, language) {\nconsole.log(\"Ouaf Ouaf! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"fr\"], greetLangDogFr)(greetLang);\nfunction greetLangCatEn(animal, language) {\nconsole.log(\"Meow! I am \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"en\"], greetLangCatEn)(greetLang);\nfunction greetLangCatFr(animal, language) {\nconsole.log(\"Miaou! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"fr\"], greetLangCatFr)(greetLang);\nfunction greetLangCowEn(animal, language) {\nconsole.log(\"Moo! Call me \" +\nanimal.name +\n\" and I speak \" +\n--- Page 313 ---\n13.3 Multimethods with multiple dispatch 285\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"en\"], greetLangCowEn)(greetLang);\nfunction greetLangCowFr(animal, language) {\nconsole.log(\"Meuh! Appelle moi \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"fr\"], greetLangCowFr)(greetLang);\nDave looks at the code for the methods that deal with French. He is surprised to see Ouaf\nOuaf instead of Woof Woof for dogs, Miaou instead of Meow for cats, and Meuh instead of\nMoo for cows.\nDave I didn’t know that animal onomatopoeia were different in French than in\nEnglish!\nTheo Ono what?\nDave Onomatopoeia, from the Greek ónoma that means name and poiéo– that means to\nproduce. It is the property of words that sound like what they represent; for\ninstance, Woof, Meow, and Moo.\nTheo Yeah, for some reason in French, dogs Ouaf, cats Miaou, and cows Meuh.\nDave I see that in the array the animal type is always before the language type.\nTheo Right! As I told you before, in a multimethod that features multiple dispatch,\nthe order doesn’t really matter, but it has to be consistent.\nTIP Multiple dispatch is when a dispatch function emits a value that depends on more\nthan one argument. In a multimethod that features multiple dispatch, the order of\nthe elements in the array emitted by the dispatch function has to be consistent with\nthe order of the elements in the wiring of the methods.\nDave Now let me see if I can figure out how to use a multimethod that features mul-\ntiple dispatch.\nDave remembers that Theo told him earlier that multimethods are used like regular func-\ntions. With that in mind, he comes up with the code for a multimethod that features multi-\nple dispatch.\nListing13.17 Calling a multimethod that features multiple dispatch\ngreetLang(myDog, french);\n// → \"Ouaf Ouaf! Je m\\'appelle Fido et je parle Français\"\ngreetLang(myDog, english);\n// → \"Woof woof! My name is Fido and I speak English\"\ngreetLang(myCat, french);\n// → \"Miaou! Je m\\'appelle Milo et je parle Français\"\n--- Page 314 ---\n286 CHAPTER 13 Polymorphism\ngreetLang(myCat, english);\n// → \"Meow! I am Milo and I speak English\"\ngreetLang(myCow, french);\n// → \"Meuh! Appelle moi Clarabelle et je parle Français\"\ngreetLang(myCow, english);\n// → \"Moo! Call me Clarabelle and I speak English\"\nTheo Now do you agree that multimethods with multiple dispatch offer a more pow-\nerful polymorphism that OOP polymorphism?\nDave Indeed, I do.\nTheo Let me show you an even more powerful polymorphism called dynamic dis-\npatch. But first, let’s get some more of that wonderful French press coffee.\nDave Great idea! While we’re in the kitchen, I think my mom made an orange Bundt\ncake using the oranges from the grove.\n13.4 Multimethods with dynamic dispatch\nDave refills their coffee cups as Theo takes two slices from the cake and dishes them up.\nThey take their coffee and cake outside to enjoy more of the fresh country air before\nresuming their conversation.\nDave What is dynamic dispatch?\nTheo It’s when the dispatch function of a multimethod returns a value that goes\nbeyond the static type of its arguments.\nDave Like what, for example?\nTheo Like a number or a Boolean, for instance.\nDave Why would such a thing be useful?\nTheo Imagine that instead of being polyglot, our animals would suffer from\ndysmakrylexia.\nDave Suffering from what?\nTheo Dysmakrylexia. It comes from the Greek dus, expressing the idea of difficulty,\nmakrýs meaning long, and léxis meaning diction. Therefore, dysmakrylexia is dif-\nficulty pronouncing long words.\nDave I’ve never heard of that.\nTheo That’s because I just invented it.\nDave Funny. What’s considered a long word for our animals?\nTheo Let’s say that when their name has more than five letters, they’re not able to\nsay it.\nDave A bit weird, but OK.\nTheo Let’s call our multimethod dysGreet. Its dispatch function returns an array\nwith two elements: the animal type and a Boolean about whether the name is\nlong or not. Take a look at this multimethod initialization.\n--- Page 315 ---\n13.4 Multimethods with dynamic dispatch 287\nListing13.18 A multimethod using a dispatch function with dynamic dispatch\nfunction dysGreetDispatch(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"dysGreet called with invalid arguments: \" + errors);\n}\n}\nvar hasLongName = animal.name.length > 5;\nreturn [animal.type, hasLongName];\n};\nvar dysGreet = multi(dysGreetDispatch);\nDave Writing the dysGreet methods doesn’t seem too complicated.\nAs Theo reaches over to pass Dave his notebook, he accidently hits his coffee cup. Now Theo’s\nnotebook is completely wet, and all the diagrams are soggy! Fortunately, Dave brought an\nextra napkin from the kitchen, and it’s still clean. He draws a flow diagram as in figure 13.4\nand then grabs his laptop and writes the implementation of the dysGreet methods.\n[\"dog\", true] dysGreetDogLong\nGreet as a dog mentioning name\n[\"cat\", true] dysGreetCatLong\nGreet as a cat mentioning name\n[\"cow\", true] dysGreetCowLong\nGreet as a cow mentioning name\nargs dysGreetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", false] dysGreetDogShort\nGreet as a dog omitting name\n[\"cat\", false] dysGreetCatShort\nGreet as a cat omitting name\n[\"cow\", false] dysGreetCowShort\nGreet as a cow omitting name\nFigure 13.4 The logic flow of the dysGreet multimethod\nListing13.19 The dysGreet methods\nfunction dysGreetDogLong(animal) {\nconsole.log(\"Woof woof! My name is \" + animal.name);\n}\ndysGreet = method([\"dog\", true], dysGreetDogLong)(dysGreet);\n--- Page 316 ---\n288 CHAPTER 13 Polymorphism\nfunction dysGreetDogShort(animal) {\nconsole.log(\"Woof woof!\");\n}\ndysGreet = method([\"dog\", false], dysGreetDogShort)(dysGreet);\nfunction dysGreetCatLong(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ndysGreet = method([\"cat\", true], dysGreetCatLong)(dysGreet);\nfunction dysGreetCatShort(animal) {\nconsole.log(\"Meow!\");\n}\ndysGreet = method([\"cat\", false], dysGreetCatShort)(dysGreet);\nfunction dysGreetCowLong(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ndysGreet = method([\"cow\", true], dysGreetCowLong)(dysGreet);\nfunction dysGreetCowShort(animal) {\nconsole.log(\"Moo!\");\n}\ndysGreet = method([\"cow\", false], dysGreetCowShort)(dysGreet);\nTheo checks that the code works as expected. He compliments Dave, not only on the\nmethod implementation but also for having the foresight to grab an extra napkin.\nListing13.20 Testing dysGreet\ndysGreet(myDog);\ndysGreet(myCow);\ndysGreet(myCat);\n//\"Woof woof!\"\n//\"Moo! Call me Clarabelle\"\n//\"Meow!\"\nTheo Well done, my friend! Our exploration of multimethods has come to an end. I\nthink it’s time for me to drive back if I want to get home before dark and beat\nthe rush hour traffic.\nDave Before you leave, let’s check if multimethods are available in programming\nlanguages other than JavaScript.\nTheo That’s a question for Joe.\nDave Do you think it’s OK if I call him now?\nTheo I think it’s probably better if you send him an email. He’s in a tech conference,\nand I’m not sure if it’s all day. Thank you for this beautiful day in the country\nand the wonderful refreshments.\nDave I enjoyed it, also, especially our discussions about etymology. I think there are\nsome oranges for you to take home and enjoy later.\nTheo Great! I can’t wait until my wife tries one.\n--- Page 317 ---\n13.5 Integrating multimethods in a production system 289\nAfter Theo leaves, Dave sends Joe an email. A few minutes later, Dave receives an email\nfrom Joe with the subject, “Support for multimethods in different languages.”\nSupport for multimethods in different languages\nPython has a library called multimethods (https://github.com/weissjeffm/multimeth-\nods), and Ruby has one called Ruby multimethods (https://github.com/psantacl/\nruby-multimethods). Both seem to work quite like the JavaScript arrows/multi-\nmethod library.\nIn Java, there is the Java Multimethod Framework (http://igm.univ-mlv.fr/~forax/\nworks/jmmf/), and C# supports multimethods natively via the dynamic keyword.\nHowever, in both Java and C#, multimethods work only with static data types and not\nwith generic data structures.\nGeneric data structure\nLanguage URL\nsupport\nJavaScript https://github.com/caderek/arrows/tree/master/ Yes\npackages/multimethod\nJava http://igm.univ-mlv.fr/~forax/works/jmmf/ No\nC# Native support No\nPython https://github.com/weissjeffm/multimethods Yes\nRuby https://github.com/psantacl/ruby-multimethods Yes\n13.5 Integrating multimethods in a production system\nWhile Theo is driving back home, his thoughts take him back to the fresh air of the coun-\ntry. This pleasant moment is interrupted by a phone call from Nancy at Klafim.\nNancy How are you doing?\nTheo Fine. I’m driving back from the countryside.\nNancy Cool. Are you available to talk about work?\nTheo Sure.\nNancy I’d like to add a tiny feature to the catalog.\nIn the past, when Nancy qualified a feature as tiny, it scared Theo because tiny turned into\nhuge. What seemed easy to her always took him a surprising amount of time to develop.\nBut after refactoring the system according to DOP principles, now what seems tiny to\nNancy is usually quite easy to implement.\nTheo What feature?\nNancy I’d like to allow librarians to view the list of authors, ordered by last name, in\ntwo formats: HTML and Markdown.\n--- Page 318 ---\n290 CHAPTER 13 Polymorphism\nTheo It doesn’t sound too complicated.\nNancy Also, I need a bit of text formatting.\nTheo What kind of text formatting?\nNancy Depending on the number of books an author has written, their name should\nbe in bold and italic fonts.\nTheo Could you send me an email with all the details. I’ll take a look at it tomorrow\nmorning.\nNancy Perfect. Have a safe drive!\nBefore going to bed, Theo reflects about today’s etymology lessons. He realizes that he\nnever looked for the etymology of the word etymology itself! He searches for the term etymol-\nogy online and learns that the word etymology derives from the Greek étumon, meaning true\nsense, and the suffix logia, denoting the study of. During the night, Theo dreams of dogs,\ncats, and cows programming on their laptops in a field of grass.\nWhen Theo arrives at the office the next day, he opens Nancy’s email with the details\nabout the text formatting feature. The details are summarized in table 13.1.\nTable 13.1 Text formatting for author names according to the number of books\nthey have written\nNumber of books Italic Bold\n10 or fewer Yes No\nBetween 11 and 50 No Yes\n51 or more Yes Yes\nTheo forwards Nancy’s email to Dave and asks him to take care of this task. Delegating\nresponsibility, after all, is the trait of a great manager.\nDave thinks the most difficult part of the feature lies in implementing an Author\n.myName(author, format) function that receives two arguments: the author data and the\ntext format. He asks himself whether he can implement this function as a multimethod\nand use what he learned yesterday with Theo at his parents’ home in the country. It seems\nthat this feature is quite similar to the one that dealt with dysmakrylexia. Instead of check-\ning the length of a string, he needs to check the length of an array.\nFirst, Dave needs a data schema for the text format. He could represent a format as a\nmap with a type field like Theo did yesterday for languages, but at the moment, it seems\nsimpler to represent a format as a string that could be either markdown or html. He comes\nup with the text format schema in listing 13.21. He already wrote the author schema with\nTheo last week. It’s in listing 13.22.\nListing13.21 The text format schema\nvar textFormatSchema = {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"enum\": [\"markdown\", \"html\"]}\n};\n--- Page 319 ---\n13.5 Integrating multimethods in a production system 291\nListing13.22 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"name\", \"bookIsbns\"],\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nNow, Dave needs to write a dispatch function and initialize the multimethod. Remember-\ning that Theo had no qualms about creating the word dysmakrylexia, he decides that he\nprefers his own neologism, prolificity, over the existing nominal form prolificness. He finds it\nuseful to have an Author.prolificityLevel helper function that returns the level of\nprolificity of the author: either low, medium, or high. Now he’s ready to code the author-\nNameDispatch function.\nListing13.23 Author.myName multimethod initialization\nAuthor.prolificityLevel = function(author) {\nvar books = _.size(_.get(author, \"bookIsbns\"));\nif (books <= 10) {\nreturn \"low\";\n};\nif (books >= 51) {\nreturn \"high\";\n}\nreturn \"medium\";\n};\nvar authorNameArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\nauthorSchema,\n{\"enum\": [\"markdown\", \"html\"]}\n]\n};\nfunction authorNameDispatch(author, format) {\nif(dev()) {\nif(!ajv.validate(authorNameArgsSchema, [author, format])) {\nthrow (\"Author.myName called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [Author.prolificityLevel(author), format];\n};\nAuthor.myName = multi(authorNameDispatch);\n--- Page 320 ---\n292 CHAPTER 13 Polymorphism\nThen Dave works on the methods: first, the HTML format methods. In HTML, bold text is\nwrapped inside a <b> tag, and italic text is wrapped in a <i> tag. For instance, in HTML,\nthree authors with different levels of prolificity would be written like this.\nListing13.24 Examples of bold and italic in HTML\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n<i>Yehonathan Sharvit<i>\nBold and italic formatting\n<b>Stephen Covey</b>\nfor highly prolific authors\n<b><i>Isaac Asimov</i></b>\nWith this information in hand, Dave writes the three methods that deal with HTML for-\nmatting. Easy!\nListing13.25 The methods that deal with HTML formatting\nfunction authorNameLowHtml(author, format) {\nreturn \"<i>\" + _.get(author, \"name\") + \"</i>\";\n}\nAuthor.myName = method([\"low\", \"html\"], authorNameLowHtml)(Author.myName);\nfunction authorNameMediumHtml(author, format) {\nreturn \"<b>\" + _.get(author, \"name\") + \"</b>\";\n}\nAuthor.myName =\nmethod([\"medium\", \"html\"], authorNameMediumHtml)(Author.myName);\nfunction authorNameHighHtml(author, format) {\nreturn \"<b><i>\" + _.get(author, \"name\") + \"</i></b>\";\n}\nAuthor.myName =\nmethod([\"high\", \"html\"], authorNameHighHtml)(Author.myName);\nThen, Dave moves on to the three methods that deal with Markdown formatting. In\nMarkdown, bold text is wrapped in two asterisks, and italic text is wrapped in a single\nasterisk. For instance, in Markdown, three authors with different levels of prolificity\nwould be written like the code in listing 13.26. The code for the Markdown methods is in\nlisting 13.27.\nListing13.26 Examples of bold and italic in Markdown\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n*Yehonathan Sharvit*\nBold and italic formatting\n**Stephen Covey**\nfor highly prolific authors\n***Isaac Asimov***\n--- Page 321 ---\n13.5 Integrating multimethods in a production system 293\nListing13.27 The methods that deal with Markdown formatting\nfunction authorNameLowMarkdown(author, format) {\nreturn \"*\" + _.get(author, \"name\") + \"*\";\n}\nAuthor.myName =\nmethod([\"low\", \"markdown\"], authorNameLowMarkdown)(Author.myName);\nfunction authorNameMediumMarkdown(author, format) {\nreturn \"**\" + _.get(author, \"name\") + \"**\";\n}\nAuthor.myName =\nmethod([\"medium\", \"markdown\"], authorNameMediumMarkdown)(Author.myName);\nfunction authorNameHighMarkdown(author, format) {\nreturn \"***\" + _.get(author, \"name\") + \"***\";\n}\nAuthor.myName =\nmethod([\"high\", \"markdown\"], authorNameHighMarkdown)(Author.myName);\nDave decides to test his code by involving a mysterious author. Listing 13.28 and listing 13.29\nshow the tests.\nListing13.28 Testing HTML formatting\nvar yehonathan = {\n\"name\": \"Yehonathan Sharvit\",\n\"bookIsbns\": [\"9781617298578\"]\n};\nAuthor.myName(yehonathan, \"html\");\n// → \"<i>Yehonathan Sharvit</i>\"\nListing13.29 Testing Markdown formatting\nAuthor.myName(yehonathan, \"markdown\");\n// → \"*Yehonathan Sharvit*\"\nTheo shows up at Dave’s desk and asks to review Dave’s implementation of the list of\nauthors feature. Curious, Theo asks Dave about the author that appears in the test of\nAuthor.myName.\nTheo Who is Yehonathan Sharvit?\nDave I don’t really know. The name appeared when I googled “data-oriented pro-\ngramming” yesterday. He wrote a book on the topic. I thought it would be cool\nto use its ISBN in my test.\n--- Page 322 ---\n294 CHAPTER 13 Polymorphism\nSummary\n The main benefit of polymorphism is extensibility.\n Multimethods make it possible to benefit from polymorphism when data is repre-\nsented with generic maps.\n A multimethod is made of a dispatch function and multiple methods.\n The dispatch function of a multimethod emits a dispatch value.\n Each of the methods used in a multimethod provides an implementation for a\nspecific dispatch value.\n Multimethods can mimic OOP class inheritance via single dispatch.\n In single dispatch, a multimethod receives a single map that contains a type field,\nand the dispatch function of the multimethod emits the value of the type field.\n In addition to single dispatch, multimethods provide two kinds of advanced\npolymorphisms: multiple dispatch and dynamic dispatch.\n Multiple dispatch is used when the behavior of the multimethod depends on\nmultiple arguments.\n Dynamic dispatch is used when the behavior of the multimethod depends on run-\ntime arguments.\n The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\n A multimethod dispatch function is responsible for\n– Defining the signature.\n– Validating the arguments.\n– Emitting a dispatch value.\n Multimethods provides extensibility by decoupling between multimethod ini-\ntialization and method implementations.\n Multimethods are called like regular functions.\n Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\n In a multimethod that features multiple dispatch, the order of the elements in\nthe array emitted by the dispatch function has to be consistent with the order of\nthe elements in the wiring of the methods.\nLodash functions introduced in this chapter\nFunction Description\nsize(coll) Gets the size of coll\n--- Page 323 ---\nAdvanced data\nmanipulation\nWhatever is well-conceived\nis clearly said\nThis chapter covers\n Manipulating nested data\n Writing clear and concise code for business\nlogic\n Separating business logic and generic data\nmanipulation\n Building custom data manipulation tools\n Using the best tool for the job\nWhen our business logic involves advanced data processing, the generic data manip-\nulation functions provided by the language run time and by third-party libraries\nmight not be sufficient. Instead of mixing the details of data manipulation with\nbusiness logic, we can write our own generic data manipulation functions and imple-\nment our custom business logic using them. Separating business logic from the inter-\nnal details of data manipulation makes the business logic code concise and easy to\nread for other developers.\n295\n--- Page 324 ---\n296 CHAPTER 14 Advanced data manipulation\n14.1 Updating a value in a map with eloquence\nDave is more and more autonomous on the Klafim project. He can implement most fea-\ntures on his own, typically turning to Theo only for code reviews. Dave’s code quality stan-\ndards are quite high. Even when his code is functionally solid, he tends to be unsatisfied\nwith its readability. Today, he asks for Theo’s help in improving the readability of the code\nthat fixes a bug Theo introduced a long time ago.\nDave I think I have a found a bug in the code that returns book information from\nthe Open Library API.\nTheo What bug?\nDave Sometimes, the API returns duplicate author names, and we pass the dupli-\ncates through to the client.\nTheo It doesn’t sound like a complicated bug to fix.\nDave Right, I fixed it, but I’m not satisfied with the readability of the code I wrote.\nTheo Being critical of our own code is an important quality for a developer to prog-\nress. What is it exactly that you don’t like?\nDave Take a look at this code.\nListing14.1 Removing duplicates in a straightforward but tedious way\nfunction removeAuthorDuplicates(book) {\nvar authors = _.get(book, \"authors\");\nvar uniqAuthors = _.uniq(authors);\nreturn _.set(book,\"authors\", uniqAuthors);\n}\nDave I’m using _.get to retrieve the array with the author names, then _.uniq to\ncreate a duplicate-free version of the array, and finally, _.set to create a new\nversion of the book with no duplicate author names.\nTheo The code is tedious because the next value of authorNames needs to be based\non its current value.\nDave But it’s a common use case! Isn’t there a simpler way to write this kind of code?\nTheo Your astonishment definitely honors you as a developer, Dave. I agree with you\nthat there must be a simpler way. Let me phone Joe and see if he’s available for\na conference call.\nJoe How’s it going, Theo?\nTheo Great! Are you back from your tech conference?\nJoe I just landed. I’m on my way home now in a taxi.\nTheo How was your talk about DOP?\nJoe Pretty good. At the beginning people were a bit suspicious, but when I told\nthem the story of Albatross and Klafim, it was quite convincing.\nTheo Yeah, adults are like children in that way; they love stories.\nJoe What about you? Did you manage to achieve polymorphism with multimethods?\nTheo Yes! Dave even managed to implement a feature in Klafim with multimethods.\nJoe Cool!\n--- Page 325 ---\n14.1 Updating a value in a map with eloquence 297\nTheo Do you have time to help Dave with a question about programming?\nJoe Sure.\nDave Hi Joe. How are you doing?\nJoe Hello Dave. Not bad. What kind of help do you need?\nDave I’m wondering if there’s a simpler way to remove duplicates inside an array\nvalue in a map. Using _.get, _.uniq, and _.set looks quite tedious.\nJoe You should build your own data manipulation tools.\nDave What do you mean?\nJoe You should write a generic update function that updates a value in a map,\napplying a calculation based on its current value.1\nDave What would the arguments of update be in your opinion?\nJoe Put the cart before the horse.\nDave What?!\nJoe Rewrite your business logic as if update were already implemented, and you’ll\ndiscover what the arguments of update should be.\nDave I see what you mean: the horse is the implementation of update, and the cart is\nthe usage of update.\nJoe Exactly. But remember, it’s better if you keep your update function generic.\nDave How?\nJoe By not limiting it to your specific use case.\nDave I see. The implementation of update should not deal with removing duplicate\nelements. Instead, it should receive the updating function—in my case,\n_.uniq—as an argument.\nJoe Exactly! Uh, sorry Dave, I gotta go, I just got home. Good luck!\nDave Take care, Joe, and thanks!\nDave ends the conference call. Looking at Theo, he reiterates the conversation with Joe.\nDave Joe advised me to write my own update function. For that purpose, he told me\nto start by rewriting removeAuthorDuplicates as if update were already\nimplemented. That will allow us to make sure we get the signature of update\nright.\nTheo Sounds like a plan.\nDave Joe called it “putting the cart before the horse.”\nTheo Joe and his funny analogies...\nTIP The best way to find the signature of a custom data manipulation function is to\nthink about the most convenient way to use it.\nDave Anyway, the way I’d like to use update inside removeAuthorDuplicates is\nlike this.\n1 Lodash provides an implementation of update, but for the sake of teaching, we are writing our own imple-\nmentation.\n--- Page 326 ---\n298 CHAPTER 14 Advanced data manipulation\nListing14.2 The code that removes duplicates in an elegant way\nfunction removeAuthorDuplicates(book) {\nreturn update(book, \"authors\", _.uniq);\n}\nTheo Looks good to me!\nDave Wow! Now the code with update is much more elegant than the code with\n_.get and _.set!\nTheo Before you implement update, I suggest that you write down in plain English\nexactly what the function does.\nDave It’s quite easy: update receives a map called map, a path called path, and a\nfunction called fun. It returns a new version of map, where path is associated\nwith fun(currentValue), and currentValue is the value associated with\npath in map.\nThinking out loud, Dave simultaneously draws a diagram like that in figure 14.1. Theo is\nbecoming more and more impressed with his young protegé as he studies the figure.\n{\n\"position\" : \"manager\", \"income\"\n\"income\" : 100000\n} map fun path\nupdate\n{\n\"position\" : \"manager\",\n\"income\" : fun(100000)\nres Figure 14.1 The\n}\nbehavior of update\nTIP Before implementing a custom data manipulation function, formulate in plain\nEnglish exactly what the function does.\nTheo With such a clear definition, it’s going to be a piece of cake to implement\nupdate!\nAfter a few minutes, Dave comes up with the code. It doesn’t take long because the plain-\nEnglish diagram helps him to organize the code.\nListing14.3 A generic update function\nfunction update(map, path, fun) {\nvar currentValue = _.get(map, path);\nvar nextValue = fun(currentValue);\nreturn _.set(map, path, nextValue);\n}\n--- Page 327 ---\n14.2 Manipulating nested data 299\nTheo Why don’t you see if it works with a simple case such as incrementing a number\nin a map?\nDave Good idea! I’ll try multiplying a value in a map by 2 with update. How’s this\nlook?\nListing14.4 Multiplying a value in a map by 2\nvar m = {\n\"position\": \"manager\",\n\"income\": 100000\n};\nupdate(m, \"income\", function(x) {\nreturn x * 2;\n});\n// → {\"position\": \"manager\", \"income\": 200000}\nTheo Great! It seems to work.\n14.2 Manipulating nested data\nThe next Monday, during Theo and Dave’s weekly sync meeting, they discuss the upcom-\ning features for Klafim. Theo fondly remembers another Monday where they met at Dave’s\nfamily home in the country. Coming back to the present moment, Theo begins.\nTheo Recently, Nancy has been asking for more and more administrative features.\nDave Like what?\nTheo I’ll give you a few examples.... Let me find the email I got from Nancy yesterday.\nDave OK.\nTheo Here it is. There are three feature requests for now: listing all the book author\nIDs, calculating the book lending ratio, and grouping books by a physical library.\nDave What feature should I tackle first?\nTheo It doesn’t matter, but you should deliver the three of these before the end of\nthe week. Good luck, and don’t hesitate to call me if you need help.\nOn Tuesday, Dave asks for Theo’s help. Dave is not pleased with how his code looks.\nDave I started to work on the three admin features, but I don’t like the code I wrote.\nLet me show you the code for retrieving the list of author IDs from the list of\nbooks returned from the database.\nTheo Can you remind me what an element in a book list returned from the database\nlooks like?\nDave Each book is a map with an authorIds array field.\nTheo OK, so it sounds like a map over the books should do it.\nDave This is what I did, but it doesn’t work as expected. Here’s my code for listing\nthe book author IDs.\n--- Page 328 ---\n300 CHAPTER 14 Advanced data manipulation\nListing14.5 Retrieving the author IDs in books as an array of arrays\nfunction authorIdsInBooks(books) {\nreturn _.map(books, \"authorIds\");\n}\nTheo What’s the problem?\nDave The problem is that it returns an array of arrays of author IDs instead of an\narray of author IDs. For instance, when I run authorIdsInBooks on a catalog\nwith two books, I get this result.\nListing14.6 The author IDs in an array of arrays\n[\n[\"sean-covey\", \"stephen-covey\"],\n[\"alan-moore\", \"dave-gibbons\"]\n]\nTheo That’s not a big problem. You can flatten an array of arrays with _.flatten,\nand you should get the result you expect.\nDave Nice! This is exactly what I need! Give me a moment to fix the code of\nauthorIdsInBooks. . . here you go.\nListing14.7 Retrieving the author IDs in books as an array of strings\nfunction authorIdsInBooks(books) {\nreturn _.flatten(_.map(books, \"authorIds\"));\n}\nTheo Don’t you think that mapping and then flattening deserves a function of its own?\nDave Maybe. It’s quite easy to implement a flatMap function.2 How about this?\nListing14.8 The implementation of flatMap\nfunction flatMap(coll, f) {\nreturn _.flatten(_.map(coll,f));\n}\nTheo Nice!\nDave I don’t know.... It’s kind of weird to have such a small function.\nTheo I don’t think that code size is what matters here.\nDave What do you mean?\nTheo See what happens when you rewrite authorIdsInBooks using flatMap.\nDave OK, here’s how I’d use flatMap to list the author IDs.\n2 Lodash provides an implementation of flatMap, but for the sake of teaching, we are writing our own\nimplementation.\n--- Page 329 ---\n14.3 Using the best tool for the job 301\nListing14.9 Retrieving the author IDs as an array of strings using flatMap\nfunction authorIdsInBooks(books) {\nreturn flatMap(books, \"authorIds\");\n}\nTheo What implementation do you prefer, the one with flatten and map (in listing\n14.7) or the one with flatMap (in listing 14.9)?\nDave I don’t know. To me, they look quite similar.\nTheo Right, but which implementation is more readable?\nDave Well, assuming I know what flatMap does, I would say the implementation\nwith flatMap. Because it’s more concise, it is a bit more readable.\nTheo Again, it’s not about the size of the code. It’s about the clarity of intent and the\npower of naming things.\nDave I don’t get that.\nTheo Let me give you an example from our day-to-day language.\nDave OK.\nTheo Could you pass me that thing on your desk that’s used for writing?\nIt takes Dave a few seconds to get that Theo has asked him to pass the pen on the desk.\nAfter he passes Theo the pen, he asks:\nDave Why didn’t you simply ask for the pen?\nTheo I wanted you to experience how it feels when we use descriptions instead of\nnames to convey our intent.\nDave Oh, I see. You mean that once we use a name for the operation that maps and\nflattens, the code becomes clearer.\nTheo Exactly.\nDave Let’s move on to the second admin feature: calculating the book lending ratio.\nTheo Before that, I think we deserve a short period for rest and refreshments, where\nwe drink a beverage made by percolation from roasted and ground seeds.\nDave A coffee break!\n14.3 Using the best tool for the job\nAfter the coffee break, Dave shows Theo his implementation of the book lending ratio cal-\nculation. This time, he seems to like the code he wrote.\nDave I’m quite proud of the code I wrote to calculate the book lending ratio.\nTheo Show me the money!\nDave My function receives a list of books from the database like this.\nListing14.10 A list of two books with bookItems\n[\n{\n\"isbn\": \"978-1779501127\",\n--- Page 330 ---\n302 CHAPTER 14 Advanced data manipulation\n\"title\": \"Watchmen\",\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n}\n]\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"bookItems\": [\n{\n\"id\": \"book-item-123\",\n\"libId\": \"hudson-park-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-17\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n]\nTheo Quite a nested piece of data!\nDave Yeah, but now that I’m using flatMap, calculating the lending ratio is quite\neasy. I’m going over all the book items with forEach and incrementing either\nthe lent or the notLent counter. At the end, I return the ratio between lent\nand (lent + notLent). Here’s how I do that.\nListing14.11 Calculating the book lending ratio using forEach\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar lent = 0;\nvar notLent = 0;\n_.forEach(bookItems, function(item) {\nif(_.get(item, \"isLent\")) {\nlent = lent + 1;\n} else {\nnotLent = notLent + 1;\n}\n});\nreturn lent/(lent + notLent);\n}\nTheo Would you allow me to tell you frankly what I think of your code?\nDave If you are asking this question, it means that you don’t like it. Right?\nTheo It’s nothing against you; I don’t like any piece of code with forEach.\n--- Page 331 ---\n14.3 Using the best tool for the job 303\nDave What’s wrong with forEach?\nTheo It’s too generic!\nDave I thought that genericity was a positive thing in programming.\nTheo It is when we build a utility function, but when we use a utility function, we\nshould use the least generic function that solves our problem.\nDave Why?\nTheo Because we ought to choose the right tool for the job, like in the real life.\nDave What do you mean?\nTheo Let me give you an example. Yesterday, I had to clean my drone from the\ninside. Do you think that I used a screwdriver or a Swiss army knife to unscrew\nthe drone cover?\nDave A screwdriver, of course! It’s much more convenient to manipulate.\nTheo Right. Also, imagine that someone looks at me using a screwdriver. It’s quite\nclear to them that I am turning a screw. It conveys my intent clearly.\nDave Are you saying that forEach is like the Swiss army knife of data manipulation?\nTheo That’s a good way to put it.\nTIP Pick the least generic utility function that solves your problem.\nDave What function should I use then, to iterate over the book item collection?\nTheo You could use _.reduce.\nDave I thought reduce was about returning data from a collection. Here, I don’t\nneed to return data; I need to update two variables, lent and notLent.\nTheo You could represent those two values in a map with two keys.\nDave Can you show me how to rewrite my lendingRatio function using reduce?\nTheo Sure. The initial value passed to reduce is the map, {\"lent\": 0, \"notLent\": 0},\nand inside each iteration, we update one of the two keys, like this.\nListing14.12 Calculating the book lending ratio using reduce\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = _.reduce(bookItems, function(res, item) {\nif(_.get(item, \"isLent\")) {\nres.lent = res.lent + 1;\n} else {\nres.notLent = res.notLent + 1;\n}\nreturn res;\n}, {notLent: 0, lent:0});\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nDave Instead of updating the variables lent and notLent, now we are updating lent\nand notLent map fields. What’s the difference?\n--- Page 332 ---\n304 CHAPTER 14 Advanced data manipulation\nTheo Dealing with map fields instead of variables allows us to get rid of reduce in\nour business logic code.\nDave How could you iterate over a collection without forEach and without reduce?\nTheo I can’t avoid the iteration over a collection, but I can hide reduce behind a\nutility function. Take a look at the way reduce is used inside the code of\nlendingRatio. What is the meaning of the reduce call?\nDave looks at the code in listing 14.12. He thinks for a long moment before he answers.\nDave I think it’s counting the number of times isLent is true and false.\nTheo Right. Now, let’s use Joe’s advice about building our own data manipulation\ntool.\nDave How exactly?\nTheo I suggest that you write a countByBoolField utility function that counts the\nnumber of times a field is true and false.\nDave OK, but before implementing this function, let me first rewrite the code of\nlendingRatio, assuming this function already exists.\nTheo You are definitely a fast learner, Dave!\nDave Thanks! I think that by using countByBoolField, the code for calculating the\nlending ratio using a custom utility function would be something like this.\nListing14.13 Calculating the book lending ratio\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = countByBoolField(bookItems, \"isLent\", \"lent\", \"notLent\");\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nTIP Don’t use _.reduce or any other low-level data manipulation function inside\ncode that deals with business logic. Instead, write a utility function—with a proper\nname—that hides _.reduce.\nTheo Perfect. Don’t you think that this code is clearer than the code using _.reduce?\nDave I do! The code is both more concise and the intent is clearer. Let me see if I\ncan implement countByBoolField now.\nTheo I suggest that you write a unit test first.\nDave Good idea.\nDave types for a bit. When he’s satisfied, he shows Theo the result.\nListing14.14 A unit test for countByBoolField\nvar input = [\n{\"a\": true},\n{\"a\": false},\n{\"a\": true},\n--- Page 333 ---\n14.4 Unwinding at ease 305\n{\"a\": true}\n];\nvar expectedRes = {\n\"aTrue\": 3,\n\"aFalse\": 1\n};\n_.isEqual(countByBoolField(input, \"a\", \"aTrue\", \"aFalse\"), expectedRes);\nTheo Looks good to me. Now, for the implementation of countByBoolField, I\nthink you are going to need our update function.\nDave I think you’re right. On each iteration, I need to increment the value of either\naTrue or aFalse using update and a function that increments a number by 1.\nAfter a few minutes of trial and error, Dave comes up with the piece of code that uses\nreduce, update, and inc. He shows Theo the code for countByBoolField.\nListing14.15 The implementation of countByBoolField\nfunction inc (n) {\nreturn n + 1;\n}\nfunction countByBoolField(coll, field, keyTrue, keyFalse) {\nreturn _.reduce(coll, function(res, item) {\nif (_.get(item, field)) {\nreturn update(res, keyTrue, inc);\n}\nreturn update(res, keyFalse, inc);\n}, {[keyTrue]: 0,\nCreates a map with\n[keyFalse]: 0});\nkeyTrue and keyFalse\n}\nassociated to 0\nTheo Well done! Shall we move on and review the third admin feature?\nDave The third feature is more complicated. I would like to use the teachings from\nthe first two features for the implementation of the third feature.\nTheo OK. Call me when you’re ready for the code review.\n14.4 Unwinding at ease\nDave really struggled with the implementation of the last admin feature, grouping books\nby a physical library. After a couple of hours of frustration, Dave calls Theo for a rescue.\nDave I really had a hard time implementing the grouping by library feature.\nTheo I only have a couple of minutes before my next meeting, but I can try to help\nyou. What’s the exact definition of grouping by library?\nDave Let me show you the unit test I wrote.",
        "sections_found": []
      },
      "accurate_page_range": "303-333"
    },
    {
      "text": "- 12.6 A new gift",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "raw_line": "- 12.6 A new gift (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 104,
      "chapter_info": {
        "page": 303,
        "title": "Advanced data validation",
        "pattern_matched": "Chapter 12",
        "text_preview": "13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with "
      },
      "chapter_sections": {
        "start_page": 303,
        "end_page": 333,
        "content": "\n--- Page 303 ---\n13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with maps\nvar myDog = {\n\"type\": \"dog\",\n\"name\": \"Fido\"\n};\nvar myCat = {\n\"type\": \"cat\",\n\"name\": \"Milo\"\n};\nvar myCow = {\n\"type\": \"cow\",\n\"name\": \"Clarabelle\"\n};\nDave Could you have given another name to the field that holds the animal type?\nTheo Absolutely. It could be anything.\nDave I see. You’re asking me the fundamental difference between your code with a\nswitch statement and my code with an interface and three classes?\nTheo Exactly.\nDave First of all, if you pass an invalid map to your greet function, bad things will\nhappen.\nTheo You’re right. Let me fix that and validate input data.\nListing13.4 Data validation\nvar animalSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nSee chapter 12 about\ndata validation for\nfunction greet(animal) {\ndetails.\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\n--- Page 304 ---\n276 CHAPTER 13 Polymorphism\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\nbreak;\ncase \"cat\":\nconsole.log(\"Meow! I am: \" + animal.name);\nbreak;\ncase \"cow\":\nconsole.log(\"Moo! Call me \" + animal.name);\nbreak;\n};\n}\n NOTE You should not use switch statements like this in your production code.\nWe use them here for didactic purposes only as a step towards distilling the essence of\npolymorphism.\nDave Another drawback of your approach is that when you want to modify the\nimplementation of greet for a specific animal, you have to change the code\nthat deals with all the animals, while in my approach, you would change only a\nspecific animal class.\nTheo I agree, and I could also fix that by having a separate function for each animal,\nsomething like this.\nListing13.5 Different implementations in different functions\nfunction greetDog(animal) {\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\n}\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am: \" + animal.name);\n}\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\nfunction greet(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\ngreetDog(animal);\nbreak;\ncase \"cat\":\ngreetCat(animal);\nbreak;\ncase \"cow\":\ngreetCow(animal);\n--- Page 305 ---\n13.2 Multimethods with single dispatch 277\nbreak;\n};\n}\nDave But what if you want to extend the functionality of greet and add a new animal?\nTheo Now you got me. I admit that with a switch statement, I can’t add a new animal\nwithout modifying the original code, whereas in OOP, I can add a new class\nwithout having to modify the original code.\nDave Yeah, but you helped me to realize that the main benefit of polymorphism is\nthat it makes the code easily extensible.\nTIP The main benefit of polymorphism is extensibility.\nTheo I’m going to ask Joe if there’s a way to benefit from polymorphism without\nobjects.\nTheo sends a message to Joe and asks him about polymorphism in DOP. Joe answers that\nhe doesn’t have time to get into a deep response because he is in a tech conference where\nhe is about to give a talk about DOP. The only thing he has time to tell Theo is that he\nshould take a look at multimethods.\nTheo and Dave read some online material about multimethods. It doesn’t look too\ncomplicated. They decide that after lunch they will give multimethods a try.\n13.2 Multimethods with single dispatch\nDuring lunch, Theo asks Dave how it feels to have grown up in the country. Dave starts\nwith an enthusiastic description about being in direct contact with nature and living a sim-\npler life than in the city. He’s grateful for the experience, but he admits that country life\ncan sometimes be hard without the conveniences of the city. But who said simple was easy?\nAfter lunch, they decide to have coffee. Dave asks Theo if he’d like to grind the coffee\nbeans himself. Theo accepts with joy. Next, Dave explains how to use a French press coffee\nmaker to get the ideal tradeoff between bitterness and rich taste. While savoring their\nFrench press coffee in the garden, Theo and Dave continue their exploration of polymor-\nphism à la DOP.\nTheo From what I read before lunch, it seems that multimethods are a software con-\nstruct that provide polymorphism without the need for objects.\nDave I don’t get how that’s possible.\nTheo Multimethods have two parts: a dispatch function and a set of methods that\nprovide an implementation for each dispatched value.\nDave I’m not sure I’m clear on that. Is a dispatch function like an interface?\nTheo It’s like an interface in the sense that it defines the way the function needs to\nbe called, but it goes beyond that. It also dispatches a value that differentiates\nbetween the different implementations.\nDave That’s a bit abstract for me.\nTheo I think I understand how to implement the animal greeting capabilities. If we\nuse a multimethod called greet, we need a dispatch function and three\nmethods. Let’s call the dispatch function greetDispatch. It dispatches the\nanimal type, either \"dog\", \"cat\", or \"cow\". Then, each dispatch value is\n--- Page 306 ---\n278 CHAPTER 13 Polymorphism\nhandled by a specific method: \"dog\" by greetDog, \"cat\" by greetCat, and\n\"cow\" by greetCow.\nTheo takes out his notebook and opens it to a blank piece of paper. He draws a diagram\nlike the one in figure 13.1.\n\"dog\" greetDog\nGreet as a dog\ngreetDispatch \"cat\" greetCat\nEmit the animal type Greet as a cat\nanimal\ntype, name \"cow\" greetCow\nGreet as a cow\nFigure 13.1 The logic flow\nof the greet multimethod\nDave Why is there an arrow between animal and the methods, in addition to the\narrows between animal and the dispatch functions?\nTheo Because the arguments of a multimethod are passed to the dispatch function\nand to the methods.\nTIP The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\nDave Arguments plural?... I see only a single argument.\nTheo You’re right. Right now our multimethod only receives a single argument, but\nsoon it will receive several arguments.\nDave I see. Could you show me how to write the code for the greet multimethod?\nTheo For that, we need a library. For instance, in JavaScript, the arrows/multi-\nmethod library provides an implementation of multimethods. Basically, we call\nmulti to create a multimethod called method to add a method.\n NOTE See http://mng.bz/nY9v for examples and documentation about this library.\nDave Where should we start?\nTheo We’ll start with multimethod initialization by creating a dispatch function\ngreetDispatch that defines the signature of the multimethod, validates the\narguments, and emits the type of the animal. Then we’ll pass greetDispatch\nto multi in order to create the greet multimethod. Our dispatch function\nwould then look like this.\nListing13.6 The dispatch function for greet multimethod\nfunction greetDispatch(animal) {\nSignature definition\nif(dev()) {\n--- Page 307 ---\n13.2 Multimethods with single dispatch 279\nif(!ajv.validate(animalSchema, animal)) {\nArgument validation\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nDispatch value\nreturn animal.type;\n}\nMultimethod\ninitialization\nvar greet = multi(greetDispatch);\nTIP A multimethod dispatch function is responsible for three things: it defines the sig-\nnature of the multimethod, it validates the arguments, and it emits a dispatch value.\nDave What’s next?\nTheo Now we need to implement a method for each dispatched value. Let’s start\nwith the method that deals with dogs. We create a greetDog function that\nreceives an animal and then add a dog method to the greet multimethod\nusing the method function from the arrows/multimethod library. The method\nfunction receives two arguments: the dispatched value and a function that cor-\nresponds to the dispatch value.\nListing13.7 Implementation of greet method for dogs\nfunction greetDog(animal) {\nMethod\nconsole.log(\"Woof woof! My name is \" + animal.name);\nimplementation\n}\ngreet = method(\"dog\", greetDog)(greet);\nMethod declaration\nDave Does the method implementation have to be in the same module as the multi-\nmethod initialization?\nTheo No, not at all! Method declarations are decoupled from multimethod initializa-\ntion exactly like class definitions are decoupled from the interface definition.\nThat’s what make multimethods extensible.\nTIP Multimethods provides extensibility by decoupling between multimethod initial-\nization and method implementations.\nDave What about cats and cows?\nTheo We add their method implementations like we did for dogs.\nTheo takes a moment to envision the implementation. Then he codes up two more greet\nmethods for cats and cows.\nListing13.8 Implementation of greet method for cats\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ngreet = method(\"cat\", greetCat)(greet);\n--- Page 308 ---\n280 CHAPTER 13 Polymorphism\nListing13.9 Implementation of greet method for cows\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ngreet = method(\"cow\", greetCow)(greet);\nTIP In the context of multimethods, a method is a function that provides an imple-\nmentation for a dispatch value.\nDave Are the names of dispatch functions and methods important?\nTheo According to what I read, not really, but I like to follow a simple naming con-\nvention: use the name of the multimethod (for example, greet) as a prefix for\nthe dispatch function (for example, greetDispatch) and the methods. Then\nI’d have the Dispatch suffix for the dispatch function and a specific suffix for\neach method (for example, greetDog, greetCat, and greetCow).\nDave How does the multimethod mechanism work under the hood?\nTheo Internally, a multimethod maintains a hash map where the keys are the dis-\npatched values, and the values are the methods. When we add a method, an\nentry is added to the hash map, and when we call the multimethod, we query the\nhash map to find the implementation that corresponds to the dispatched value.\nDave I don’t think you’ve told me yet how to call a multimethod.\nTheo We call it as a regular function. Give me a minute, and I’ll show you an exam-\nple that calls a multimethod.\nListing13.10 Calling a multimethod like a regular function\ngreet(myDog);\n// → \"Woof woof! My name is Fido\"\ngreet(myCat);\n// → \"Meow! I am Milo\"\ngreet(myCow);\n// → \"Moo! Call me Clarabelle\"\nTIP Multimethods are called like regular functions.\nDave You told me earlier that in the dispatch function, we should validate the argu-\nments. Is that mandatory or is it a best practice?\nTheo It’s a best practice.\nDave What happens if the dispatch function doesn’t validate the arguments, and we\npass an invalid argument?\nTheo Like when an animal has no corresponding method?\nDave Exactly!\nTheo In that case, you’ll get an error. For instance, the arrows/multimethods library\nthrows a NoMethodError exception.\nDave That’s annoying. Is there a way to provide a default implementation?\n--- Page 309 ---\n13.3 Multimethods with multiple dispatch 281\nTheo Absolutely! In order to define a default implementation, you pass to method—\nas a single argument—the function that provides the default implementation.\nTheo writes the code and shows it to Dave. Dave then tests Theo’s code and seems satisfied\nwith the result.\nListing13.11 Defining a default implementation\nfunction greetDefault(animal) {\nconsole.log(\"My name is \" + animal.name);\n}\ngreet = method(greetDefault)(greet);\nListing13.12 Calling a multimethod when no method fits the dispatch value\nvar myHorse = {\n\"type\": \"horse\",\n\"name\": \"Horace\"\n};\ngreet(myHorse);\n// → \"My name is Horace\"\nTIP Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\nDave Cool!\n13.3 Multimethods with multiple dispatch\nTheo So far, we’ve mimicked OOP by having the type of the multimethod argument\nas a dispatch value. But if you think again about the flow of a multimethod,\nyou’ll discover something interesting. Would you like to try and draw a dia-\ngram that describes the flow of a multimethod in general?\nDave Let me get a fresh napkin. The one under my glass is a bit wet.\nTheo Uh, Dave, you can use my notebook.\nIt takes Dave a few minutes to draw a diagram like the one in figure 13.2. He pushes the\nnotebook back to Theo.\nValue1 Method1\nHandle case 1\nDispatch function Value3 Method3\nEmit a dispatch value Handle case 3\nargs\nValue2 Method2\nHandle case 2\nFigure 13.2 The logic flow\nof multimethods\n--- Page 310 ---\n282 CHAPTER 13 Polymorphism\nTheo Excellent! I hope you see that the dispatch function can emit any value.\nDave Like what?\nTheo Like emitting the type of two arguments!\nDave What do you mean?\nTheo Imagine that our animals are polyglot.\nDave Poly what?\nTheo Polyglot comes from the Greek polús, meaning much, and from glôssa, meaning\nlanguage. A polyglot is a person who can speak many languages.\nDave What languages would our animals speak?\nTheo I don’t know. Let’s say English and French.\nDave OK, and how would we represent a language in our program?\nTheo With a map, of course!\nDave What fields would we have in a language map?\nTheo Let’s keep things simple and have two fields: type and name.\nDave Like an animal map?\nTheo Not exactly. In a language map, the type field must be either fr for French or en\nfor English, whereas in the animal map, the type field is either dog, cat, or cow.\nDave Let me try to write the language map schema and the two language maps.\nTheo gladly consents; his French press coffee is getting cold! Dave writes his implementa-\ntion of the code and shows Theo.\nListing13.13 The schema of a language map\nvar languageSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nListing13.14 Two language maps\nvar french = {\n\"type\": \"fr\",\n\"name\": \"Français\"\n};\nvar english = {\n\"type\": \"en\",\n\"name\": \"English\"\n};\nTheo Excellent! Now, let’s write the code for the dispatch function and the methods\nfor our polyglot animals. Let’s call our multimethod, greetLang. We have one\ndispatch function and six methods.\n--- Page 311 ---\n13.3 Multimethods with multiple dispatch 283\nDave Right, three animals (dog, cat, and cow) times two languages (en and fr).\nBefore the implementation, I’d like to draw a flow diagram. It will help me to\nmake things crystal clear.\nTheo You need my notebook again?\nNot waiting for Dave to respond, Theo pushes his notebook across the table to Dave. Dave\ndraws a diagram like the one in figure 13.3 and slides the notebook back to Theo.\n[\"dog\", \"en\"] greetLangDogEn\nGreet as a dog in English\n[\"cat\", \"en\"] greetLangCatEn\nGreet as a cat in English\n[\"cow\", \"en\"] greetLangCowEn\nGreet as a cow in English\nargs greetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", \"fr\"] greetLangDogFr\nGreet as a dog in French\n[\"cat\", \"fr\"] greetLangCatFr\nGreet as a cat in French\n[\"cow\", \"fr\"] greetLangCowFr\nGreet as a cow in French\nFigure 13.3 The logic flow of the greetLang multimethod\nTheo Why did you omit the arrow between the arguments and the methods?\nDave In order to keep the diagram readable. Otherwise, there would be too many\narrows.\nTheo OK, I see. Are you ready for coding?\nDave Yes!\nTheo The dispatch function needs to validate its arguments and return an array with\ntwo elements: the type of animal and the type of language.\nDave types for a bit on his laptop. He initializes the multimethod with a dispatch function\nthat returns the type of its arguments and then shows the code to Theo.\nListing13.15 Initializing a multimethod with a dispatch function\nvar greetLangArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [animalSchema, languageSchema]\n};\nfunction greetLangDispatch(animal, language) {\nif(dev()) {\n--- Page 312 ---\n284 CHAPTER 13 Polymorphism\nif(!ajv.validate(greetLangArgsSchema, [animal, language])) {\nthrow (\"greetLang called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [animal.type, language.type];\n};\nvar greetLang = multi(greetLangDispatch);\nDave Does the order of the elements in the array matter?\nTheo It doesn’t matter, but it needs to be consistent with the wiring of the methods.\nThe implementation of greetLang would therefore look like this.\nListing13.16 The implementation of greetLang methods\nfunction greetLangDogEn(animal, language) {\nconsole.log(\"Woof woof! My name is \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"en\"], greetLangDogEn)(greetLang);\nfunction greetLangDogFr(animal, language) {\nconsole.log(\"Ouaf Ouaf! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"fr\"], greetLangDogFr)(greetLang);\nfunction greetLangCatEn(animal, language) {\nconsole.log(\"Meow! I am \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"en\"], greetLangCatEn)(greetLang);\nfunction greetLangCatFr(animal, language) {\nconsole.log(\"Miaou! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"fr\"], greetLangCatFr)(greetLang);\nfunction greetLangCowEn(animal, language) {\nconsole.log(\"Moo! Call me \" +\nanimal.name +\n\" and I speak \" +\n--- Page 313 ---\n13.3 Multimethods with multiple dispatch 285\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"en\"], greetLangCowEn)(greetLang);\nfunction greetLangCowFr(animal, language) {\nconsole.log(\"Meuh! Appelle moi \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"fr\"], greetLangCowFr)(greetLang);\nDave looks at the code for the methods that deal with French. He is surprised to see Ouaf\nOuaf instead of Woof Woof for dogs, Miaou instead of Meow for cats, and Meuh instead of\nMoo for cows.\nDave I didn’t know that animal onomatopoeia were different in French than in\nEnglish!\nTheo Ono what?\nDave Onomatopoeia, from the Greek ónoma that means name and poiéo– that means to\nproduce. It is the property of words that sound like what they represent; for\ninstance, Woof, Meow, and Moo.\nTheo Yeah, for some reason in French, dogs Ouaf, cats Miaou, and cows Meuh.\nDave I see that in the array the animal type is always before the language type.\nTheo Right! As I told you before, in a multimethod that features multiple dispatch,\nthe order doesn’t really matter, but it has to be consistent.\nTIP Multiple dispatch is when a dispatch function emits a value that depends on more\nthan one argument. In a multimethod that features multiple dispatch, the order of\nthe elements in the array emitted by the dispatch function has to be consistent with\nthe order of the elements in the wiring of the methods.\nDave Now let me see if I can figure out how to use a multimethod that features mul-\ntiple dispatch.\nDave remembers that Theo told him earlier that multimethods are used like regular func-\ntions. With that in mind, he comes up with the code for a multimethod that features multi-\nple dispatch.\nListing13.17 Calling a multimethod that features multiple dispatch\ngreetLang(myDog, french);\n// → \"Ouaf Ouaf! Je m\\'appelle Fido et je parle Français\"\ngreetLang(myDog, english);\n// → \"Woof woof! My name is Fido and I speak English\"\ngreetLang(myCat, french);\n// → \"Miaou! Je m\\'appelle Milo et je parle Français\"\n--- Page 314 ---\n286 CHAPTER 13 Polymorphism\ngreetLang(myCat, english);\n// → \"Meow! I am Milo and I speak English\"\ngreetLang(myCow, french);\n// → \"Meuh! Appelle moi Clarabelle et je parle Français\"\ngreetLang(myCow, english);\n// → \"Moo! Call me Clarabelle and I speak English\"\nTheo Now do you agree that multimethods with multiple dispatch offer a more pow-\nerful polymorphism that OOP polymorphism?\nDave Indeed, I do.\nTheo Let me show you an even more powerful polymorphism called dynamic dis-\npatch. But first, let’s get some more of that wonderful French press coffee.\nDave Great idea! While we’re in the kitchen, I think my mom made an orange Bundt\ncake using the oranges from the grove.\n13.4 Multimethods with dynamic dispatch\nDave refills their coffee cups as Theo takes two slices from the cake and dishes them up.\nThey take their coffee and cake outside to enjoy more of the fresh country air before\nresuming their conversation.\nDave What is dynamic dispatch?\nTheo It’s when the dispatch function of a multimethod returns a value that goes\nbeyond the static type of its arguments.\nDave Like what, for example?\nTheo Like a number or a Boolean, for instance.\nDave Why would such a thing be useful?\nTheo Imagine that instead of being polyglot, our animals would suffer from\ndysmakrylexia.\nDave Suffering from what?\nTheo Dysmakrylexia. It comes from the Greek dus, expressing the idea of difficulty,\nmakrýs meaning long, and léxis meaning diction. Therefore, dysmakrylexia is dif-\nficulty pronouncing long words.\nDave I’ve never heard of that.\nTheo That’s because I just invented it.\nDave Funny. What’s considered a long word for our animals?\nTheo Let’s say that when their name has more than five letters, they’re not able to\nsay it.\nDave A bit weird, but OK.\nTheo Let’s call our multimethod dysGreet. Its dispatch function returns an array\nwith two elements: the animal type and a Boolean about whether the name is\nlong or not. Take a look at this multimethod initialization.\n--- Page 315 ---\n13.4 Multimethods with dynamic dispatch 287\nListing13.18 A multimethod using a dispatch function with dynamic dispatch\nfunction dysGreetDispatch(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"dysGreet called with invalid arguments: \" + errors);\n}\n}\nvar hasLongName = animal.name.length > 5;\nreturn [animal.type, hasLongName];\n};\nvar dysGreet = multi(dysGreetDispatch);\nDave Writing the dysGreet methods doesn’t seem too complicated.\nAs Theo reaches over to pass Dave his notebook, he accidently hits his coffee cup. Now Theo’s\nnotebook is completely wet, and all the diagrams are soggy! Fortunately, Dave brought an\nextra napkin from the kitchen, and it’s still clean. He draws a flow diagram as in figure 13.4\nand then grabs his laptop and writes the implementation of the dysGreet methods.\n[\"dog\", true] dysGreetDogLong\nGreet as a dog mentioning name\n[\"cat\", true] dysGreetCatLong\nGreet as a cat mentioning name\n[\"cow\", true] dysGreetCowLong\nGreet as a cow mentioning name\nargs dysGreetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", false] dysGreetDogShort\nGreet as a dog omitting name\n[\"cat\", false] dysGreetCatShort\nGreet as a cat omitting name\n[\"cow\", false] dysGreetCowShort\nGreet as a cow omitting name\nFigure 13.4 The logic flow of the dysGreet multimethod\nListing13.19 The dysGreet methods\nfunction dysGreetDogLong(animal) {\nconsole.log(\"Woof woof! My name is \" + animal.name);\n}\ndysGreet = method([\"dog\", true], dysGreetDogLong)(dysGreet);\n--- Page 316 ---\n288 CHAPTER 13 Polymorphism\nfunction dysGreetDogShort(animal) {\nconsole.log(\"Woof woof!\");\n}\ndysGreet = method([\"dog\", false], dysGreetDogShort)(dysGreet);\nfunction dysGreetCatLong(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ndysGreet = method([\"cat\", true], dysGreetCatLong)(dysGreet);\nfunction dysGreetCatShort(animal) {\nconsole.log(\"Meow!\");\n}\ndysGreet = method([\"cat\", false], dysGreetCatShort)(dysGreet);\nfunction dysGreetCowLong(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ndysGreet = method([\"cow\", true], dysGreetCowLong)(dysGreet);\nfunction dysGreetCowShort(animal) {\nconsole.log(\"Moo!\");\n}\ndysGreet = method([\"cow\", false], dysGreetCowShort)(dysGreet);\nTheo checks that the code works as expected. He compliments Dave, not only on the\nmethod implementation but also for having the foresight to grab an extra napkin.\nListing13.20 Testing dysGreet\ndysGreet(myDog);\ndysGreet(myCow);\ndysGreet(myCat);\n//\"Woof woof!\"\n//\"Moo! Call me Clarabelle\"\n//\"Meow!\"\nTheo Well done, my friend! Our exploration of multimethods has come to an end. I\nthink it’s time for me to drive back if I want to get home before dark and beat\nthe rush hour traffic.\nDave Before you leave, let’s check if multimethods are available in programming\nlanguages other than JavaScript.\nTheo That’s a question for Joe.\nDave Do you think it’s OK if I call him now?\nTheo I think it’s probably better if you send him an email. He’s in a tech conference,\nand I’m not sure if it’s all day. Thank you for this beautiful day in the country\nand the wonderful refreshments.\nDave I enjoyed it, also, especially our discussions about etymology. I think there are\nsome oranges for you to take home and enjoy later.\nTheo Great! I can’t wait until my wife tries one.\n--- Page 317 ---\n13.5 Integrating multimethods in a production system 289\nAfter Theo leaves, Dave sends Joe an email. A few minutes later, Dave receives an email\nfrom Joe with the subject, “Support for multimethods in different languages.”\nSupport for multimethods in different languages\nPython has a library called multimethods (https://github.com/weissjeffm/multimeth-\nods), and Ruby has one called Ruby multimethods (https://github.com/psantacl/\nruby-multimethods). Both seem to work quite like the JavaScript arrows/multi-\nmethod library.\nIn Java, there is the Java Multimethod Framework (http://igm.univ-mlv.fr/~forax/\nworks/jmmf/), and C# supports multimethods natively via the dynamic keyword.\nHowever, in both Java and C#, multimethods work only with static data types and not\nwith generic data structures.\nGeneric data structure\nLanguage URL\nsupport\nJavaScript https://github.com/caderek/arrows/tree/master/ Yes\npackages/multimethod\nJava http://igm.univ-mlv.fr/~forax/works/jmmf/ No\nC# Native support No\nPython https://github.com/weissjeffm/multimethods Yes\nRuby https://github.com/psantacl/ruby-multimethods Yes\n13.5 Integrating multimethods in a production system\nWhile Theo is driving back home, his thoughts take him back to the fresh air of the coun-\ntry. This pleasant moment is interrupted by a phone call from Nancy at Klafim.\nNancy How are you doing?\nTheo Fine. I’m driving back from the countryside.\nNancy Cool. Are you available to talk about work?\nTheo Sure.\nNancy I’d like to add a tiny feature to the catalog.\nIn the past, when Nancy qualified a feature as tiny, it scared Theo because tiny turned into\nhuge. What seemed easy to her always took him a surprising amount of time to develop.\nBut after refactoring the system according to DOP principles, now what seems tiny to\nNancy is usually quite easy to implement.\nTheo What feature?\nNancy I’d like to allow librarians to view the list of authors, ordered by last name, in\ntwo formats: HTML and Markdown.\n--- Page 318 ---\n290 CHAPTER 13 Polymorphism\nTheo It doesn’t sound too complicated.\nNancy Also, I need a bit of text formatting.\nTheo What kind of text formatting?\nNancy Depending on the number of books an author has written, their name should\nbe in bold and italic fonts.\nTheo Could you send me an email with all the details. I’ll take a look at it tomorrow\nmorning.\nNancy Perfect. Have a safe drive!\nBefore going to bed, Theo reflects about today’s etymology lessons. He realizes that he\nnever looked for the etymology of the word etymology itself! He searches for the term etymol-\nogy online and learns that the word etymology derives from the Greek étumon, meaning true\nsense, and the suffix logia, denoting the study of. During the night, Theo dreams of dogs,\ncats, and cows programming on their laptops in a field of grass.\nWhen Theo arrives at the office the next day, he opens Nancy’s email with the details\nabout the text formatting feature. The details are summarized in table 13.1.\nTable 13.1 Text formatting for author names according to the number of books\nthey have written\nNumber of books Italic Bold\n10 or fewer Yes No\nBetween 11 and 50 No Yes\n51 or more Yes Yes\nTheo forwards Nancy’s email to Dave and asks him to take care of this task. Delegating\nresponsibility, after all, is the trait of a great manager.\nDave thinks the most difficult part of the feature lies in implementing an Author\n.myName(author, format) function that receives two arguments: the author data and the\ntext format. He asks himself whether he can implement this function as a multimethod\nand use what he learned yesterday with Theo at his parents’ home in the country. It seems\nthat this feature is quite similar to the one that dealt with dysmakrylexia. Instead of check-\ning the length of a string, he needs to check the length of an array.\nFirst, Dave needs a data schema for the text format. He could represent a format as a\nmap with a type field like Theo did yesterday for languages, but at the moment, it seems\nsimpler to represent a format as a string that could be either markdown or html. He comes\nup with the text format schema in listing 13.21. He already wrote the author schema with\nTheo last week. It’s in listing 13.22.\nListing13.21 The text format schema\nvar textFormatSchema = {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"enum\": [\"markdown\", \"html\"]}\n};\n--- Page 319 ---\n13.5 Integrating multimethods in a production system 291\nListing13.22 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"name\", \"bookIsbns\"],\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nNow, Dave needs to write a dispatch function and initialize the multimethod. Remember-\ning that Theo had no qualms about creating the word dysmakrylexia, he decides that he\nprefers his own neologism, prolificity, over the existing nominal form prolificness. He finds it\nuseful to have an Author.prolificityLevel helper function that returns the level of\nprolificity of the author: either low, medium, or high. Now he’s ready to code the author-\nNameDispatch function.\nListing13.23 Author.myName multimethod initialization\nAuthor.prolificityLevel = function(author) {\nvar books = _.size(_.get(author, \"bookIsbns\"));\nif (books <= 10) {\nreturn \"low\";\n};\nif (books >= 51) {\nreturn \"high\";\n}\nreturn \"medium\";\n};\nvar authorNameArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\nauthorSchema,\n{\"enum\": [\"markdown\", \"html\"]}\n]\n};\nfunction authorNameDispatch(author, format) {\nif(dev()) {\nif(!ajv.validate(authorNameArgsSchema, [author, format])) {\nthrow (\"Author.myName called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [Author.prolificityLevel(author), format];\n};\nAuthor.myName = multi(authorNameDispatch);\n--- Page 320 ---\n292 CHAPTER 13 Polymorphism\nThen Dave works on the methods: first, the HTML format methods. In HTML, bold text is\nwrapped inside a <b> tag, and italic text is wrapped in a <i> tag. For instance, in HTML,\nthree authors with different levels of prolificity would be written like this.\nListing13.24 Examples of bold and italic in HTML\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n<i>Yehonathan Sharvit<i>\nBold and italic formatting\n<b>Stephen Covey</b>\nfor highly prolific authors\n<b><i>Isaac Asimov</i></b>\nWith this information in hand, Dave writes the three methods that deal with HTML for-\nmatting. Easy!\nListing13.25 The methods that deal with HTML formatting\nfunction authorNameLowHtml(author, format) {\nreturn \"<i>\" + _.get(author, \"name\") + \"</i>\";\n}\nAuthor.myName = method([\"low\", \"html\"], authorNameLowHtml)(Author.myName);\nfunction authorNameMediumHtml(author, format) {\nreturn \"<b>\" + _.get(author, \"name\") + \"</b>\";\n}\nAuthor.myName =\nmethod([\"medium\", \"html\"], authorNameMediumHtml)(Author.myName);\nfunction authorNameHighHtml(author, format) {\nreturn \"<b><i>\" + _.get(author, \"name\") + \"</i></b>\";\n}\nAuthor.myName =\nmethod([\"high\", \"html\"], authorNameHighHtml)(Author.myName);\nThen, Dave moves on to the three methods that deal with Markdown formatting. In\nMarkdown, bold text is wrapped in two asterisks, and italic text is wrapped in a single\nasterisk. For instance, in Markdown, three authors with different levels of prolificity\nwould be written like the code in listing 13.26. The code for the Markdown methods is in\nlisting 13.27.\nListing13.26 Examples of bold and italic in Markdown\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n*Yehonathan Sharvit*\nBold and italic formatting\n**Stephen Covey**\nfor highly prolific authors\n***Isaac Asimov***\n--- Page 321 ---\n13.5 Integrating multimethods in a production system 293\nListing13.27 The methods that deal with Markdown formatting\nfunction authorNameLowMarkdown(author, format) {\nreturn \"*\" + _.get(author, \"name\") + \"*\";\n}\nAuthor.myName =\nmethod([\"low\", \"markdown\"], authorNameLowMarkdown)(Author.myName);\nfunction authorNameMediumMarkdown(author, format) {\nreturn \"**\" + _.get(author, \"name\") + \"**\";\n}\nAuthor.myName =\nmethod([\"medium\", \"markdown\"], authorNameMediumMarkdown)(Author.myName);\nfunction authorNameHighMarkdown(author, format) {\nreturn \"***\" + _.get(author, \"name\") + \"***\";\n}\nAuthor.myName =\nmethod([\"high\", \"markdown\"], authorNameHighMarkdown)(Author.myName);\nDave decides to test his code by involving a mysterious author. Listing 13.28 and listing 13.29\nshow the tests.\nListing13.28 Testing HTML formatting\nvar yehonathan = {\n\"name\": \"Yehonathan Sharvit\",\n\"bookIsbns\": [\"9781617298578\"]\n};\nAuthor.myName(yehonathan, \"html\");\n// → \"<i>Yehonathan Sharvit</i>\"\nListing13.29 Testing Markdown formatting\nAuthor.myName(yehonathan, \"markdown\");\n// → \"*Yehonathan Sharvit*\"\nTheo shows up at Dave’s desk and asks to review Dave’s implementation of the list of\nauthors feature. Curious, Theo asks Dave about the author that appears in the test of\nAuthor.myName.\nTheo Who is Yehonathan Sharvit?\nDave I don’t really know. The name appeared when I googled “data-oriented pro-\ngramming” yesterday. He wrote a book on the topic. I thought it would be cool\nto use its ISBN in my test.\n--- Page 322 ---\n294 CHAPTER 13 Polymorphism\nSummary\n The main benefit of polymorphism is extensibility.\n Multimethods make it possible to benefit from polymorphism when data is repre-\nsented with generic maps.\n A multimethod is made of a dispatch function and multiple methods.\n The dispatch function of a multimethod emits a dispatch value.\n Each of the methods used in a multimethod provides an implementation for a\nspecific dispatch value.\n Multimethods can mimic OOP class inheritance via single dispatch.\n In single dispatch, a multimethod receives a single map that contains a type field,\nand the dispatch function of the multimethod emits the value of the type field.\n In addition to single dispatch, multimethods provide two kinds of advanced\npolymorphisms: multiple dispatch and dynamic dispatch.\n Multiple dispatch is used when the behavior of the multimethod depends on\nmultiple arguments.\n Dynamic dispatch is used when the behavior of the multimethod depends on run-\ntime arguments.\n The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\n A multimethod dispatch function is responsible for\n– Defining the signature.\n– Validating the arguments.\n– Emitting a dispatch value.\n Multimethods provides extensibility by decoupling between multimethod ini-\ntialization and method implementations.\n Multimethods are called like regular functions.\n Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\n In a multimethod that features multiple dispatch, the order of the elements in\nthe array emitted by the dispatch function has to be consistent with the order of\nthe elements in the wiring of the methods.\nLodash functions introduced in this chapter\nFunction Description\nsize(coll) Gets the size of coll\n--- Page 323 ---\nAdvanced data\nmanipulation\nWhatever is well-conceived\nis clearly said\nThis chapter covers\n Manipulating nested data\n Writing clear and concise code for business\nlogic\n Separating business logic and generic data\nmanipulation\n Building custom data manipulation tools\n Using the best tool for the job\nWhen our business logic involves advanced data processing, the generic data manip-\nulation functions provided by the language run time and by third-party libraries\nmight not be sufficient. Instead of mixing the details of data manipulation with\nbusiness logic, we can write our own generic data manipulation functions and imple-\nment our custom business logic using them. Separating business logic from the inter-\nnal details of data manipulation makes the business logic code concise and easy to\nread for other developers.\n295\n--- Page 324 ---\n296 CHAPTER 14 Advanced data manipulation\n14.1 Updating a value in a map with eloquence\nDave is more and more autonomous on the Klafim project. He can implement most fea-\ntures on his own, typically turning to Theo only for code reviews. Dave’s code quality stan-\ndards are quite high. Even when his code is functionally solid, he tends to be unsatisfied\nwith its readability. Today, he asks for Theo’s help in improving the readability of the code\nthat fixes a bug Theo introduced a long time ago.\nDave I think I have a found a bug in the code that returns book information from\nthe Open Library API.\nTheo What bug?\nDave Sometimes, the API returns duplicate author names, and we pass the dupli-\ncates through to the client.\nTheo It doesn’t sound like a complicated bug to fix.\nDave Right, I fixed it, but I’m not satisfied with the readability of the code I wrote.\nTheo Being critical of our own code is an important quality for a developer to prog-\nress. What is it exactly that you don’t like?\nDave Take a look at this code.\nListing14.1 Removing duplicates in a straightforward but tedious way\nfunction removeAuthorDuplicates(book) {\nvar authors = _.get(book, \"authors\");\nvar uniqAuthors = _.uniq(authors);\nreturn _.set(book,\"authors\", uniqAuthors);\n}\nDave I’m using _.get to retrieve the array with the author names, then _.uniq to\ncreate a duplicate-free version of the array, and finally, _.set to create a new\nversion of the book with no duplicate author names.\nTheo The code is tedious because the next value of authorNames needs to be based\non its current value.\nDave But it’s a common use case! Isn’t there a simpler way to write this kind of code?\nTheo Your astonishment definitely honors you as a developer, Dave. I agree with you\nthat there must be a simpler way. Let me phone Joe and see if he’s available for\na conference call.\nJoe How’s it going, Theo?\nTheo Great! Are you back from your tech conference?\nJoe I just landed. I’m on my way home now in a taxi.\nTheo How was your talk about DOP?\nJoe Pretty good. At the beginning people were a bit suspicious, but when I told\nthem the story of Albatross and Klafim, it was quite convincing.\nTheo Yeah, adults are like children in that way; they love stories.\nJoe What about you? Did you manage to achieve polymorphism with multimethods?\nTheo Yes! Dave even managed to implement a feature in Klafim with multimethods.\nJoe Cool!\n--- Page 325 ---\n14.1 Updating a value in a map with eloquence 297\nTheo Do you have time to help Dave with a question about programming?\nJoe Sure.\nDave Hi Joe. How are you doing?\nJoe Hello Dave. Not bad. What kind of help do you need?\nDave I’m wondering if there’s a simpler way to remove duplicates inside an array\nvalue in a map. Using _.get, _.uniq, and _.set looks quite tedious.\nJoe You should build your own data manipulation tools.\nDave What do you mean?\nJoe You should write a generic update function that updates a value in a map,\napplying a calculation based on its current value.1\nDave What would the arguments of update be in your opinion?\nJoe Put the cart before the horse.\nDave What?!\nJoe Rewrite your business logic as if update were already implemented, and you’ll\ndiscover what the arguments of update should be.\nDave I see what you mean: the horse is the implementation of update, and the cart is\nthe usage of update.\nJoe Exactly. But remember, it’s better if you keep your update function generic.\nDave How?\nJoe By not limiting it to your specific use case.\nDave I see. The implementation of update should not deal with removing duplicate\nelements. Instead, it should receive the updating function—in my case,\n_.uniq—as an argument.\nJoe Exactly! Uh, sorry Dave, I gotta go, I just got home. Good luck!\nDave Take care, Joe, and thanks!\nDave ends the conference call. Looking at Theo, he reiterates the conversation with Joe.\nDave Joe advised me to write my own update function. For that purpose, he told me\nto start by rewriting removeAuthorDuplicates as if update were already\nimplemented. That will allow us to make sure we get the signature of update\nright.\nTheo Sounds like a plan.\nDave Joe called it “putting the cart before the horse.”\nTheo Joe and his funny analogies...\nTIP The best way to find the signature of a custom data manipulation function is to\nthink about the most convenient way to use it.\nDave Anyway, the way I’d like to use update inside removeAuthorDuplicates is\nlike this.\n1 Lodash provides an implementation of update, but for the sake of teaching, we are writing our own imple-\nmentation.\n--- Page 326 ---\n298 CHAPTER 14 Advanced data manipulation\nListing14.2 The code that removes duplicates in an elegant way\nfunction removeAuthorDuplicates(book) {\nreturn update(book, \"authors\", _.uniq);\n}\nTheo Looks good to me!\nDave Wow! Now the code with update is much more elegant than the code with\n_.get and _.set!\nTheo Before you implement update, I suggest that you write down in plain English\nexactly what the function does.\nDave It’s quite easy: update receives a map called map, a path called path, and a\nfunction called fun. It returns a new version of map, where path is associated\nwith fun(currentValue), and currentValue is the value associated with\npath in map.\nThinking out loud, Dave simultaneously draws a diagram like that in figure 14.1. Theo is\nbecoming more and more impressed with his young protegé as he studies the figure.\n{\n\"position\" : \"manager\", \"income\"\n\"income\" : 100000\n} map fun path\nupdate\n{\n\"position\" : \"manager\",\n\"income\" : fun(100000)\nres Figure 14.1 The\n}\nbehavior of update\nTIP Before implementing a custom data manipulation function, formulate in plain\nEnglish exactly what the function does.\nTheo With such a clear definition, it’s going to be a piece of cake to implement\nupdate!\nAfter a few minutes, Dave comes up with the code. It doesn’t take long because the plain-\nEnglish diagram helps him to organize the code.\nListing14.3 A generic update function\nfunction update(map, path, fun) {\nvar currentValue = _.get(map, path);\nvar nextValue = fun(currentValue);\nreturn _.set(map, path, nextValue);\n}\n--- Page 327 ---\n14.2 Manipulating nested data 299\nTheo Why don’t you see if it works with a simple case such as incrementing a number\nin a map?\nDave Good idea! I’ll try multiplying a value in a map by 2 with update. How’s this\nlook?\nListing14.4 Multiplying a value in a map by 2\nvar m = {\n\"position\": \"manager\",\n\"income\": 100000\n};\nupdate(m, \"income\", function(x) {\nreturn x * 2;\n});\n// → {\"position\": \"manager\", \"income\": 200000}\nTheo Great! It seems to work.\n14.2 Manipulating nested data\nThe next Monday, during Theo and Dave’s weekly sync meeting, they discuss the upcom-\ning features for Klafim. Theo fondly remembers another Monday where they met at Dave’s\nfamily home in the country. Coming back to the present moment, Theo begins.\nTheo Recently, Nancy has been asking for more and more administrative features.\nDave Like what?\nTheo I’ll give you a few examples.... Let me find the email I got from Nancy yesterday.\nDave OK.\nTheo Here it is. There are three feature requests for now: listing all the book author\nIDs, calculating the book lending ratio, and grouping books by a physical library.\nDave What feature should I tackle first?\nTheo It doesn’t matter, but you should deliver the three of these before the end of\nthe week. Good luck, and don’t hesitate to call me if you need help.\nOn Tuesday, Dave asks for Theo’s help. Dave is not pleased with how his code looks.\nDave I started to work on the three admin features, but I don’t like the code I wrote.\nLet me show you the code for retrieving the list of author IDs from the list of\nbooks returned from the database.\nTheo Can you remind me what an element in a book list returned from the database\nlooks like?\nDave Each book is a map with an authorIds array field.\nTheo OK, so it sounds like a map over the books should do it.\nDave This is what I did, but it doesn’t work as expected. Here’s my code for listing\nthe book author IDs.\n--- Page 328 ---\n300 CHAPTER 14 Advanced data manipulation\nListing14.5 Retrieving the author IDs in books as an array of arrays\nfunction authorIdsInBooks(books) {\nreturn _.map(books, \"authorIds\");\n}\nTheo What’s the problem?\nDave The problem is that it returns an array of arrays of author IDs instead of an\narray of author IDs. For instance, when I run authorIdsInBooks on a catalog\nwith two books, I get this result.\nListing14.6 The author IDs in an array of arrays\n[\n[\"sean-covey\", \"stephen-covey\"],\n[\"alan-moore\", \"dave-gibbons\"]\n]\nTheo That’s not a big problem. You can flatten an array of arrays with _.flatten,\nand you should get the result you expect.\nDave Nice! This is exactly what I need! Give me a moment to fix the code of\nauthorIdsInBooks. . . here you go.\nListing14.7 Retrieving the author IDs in books as an array of strings\nfunction authorIdsInBooks(books) {\nreturn _.flatten(_.map(books, \"authorIds\"));\n}\nTheo Don’t you think that mapping and then flattening deserves a function of its own?\nDave Maybe. It’s quite easy to implement a flatMap function.2 How about this?\nListing14.8 The implementation of flatMap\nfunction flatMap(coll, f) {\nreturn _.flatten(_.map(coll,f));\n}\nTheo Nice!\nDave I don’t know.... It’s kind of weird to have such a small function.\nTheo I don’t think that code size is what matters here.\nDave What do you mean?\nTheo See what happens when you rewrite authorIdsInBooks using flatMap.\nDave OK, here’s how I’d use flatMap to list the author IDs.\n2 Lodash provides an implementation of flatMap, but for the sake of teaching, we are writing our own\nimplementation.\n--- Page 329 ---\n14.3 Using the best tool for the job 301\nListing14.9 Retrieving the author IDs as an array of strings using flatMap\nfunction authorIdsInBooks(books) {\nreturn flatMap(books, \"authorIds\");\n}\nTheo What implementation do you prefer, the one with flatten and map (in listing\n14.7) or the one with flatMap (in listing 14.9)?\nDave I don’t know. To me, they look quite similar.\nTheo Right, but which implementation is more readable?\nDave Well, assuming I know what flatMap does, I would say the implementation\nwith flatMap. Because it’s more concise, it is a bit more readable.\nTheo Again, it’s not about the size of the code. It’s about the clarity of intent and the\npower of naming things.\nDave I don’t get that.\nTheo Let me give you an example from our day-to-day language.\nDave OK.\nTheo Could you pass me that thing on your desk that’s used for writing?\nIt takes Dave a few seconds to get that Theo has asked him to pass the pen on the desk.\nAfter he passes Theo the pen, he asks:\nDave Why didn’t you simply ask for the pen?\nTheo I wanted you to experience how it feels when we use descriptions instead of\nnames to convey our intent.\nDave Oh, I see. You mean that once we use a name for the operation that maps and\nflattens, the code becomes clearer.\nTheo Exactly.\nDave Let’s move on to the second admin feature: calculating the book lending ratio.\nTheo Before that, I think we deserve a short period for rest and refreshments, where\nwe drink a beverage made by percolation from roasted and ground seeds.\nDave A coffee break!\n14.3 Using the best tool for the job\nAfter the coffee break, Dave shows Theo his implementation of the book lending ratio cal-\nculation. This time, he seems to like the code he wrote.\nDave I’m quite proud of the code I wrote to calculate the book lending ratio.\nTheo Show me the money!\nDave My function receives a list of books from the database like this.\nListing14.10 A list of two books with bookItems\n[\n{\n\"isbn\": \"978-1779501127\",\n--- Page 330 ---\n302 CHAPTER 14 Advanced data manipulation\n\"title\": \"Watchmen\",\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n}\n]\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"bookItems\": [\n{\n\"id\": \"book-item-123\",\n\"libId\": \"hudson-park-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-17\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n]\nTheo Quite a nested piece of data!\nDave Yeah, but now that I’m using flatMap, calculating the lending ratio is quite\neasy. I’m going over all the book items with forEach and incrementing either\nthe lent or the notLent counter. At the end, I return the ratio between lent\nand (lent + notLent). Here’s how I do that.\nListing14.11 Calculating the book lending ratio using forEach\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar lent = 0;\nvar notLent = 0;\n_.forEach(bookItems, function(item) {\nif(_.get(item, \"isLent\")) {\nlent = lent + 1;\n} else {\nnotLent = notLent + 1;\n}\n});\nreturn lent/(lent + notLent);\n}\nTheo Would you allow me to tell you frankly what I think of your code?\nDave If you are asking this question, it means that you don’t like it. Right?\nTheo It’s nothing against you; I don’t like any piece of code with forEach.\n--- Page 331 ---\n14.3 Using the best tool for the job 303\nDave What’s wrong with forEach?\nTheo It’s too generic!\nDave I thought that genericity was a positive thing in programming.\nTheo It is when we build a utility function, but when we use a utility function, we\nshould use the least generic function that solves our problem.\nDave Why?\nTheo Because we ought to choose the right tool for the job, like in the real life.\nDave What do you mean?\nTheo Let me give you an example. Yesterday, I had to clean my drone from the\ninside. Do you think that I used a screwdriver or a Swiss army knife to unscrew\nthe drone cover?\nDave A screwdriver, of course! It’s much more convenient to manipulate.\nTheo Right. Also, imagine that someone looks at me using a screwdriver. It’s quite\nclear to them that I am turning a screw. It conveys my intent clearly.\nDave Are you saying that forEach is like the Swiss army knife of data manipulation?\nTheo That’s a good way to put it.\nTIP Pick the least generic utility function that solves your problem.\nDave What function should I use then, to iterate over the book item collection?\nTheo You could use _.reduce.\nDave I thought reduce was about returning data from a collection. Here, I don’t\nneed to return data; I need to update two variables, lent and notLent.\nTheo You could represent those two values in a map with two keys.\nDave Can you show me how to rewrite my lendingRatio function using reduce?\nTheo Sure. The initial value passed to reduce is the map, {\"lent\": 0, \"notLent\": 0},\nand inside each iteration, we update one of the two keys, like this.\nListing14.12 Calculating the book lending ratio using reduce\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = _.reduce(bookItems, function(res, item) {\nif(_.get(item, \"isLent\")) {\nres.lent = res.lent + 1;\n} else {\nres.notLent = res.notLent + 1;\n}\nreturn res;\n}, {notLent: 0, lent:0});\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nDave Instead of updating the variables lent and notLent, now we are updating lent\nand notLent map fields. What’s the difference?\n--- Page 332 ---\n304 CHAPTER 14 Advanced data manipulation\nTheo Dealing with map fields instead of variables allows us to get rid of reduce in\nour business logic code.\nDave How could you iterate over a collection without forEach and without reduce?\nTheo I can’t avoid the iteration over a collection, but I can hide reduce behind a\nutility function. Take a look at the way reduce is used inside the code of\nlendingRatio. What is the meaning of the reduce call?\nDave looks at the code in listing 14.12. He thinks for a long moment before he answers.\nDave I think it’s counting the number of times isLent is true and false.\nTheo Right. Now, let’s use Joe’s advice about building our own data manipulation\ntool.\nDave How exactly?\nTheo I suggest that you write a countByBoolField utility function that counts the\nnumber of times a field is true and false.\nDave OK, but before implementing this function, let me first rewrite the code of\nlendingRatio, assuming this function already exists.\nTheo You are definitely a fast learner, Dave!\nDave Thanks! I think that by using countByBoolField, the code for calculating the\nlending ratio using a custom utility function would be something like this.\nListing14.13 Calculating the book lending ratio\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = countByBoolField(bookItems, \"isLent\", \"lent\", \"notLent\");\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nTIP Don’t use _.reduce or any other low-level data manipulation function inside\ncode that deals with business logic. Instead, write a utility function—with a proper\nname—that hides _.reduce.\nTheo Perfect. Don’t you think that this code is clearer than the code using _.reduce?\nDave I do! The code is both more concise and the intent is clearer. Let me see if I\ncan implement countByBoolField now.\nTheo I suggest that you write a unit test first.\nDave Good idea.\nDave types for a bit. When he’s satisfied, he shows Theo the result.\nListing14.14 A unit test for countByBoolField\nvar input = [\n{\"a\": true},\n{\"a\": false},\n{\"a\": true},\n--- Page 333 ---\n14.4 Unwinding at ease 305\n{\"a\": true}\n];\nvar expectedRes = {\n\"aTrue\": 3,\n\"aFalse\": 1\n};\n_.isEqual(countByBoolField(input, \"a\", \"aTrue\", \"aFalse\"), expectedRes);\nTheo Looks good to me. Now, for the implementation of countByBoolField, I\nthink you are going to need our update function.\nDave I think you’re right. On each iteration, I need to increment the value of either\naTrue or aFalse using update and a function that increments a number by 1.\nAfter a few minutes of trial and error, Dave comes up with the piece of code that uses\nreduce, update, and inc. He shows Theo the code for countByBoolField.\nListing14.15 The implementation of countByBoolField\nfunction inc (n) {\nreturn n + 1;\n}\nfunction countByBoolField(coll, field, keyTrue, keyFalse) {\nreturn _.reduce(coll, function(res, item) {\nif (_.get(item, field)) {\nreturn update(res, keyTrue, inc);\n}\nreturn update(res, keyFalse, inc);\n}, {[keyTrue]: 0,\nCreates a map with\n[keyFalse]: 0});\nkeyTrue and keyFalse\n}\nassociated to 0\nTheo Well done! Shall we move on and review the third admin feature?\nDave The third feature is more complicated. I would like to use the teachings from\nthe first two features for the implementation of the third feature.\nTheo OK. Call me when you’re ready for the code review.\n14.4 Unwinding at ease\nDave really struggled with the implementation of the last admin feature, grouping books\nby a physical library. After a couple of hours of frustration, Dave calls Theo for a rescue.\nDave I really had a hard time implementing the grouping by library feature.\nTheo I only have a couple of minutes before my next meeting, but I can try to help\nyou. What’s the exact definition of grouping by library?\nDave Let me show you the unit test I wrote.",
        "sections_found": []
      },
      "accurate_page_range": "303-333"
    },
    {
      "text": "- Summary",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "raw_line": "- Summary (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 105,
      "chapter_info": {
        "page": 303,
        "title": "Advanced data validation",
        "pattern_matched": "Chapter 12",
        "text_preview": "13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with "
      },
      "chapter_sections": {
        "start_page": 303,
        "end_page": 333,
        "content": "\n--- Page 303 ---\n13.1 The essence of polymorphism 275\nDave How would animal look, exactly?\nTheo Like I just said, a map with two fields: name and type. Let me input that for you.\nListing13.3 Representing animals with maps\nvar myDog = {\n\"type\": \"dog\",\n\"name\": \"Fido\"\n};\nvar myCat = {\n\"type\": \"cat\",\n\"name\": \"Milo\"\n};\nvar myCow = {\n\"type\": \"cow\",\n\"name\": \"Clarabelle\"\n};\nDave Could you have given another name to the field that holds the animal type?\nTheo Absolutely. It could be anything.\nDave I see. You’re asking me the fundamental difference between your code with a\nswitch statement and my code with an interface and three classes?\nTheo Exactly.\nDave First of all, if you pass an invalid map to your greet function, bad things will\nhappen.\nTheo You’re right. Let me fix that and validate input data.\nListing13.4 Data validation\nvar animalSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nSee chapter 12 about\ndata validation for\nfunction greet(animal) {\ndetails.\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\n--- Page 304 ---\n276 CHAPTER 13 Polymorphism\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\nbreak;\ncase \"cat\":\nconsole.log(\"Meow! I am: \" + animal.name);\nbreak;\ncase \"cow\":\nconsole.log(\"Moo! Call me \" + animal.name);\nbreak;\n};\n}\n NOTE You should not use switch statements like this in your production code.\nWe use them here for didactic purposes only as a step towards distilling the essence of\npolymorphism.\nDave Another drawback of your approach is that when you want to modify the\nimplementation of greet for a specific animal, you have to change the code\nthat deals with all the animals, while in my approach, you would change only a\nspecific animal class.\nTheo I agree, and I could also fix that by having a separate function for each animal,\nsomething like this.\nListing13.5 Different implementations in different functions\nfunction greetDog(animal) {\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\n}\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am: \" + animal.name);\n}\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\nfunction greet(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nswitch (animal.type) {\ncase \"dog\":\ngreetDog(animal);\nbreak;\ncase \"cat\":\ngreetCat(animal);\nbreak;\ncase \"cow\":\ngreetCow(animal);\n--- Page 305 ---\n13.2 Multimethods with single dispatch 277\nbreak;\n};\n}\nDave But what if you want to extend the functionality of greet and add a new animal?\nTheo Now you got me. I admit that with a switch statement, I can’t add a new animal\nwithout modifying the original code, whereas in OOP, I can add a new class\nwithout having to modify the original code.\nDave Yeah, but you helped me to realize that the main benefit of polymorphism is\nthat it makes the code easily extensible.\nTIP The main benefit of polymorphism is extensibility.\nTheo I’m going to ask Joe if there’s a way to benefit from polymorphism without\nobjects.\nTheo sends a message to Joe and asks him about polymorphism in DOP. Joe answers that\nhe doesn’t have time to get into a deep response because he is in a tech conference where\nhe is about to give a talk about DOP. The only thing he has time to tell Theo is that he\nshould take a look at multimethods.\nTheo and Dave read some online material about multimethods. It doesn’t look too\ncomplicated. They decide that after lunch they will give multimethods a try.\n13.2 Multimethods with single dispatch\nDuring lunch, Theo asks Dave how it feels to have grown up in the country. Dave starts\nwith an enthusiastic description about being in direct contact with nature and living a sim-\npler life than in the city. He’s grateful for the experience, but he admits that country life\ncan sometimes be hard without the conveniences of the city. But who said simple was easy?\nAfter lunch, they decide to have coffee. Dave asks Theo if he’d like to grind the coffee\nbeans himself. Theo accepts with joy. Next, Dave explains how to use a French press coffee\nmaker to get the ideal tradeoff between bitterness and rich taste. While savoring their\nFrench press coffee in the garden, Theo and Dave continue their exploration of polymor-\nphism à la DOP.\nTheo From what I read before lunch, it seems that multimethods are a software con-\nstruct that provide polymorphism without the need for objects.\nDave I don’t get how that’s possible.\nTheo Multimethods have two parts: a dispatch function and a set of methods that\nprovide an implementation for each dispatched value.\nDave I’m not sure I’m clear on that. Is a dispatch function like an interface?\nTheo It’s like an interface in the sense that it defines the way the function needs to\nbe called, but it goes beyond that. It also dispatches a value that differentiates\nbetween the different implementations.\nDave That’s a bit abstract for me.\nTheo I think I understand how to implement the animal greeting capabilities. If we\nuse a multimethod called greet, we need a dispatch function and three\nmethods. Let’s call the dispatch function greetDispatch. It dispatches the\nanimal type, either \"dog\", \"cat\", or \"cow\". Then, each dispatch value is\n--- Page 306 ---\n278 CHAPTER 13 Polymorphism\nhandled by a specific method: \"dog\" by greetDog, \"cat\" by greetCat, and\n\"cow\" by greetCow.\nTheo takes out his notebook and opens it to a blank piece of paper. He draws a diagram\nlike the one in figure 13.1.\n\"dog\" greetDog\nGreet as a dog\ngreetDispatch \"cat\" greetCat\nEmit the animal type Greet as a cat\nanimal\ntype, name \"cow\" greetCow\nGreet as a cow\nFigure 13.1 The logic flow\nof the greet multimethod\nDave Why is there an arrow between animal and the methods, in addition to the\narrows between animal and the dispatch functions?\nTheo Because the arguments of a multimethod are passed to the dispatch function\nand to the methods.\nTIP The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\nDave Arguments plural?... I see only a single argument.\nTheo You’re right. Right now our multimethod only receives a single argument, but\nsoon it will receive several arguments.\nDave I see. Could you show me how to write the code for the greet multimethod?\nTheo For that, we need a library. For instance, in JavaScript, the arrows/multi-\nmethod library provides an implementation of multimethods. Basically, we call\nmulti to create a multimethod called method to add a method.\n NOTE See http://mng.bz/nY9v for examples and documentation about this library.\nDave Where should we start?\nTheo We’ll start with multimethod initialization by creating a dispatch function\ngreetDispatch that defines the signature of the multimethod, validates the\narguments, and emits the type of the animal. Then we’ll pass greetDispatch\nto multi in order to create the greet multimethod. Our dispatch function\nwould then look like this.\nListing13.6 The dispatch function for greet multimethod\nfunction greetDispatch(animal) {\nSignature definition\nif(dev()) {\n--- Page 307 ---\n13.2 Multimethods with single dispatch 279\nif(!ajv.validate(animalSchema, animal)) {\nArgument validation\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"greet called with invalid arguments: \" + errors);\n}\n}\nDispatch value\nreturn animal.type;\n}\nMultimethod\ninitialization\nvar greet = multi(greetDispatch);\nTIP A multimethod dispatch function is responsible for three things: it defines the sig-\nnature of the multimethod, it validates the arguments, and it emits a dispatch value.\nDave What’s next?\nTheo Now we need to implement a method for each dispatched value. Let’s start\nwith the method that deals with dogs. We create a greetDog function that\nreceives an animal and then add a dog method to the greet multimethod\nusing the method function from the arrows/multimethod library. The method\nfunction receives two arguments: the dispatched value and a function that cor-\nresponds to the dispatch value.\nListing13.7 Implementation of greet method for dogs\nfunction greetDog(animal) {\nMethod\nconsole.log(\"Woof woof! My name is \" + animal.name);\nimplementation\n}\ngreet = method(\"dog\", greetDog)(greet);\nMethod declaration\nDave Does the method implementation have to be in the same module as the multi-\nmethod initialization?\nTheo No, not at all! Method declarations are decoupled from multimethod initializa-\ntion exactly like class definitions are decoupled from the interface definition.\nThat’s what make multimethods extensible.\nTIP Multimethods provides extensibility by decoupling between multimethod initial-\nization and method implementations.\nDave What about cats and cows?\nTheo We add their method implementations like we did for dogs.\nTheo takes a moment to envision the implementation. Then he codes up two more greet\nmethods for cats and cows.\nListing13.8 Implementation of greet method for cats\nfunction greetCat(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ngreet = method(\"cat\", greetCat)(greet);\n--- Page 308 ---\n280 CHAPTER 13 Polymorphism\nListing13.9 Implementation of greet method for cows\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ngreet = method(\"cow\", greetCow)(greet);\nTIP In the context of multimethods, a method is a function that provides an imple-\nmentation for a dispatch value.\nDave Are the names of dispatch functions and methods important?\nTheo According to what I read, not really, but I like to follow a simple naming con-\nvention: use the name of the multimethod (for example, greet) as a prefix for\nthe dispatch function (for example, greetDispatch) and the methods. Then\nI’d have the Dispatch suffix for the dispatch function and a specific suffix for\neach method (for example, greetDog, greetCat, and greetCow).\nDave How does the multimethod mechanism work under the hood?\nTheo Internally, a multimethod maintains a hash map where the keys are the dis-\npatched values, and the values are the methods. When we add a method, an\nentry is added to the hash map, and when we call the multimethod, we query the\nhash map to find the implementation that corresponds to the dispatched value.\nDave I don’t think you’ve told me yet how to call a multimethod.\nTheo We call it as a regular function. Give me a minute, and I’ll show you an exam-\nple that calls a multimethod.\nListing13.10 Calling a multimethod like a regular function\ngreet(myDog);\n// → \"Woof woof! My name is Fido\"\ngreet(myCat);\n// → \"Meow! I am Milo\"\ngreet(myCow);\n// → \"Moo! Call me Clarabelle\"\nTIP Multimethods are called like regular functions.\nDave You told me earlier that in the dispatch function, we should validate the argu-\nments. Is that mandatory or is it a best practice?\nTheo It’s a best practice.\nDave What happens if the dispatch function doesn’t validate the arguments, and we\npass an invalid argument?\nTheo Like when an animal has no corresponding method?\nDave Exactly!\nTheo In that case, you’ll get an error. For instance, the arrows/multimethods library\nthrows a NoMethodError exception.\nDave That’s annoying. Is there a way to provide a default implementation?\n--- Page 309 ---\n13.3 Multimethods with multiple dispatch 281\nTheo Absolutely! In order to define a default implementation, you pass to method—\nas a single argument—the function that provides the default implementation.\nTheo writes the code and shows it to Dave. Dave then tests Theo’s code and seems satisfied\nwith the result.\nListing13.11 Defining a default implementation\nfunction greetDefault(animal) {\nconsole.log(\"My name is \" + animal.name);\n}\ngreet = method(greetDefault)(greet);\nListing13.12 Calling a multimethod when no method fits the dispatch value\nvar myHorse = {\n\"type\": \"horse\",\n\"name\": \"Horace\"\n};\ngreet(myHorse);\n// → \"My name is Horace\"\nTIP Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\nDave Cool!\n13.3 Multimethods with multiple dispatch\nTheo So far, we’ve mimicked OOP by having the type of the multimethod argument\nas a dispatch value. But if you think again about the flow of a multimethod,\nyou’ll discover something interesting. Would you like to try and draw a dia-\ngram that describes the flow of a multimethod in general?\nDave Let me get a fresh napkin. The one under my glass is a bit wet.\nTheo Uh, Dave, you can use my notebook.\nIt takes Dave a few minutes to draw a diagram like the one in figure 13.2. He pushes the\nnotebook back to Theo.\nValue1 Method1\nHandle case 1\nDispatch function Value3 Method3\nEmit a dispatch value Handle case 3\nargs\nValue2 Method2\nHandle case 2\nFigure 13.2 The logic flow\nof multimethods\n--- Page 310 ---\n282 CHAPTER 13 Polymorphism\nTheo Excellent! I hope you see that the dispatch function can emit any value.\nDave Like what?\nTheo Like emitting the type of two arguments!\nDave What do you mean?\nTheo Imagine that our animals are polyglot.\nDave Poly what?\nTheo Polyglot comes from the Greek polús, meaning much, and from glôssa, meaning\nlanguage. A polyglot is a person who can speak many languages.\nDave What languages would our animals speak?\nTheo I don’t know. Let’s say English and French.\nDave OK, and how would we represent a language in our program?\nTheo With a map, of course!\nDave What fields would we have in a language map?\nTheo Let’s keep things simple and have two fields: type and name.\nDave Like an animal map?\nTheo Not exactly. In a language map, the type field must be either fr for French or en\nfor English, whereas in the animal map, the type field is either dog, cat, or cow.\nDave Let me try to write the language map schema and the two language maps.\nTheo gladly consents; his French press coffee is getting cold! Dave writes his implementa-\ntion of the code and shows Theo.\nListing13.13 The schema of a language map\nvar languageSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"type\": \"string\"}\n},\n\"required\": [\"name\", \"type\"],\n};\nListing13.14 Two language maps\nvar french = {\n\"type\": \"fr\",\n\"name\": \"Français\"\n};\nvar english = {\n\"type\": \"en\",\n\"name\": \"English\"\n};\nTheo Excellent! Now, let’s write the code for the dispatch function and the methods\nfor our polyglot animals. Let’s call our multimethod, greetLang. We have one\ndispatch function and six methods.\n--- Page 311 ---\n13.3 Multimethods with multiple dispatch 283\nDave Right, three animals (dog, cat, and cow) times two languages (en and fr).\nBefore the implementation, I’d like to draw a flow diagram. It will help me to\nmake things crystal clear.\nTheo You need my notebook again?\nNot waiting for Dave to respond, Theo pushes his notebook across the table to Dave. Dave\ndraws a diagram like the one in figure 13.3 and slides the notebook back to Theo.\n[\"dog\", \"en\"] greetLangDogEn\nGreet as a dog in English\n[\"cat\", \"en\"] greetLangCatEn\nGreet as a cat in English\n[\"cow\", \"en\"] greetLangCowEn\nGreet as a cow in English\nargs greetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", \"fr\"] greetLangDogFr\nGreet as a dog in French\n[\"cat\", \"fr\"] greetLangCatFr\nGreet as a cat in French\n[\"cow\", \"fr\"] greetLangCowFr\nGreet as a cow in French\nFigure 13.3 The logic flow of the greetLang multimethod\nTheo Why did you omit the arrow between the arguments and the methods?\nDave In order to keep the diagram readable. Otherwise, there would be too many\narrows.\nTheo OK, I see. Are you ready for coding?\nDave Yes!\nTheo The dispatch function needs to validate its arguments and return an array with\ntwo elements: the type of animal and the type of language.\nDave types for a bit on his laptop. He initializes the multimethod with a dispatch function\nthat returns the type of its arguments and then shows the code to Theo.\nListing13.15 Initializing a multimethod with a dispatch function\nvar greetLangArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [animalSchema, languageSchema]\n};\nfunction greetLangDispatch(animal, language) {\nif(dev()) {\n--- Page 312 ---\n284 CHAPTER 13 Polymorphism\nif(!ajv.validate(greetLangArgsSchema, [animal, language])) {\nthrow (\"greetLang called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [animal.type, language.type];\n};\nvar greetLang = multi(greetLangDispatch);\nDave Does the order of the elements in the array matter?\nTheo It doesn’t matter, but it needs to be consistent with the wiring of the methods.\nThe implementation of greetLang would therefore look like this.\nListing13.16 The implementation of greetLang methods\nfunction greetLangDogEn(animal, language) {\nconsole.log(\"Woof woof! My name is \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"en\"], greetLangDogEn)(greetLang);\nfunction greetLangDogFr(animal, language) {\nconsole.log(\"Ouaf Ouaf! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"dog\", \"fr\"], greetLangDogFr)(greetLang);\nfunction greetLangCatEn(animal, language) {\nconsole.log(\"Meow! I am \" +\nanimal.name +\n\" and I speak \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"en\"], greetLangCatEn)(greetLang);\nfunction greetLangCatFr(animal, language) {\nconsole.log(\"Miaou! Je m'appelle \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cat\", \"fr\"], greetLangCatFr)(greetLang);\nfunction greetLangCowEn(animal, language) {\nconsole.log(\"Moo! Call me \" +\nanimal.name +\n\" and I speak \" +\n--- Page 313 ---\n13.3 Multimethods with multiple dispatch 285\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"en\"], greetLangCowEn)(greetLang);\nfunction greetLangCowFr(animal, language) {\nconsole.log(\"Meuh! Appelle moi \" +\nanimal.name +\n\" et je parle \" +\nlanguage.name);\n}\ngreetLang = method([\"cow\", \"fr\"], greetLangCowFr)(greetLang);\nDave looks at the code for the methods that deal with French. He is surprised to see Ouaf\nOuaf instead of Woof Woof for dogs, Miaou instead of Meow for cats, and Meuh instead of\nMoo for cows.\nDave I didn’t know that animal onomatopoeia were different in French than in\nEnglish!\nTheo Ono what?\nDave Onomatopoeia, from the Greek ónoma that means name and poiéo– that means to\nproduce. It is the property of words that sound like what they represent; for\ninstance, Woof, Meow, and Moo.\nTheo Yeah, for some reason in French, dogs Ouaf, cats Miaou, and cows Meuh.\nDave I see that in the array the animal type is always before the language type.\nTheo Right! As I told you before, in a multimethod that features multiple dispatch,\nthe order doesn’t really matter, but it has to be consistent.\nTIP Multiple dispatch is when a dispatch function emits a value that depends on more\nthan one argument. In a multimethod that features multiple dispatch, the order of\nthe elements in the array emitted by the dispatch function has to be consistent with\nthe order of the elements in the wiring of the methods.\nDave Now let me see if I can figure out how to use a multimethod that features mul-\ntiple dispatch.\nDave remembers that Theo told him earlier that multimethods are used like regular func-\ntions. With that in mind, he comes up with the code for a multimethod that features multi-\nple dispatch.\nListing13.17 Calling a multimethod that features multiple dispatch\ngreetLang(myDog, french);\n// → \"Ouaf Ouaf! Je m\\'appelle Fido et je parle Français\"\ngreetLang(myDog, english);\n// → \"Woof woof! My name is Fido and I speak English\"\ngreetLang(myCat, french);\n// → \"Miaou! Je m\\'appelle Milo et je parle Français\"\n--- Page 314 ---\n286 CHAPTER 13 Polymorphism\ngreetLang(myCat, english);\n// → \"Meow! I am Milo and I speak English\"\ngreetLang(myCow, french);\n// → \"Meuh! Appelle moi Clarabelle et je parle Français\"\ngreetLang(myCow, english);\n// → \"Moo! Call me Clarabelle and I speak English\"\nTheo Now do you agree that multimethods with multiple dispatch offer a more pow-\nerful polymorphism that OOP polymorphism?\nDave Indeed, I do.\nTheo Let me show you an even more powerful polymorphism called dynamic dis-\npatch. But first, let’s get some more of that wonderful French press coffee.\nDave Great idea! While we’re in the kitchen, I think my mom made an orange Bundt\ncake using the oranges from the grove.\n13.4 Multimethods with dynamic dispatch\nDave refills their coffee cups as Theo takes two slices from the cake and dishes them up.\nThey take their coffee and cake outside to enjoy more of the fresh country air before\nresuming their conversation.\nDave What is dynamic dispatch?\nTheo It’s when the dispatch function of a multimethod returns a value that goes\nbeyond the static type of its arguments.\nDave Like what, for example?\nTheo Like a number or a Boolean, for instance.\nDave Why would such a thing be useful?\nTheo Imagine that instead of being polyglot, our animals would suffer from\ndysmakrylexia.\nDave Suffering from what?\nTheo Dysmakrylexia. It comes from the Greek dus, expressing the idea of difficulty,\nmakrýs meaning long, and léxis meaning diction. Therefore, dysmakrylexia is dif-\nficulty pronouncing long words.\nDave I’ve never heard of that.\nTheo That’s because I just invented it.\nDave Funny. What’s considered a long word for our animals?\nTheo Let’s say that when their name has more than five letters, they’re not able to\nsay it.\nDave A bit weird, but OK.\nTheo Let’s call our multimethod dysGreet. Its dispatch function returns an array\nwith two elements: the animal type and a Boolean about whether the name is\nlong or not. Take a look at this multimethod initialization.\n--- Page 315 ---\n13.4 Multimethods with dynamic dispatch 287\nListing13.18 A multimethod using a dispatch function with dynamic dispatch\nfunction dysGreetDispatch(animal) {\nif(dev()) {\nif(!ajv.validate(animalSchema, animal)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"dysGreet called with invalid arguments: \" + errors);\n}\n}\nvar hasLongName = animal.name.length > 5;\nreturn [animal.type, hasLongName];\n};\nvar dysGreet = multi(dysGreetDispatch);\nDave Writing the dysGreet methods doesn’t seem too complicated.\nAs Theo reaches over to pass Dave his notebook, he accidently hits his coffee cup. Now Theo’s\nnotebook is completely wet, and all the diagrams are soggy! Fortunately, Dave brought an\nextra napkin from the kitchen, and it’s still clean. He draws a flow diagram as in figure 13.4\nand then grabs his laptop and writes the implementation of the dysGreet methods.\n[\"dog\", true] dysGreetDogLong\nGreet as a dog mentioning name\n[\"cat\", true] dysGreetCatLong\nGreet as a cat mentioning name\n[\"cow\", true] dysGreetCowLong\nGreet as a cow mentioning name\nargs dysGreetLangDispatch\nanimal, language Emit the animal and the language types\n[\"dog\", false] dysGreetDogShort\nGreet as a dog omitting name\n[\"cat\", false] dysGreetCatShort\nGreet as a cat omitting name\n[\"cow\", false] dysGreetCowShort\nGreet as a cow omitting name\nFigure 13.4 The logic flow of the dysGreet multimethod\nListing13.19 The dysGreet methods\nfunction dysGreetDogLong(animal) {\nconsole.log(\"Woof woof! My name is \" + animal.name);\n}\ndysGreet = method([\"dog\", true], dysGreetDogLong)(dysGreet);\n--- Page 316 ---\n288 CHAPTER 13 Polymorphism\nfunction dysGreetDogShort(animal) {\nconsole.log(\"Woof woof!\");\n}\ndysGreet = method([\"dog\", false], dysGreetDogShort)(dysGreet);\nfunction dysGreetCatLong(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ndysGreet = method([\"cat\", true], dysGreetCatLong)(dysGreet);\nfunction dysGreetCatShort(animal) {\nconsole.log(\"Meow!\");\n}\ndysGreet = method([\"cat\", false], dysGreetCatShort)(dysGreet);\nfunction dysGreetCowLong(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ndysGreet = method([\"cow\", true], dysGreetCowLong)(dysGreet);\nfunction dysGreetCowShort(animal) {\nconsole.log(\"Moo!\");\n}\ndysGreet = method([\"cow\", false], dysGreetCowShort)(dysGreet);\nTheo checks that the code works as expected. He compliments Dave, not only on the\nmethod implementation but also for having the foresight to grab an extra napkin.\nListing13.20 Testing dysGreet\ndysGreet(myDog);\ndysGreet(myCow);\ndysGreet(myCat);\n//\"Woof woof!\"\n//\"Moo! Call me Clarabelle\"\n//\"Meow!\"\nTheo Well done, my friend! Our exploration of multimethods has come to an end. I\nthink it’s time for me to drive back if I want to get home before dark and beat\nthe rush hour traffic.\nDave Before you leave, let’s check if multimethods are available in programming\nlanguages other than JavaScript.\nTheo That’s a question for Joe.\nDave Do you think it’s OK if I call him now?\nTheo I think it’s probably better if you send him an email. He’s in a tech conference,\nand I’m not sure if it’s all day. Thank you for this beautiful day in the country\nand the wonderful refreshments.\nDave I enjoyed it, also, especially our discussions about etymology. I think there are\nsome oranges for you to take home and enjoy later.\nTheo Great! I can’t wait until my wife tries one.\n--- Page 317 ---\n13.5 Integrating multimethods in a production system 289\nAfter Theo leaves, Dave sends Joe an email. A few minutes later, Dave receives an email\nfrom Joe with the subject, “Support for multimethods in different languages.”\nSupport for multimethods in different languages\nPython has a library called multimethods (https://github.com/weissjeffm/multimeth-\nods), and Ruby has one called Ruby multimethods (https://github.com/psantacl/\nruby-multimethods). Both seem to work quite like the JavaScript arrows/multi-\nmethod library.\nIn Java, there is the Java Multimethod Framework (http://igm.univ-mlv.fr/~forax/\nworks/jmmf/), and C# supports multimethods natively via the dynamic keyword.\nHowever, in both Java and C#, multimethods work only with static data types and not\nwith generic data structures.\nGeneric data structure\nLanguage URL\nsupport\nJavaScript https://github.com/caderek/arrows/tree/master/ Yes\npackages/multimethod\nJava http://igm.univ-mlv.fr/~forax/works/jmmf/ No\nC# Native support No\nPython https://github.com/weissjeffm/multimethods Yes\nRuby https://github.com/psantacl/ruby-multimethods Yes\n13.5 Integrating multimethods in a production system\nWhile Theo is driving back home, his thoughts take him back to the fresh air of the coun-\ntry. This pleasant moment is interrupted by a phone call from Nancy at Klafim.\nNancy How are you doing?\nTheo Fine. I’m driving back from the countryside.\nNancy Cool. Are you available to talk about work?\nTheo Sure.\nNancy I’d like to add a tiny feature to the catalog.\nIn the past, when Nancy qualified a feature as tiny, it scared Theo because tiny turned into\nhuge. What seemed easy to her always took him a surprising amount of time to develop.\nBut after refactoring the system according to DOP principles, now what seems tiny to\nNancy is usually quite easy to implement.\nTheo What feature?\nNancy I’d like to allow librarians to view the list of authors, ordered by last name, in\ntwo formats: HTML and Markdown.\n--- Page 318 ---\n290 CHAPTER 13 Polymorphism\nTheo It doesn’t sound too complicated.\nNancy Also, I need a bit of text formatting.\nTheo What kind of text formatting?\nNancy Depending on the number of books an author has written, their name should\nbe in bold and italic fonts.\nTheo Could you send me an email with all the details. I’ll take a look at it tomorrow\nmorning.\nNancy Perfect. Have a safe drive!\nBefore going to bed, Theo reflects about today’s etymology lessons. He realizes that he\nnever looked for the etymology of the word etymology itself! He searches for the term etymol-\nogy online and learns that the word etymology derives from the Greek étumon, meaning true\nsense, and the suffix logia, denoting the study of. During the night, Theo dreams of dogs,\ncats, and cows programming on their laptops in a field of grass.\nWhen Theo arrives at the office the next day, he opens Nancy’s email with the details\nabout the text formatting feature. The details are summarized in table 13.1.\nTable 13.1 Text formatting for author names according to the number of books\nthey have written\nNumber of books Italic Bold\n10 or fewer Yes No\nBetween 11 and 50 No Yes\n51 or more Yes Yes\nTheo forwards Nancy’s email to Dave and asks him to take care of this task. Delegating\nresponsibility, after all, is the trait of a great manager.\nDave thinks the most difficult part of the feature lies in implementing an Author\n.myName(author, format) function that receives two arguments: the author data and the\ntext format. He asks himself whether he can implement this function as a multimethod\nand use what he learned yesterday with Theo at his parents’ home in the country. It seems\nthat this feature is quite similar to the one that dealt with dysmakrylexia. Instead of check-\ning the length of a string, he needs to check the length of an array.\nFirst, Dave needs a data schema for the text format. He could represent a format as a\nmap with a type field like Theo did yesterday for languages, but at the moment, it seems\nsimpler to represent a format as a string that could be either markdown or html. He comes\nup with the text format schema in listing 13.21. He already wrote the author schema with\nTheo last week. It’s in listing 13.22.\nListing13.21 The text format schema\nvar textFormatSchema = {\n\"name\": {\"type\": \"string\"},\n\"type\": {\"enum\": [\"markdown\", \"html\"]}\n};\n--- Page 319 ---\n13.5 Integrating multimethods in a production system 291\nListing13.22 The author schema\nvar authorSchema = {\n\"type\": \"object\",\n\"required\": [\"name\", \"bookIsbns\"],\n\"properties\": {\n\"name\": {\"type\": \"string\"},\n\"bookIsbns\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n};\nNow, Dave needs to write a dispatch function and initialize the multimethod. Remember-\ning that Theo had no qualms about creating the word dysmakrylexia, he decides that he\nprefers his own neologism, prolificity, over the existing nominal form prolificness. He finds it\nuseful to have an Author.prolificityLevel helper function that returns the level of\nprolificity of the author: either low, medium, or high. Now he’s ready to code the author-\nNameDispatch function.\nListing13.23 Author.myName multimethod initialization\nAuthor.prolificityLevel = function(author) {\nvar books = _.size(_.get(author, \"bookIsbns\"));\nif (books <= 10) {\nreturn \"low\";\n};\nif (books >= 51) {\nreturn \"high\";\n}\nreturn \"medium\";\n};\nvar authorNameArgsSchema = {\n\"type\": \"array\",\n\"prefixItems\": [\nauthorSchema,\n{\"enum\": [\"markdown\", \"html\"]}\n]\n};\nfunction authorNameDispatch(author, format) {\nif(dev()) {\nif(!ajv.validate(authorNameArgsSchema, [author, format])) {\nthrow (\"Author.myName called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [Author.prolificityLevel(author), format];\n};\nAuthor.myName = multi(authorNameDispatch);\n--- Page 320 ---\n292 CHAPTER 13 Polymorphism\nThen Dave works on the methods: first, the HTML format methods. In HTML, bold text is\nwrapped inside a <b> tag, and italic text is wrapped in a <i> tag. For instance, in HTML,\nthree authors with different levels of prolificity would be written like this.\nListing13.24 Examples of bold and italic in HTML\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n<i>Yehonathan Sharvit<i>\nBold and italic formatting\n<b>Stephen Covey</b>\nfor highly prolific authors\n<b><i>Isaac Asimov</i></b>\nWith this information in hand, Dave writes the three methods that deal with HTML for-\nmatting. Easy!\nListing13.25 The methods that deal with HTML formatting\nfunction authorNameLowHtml(author, format) {\nreturn \"<i>\" + _.get(author, \"name\") + \"</i>\";\n}\nAuthor.myName = method([\"low\", \"html\"], authorNameLowHtml)(Author.myName);\nfunction authorNameMediumHtml(author, format) {\nreturn \"<b>\" + _.get(author, \"name\") + \"</b>\";\n}\nAuthor.myName =\nmethod([\"medium\", \"html\"], authorNameMediumHtml)(Author.myName);\nfunction authorNameHighHtml(author, format) {\nreturn \"<b><i>\" + _.get(author, \"name\") + \"</i></b>\";\n}\nAuthor.myName =\nmethod([\"high\", \"html\"], authorNameHighHtml)(Author.myName);\nThen, Dave moves on to the three methods that deal with Markdown formatting. In\nMarkdown, bold text is wrapped in two asterisks, and italic text is wrapped in a single\nasterisk. For instance, in Markdown, three authors with different levels of prolificity\nwould be written like the code in listing 13.26. The code for the Markdown methods is in\nlisting 13.27.\nListing13.26 Examples of bold and italic in Markdown\nItalic formatting for Bold formatting for\nminimally prolific authors moderately prolific authors\n*Yehonathan Sharvit*\nBold and italic formatting\n**Stephen Covey**\nfor highly prolific authors\n***Isaac Asimov***\n--- Page 321 ---\n13.5 Integrating multimethods in a production system 293\nListing13.27 The methods that deal with Markdown formatting\nfunction authorNameLowMarkdown(author, format) {\nreturn \"*\" + _.get(author, \"name\") + \"*\";\n}\nAuthor.myName =\nmethod([\"low\", \"markdown\"], authorNameLowMarkdown)(Author.myName);\nfunction authorNameMediumMarkdown(author, format) {\nreturn \"**\" + _.get(author, \"name\") + \"**\";\n}\nAuthor.myName =\nmethod([\"medium\", \"markdown\"], authorNameMediumMarkdown)(Author.myName);\nfunction authorNameHighMarkdown(author, format) {\nreturn \"***\" + _.get(author, \"name\") + \"***\";\n}\nAuthor.myName =\nmethod([\"high\", \"markdown\"], authorNameHighMarkdown)(Author.myName);\nDave decides to test his code by involving a mysterious author. Listing 13.28 and listing 13.29\nshow the tests.\nListing13.28 Testing HTML formatting\nvar yehonathan = {\n\"name\": \"Yehonathan Sharvit\",\n\"bookIsbns\": [\"9781617298578\"]\n};\nAuthor.myName(yehonathan, \"html\");\n// → \"<i>Yehonathan Sharvit</i>\"\nListing13.29 Testing Markdown formatting\nAuthor.myName(yehonathan, \"markdown\");\n// → \"*Yehonathan Sharvit*\"\nTheo shows up at Dave’s desk and asks to review Dave’s implementation of the list of\nauthors feature. Curious, Theo asks Dave about the author that appears in the test of\nAuthor.myName.\nTheo Who is Yehonathan Sharvit?\nDave I don’t really know. The name appeared when I googled “data-oriented pro-\ngramming” yesterday. He wrote a book on the topic. I thought it would be cool\nto use its ISBN in my test.\n--- Page 322 ---\n294 CHAPTER 13 Polymorphism\nSummary\n The main benefit of polymorphism is extensibility.\n Multimethods make it possible to benefit from polymorphism when data is repre-\nsented with generic maps.\n A multimethod is made of a dispatch function and multiple methods.\n The dispatch function of a multimethod emits a dispatch value.\n Each of the methods used in a multimethod provides an implementation for a\nspecific dispatch value.\n Multimethods can mimic OOP class inheritance via single dispatch.\n In single dispatch, a multimethod receives a single map that contains a type field,\nand the dispatch function of the multimethod emits the value of the type field.\n In addition to single dispatch, multimethods provide two kinds of advanced\npolymorphisms: multiple dispatch and dynamic dispatch.\n Multiple dispatch is used when the behavior of the multimethod depends on\nmultiple arguments.\n Dynamic dispatch is used when the behavior of the multimethod depends on run-\ntime arguments.\n The arguments of a multimethod are passed to the dispatch function and to the\nmethods.\n A multimethod dispatch function is responsible for\n– Defining the signature.\n– Validating the arguments.\n– Emitting a dispatch value.\n Multimethods provides extensibility by decoupling between multimethod ini-\ntialization and method implementations.\n Multimethods are called like regular functions.\n Multimethods support default implementations that are called when no method\ncorresponds to the dispatch value.\n In a multimethod that features multiple dispatch, the order of the elements in\nthe array emitted by the dispatch function has to be consistent with the order of\nthe elements in the wiring of the methods.\nLodash functions introduced in this chapter\nFunction Description\nsize(coll) Gets the size of coll\n--- Page 323 ---\nAdvanced data\nmanipulation\nWhatever is well-conceived\nis clearly said\nThis chapter covers\n Manipulating nested data\n Writing clear and concise code for business\nlogic\n Separating business logic and generic data\nmanipulation\n Building custom data manipulation tools\n Using the best tool for the job\nWhen our business logic involves advanced data processing, the generic data manip-\nulation functions provided by the language run time and by third-party libraries\nmight not be sufficient. Instead of mixing the details of data manipulation with\nbusiness logic, we can write our own generic data manipulation functions and imple-\nment our custom business logic using them. Separating business logic from the inter-\nnal details of data manipulation makes the business logic code concise and easy to\nread for other developers.\n295\n--- Page 324 ---\n296 CHAPTER 14 Advanced data manipulation\n14.1 Updating a value in a map with eloquence\nDave is more and more autonomous on the Klafim project. He can implement most fea-\ntures on his own, typically turning to Theo only for code reviews. Dave’s code quality stan-\ndards are quite high. Even when his code is functionally solid, he tends to be unsatisfied\nwith its readability. Today, he asks for Theo’s help in improving the readability of the code\nthat fixes a bug Theo introduced a long time ago.\nDave I think I have a found a bug in the code that returns book information from\nthe Open Library API.\nTheo What bug?\nDave Sometimes, the API returns duplicate author names, and we pass the dupli-\ncates through to the client.\nTheo It doesn’t sound like a complicated bug to fix.\nDave Right, I fixed it, but I’m not satisfied with the readability of the code I wrote.\nTheo Being critical of our own code is an important quality for a developer to prog-\nress. What is it exactly that you don’t like?\nDave Take a look at this code.\nListing14.1 Removing duplicates in a straightforward but tedious way\nfunction removeAuthorDuplicates(book) {\nvar authors = _.get(book, \"authors\");\nvar uniqAuthors = _.uniq(authors);\nreturn _.set(book,\"authors\", uniqAuthors);\n}\nDave I’m using _.get to retrieve the array with the author names, then _.uniq to\ncreate a duplicate-free version of the array, and finally, _.set to create a new\nversion of the book with no duplicate author names.\nTheo The code is tedious because the next value of authorNames needs to be based\non its current value.\nDave But it’s a common use case! Isn’t there a simpler way to write this kind of code?\nTheo Your astonishment definitely honors you as a developer, Dave. I agree with you\nthat there must be a simpler way. Let me phone Joe and see if he’s available for\na conference call.\nJoe How’s it going, Theo?\nTheo Great! Are you back from your tech conference?\nJoe I just landed. I’m on my way home now in a taxi.\nTheo How was your talk about DOP?\nJoe Pretty good. At the beginning people were a bit suspicious, but when I told\nthem the story of Albatross and Klafim, it was quite convincing.\nTheo Yeah, adults are like children in that way; they love stories.\nJoe What about you? Did you manage to achieve polymorphism with multimethods?\nTheo Yes! Dave even managed to implement a feature in Klafim with multimethods.\nJoe Cool!\n--- Page 325 ---\n14.1 Updating a value in a map with eloquence 297\nTheo Do you have time to help Dave with a question about programming?\nJoe Sure.\nDave Hi Joe. How are you doing?\nJoe Hello Dave. Not bad. What kind of help do you need?\nDave I’m wondering if there’s a simpler way to remove duplicates inside an array\nvalue in a map. Using _.get, _.uniq, and _.set looks quite tedious.\nJoe You should build your own data manipulation tools.\nDave What do you mean?\nJoe You should write a generic update function that updates a value in a map,\napplying a calculation based on its current value.1\nDave What would the arguments of update be in your opinion?\nJoe Put the cart before the horse.\nDave What?!\nJoe Rewrite your business logic as if update were already implemented, and you’ll\ndiscover what the arguments of update should be.\nDave I see what you mean: the horse is the implementation of update, and the cart is\nthe usage of update.\nJoe Exactly. But remember, it’s better if you keep your update function generic.\nDave How?\nJoe By not limiting it to your specific use case.\nDave I see. The implementation of update should not deal with removing duplicate\nelements. Instead, it should receive the updating function—in my case,\n_.uniq—as an argument.\nJoe Exactly! Uh, sorry Dave, I gotta go, I just got home. Good luck!\nDave Take care, Joe, and thanks!\nDave ends the conference call. Looking at Theo, he reiterates the conversation with Joe.\nDave Joe advised me to write my own update function. For that purpose, he told me\nto start by rewriting removeAuthorDuplicates as if update were already\nimplemented. That will allow us to make sure we get the signature of update\nright.\nTheo Sounds like a plan.\nDave Joe called it “putting the cart before the horse.”\nTheo Joe and his funny analogies...\nTIP The best way to find the signature of a custom data manipulation function is to\nthink about the most convenient way to use it.\nDave Anyway, the way I’d like to use update inside removeAuthorDuplicates is\nlike this.\n1 Lodash provides an implementation of update, but for the sake of teaching, we are writing our own imple-\nmentation.\n--- Page 326 ---\n298 CHAPTER 14 Advanced data manipulation\nListing14.2 The code that removes duplicates in an elegant way\nfunction removeAuthorDuplicates(book) {\nreturn update(book, \"authors\", _.uniq);\n}\nTheo Looks good to me!\nDave Wow! Now the code with update is much more elegant than the code with\n_.get and _.set!\nTheo Before you implement update, I suggest that you write down in plain English\nexactly what the function does.\nDave It’s quite easy: update receives a map called map, a path called path, and a\nfunction called fun. It returns a new version of map, where path is associated\nwith fun(currentValue), and currentValue is the value associated with\npath in map.\nThinking out loud, Dave simultaneously draws a diagram like that in figure 14.1. Theo is\nbecoming more and more impressed with his young protegé as he studies the figure.\n{\n\"position\" : \"manager\", \"income\"\n\"income\" : 100000\n} map fun path\nupdate\n{\n\"position\" : \"manager\",\n\"income\" : fun(100000)\nres Figure 14.1 The\n}\nbehavior of update\nTIP Before implementing a custom data manipulation function, formulate in plain\nEnglish exactly what the function does.\nTheo With such a clear definition, it’s going to be a piece of cake to implement\nupdate!\nAfter a few minutes, Dave comes up with the code. It doesn’t take long because the plain-\nEnglish diagram helps him to organize the code.\nListing14.3 A generic update function\nfunction update(map, path, fun) {\nvar currentValue = _.get(map, path);\nvar nextValue = fun(currentValue);\nreturn _.set(map, path, nextValue);\n}\n--- Page 327 ---\n14.2 Manipulating nested data 299\nTheo Why don’t you see if it works with a simple case such as incrementing a number\nin a map?\nDave Good idea! I’ll try multiplying a value in a map by 2 with update. How’s this\nlook?\nListing14.4 Multiplying a value in a map by 2\nvar m = {\n\"position\": \"manager\",\n\"income\": 100000\n};\nupdate(m, \"income\", function(x) {\nreturn x * 2;\n});\n// → {\"position\": \"manager\", \"income\": 200000}\nTheo Great! It seems to work.\n14.2 Manipulating nested data\nThe next Monday, during Theo and Dave’s weekly sync meeting, they discuss the upcom-\ning features for Klafim. Theo fondly remembers another Monday where they met at Dave’s\nfamily home in the country. Coming back to the present moment, Theo begins.\nTheo Recently, Nancy has been asking for more and more administrative features.\nDave Like what?\nTheo I’ll give you a few examples.... Let me find the email I got from Nancy yesterday.\nDave OK.\nTheo Here it is. There are three feature requests for now: listing all the book author\nIDs, calculating the book lending ratio, and grouping books by a physical library.\nDave What feature should I tackle first?\nTheo It doesn’t matter, but you should deliver the three of these before the end of\nthe week. Good luck, and don’t hesitate to call me if you need help.\nOn Tuesday, Dave asks for Theo’s help. Dave is not pleased with how his code looks.\nDave I started to work on the three admin features, but I don’t like the code I wrote.\nLet me show you the code for retrieving the list of author IDs from the list of\nbooks returned from the database.\nTheo Can you remind me what an element in a book list returned from the database\nlooks like?\nDave Each book is a map with an authorIds array field.\nTheo OK, so it sounds like a map over the books should do it.\nDave This is what I did, but it doesn’t work as expected. Here’s my code for listing\nthe book author IDs.\n--- Page 328 ---\n300 CHAPTER 14 Advanced data manipulation\nListing14.5 Retrieving the author IDs in books as an array of arrays\nfunction authorIdsInBooks(books) {\nreturn _.map(books, \"authorIds\");\n}\nTheo What’s the problem?\nDave The problem is that it returns an array of arrays of author IDs instead of an\narray of author IDs. For instance, when I run authorIdsInBooks on a catalog\nwith two books, I get this result.\nListing14.6 The author IDs in an array of arrays\n[\n[\"sean-covey\", \"stephen-covey\"],\n[\"alan-moore\", \"dave-gibbons\"]\n]\nTheo That’s not a big problem. You can flatten an array of arrays with _.flatten,\nand you should get the result you expect.\nDave Nice! This is exactly what I need! Give me a moment to fix the code of\nauthorIdsInBooks. . . here you go.\nListing14.7 Retrieving the author IDs in books as an array of strings\nfunction authorIdsInBooks(books) {\nreturn _.flatten(_.map(books, \"authorIds\"));\n}\nTheo Don’t you think that mapping and then flattening deserves a function of its own?\nDave Maybe. It’s quite easy to implement a flatMap function.2 How about this?\nListing14.8 The implementation of flatMap\nfunction flatMap(coll, f) {\nreturn _.flatten(_.map(coll,f));\n}\nTheo Nice!\nDave I don’t know.... It’s kind of weird to have such a small function.\nTheo I don’t think that code size is what matters here.\nDave What do you mean?\nTheo See what happens when you rewrite authorIdsInBooks using flatMap.\nDave OK, here’s how I’d use flatMap to list the author IDs.\n2 Lodash provides an implementation of flatMap, but for the sake of teaching, we are writing our own\nimplementation.\n--- Page 329 ---\n14.3 Using the best tool for the job 301\nListing14.9 Retrieving the author IDs as an array of strings using flatMap\nfunction authorIdsInBooks(books) {\nreturn flatMap(books, \"authorIds\");\n}\nTheo What implementation do you prefer, the one with flatten and map (in listing\n14.7) or the one with flatMap (in listing 14.9)?\nDave I don’t know. To me, they look quite similar.\nTheo Right, but which implementation is more readable?\nDave Well, assuming I know what flatMap does, I would say the implementation\nwith flatMap. Because it’s more concise, it is a bit more readable.\nTheo Again, it’s not about the size of the code. It’s about the clarity of intent and the\npower of naming things.\nDave I don’t get that.\nTheo Let me give you an example from our day-to-day language.\nDave OK.\nTheo Could you pass me that thing on your desk that’s used for writing?\nIt takes Dave a few seconds to get that Theo has asked him to pass the pen on the desk.\nAfter he passes Theo the pen, he asks:\nDave Why didn’t you simply ask for the pen?\nTheo I wanted you to experience how it feels when we use descriptions instead of\nnames to convey our intent.\nDave Oh, I see. You mean that once we use a name for the operation that maps and\nflattens, the code becomes clearer.\nTheo Exactly.\nDave Let’s move on to the second admin feature: calculating the book lending ratio.\nTheo Before that, I think we deserve a short period for rest and refreshments, where\nwe drink a beverage made by percolation from roasted and ground seeds.\nDave A coffee break!\n14.3 Using the best tool for the job\nAfter the coffee break, Dave shows Theo his implementation of the book lending ratio cal-\nculation. This time, he seems to like the code he wrote.\nDave I’m quite proud of the code I wrote to calculate the book lending ratio.\nTheo Show me the money!\nDave My function receives a list of books from the database like this.\nListing14.10 A list of two books with bookItems\n[\n{\n\"isbn\": \"978-1779501127\",\n--- Page 330 ---\n302 CHAPTER 14 Advanced data manipulation\n\"title\": \"Watchmen\",\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n}\n]\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"bookItems\": [\n{\n\"id\": \"book-item-123\",\n\"libId\": \"hudson-park-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-17\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n]\nTheo Quite a nested piece of data!\nDave Yeah, but now that I’m using flatMap, calculating the lending ratio is quite\neasy. I’m going over all the book items with forEach and incrementing either\nthe lent or the notLent counter. At the end, I return the ratio between lent\nand (lent + notLent). Here’s how I do that.\nListing14.11 Calculating the book lending ratio using forEach\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar lent = 0;\nvar notLent = 0;\n_.forEach(bookItems, function(item) {\nif(_.get(item, \"isLent\")) {\nlent = lent + 1;\n} else {\nnotLent = notLent + 1;\n}\n});\nreturn lent/(lent + notLent);\n}\nTheo Would you allow me to tell you frankly what I think of your code?\nDave If you are asking this question, it means that you don’t like it. Right?\nTheo It’s nothing against you; I don’t like any piece of code with forEach.\n--- Page 331 ---\n14.3 Using the best tool for the job 303\nDave What’s wrong with forEach?\nTheo It’s too generic!\nDave I thought that genericity was a positive thing in programming.\nTheo It is when we build a utility function, but when we use a utility function, we\nshould use the least generic function that solves our problem.\nDave Why?\nTheo Because we ought to choose the right tool for the job, like in the real life.\nDave What do you mean?\nTheo Let me give you an example. Yesterday, I had to clean my drone from the\ninside. Do you think that I used a screwdriver or a Swiss army knife to unscrew\nthe drone cover?\nDave A screwdriver, of course! It’s much more convenient to manipulate.\nTheo Right. Also, imagine that someone looks at me using a screwdriver. It’s quite\nclear to them that I am turning a screw. It conveys my intent clearly.\nDave Are you saying that forEach is like the Swiss army knife of data manipulation?\nTheo That’s a good way to put it.\nTIP Pick the least generic utility function that solves your problem.\nDave What function should I use then, to iterate over the book item collection?\nTheo You could use _.reduce.\nDave I thought reduce was about returning data from a collection. Here, I don’t\nneed to return data; I need to update two variables, lent and notLent.\nTheo You could represent those two values in a map with two keys.\nDave Can you show me how to rewrite my lendingRatio function using reduce?\nTheo Sure. The initial value passed to reduce is the map, {\"lent\": 0, \"notLent\": 0},\nand inside each iteration, we update one of the two keys, like this.\nListing14.12 Calculating the book lending ratio using reduce\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = _.reduce(bookItems, function(res, item) {\nif(_.get(item, \"isLent\")) {\nres.lent = res.lent + 1;\n} else {\nres.notLent = res.notLent + 1;\n}\nreturn res;\n}, {notLent: 0, lent:0});\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nDave Instead of updating the variables lent and notLent, now we are updating lent\nand notLent map fields. What’s the difference?\n--- Page 332 ---\n304 CHAPTER 14 Advanced data manipulation\nTheo Dealing with map fields instead of variables allows us to get rid of reduce in\nour business logic code.\nDave How could you iterate over a collection without forEach and without reduce?\nTheo I can’t avoid the iteration over a collection, but I can hide reduce behind a\nutility function. Take a look at the way reduce is used inside the code of\nlendingRatio. What is the meaning of the reduce call?\nDave looks at the code in listing 14.12. He thinks for a long moment before he answers.\nDave I think it’s counting the number of times isLent is true and false.\nTheo Right. Now, let’s use Joe’s advice about building our own data manipulation\ntool.\nDave How exactly?\nTheo I suggest that you write a countByBoolField utility function that counts the\nnumber of times a field is true and false.\nDave OK, but before implementing this function, let me first rewrite the code of\nlendingRatio, assuming this function already exists.\nTheo You are definitely a fast learner, Dave!\nDave Thanks! I think that by using countByBoolField, the code for calculating the\nlending ratio using a custom utility function would be something like this.\nListing14.13 Calculating the book lending ratio\nfunction lendingRatio(books) {\nvar bookItems = flatMap(books, \"bookItems\");\nvar stats = countByBoolField(bookItems, \"isLent\", \"lent\", \"notLent\");\nreturn stats.lent/(stats.lent + stats.notLent);\n}\nTIP Don’t use _.reduce or any other low-level data manipulation function inside\ncode that deals with business logic. Instead, write a utility function—with a proper\nname—that hides _.reduce.\nTheo Perfect. Don’t you think that this code is clearer than the code using _.reduce?\nDave I do! The code is both more concise and the intent is clearer. Let me see if I\ncan implement countByBoolField now.\nTheo I suggest that you write a unit test first.\nDave Good idea.\nDave types for a bit. When he’s satisfied, he shows Theo the result.\nListing14.14 A unit test for countByBoolField\nvar input = [\n{\"a\": true},\n{\"a\": false},\n{\"a\": true},\n--- Page 333 ---\n14.4 Unwinding at ease 305\n{\"a\": true}\n];\nvar expectedRes = {\n\"aTrue\": 3,\n\"aFalse\": 1\n};\n_.isEqual(countByBoolField(input, \"a\", \"aTrue\", \"aFalse\"), expectedRes);\nTheo Looks good to me. Now, for the implementation of countByBoolField, I\nthink you are going to need our update function.\nDave I think you’re right. On each iteration, I need to increment the value of either\naTrue or aFalse using update and a function that increments a number by 1.\nAfter a few minutes of trial and error, Dave comes up with the piece of code that uses\nreduce, update, and inc. He shows Theo the code for countByBoolField.\nListing14.15 The implementation of countByBoolField\nfunction inc (n) {\nreturn n + 1;\n}\nfunction countByBoolField(coll, field, keyTrue, keyFalse) {\nreturn _.reduce(coll, function(res, item) {\nif (_.get(item, field)) {\nreturn update(res, keyTrue, inc);\n}\nreturn update(res, keyFalse, inc);\n}, {[keyTrue]: 0,\nCreates a map with\n[keyFalse]: 0});\nkeyTrue and keyFalse\n}\nassociated to 0\nTheo Well done! Shall we move on and review the third admin feature?\nDave The third feature is more complicated. I would like to use the teachings from\nthe first two features for the implementation of the third feature.\nTheo OK. Call me when you’re ready for the code review.\n14.4 Unwinding at ease\nDave really struggled with the implementation of the last admin feature, grouping books\nby a physical library. After a couple of hours of frustration, Dave calls Theo for a rescue.\nDave I really had a hard time implementing the grouping by library feature.\nTheo I only have a couple of minutes before my next meeting, but I can try to help\nyou. What’s the exact definition of grouping by library?\nDave Let me show you the unit test I wrote.",
        "sections_found": []
      },
      "accurate_page_range": "303-333"
    },
    {
      "text": "- 13.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "raw_line": "- 13.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 106
    },
    {
      "text": "- 13.1 The essence of polymorphism",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "raw_line": "- 13.1 The essence of polymorphism (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 107
    },
    {
      "text": "- 13.2 Multimethods with single dispatch",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "raw_line": "- 13.2 Multimethods with single dispatch (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 108
    },
    {
      "text": "- 13.3 Multimethods with multiple dispatch",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "raw_line": "- 13.3 Multimethods with multiple dispatch (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 109
    },
    {
      "text": "- 13.4 Multimethods with dynamic dispatch",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "raw_line": "- 13.4 Multimethods with dynamic dispatch (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 110
    },
    {
      "text": "- 13.5 Integrating multimethods in a production system",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "raw_line": "- 13.5 Integrating multimethods in a production system (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 111
    },
    {
      "text": "- Summary",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "raw_line": "- Summary (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 112
    },
    {
      "text": "- 14.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "14 Advanced data manipulation",
      "raw_line": "- 14.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 113
    },
    {
      "text": "- 14.1 Updating a value in a map with eloquence",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "14 Advanced data manipulation",
      "raw_line": "- 14.1 Updating a value in a map with eloquence (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 114
    },
    {
      "text": "- 14.2 Manipulating nested data",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "14 Advanced data manipulation",
      "raw_line": "- 14.2 Manipulating nested data (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 115
    },
    {
      "text": "- 14.3 Using the best tool for the job",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "14 Advanced data manipulation",
      "raw_line": "- 14.3 Using the best tool for the job (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 116
    },
    {
      "text": "- 14.4 Unwinding at ease",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "14 Advanced data manipulation",
      "raw_line": "- 14.4 Unwinding at ease (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 117
    },
    {
      "text": "- Summary",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "14 Advanced data manipulation",
      "raw_line": "- Summary (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 118
    },
    {
      "text": "- 15.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- 15.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 119
    },
    {
      "text": "- 15.1 Determinism in programming",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- 15.1 Determinism in programming (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 120
    },
    {
      "text": "- 15.2 Reproducibility with numbers and strings",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- 15.2 Reproducibility with numbers and strings (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 121
    },
    {
      "text": "- 15.3 Reproducibility with any data",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- 15.3 Reproducibility with any data (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 122
    },
    {
      "text": "- 15.4 Unit tests",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- 15.4 Unit tests (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 123
    },
    {
      "text": "- 15.5 Dealing with external data sources",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- 15.5 Dealing with external data sources (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 124
    },
    {
      "text": "- Farewell",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- Farewell (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 125
    },
    {
      "text": "- Summary",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- Summary (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 126
    },
    {
      "text": "- A.0 Introduction (사용자 추가)",
      "node_level": 2,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.0 Introduction (사용자 추가) (node2) **[LEAF]**",
      "is_part_intro": false,
      "id": 127
    },
    {
      "text": "- A.1.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.1.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 128
    },
    {
      "text": "- A.1.1 Illustration of Principle #1",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.1.1 Illustration of Principle #1 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 129
    },
    {
      "text": "- A.1.2 Benefits of Principle #1",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.1.2 Benefits of Principle #1 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 130
    },
    {
      "text": "- A.1.3 Cost for Principle #1",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.1.3 Cost for Principle #1 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 131
    },
    {
      "text": "- A.1.4 Summary of Principle #1",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.1.4 Summary of Principle #1 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 132
    },
    {
      "text": "- A.2.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.2.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 133
    },
    {
      "text": "- A.2.1 Illustration of Principle #2",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.2.1 Illustration of Principle #2 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 134
    },
    {
      "text": "- A.2.2 Benefits of Principle #2",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.2.2 Benefits of Principle #2 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 135
    },
    {
      "text": "- A.2.3 Cost for Principle #2",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.2.3 Cost for Principle #2 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 136
    },
    {
      "text": "- A.2.4 Summary of Principle #2",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.2.4 Summary of Principle #2 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 137
    },
    {
      "text": "- A.3.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.3.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 138
    },
    {
      "text": "- A.3.1 Illustration of Principle #3",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.3.1 Illustration of Principle #3 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 139
    },
    {
      "text": "- A.3.2 Benefits of Principle #3",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.3.2 Benefits of Principle #3 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 140
    },
    {
      "text": "- A.3.3 Cost for Principle #3",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.3.3 Cost for Principle #3 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 141
    },
    {
      "text": "- A.3.4 Summary of Principle #3",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.3.4 Summary of Principle #3 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 142
    },
    {
      "text": "- A.4.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.4.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 143
    },
    {
      "text": "- A.4.1 Illustration of Principle #4",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.4.1 Illustration of Principle #4 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 144
    },
    {
      "text": "- A.4.2 Benefits of Principle #4",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.4.2 Benefits of Principle #4 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 145
    },
    {
      "text": "- A.4.3 Cost for Principle #4",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.4.3 Cost for Principle #4 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 146
    },
    {
      "text": "- A.4.4 Summary of Principle #4",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- A.4.4 Summary of Principle #4 (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 147
    },
    {
      "text": "- Conclusion",
      "node_level": 2,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- Conclusion (node2) **[LEAF]**",
      "is_part_intro": false,
      "id": 148
    },
    {
      "text": "- B.0 Introduction (사용자 추가)",
      "node_level": 2,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.0 Introduction (사용자 추가) (node2) **[LEAF]**",
      "is_part_intro": false,
      "id": 149
    },
    {
      "text": "- B.1.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.1.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 150
    },
    {
      "text": "- B.1.1 Accessing non-nested map fields with dynamic getters",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.1.1 Accessing non-nested map fields with dynamic getters (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 151
    },
    {
      "text": "- B.1.2 Accessing nested map fields with dynamic getters",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.1.2 Accessing nested map fields with dynamic getters (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 152
    },
    {
      "text": "- B.2.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.2.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 153
    },
    {
      "text": "- B.2.1 Accessing non-nested map fields with value getters",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.2.1 Accessing non-nested map fields with value getters (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 154
    },
    {
      "text": "- B.2.2 Accessing nested map fields with value getters",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.2.2 Accessing nested map fields with value getters (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 155
    },
    {
      "text": "- B.3.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.3.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 156
    },
    {
      "text": "- B.3.1 Accessing non-nested map fields with typed getters",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.3.1 Accessing non-nested map fields with typed getters (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 157
    },
    {
      "text": "- B.3.2 Accessing nested map fields with typed getters",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.3.2 Accessing nested map fields with typed getters (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 158
    },
    {
      "text": "- B.4.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.4.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 159
    },
    {
      "text": "- B.4.1 Generic access to non-nested class members",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.4.1 Generic access to non-nested class members (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 160
    },
    {
      "text": "- B.4.2 Generic access to nested class members",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.4.2 Generic access to nested class members (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 161
    },
    {
      "text": "- B.4.3 Automatic JSON serialization of objects",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- B.4.3 Automatic JSON serialization of objects (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 162
    },
    {
      "text": "- Summary",
      "node_level": 2,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- Summary (node2) **[LEAF]**",
      "is_part_intro": false,
      "id": 163
    },
    {
      "text": "- C.0 Introduction (사용자 추가)",
      "node_level": 2,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.0 Introduction (사용자 추가) (node2) **[LEAF]**",
      "is_part_intro": false,
      "id": 164
    },
    {
      "text": "- C.1.1 1958: Lisp",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.1.1 1958: Lisp (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 165
    },
    {
      "text": "- C.1.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.1.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 166
    },
    {
      "text": "- C.1.2 1981: Values and objects",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.1.2 1981: Values and objects (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 167
    },
    {
      "text": "- C.1.3 2000: Ideal hash trees",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.1.3 2000: Ideal hash trees (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 168
    },
    {
      "text": "- C.1.4 2006: Out of the Tar Pit",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.1.4 2006: Out of the Tar Pit (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 169
    },
    {
      "text": "- C.1.5 2007: Clojure",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.1.5 2007: Clojure (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 170
    },
    {
      "text": "- C.1.6 2009: Immutability for all",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.1.6 2009: Immutability for all (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 171
    },
    {
      "text": "- C.2.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.2.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 172
    },
    {
      "text": "- C.2.1 Principle #1: Separate code from data",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.2.1 Principle #1: Separate code from data (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 173
    },
    {
      "text": "- C.2.2 Principle #2: Represent data with generic data structures",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.2.2 Principle #2: Represent data with generic data structures (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 174
    },
    {
      "text": "- C.2.3 Principle #3: Data is immutable",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.2.3 Principle #3: Data is immutable (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 175
    },
    {
      "text": "- C.2.4 Principle #4: Separate data schema from data representation",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.2.4 Principle #4: Separate data schema from data representation (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 176
    },
    {
      "text": "- C.3.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.3.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 177
    },
    {
      "text": "- C.3.1 Data-oriented design",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.3.1 Data-oriented design (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 178
    },
    {
      "text": "- C.3.2 Data-driven programming",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.3.2 Data-driven programming (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 179
    },
    {
      "text": "- C.3.3 Data-oriented programming (DOP)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- C.3.3 Data-oriented programming (DOP) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 180
    },
    {
      "text": "- Summary",
      "node_level": 2,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "raw_line": "- Summary (node2) **[LEAF]**",
      "is_part_intro": false,
      "id": 181
    }
  ]
}