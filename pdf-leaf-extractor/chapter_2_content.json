{
  "chapter": "2",
  "title": "Separation between code and data",
  "page_info": {
    "page": 56,
    "title": "Separation between code and data",
    "pattern_matched": "Chapter 2",
    "text_preview": "28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his te"
  },
  "leaf_nodes": [
    {
      "text": "- 2.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "raw_line": "- 2.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 14,
      "chapter_info": {
        "page": 56,
        "title": "Separation between code and data",
        "pattern_matched": "Chapter 2",
        "text_preview": "28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his te"
      },
      "chapter_sections": {
        "start_page": 56,
        "end_page": 75,
        "content": "\n--- Page 56 ---\n28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his team have built in Clojure over the last 7\nyears are less complex and more flexible than the systems he used to build in Java. Accord-\ning to Joe, the systems they build now tend to be much simpler because they follow the\nprinciples of DOP.\nTheo I’ve never heard of data-oriented programming. Is it a new concept?\nJoe Yes and no. Most of the foundational ideas of data-oriented programming, or\nDOP as we like to call it, are well known to programmers as best practices. The\nnovelty of DOP, however, is that it combines best practices into a cohesive\nwhole.\nTheo That’s a bit abstract for me. Can you give me an example?\nJoe Sure! Take, for instance, the first insight of DOP. It’s about the relations between\ncode and data.\nTheo You mean the encapsulation of data in objects?\nJoe Actually, DOP is against data encapsulation.\nTheo Why is that? I thought data encapsulation was a positive programming paradigm.\nJoe Data encapsulation has both merits and drawbacks. Think about the way you\ndesigned the Library Management System. According to DOP, the main cause\nof complexity and inflexibility in systems is that code and data are mixed\ntogether in objects.\nTIP DOP is against data encapsulation.\nTheo It sounds similar to what I’ve heard about functional programming. So, if I\nwant to adopt DOP, do I need to get rid of object-oriented programming and\nlearn functional programming?\nJoe No, DOP principles are language-agnostic. They can be applied in both object-\noriented and functional programming languages.\nTheo That’s a relief! I was afraid that you were going to teach me about monads,\nalgebraic data types, and higher order functions.\nJoe No, none of that is required in DOP.\nTIP DOP principles are language-agnostic.\nTheo What does the separation between code and data look like in DOP then?\nJoe Data is represented by data entities that only hold members. Code is aggre-\ngated into modules where all functions are stateless.\nTheo What do you mean by stateless functions?\nJoe Instead of having the state encapsulated in the object, the data entity is passed\nas an argument.\nTheo I don’t get that.\nJoe Here, let’s make it visual.\n--- Page 57 ---\n2.2 Data entities 29\nJoe steps up to a whiteboard and quickly draws a diagram to illustrate his comment. Fig-\nure 2.2 shows Joe’s drawing.\nCode modules Stateless functions\nSeparate code from data\nData entities Only members\nFigure 2.2 The separation between code and data\nTheo It’s still not clear.\nJoe It will become clearer when I show you how it looks in the context of your\nLibrary Management System.\nTheo OK. Shall we start with code or with data?\nJoe Well, it’s data-oriented programming, so let’s start with data.\n2.2 Data entities\nIn DOP, we start the design process by discovering the data entities of our system.\nHere’s what Joe and Theo have to say about data entities.\nJoe What are the data entities of your system?\nTheo What do you mean by data entities?\nJoe I mean the parts of your system that hold information.\n NOTE Data entities are the parts of your system that hold information.\nTheo Well, it’s a Library Management System, so we have books and members.\nJoe Of course, but there are more. One way to discover the data entities of a system\nis to look for nouns and noun phrases in the requirements of the system.\nTheo looks at Nancy’s requirement napkin. He highlights the nouns and noun phrases\nthat seem to represent data entities.\nHighlighting terms in the requirements that correspond to data entities\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n--- Page 58 ---\n30 CHAPTER 2 Separation between code and data\nJoe Excellent. Can you see a natural way to group these entities?\nTheo Not sure, but it seems to me that users, members, and librarians form one\ngroup, whereas books, authors, and book copies form another group.\nJoe Sounds good to me. What would you call each group?\nTheo Probably user management for the first group and catalog for the second\ngroup.\nThe data entities of the system organized in a nested list\n The catalog data\n– Data about books\n– Data about authors\n– Data about book items\n– Data about book lendings\n The user management data\n– Data about users\n– Data about members\n– Data about librarians\nTheo I’m not sure about the relations between books and authors. Should it be asso-\nciation or composition?\nJoe Don’t worry too much about the details for the moment. We’ll refine our data\nentity design later. For now, let’s visualize the two groups in a mind map.\nTheo and Joe confer for a bit. Figure 2.3 shows the mind map they come up with.\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 2.3 The data entities of the\nsystem organized in a mind map\n--- Page 59 ---\n2.3 Code modules 31\nThe most precise way to visualize the data entities of a DOP system is to draw a data\nentity diagram with different arrows for association and composition. We will come\nback to data entity diagrams later.\nTIP Discover the data entities of your system and then sort them into high-level\ngroups, either as a nested list or as a mind map.\nWe will dive deeper into the design and representation of data entities in the next\nchapter. For now, let’s simplify things and say that the data of our library system is\nmade of two high-level groups: user management and catalog.\n2.3 Code modules\nThe second step of the design process in DOP is to define the code modules. Let’s lis-\nten in on Joe and Theo again.\nJoe Now that you have identified the data entities of your system and have\narranged them into high-level groups, it’s time to think about the code part of\nyour system.\nTheo What do you mean by the code part?\nJoe One way to think about that is to identity the functionality of your system.\nTheo looks again at Nancy’s requirements. This time he highlights the verb phrases that\nrepresent functionality.\nHighlighting terms in the requirements that correspond to functionality\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\nIn addition, it’s obvious to Theo that members can also return a book. Moreover, there\nshould be a way to detect whether a user is a librarian or not. He adds those to the require-\nments and then lists the functionality of the system.\nThe functionality of the library system\n Search for a book.\n Add a book item.\n Block a member.\n--- Page 60 ---\n32 CHAPTER 2 Separation between code and data\n(continued)\n Unblock a member.\n Log a user into the system.\n List the books currently lent to a member.\n Borrow a book.\n Return a book.\n Check whether a user is a librarian.\nJoe Excellent! Now, tell me what functionality needs to be exposed to the outside\nworld?\nTheo What do you mean by exposed to the outside world?\nJoe Imagine that the Library Management System exposes an API over HTTP.\nWhat functionality would be exposed by the HTTP endpoints?\nTheo Well, all system functionality would be exposed except checking to see if a user\nis a librarian.\nJoe OK. Now give each exposed function a short name and gather them together\nin a module box called Library.\nThat takes Theo less than a minute. Figure 2.4 shows the module that contains the\nexposed functions of the library devised by Theo.\nC Library\nsearchBook()\naddBookItem()\nblockMember()\nunblockMember()\ngetBookLendings() Figure 2.4 The Library module\ncheckoutBook() contains the exposed functions of the\nreturnBook() Library Management System.\nTIP The first step in designing the code part of a DOP system is to aggregate the\nexposed functions into a single module.\nJoe Beautiful! You just created your first code module.\nTheo To me it looks like a class. What’s the difference between a module and a class?\nJoe A module is an aggregation of functions. In OOP, a module is represented\nbya class, but in other programming languages, it might be a package or a\nnamespace.\nTheo I see.\nJoe The important thing about DOP code modules is that they contain only state-\nless functions.\nTheo You mean like static methods in Java?\nJoe Yes, and the classes of these static methods should not have any data members.\n--- Page 61 ---\n2.3 Code modules 33\nTheo So, how do the functions know what piece of information they operate on?\nJoe Easy. We pass that as the first argument to the function.\nTheo OK. Can you give me an example?\nJoe, biting his nails, takes a look at the list of functions of the Library module in figure 2.4.\nHe spots a likely candidate.\nJoe Let’s take, for example, getBookLendings. In classic OOP, what would its\narguments be?\nTheo A librarian ID and a member ID.\nJoe So, in traditional OOP, getBookLendings would be a method of a Library\nclass that receives two arguments: librarianId and memberId.\nTheo Yep.\nJoe Now comes the subtle part. In DOP, getBookLendings is part of the Library\nmodule, and it receives the LibraryData as an argument.\nTheo Could you show me what you mean?\nJoe Sure.\nJoe goes over to Theo’s keyboard and starts typing. He enters an example of what a class\nmethod looks like in OOP:\nclass Library {\ncatalog\nuserManagement\ngetBookLendings(userId, memberId) {\n// accesses library state via this.catalog and this.userManagement\n}\n}\nTheo Right! The method accesses the state of the object (in our case, the library\ndata) via this.\nJoe Would you say that the object’s state is an argument of the object’s methods?\nTheo I’d say that the object’s state is an implicit argument to the object’s methods.\nTIP In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\nJoe Well, in DOP, we pass data as an explicit argument. The signature of getBook-\nLendings would look like this.\nListing2.1 The signature of getBookLendings\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\n}\n}\n--- Page 62 ---\n34 CHAPTER 2 Separation between code and data\nJoe The state of the library is stored in libraryData, and libraryData is passed\nto the getBookLendings static method as an explicit argument.\nTheo Is that a general rule?\nJoe Absolutely! The same rule applies to the other functions of the Library mod-\nule and to other modules as well. All of the modules are stateless—they receive\nthe library data that they manipulate as an argument.\nTIP In DOP, functions of a code module are stateless. They receive the data that they\nmanipulate as an explicit argument, which is usually the first argument.\n NOTE A module is an aggregation of functions. In DOP, the module functions are\nstateless.\nTheo It reminds me of Python and the way the self argument appears in method\nsignatures. Here, let me show you an example.\nListing2.2 A Python object as an explicit argument in method signatures\nclass Library:\ncatalog = {}\nuserManagement = {}\ndef getBookLendings(self, userId, memberId):\n# accesses library state via self.catalog and self.userManagement\nJoe Indeed, but the difference I’m talking about is much deeper than a syntax\nchange. It’s about the fact that data lives outside the modules.\nTheo I got that. As you said, module functions are stateless.\nJoe Exactly! Would you like to try and apply this principle across the whole\nLibrary module?\nTheo Sure.\nTheo refines the design of the Library module by including the details about the func-\ntions’ arguments. He presents the diagram in figure 2.5 to Joe.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId) Figure 2.5 The Library module\nreturnBook(libraryData, userId, bookItemId)\nwith the functions’ arguments\nJoe Perfect. Now, we’re ready to tackle the high-level design of our system.\nTheo What’s a high-level design in DOP?\n--- Page 63 ---\n2.3 Code modules 35\nJoe A high-level design in DOP is the definition of modules and the interaction\nbetween them.\nTheo I see. Are there any guidelines to help me define the modules?\nJoe Definitely. The high-level modules of the system correspond to the high-level\ndata entities.\nTheo You mean the data entities that appear in the data mind map?\nJoe Exactly!\nTheo looks again at the data mind map (figure 2.6). He focuses on the high-level data enti-\nties library, catalog, and user management. This means that in the system, besides the\nLibrary module, we have two high-level modules:\n The Catalog module deals with catalog data.\n The UserManagement module deals with user management data.\nCatalog\nLibrary data Figure 2.6 A mind map of the high-\nlevel data entities of the Library\nUser management\nManagement System\nTheo then draws the high-level design of the Library Management System with the Catalog\nand UserManagement modules. Figure 2.7 shows the addition of these modules, where:\n Functions of Catalog receive catalogData as their first argument.\n Functions of UserManagement receive userManagementData as their first argument.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.7 The modules of the Library Management System with their functions’ arguments\n--- Page 64 ---\n36 CHAPTER 2 Separation between code and data\nIt’s not 100% clear for Theo at this point how the data entities get passed between mod-\nules. For the moment, he thinks of libraryData as a class with two members:\n catalog holds the catalog data.\n userManagement holds the user management data.\nTheo also sees that the functions of Library share a common pattern. (Later on in this\nchapter, we’ll see the code for some functions of the Library module.)\n They receive libraryData as an argument.\n They pass libraryData.catalog to the functions of Catalog.\n They pass libraryData.userManagement to the functions of UserManagement.\nTIP The high-level modules of a DOP system correspond to the high-level data enti-\nties.\n2.4 DOP systems are easy to understand\nTheo takes a look at the two diagrams that represent the high-level design of his system:\n The data entities in the data mind map in figure 2.8\n The code modules in the module diagram in figure 2.9\nA bit perplexed, Theo asks Joe:\nTheo I’m not sure that this system is better than a traditional OOP system where\nobjects encapsulate data.\nJoe The main benefit of a DOP system over a traditional OOP system is that it’s eas-\nier to understand.\nTheo What makes it easier to understand?\nJoe The fact that the system is split cleanly into code modules and data entities.\nTheo How does that help?\nJoe When you try to understand the data entities of the system, you don’t have to\nthink about the details of the code that manipulates the data entities.\nTheo So, when I look at the data mind map of my Library Management System, I can\nunderstand it on its own?\nJoe Exactly, and similarly, when you try to understand the code modules of the sys-\ntem, you don’t have to think about the details of the data entities manipulated\nby the code. There is a clear separation of concerns between the code and the\ndata.\nTheo looks again at the data mind map in figure 2.8. He has kind of an Aha! moment:\nData lives on its own!\n NOTE A DOP system is easier to understand because the system is split into two\nparts: data entities and code modules.\n--- Page 65 ---\n2.4 DOP systems are easy to understand 37\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nFigure 2.8 A data mind map of the\nLibrarians\nLibrary Management System\nNow, Theo looks at the module diagram in figure 2.9. He feels a bit confused and asks Joe\nfor clarification:\n On one hand, the module diagram looks similar to the class diagrams from classic\nOOP, boxes for classes and arrows for relations between classes.\n On the other hand, the code module diagram looks much simpler than the class\ndiagrams from classic OOP, but he cannot explain why.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.9 The modules of the Library Management System with the function arguments\nTheo The module diagram seems much simpler than the class diagrams I am used to\nin OOP. I feel it, but I can’t put it into words.\nJoe The reason is that module diagrams have constraints.\n--- Page 66 ---\n38 CHAPTER 2 Separation between code and data\nTheo What kind of constraints?\nJoe Constraints on the functions we saw before. All the functions are static (or\nstateless), but there’s also constraints on the relations between the modules.\nTIP All the functions in a DOP module are stateless.\nTheo In what way are the relations between modules constrained?\nJoe There is a single kind of relation between DOP modules—the usage relation. A\nmodule uses code from another module. There’s no association, no composi-\ntion, and no inheritance between modules. That’s what makes a DOP module\ndiagram easy to understand.\nTheo I understand why there is no association and no composition between DOP\nmodules. After all, association and composition are data relations. But why no\ninheritance relation? Does that mean that DOP is against polymorphism?\nJoe That’s a great question! The quick answer is that in DOP, we achieve polymor-\nphism with a different mechanism than class inheritance. We will talk about it\nsome day.\n NOTE For a discussion of polymorphism in DOP, see chapter 13.\nTheo Now, you’ve piqued my curiosity. I thought inheritance was the only way to\nachieve polymorphism.\nTheo looks again at the module diagram in figure 2.9. Now he not only feels that this dia-\ngram is simpler than traditional OOP class diagrams, he understands why it’s simpler: all\nthe functions are static, and all the relations between modules are of type usage. Table 2.1\nsummarizes Theo’s perception.\nTIP The only kind of relation between DOP modules is the usage relation.\nTable 2.1 What makes each part of a DOP system easy to understand\nSystem part Constraint on entities Constraints on relations\nData entities Members only (no code) Association and composition\nCode modules Stateless functions (no members) Usage (no inheritance)\nTIP Each part of a DOP system is easy to understand because it provides constraints.\n2.5 DOP systems are flexible\nTheo I see how a sharp separation between code and data makes DOP systems easier\nto understand than classic OOP systems. But what about adapting to changes\nin requirements?\nJoe Another benefit of DOP systems is that it is easy to extend them and to adapt to\nchanging requirements.\n--- Page 67 ---\n2.5 DOP systems are flexible 39\nTheo I remember that, when Nancy asked me to add Super members and VIP mem-\nbers to the system, it was hard to adapt my OOP system. I had to introduce a\nfew base classes, and the class hierarchy became really complex.\nJoe I know exactly what you mean. I’ve experienced the same kind of struggle so\nmany times. Describe the changes in the requirements for Super members and\nVIP members, and I’m quite sure that you’ll see how easy it would be to extend\nyour DOP system.\nThe requirements for Super members and VIP members\n Super members are members that are allowed to list the book lendings to\nother members.\n VIP members are members that are allowed to add book items to the library.\nTheo opens his IDE and starts to code the getBookLendings function of the Library\nmodule (see listing 2.3), first without addressing the requirements for Super members.\nTheo remembers what Joe told him about module functions in DOP:\n Functions are stateless.\n Functions receive the data they manipulate as their first argument.\nIn terms of functionality, getBookLendings has two parts:\n Checks that the user is a librarian.\n Retrieves the book lendings from the catalog.\nBasically, the code of getBookLendings has two parts as well:\n Calls the isLibrarian function from the UserManagement module and passes it\nthe UserManagementData.\n Calls the getBookLendings function from the Catalog module and passes it the\nCatalogData.\nListing2.3 Getting the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\n}\ngeneric data collections.\n--- Page 68 ---\n40 CHAPTER 2 Separation between code and data\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nIt’s Theo’s first piece of DOP code and passing around all those data objects—library-\nData, libraryData.userManagement, and libraryData.catalog—feels a bit awkward.\nBut he did it! Joe looks at Theo’s code and seems satisfied.\nJoe Now, how would you adapt your code to Super members?\nTheo I would add a function isSuperMember to the UserManagement module and\ncall it from Library.getBookLendings.\nJoe Exactly! It’s as simple as that.\nTheo types the code on his laptop so that he can show it to Joe. Here’s how Theo adapts\nhis code for Super members.\nListing2.4 Allowing Super members to get the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(Usermanagement.isLibrarian(libraryData.userManagement, userId) ||\nUsermanagement.isSuperMember(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isSuperMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nNow, the awkward feeling caused by passing around all those data objects is dominated by\na feeling of relief. Adapting to this change in requirements takes only a few lines of code\nand requires no changes in the system design. Once again, Joe seems satisfied.\nTIP DOP systems are flexible. Quite often they adapt to changing requirements with-\nout changing the system design.\n--- Page 69 ---\n2.5 DOP systems are flexible 41\nTheo starts coding addBookItem. He looks at the signature of Library.addBookItem,\nand the meaning of the third argument bookItemInfo isn’t clear to him. He asks Joe for\nclarification.\nListing2.5 The signature of Library.addBookItem\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\n}\n}\nTheo What is bookItemInfo?\nJoe Let’s call it the book item information. Imagine we have a way to represent this\ninformation in a data entity named bookItemInfo.\nTheo You mean an object?\nJoe For now, it’s OK to think about bookItemInfo as an object. Later on, I will\nshow you how to we represent data in DOP.\nBesides this subtlety about how the book item information is represented by book-\nItemInfo, the code for Library.addBookItem in listing 2.6 is quite similar to the code\nTheo wrote for Library.getBookLendings in listing 2.4. Once again, Theo is amazed by\nthe fact that adding support for VIP members requires no design change.\nListing2.6 Allowing VIP members to add a book item to the library\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId) ||\nUserManagement.isVIPMember(libraryData.userManagement, userId)) {\nreturn Catalog.addBookItem(libraryData.catalog, bookItemInfo);\n} else {\nthrow \"Not allowed to add a book item\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isVIPMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic addBookItem(catalogData, memberId) {\n// will be implemented later\nIn chapter 4, we will see how\n}\nto manage state of the system\n}\nwith immutable data.\n--- Page 70 ---\n42 CHAPTER 2 Separation between code and data\nTheo It takes a big mindset shift to learn how to separate code from data!\nJoe What was the most challenging thing to accept?\nTheo The fact that data is not encapsulated in objects.\nJoe It was the same for me when I switched from OOP to DOP.\nNow it’s time to eat! Theo takes Joe for lunch at Simple, a nice, small restaurant near the\noffice.\nSummary\n DOP principles are language-agnostic.\n DOP principle #1 is to separate code from data.\n The separation between code and data in DOP systems makes them simpler\n(easier to understand) than traditional OOP systems.\n Data entities are the parts of your system that hold information.\n DOP is against data encapsulation.\n The more flexible a system is, the easier it is to adapt to changing requirements.\n The separation between code and data in DOP systems makes them more flexi-\nble than traditional OOP systems.\n When code is separated from data, we have the freedom to design code and\ndata in isolation.\n We represent data as data entities.\n We discover the data entities of our system and sort them into high-level groups,\neither as a nested list or as a mind map.\n A DOP system is easier to understand than a traditional OOP system because\nthe system is split into two parts: data entities and code modules.\n In DOP, a code module is an aggregation of stateless functions.\n DOP systems are flexible. Quite often they adapt to changing requirements\nwithout changing the system design.\n In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\n Stateless functions receive data they manipulate as an explicit argument.\n The high-level modules of a DOP system correspond to high-level data entities.\n The only kind of relation between code modules is the usage relation.\n The only kinds of relation between data entities are the association and the compo-\nsition relation.\n For a discussion of polymorphism in DOP, see chapter 13.\n--- Page 71 ---\nBasic data manipulation\nMeditation and programming\nThis chapter covers\n Representing records with string maps to improve\nflexibility\n Manipulating data with generic functions\n Accessing each piece of information via its\ninformation path\n Gaining JSON serialization for free\nAfter learning why and how to separate code from data in the previous chapter,\nlet’s talk about data on its own. In contrast to traditional OOP, where system design\ntends to involve a rigid class hierarchy, DOP prescribes that we represent our data\nmodel as a flexible combination of maps and arrays (or lists), where we can access\neach piece of information via an information path. This chapter is a deep dive into\nthe second principle of DOP.\nPRINCIPLE #2 Represent data entities with generic data structures.\n43\n--- Page 72 ---\n44 CHAPTER 3 Basic data manipulation\nWe increase system flexibility when we represent records as string maps and not as\nobjects instantiated from classes. This liberates data from the rigidity of a class-based sys-\ntem. Data becomes a first-class citizen powered by generic functions to add, remove, or\nrename fields.\n NOTE We refer to maps that have strings as keys as string maps.\nThe dependency between the code that manipulates data and the data is a weak\ndependency. The code only needs to know the keys of specific fields in the record it\nwants to manipulate. The code doesn’t even need to know about all the keys in the\nrecord, only the ones relevant to it. In this chapter, we’ll deal only with data query.\nWe’ll discuss managing changes in system state in the next chapter.\n3.1 Designing a data model\nDuring lunch at Simple, Theo and Joe don’t talk about programming. Instead, they start\ngetting to know each other on a personal level. Theo discovers that Joe is married to Kay,\nwho has just opened her creative therapy practice after many years of studying various\nfields related to well-being. Neriah, their 14-year-old son, is passionate about drones, whereas\nAurelia, their 12-year-old daughter, plays the transverse flute.\nJoe tells Theo that he’s been practicing meditation for 10 years. Meditation, he says, has\ntaught him how to break away from being continually lost in a “storm thought” (especially\nnegative thoughts, which can be the source of great suffering) to achieve a more direct\nrelationship with reality. The more he learns to experience reality as it is, the calmer his\nmind. When he first started to practice meditation, it was sometimes difficult and even\nweird, but by persevering, he has increased his feeling of well-being with each passing year.\nWhen they’re back at the office, Joe tells Theo that his next step in their DOP journey\nwill be about data models. This includes data representation.\nJoe When we design the data part of our system, we’re free to do it in isolation.\nTheo What do you mean by isolation?\nJoe I mean that you don’t have to bother with code, only data.\nTheo Oh, right. I remember you telling me how that makes a DOP system simpler\nthan OOP. Separation of concerns is a design principle I’m used to in OOP.\nJoe Indeed.\nTheo And, when we think about data, the only relations we have to think about are\nassociation and composition.\nJoe Correct.\nTheo Will the data model design be significantly different than the data model I’m\nused to designing as an OOP developer?\nJoe Not so much.\nTheo OK. Let me see if I can draw a DOP-style data entity diagram.\nTheo takes a look at the data mind map that he drew earlier in the morning. He then\ndraws the diagram in figure 3.1.\nHe refines the details of the fields of each data entity and the kind of relations between\nentities. Figure 3.2 shows the result of this redefined data entity diagram.\n--- Page 73 ---\n3.1 Designing a data model 45\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 3.1 A data mind map of\nthe Library Management System\nCC Library\nname: String\naddress: String\nCC Catalog CC UserManagement\n* * *\nCC Book CC Librarian CC Member\nemail: String email: String\ntitle : String\npassword: String password: String\npublicationYear: Number\n*\nISBN: String\npublisher: String\n* *\nCC Author CC BookLending\nname: String lendingDate: String\nCC BookItem\n* libld: String\npurchaseDate: String\nFigure 3.2 A data model of the Library Management System\n--- Page 74 ---\n46 CHAPTER 3 Basic data manipulation\nJoe The next step is to be more explicit about the relations between entities.\nTheo What do you mean?\nJoe For example, in your entity diagram, Book and Author are connected by a\nmany-to-many association relation. How is this relation going to be repre-\nsented in your program?\nTheo In the Book entity, there will be a collection of author IDs, and in the Author\nentity, there will be a collection of book IDs.\nJoe Sounds good. And what will the book ID be?\nTheo The book ISBN.\n NOTE The International Standard Book Number (ISBN) is a numeric commercial\nbook identifier that is intended to be unique.\nJoe And where will you hold the index that enables you to retrieve a Book from its\nISBN?\nTheo In the Catalog because the catalog holds a bookByISBN index.\nJoe What about author ID?\nTheo Author ID is the author name in lowercase and with dashes instead of white\nspaces (assuming that we don’t have two authors with the same name).\nJoe And I guess that you also hold the author index in the Catalog?\nTheo Exactly!\nJoe Excellent. You’ve been 100% explicit about the relation between Book and\nAuthor. I’ll ask you to do the same with the other relations of the system.\nIt’s quite easy for Theo to do, as he has done that so many times as an OOP developer. Fig-\nure 3.3 provides the detailed entity diagram of Theo’s system.\n NOTE By positional collection, we mean a collection where the elements are in order\n(like a list or an array). By index, we mean a collection where the elements are accessi-\nble via a key (like a hash map or a dictionary).\nThe Catalog entity contains two indexes:\n booksByIsbn—The keys are book ISBNs, and the values are Book entities. Its type is\nnoted as {Book}.\n authorsById—The keys are author IDs, and the values are Author entities. Its type\nis noted as {Author}.\nInside a Book entity, we have authors, which is a positional collection of author IDs of type\n[String]. Inside an Author entity, we have books, which is a collection of book IDs of\ntype [String].\n NOTE For the notation for collections and index types, a positional collection of\nStrings is noted as [String]. An index of Books is noted as {Book}. In the context of\na data model, the index keys are always strings.\n--- Page 75 ---\n3.1 Designing a data model 47\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: UserManagement\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian\nCC Book i n d a : m S e tr : i n S g tring email: String CC Me * mber\ntitle : String encryptedPassword: String\nbookIsbns: [String] email: String\npublicationYear: Number\nencryptedPassword: String\nisbn: String *\nisBlocked: Boolean\nauthorIds: [String]\nbookLendings: [BookLending]\nbookItems: [BookItem] *\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.3 Library management relation model. Dashed lines (e.g., between Book and Author) denote\nindirect relations, [String] denotes a positional collection of strings, and {Book} denotes an index of\nBooks.\nThere is a dashed line between Book and Author, which means that the relation between\nBook and Author is indirect. To access the collection of Author entities from a Book entity,\nwe’ll use the authorById index defined in the Catalog entity.\nJoe I like your data entity diagram.\nTheo Thank you.\nJoe Can you tell me what the three kinds of data aggregations are in your diagram\n(and, in fact, in any data entity diagram)?\nTheo Let’s see...we have positional collections like authors in Book. We have\nindexes like booksByIsbn in Catalog. I can’t find the third one.\nJoe The third kind of data aggregation is what we’ve called, until now, an “entity”\n(like Library, Catalog, Book, etc.), and the common term for entity in com-\nputer science is record.",
        "sections_found": []
      },
      "accurate_page_range": "56-75"
    },
    {
      "text": "- 2.1 The two parts of a DOP system",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "raw_line": "- 2.1 The two parts of a DOP system (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 15,
      "chapter_info": {
        "page": 56,
        "title": "Separation between code and data",
        "pattern_matched": "Chapter 2",
        "text_preview": "28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his te"
      },
      "chapter_sections": {
        "start_page": 56,
        "end_page": 75,
        "content": "\n--- Page 56 ---\n28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his team have built in Clojure over the last 7\nyears are less complex and more flexible than the systems he used to build in Java. Accord-\ning to Joe, the systems they build now tend to be much simpler because they follow the\nprinciples of DOP.\nTheo I’ve never heard of data-oriented programming. Is it a new concept?\nJoe Yes and no. Most of the foundational ideas of data-oriented programming, or\nDOP as we like to call it, are well known to programmers as best practices. The\nnovelty of DOP, however, is that it combines best practices into a cohesive\nwhole.\nTheo That’s a bit abstract for me. Can you give me an example?\nJoe Sure! Take, for instance, the first insight of DOP. It’s about the relations between\ncode and data.\nTheo You mean the encapsulation of data in objects?\nJoe Actually, DOP is against data encapsulation.\nTheo Why is that? I thought data encapsulation was a positive programming paradigm.\nJoe Data encapsulation has both merits and drawbacks. Think about the way you\ndesigned the Library Management System. According to DOP, the main cause\nof complexity and inflexibility in systems is that code and data are mixed\ntogether in objects.\nTIP DOP is against data encapsulation.\nTheo It sounds similar to what I’ve heard about functional programming. So, if I\nwant to adopt DOP, do I need to get rid of object-oriented programming and\nlearn functional programming?\nJoe No, DOP principles are language-agnostic. They can be applied in both object-\noriented and functional programming languages.\nTheo That’s a relief! I was afraid that you were going to teach me about monads,\nalgebraic data types, and higher order functions.\nJoe No, none of that is required in DOP.\nTIP DOP principles are language-agnostic.\nTheo What does the separation between code and data look like in DOP then?\nJoe Data is represented by data entities that only hold members. Code is aggre-\ngated into modules where all functions are stateless.\nTheo What do you mean by stateless functions?\nJoe Instead of having the state encapsulated in the object, the data entity is passed\nas an argument.\nTheo I don’t get that.\nJoe Here, let’s make it visual.\n--- Page 57 ---\n2.2 Data entities 29\nJoe steps up to a whiteboard and quickly draws a diagram to illustrate his comment. Fig-\nure 2.2 shows Joe’s drawing.\nCode modules Stateless functions\nSeparate code from data\nData entities Only members\nFigure 2.2 The separation between code and data\nTheo It’s still not clear.\nJoe It will become clearer when I show you how it looks in the context of your\nLibrary Management System.\nTheo OK. Shall we start with code or with data?\nJoe Well, it’s data-oriented programming, so let’s start with data.\n2.2 Data entities\nIn DOP, we start the design process by discovering the data entities of our system.\nHere’s what Joe and Theo have to say about data entities.\nJoe What are the data entities of your system?\nTheo What do you mean by data entities?\nJoe I mean the parts of your system that hold information.\n NOTE Data entities are the parts of your system that hold information.\nTheo Well, it’s a Library Management System, so we have books and members.\nJoe Of course, but there are more. One way to discover the data entities of a system\nis to look for nouns and noun phrases in the requirements of the system.\nTheo looks at Nancy’s requirement napkin. He highlights the nouns and noun phrases\nthat seem to represent data entities.\nHighlighting terms in the requirements that correspond to data entities\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n--- Page 58 ---\n30 CHAPTER 2 Separation between code and data\nJoe Excellent. Can you see a natural way to group these entities?\nTheo Not sure, but it seems to me that users, members, and librarians form one\ngroup, whereas books, authors, and book copies form another group.\nJoe Sounds good to me. What would you call each group?\nTheo Probably user management for the first group and catalog for the second\ngroup.\nThe data entities of the system organized in a nested list\n The catalog data\n– Data about books\n– Data about authors\n– Data about book items\n– Data about book lendings\n The user management data\n– Data about users\n– Data about members\n– Data about librarians\nTheo I’m not sure about the relations between books and authors. Should it be asso-\nciation or composition?\nJoe Don’t worry too much about the details for the moment. We’ll refine our data\nentity design later. For now, let’s visualize the two groups in a mind map.\nTheo and Joe confer for a bit. Figure 2.3 shows the mind map they come up with.\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 2.3 The data entities of the\nsystem organized in a mind map\n--- Page 59 ---\n2.3 Code modules 31\nThe most precise way to visualize the data entities of a DOP system is to draw a data\nentity diagram with different arrows for association and composition. We will come\nback to data entity diagrams later.\nTIP Discover the data entities of your system and then sort them into high-level\ngroups, either as a nested list or as a mind map.\nWe will dive deeper into the design and representation of data entities in the next\nchapter. For now, let’s simplify things and say that the data of our library system is\nmade of two high-level groups: user management and catalog.\n2.3 Code modules\nThe second step of the design process in DOP is to define the code modules. Let’s lis-\nten in on Joe and Theo again.\nJoe Now that you have identified the data entities of your system and have\narranged them into high-level groups, it’s time to think about the code part of\nyour system.\nTheo What do you mean by the code part?\nJoe One way to think about that is to identity the functionality of your system.\nTheo looks again at Nancy’s requirements. This time he highlights the verb phrases that\nrepresent functionality.\nHighlighting terms in the requirements that correspond to functionality\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\nIn addition, it’s obvious to Theo that members can also return a book. Moreover, there\nshould be a way to detect whether a user is a librarian or not. He adds those to the require-\nments and then lists the functionality of the system.\nThe functionality of the library system\n Search for a book.\n Add a book item.\n Block a member.\n--- Page 60 ---\n32 CHAPTER 2 Separation between code and data\n(continued)\n Unblock a member.\n Log a user into the system.\n List the books currently lent to a member.\n Borrow a book.\n Return a book.\n Check whether a user is a librarian.\nJoe Excellent! Now, tell me what functionality needs to be exposed to the outside\nworld?\nTheo What do you mean by exposed to the outside world?\nJoe Imagine that the Library Management System exposes an API over HTTP.\nWhat functionality would be exposed by the HTTP endpoints?\nTheo Well, all system functionality would be exposed except checking to see if a user\nis a librarian.\nJoe OK. Now give each exposed function a short name and gather them together\nin a module box called Library.\nThat takes Theo less than a minute. Figure 2.4 shows the module that contains the\nexposed functions of the library devised by Theo.\nC Library\nsearchBook()\naddBookItem()\nblockMember()\nunblockMember()\ngetBookLendings() Figure 2.4 The Library module\ncheckoutBook() contains the exposed functions of the\nreturnBook() Library Management System.\nTIP The first step in designing the code part of a DOP system is to aggregate the\nexposed functions into a single module.\nJoe Beautiful! You just created your first code module.\nTheo To me it looks like a class. What’s the difference between a module and a class?\nJoe A module is an aggregation of functions. In OOP, a module is represented\nbya class, but in other programming languages, it might be a package or a\nnamespace.\nTheo I see.\nJoe The important thing about DOP code modules is that they contain only state-\nless functions.\nTheo You mean like static methods in Java?\nJoe Yes, and the classes of these static methods should not have any data members.\n--- Page 61 ---\n2.3 Code modules 33\nTheo So, how do the functions know what piece of information they operate on?\nJoe Easy. We pass that as the first argument to the function.\nTheo OK. Can you give me an example?\nJoe, biting his nails, takes a look at the list of functions of the Library module in figure 2.4.\nHe spots a likely candidate.\nJoe Let’s take, for example, getBookLendings. In classic OOP, what would its\narguments be?\nTheo A librarian ID and a member ID.\nJoe So, in traditional OOP, getBookLendings would be a method of a Library\nclass that receives two arguments: librarianId and memberId.\nTheo Yep.\nJoe Now comes the subtle part. In DOP, getBookLendings is part of the Library\nmodule, and it receives the LibraryData as an argument.\nTheo Could you show me what you mean?\nJoe Sure.\nJoe goes over to Theo’s keyboard and starts typing. He enters an example of what a class\nmethod looks like in OOP:\nclass Library {\ncatalog\nuserManagement\ngetBookLendings(userId, memberId) {\n// accesses library state via this.catalog and this.userManagement\n}\n}\nTheo Right! The method accesses the state of the object (in our case, the library\ndata) via this.\nJoe Would you say that the object’s state is an argument of the object’s methods?\nTheo I’d say that the object’s state is an implicit argument to the object’s methods.\nTIP In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\nJoe Well, in DOP, we pass data as an explicit argument. The signature of getBook-\nLendings would look like this.\nListing2.1 The signature of getBookLendings\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\n}\n}\n--- Page 62 ---\n34 CHAPTER 2 Separation between code and data\nJoe The state of the library is stored in libraryData, and libraryData is passed\nto the getBookLendings static method as an explicit argument.\nTheo Is that a general rule?\nJoe Absolutely! The same rule applies to the other functions of the Library mod-\nule and to other modules as well. All of the modules are stateless—they receive\nthe library data that they manipulate as an argument.\nTIP In DOP, functions of a code module are stateless. They receive the data that they\nmanipulate as an explicit argument, which is usually the first argument.\n NOTE A module is an aggregation of functions. In DOP, the module functions are\nstateless.\nTheo It reminds me of Python and the way the self argument appears in method\nsignatures. Here, let me show you an example.\nListing2.2 A Python object as an explicit argument in method signatures\nclass Library:\ncatalog = {}\nuserManagement = {}\ndef getBookLendings(self, userId, memberId):\n# accesses library state via self.catalog and self.userManagement\nJoe Indeed, but the difference I’m talking about is much deeper than a syntax\nchange. It’s about the fact that data lives outside the modules.\nTheo I got that. As you said, module functions are stateless.\nJoe Exactly! Would you like to try and apply this principle across the whole\nLibrary module?\nTheo Sure.\nTheo refines the design of the Library module by including the details about the func-\ntions’ arguments. He presents the diagram in figure 2.5 to Joe.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId) Figure 2.5 The Library module\nreturnBook(libraryData, userId, bookItemId)\nwith the functions’ arguments\nJoe Perfect. Now, we’re ready to tackle the high-level design of our system.\nTheo What’s a high-level design in DOP?\n--- Page 63 ---\n2.3 Code modules 35\nJoe A high-level design in DOP is the definition of modules and the interaction\nbetween them.\nTheo I see. Are there any guidelines to help me define the modules?\nJoe Definitely. The high-level modules of the system correspond to the high-level\ndata entities.\nTheo You mean the data entities that appear in the data mind map?\nJoe Exactly!\nTheo looks again at the data mind map (figure 2.6). He focuses on the high-level data enti-\nties library, catalog, and user management. This means that in the system, besides the\nLibrary module, we have two high-level modules:\n The Catalog module deals with catalog data.\n The UserManagement module deals with user management data.\nCatalog\nLibrary data Figure 2.6 A mind map of the high-\nlevel data entities of the Library\nUser management\nManagement System\nTheo then draws the high-level design of the Library Management System with the Catalog\nand UserManagement modules. Figure 2.7 shows the addition of these modules, where:\n Functions of Catalog receive catalogData as their first argument.\n Functions of UserManagement receive userManagementData as their first argument.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.7 The modules of the Library Management System with their functions’ arguments\n--- Page 64 ---\n36 CHAPTER 2 Separation between code and data\nIt’s not 100% clear for Theo at this point how the data entities get passed between mod-\nules. For the moment, he thinks of libraryData as a class with two members:\n catalog holds the catalog data.\n userManagement holds the user management data.\nTheo also sees that the functions of Library share a common pattern. (Later on in this\nchapter, we’ll see the code for some functions of the Library module.)\n They receive libraryData as an argument.\n They pass libraryData.catalog to the functions of Catalog.\n They pass libraryData.userManagement to the functions of UserManagement.\nTIP The high-level modules of a DOP system correspond to the high-level data enti-\nties.\n2.4 DOP systems are easy to understand\nTheo takes a look at the two diagrams that represent the high-level design of his system:\n The data entities in the data mind map in figure 2.8\n The code modules in the module diagram in figure 2.9\nA bit perplexed, Theo asks Joe:\nTheo I’m not sure that this system is better than a traditional OOP system where\nobjects encapsulate data.\nJoe The main benefit of a DOP system over a traditional OOP system is that it’s eas-\nier to understand.\nTheo What makes it easier to understand?\nJoe The fact that the system is split cleanly into code modules and data entities.\nTheo How does that help?\nJoe When you try to understand the data entities of the system, you don’t have to\nthink about the details of the code that manipulates the data entities.\nTheo So, when I look at the data mind map of my Library Management System, I can\nunderstand it on its own?\nJoe Exactly, and similarly, when you try to understand the code modules of the sys-\ntem, you don’t have to think about the details of the data entities manipulated\nby the code. There is a clear separation of concerns between the code and the\ndata.\nTheo looks again at the data mind map in figure 2.8. He has kind of an Aha! moment:\nData lives on its own!\n NOTE A DOP system is easier to understand because the system is split into two\nparts: data entities and code modules.\n--- Page 65 ---\n2.4 DOP systems are easy to understand 37\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nFigure 2.8 A data mind map of the\nLibrarians\nLibrary Management System\nNow, Theo looks at the module diagram in figure 2.9. He feels a bit confused and asks Joe\nfor clarification:\n On one hand, the module diagram looks similar to the class diagrams from classic\nOOP, boxes for classes and arrows for relations between classes.\n On the other hand, the code module diagram looks much simpler than the class\ndiagrams from classic OOP, but he cannot explain why.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.9 The modules of the Library Management System with the function arguments\nTheo The module diagram seems much simpler than the class diagrams I am used to\nin OOP. I feel it, but I can’t put it into words.\nJoe The reason is that module diagrams have constraints.\n--- Page 66 ---\n38 CHAPTER 2 Separation between code and data\nTheo What kind of constraints?\nJoe Constraints on the functions we saw before. All the functions are static (or\nstateless), but there’s also constraints on the relations between the modules.\nTIP All the functions in a DOP module are stateless.\nTheo In what way are the relations between modules constrained?\nJoe There is a single kind of relation between DOP modules—the usage relation. A\nmodule uses code from another module. There’s no association, no composi-\ntion, and no inheritance between modules. That’s what makes a DOP module\ndiagram easy to understand.\nTheo I understand why there is no association and no composition between DOP\nmodules. After all, association and composition are data relations. But why no\ninheritance relation? Does that mean that DOP is against polymorphism?\nJoe That’s a great question! The quick answer is that in DOP, we achieve polymor-\nphism with a different mechanism than class inheritance. We will talk about it\nsome day.\n NOTE For a discussion of polymorphism in DOP, see chapter 13.\nTheo Now, you’ve piqued my curiosity. I thought inheritance was the only way to\nachieve polymorphism.\nTheo looks again at the module diagram in figure 2.9. Now he not only feels that this dia-\ngram is simpler than traditional OOP class diagrams, he understands why it’s simpler: all\nthe functions are static, and all the relations between modules are of type usage. Table 2.1\nsummarizes Theo’s perception.\nTIP The only kind of relation between DOP modules is the usage relation.\nTable 2.1 What makes each part of a DOP system easy to understand\nSystem part Constraint on entities Constraints on relations\nData entities Members only (no code) Association and composition\nCode modules Stateless functions (no members) Usage (no inheritance)\nTIP Each part of a DOP system is easy to understand because it provides constraints.\n2.5 DOP systems are flexible\nTheo I see how a sharp separation between code and data makes DOP systems easier\nto understand than classic OOP systems. But what about adapting to changes\nin requirements?\nJoe Another benefit of DOP systems is that it is easy to extend them and to adapt to\nchanging requirements.\n--- Page 67 ---\n2.5 DOP systems are flexible 39\nTheo I remember that, when Nancy asked me to add Super members and VIP mem-\nbers to the system, it was hard to adapt my OOP system. I had to introduce a\nfew base classes, and the class hierarchy became really complex.\nJoe I know exactly what you mean. I’ve experienced the same kind of struggle so\nmany times. Describe the changes in the requirements for Super members and\nVIP members, and I’m quite sure that you’ll see how easy it would be to extend\nyour DOP system.\nThe requirements for Super members and VIP members\n Super members are members that are allowed to list the book lendings to\nother members.\n VIP members are members that are allowed to add book items to the library.\nTheo opens his IDE and starts to code the getBookLendings function of the Library\nmodule (see listing 2.3), first without addressing the requirements for Super members.\nTheo remembers what Joe told him about module functions in DOP:\n Functions are stateless.\n Functions receive the data they manipulate as their first argument.\nIn terms of functionality, getBookLendings has two parts:\n Checks that the user is a librarian.\n Retrieves the book lendings from the catalog.\nBasically, the code of getBookLendings has two parts as well:\n Calls the isLibrarian function from the UserManagement module and passes it\nthe UserManagementData.\n Calls the getBookLendings function from the Catalog module and passes it the\nCatalogData.\nListing2.3 Getting the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\n}\ngeneric data collections.\n--- Page 68 ---\n40 CHAPTER 2 Separation between code and data\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nIt’s Theo’s first piece of DOP code and passing around all those data objects—library-\nData, libraryData.userManagement, and libraryData.catalog—feels a bit awkward.\nBut he did it! Joe looks at Theo’s code and seems satisfied.\nJoe Now, how would you adapt your code to Super members?\nTheo I would add a function isSuperMember to the UserManagement module and\ncall it from Library.getBookLendings.\nJoe Exactly! It’s as simple as that.\nTheo types the code on his laptop so that he can show it to Joe. Here’s how Theo adapts\nhis code for Super members.\nListing2.4 Allowing Super members to get the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(Usermanagement.isLibrarian(libraryData.userManagement, userId) ||\nUsermanagement.isSuperMember(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isSuperMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nNow, the awkward feeling caused by passing around all those data objects is dominated by\na feeling of relief. Adapting to this change in requirements takes only a few lines of code\nand requires no changes in the system design. Once again, Joe seems satisfied.\nTIP DOP systems are flexible. Quite often they adapt to changing requirements with-\nout changing the system design.\n--- Page 69 ---\n2.5 DOP systems are flexible 41\nTheo starts coding addBookItem. He looks at the signature of Library.addBookItem,\nand the meaning of the third argument bookItemInfo isn’t clear to him. He asks Joe for\nclarification.\nListing2.5 The signature of Library.addBookItem\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\n}\n}\nTheo What is bookItemInfo?\nJoe Let’s call it the book item information. Imagine we have a way to represent this\ninformation in a data entity named bookItemInfo.\nTheo You mean an object?\nJoe For now, it’s OK to think about bookItemInfo as an object. Later on, I will\nshow you how to we represent data in DOP.\nBesides this subtlety about how the book item information is represented by book-\nItemInfo, the code for Library.addBookItem in listing 2.6 is quite similar to the code\nTheo wrote for Library.getBookLendings in listing 2.4. Once again, Theo is amazed by\nthe fact that adding support for VIP members requires no design change.\nListing2.6 Allowing VIP members to add a book item to the library\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId) ||\nUserManagement.isVIPMember(libraryData.userManagement, userId)) {\nreturn Catalog.addBookItem(libraryData.catalog, bookItemInfo);\n} else {\nthrow \"Not allowed to add a book item\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isVIPMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic addBookItem(catalogData, memberId) {\n// will be implemented later\nIn chapter 4, we will see how\n}\nto manage state of the system\n}\nwith immutable data.\n--- Page 70 ---\n42 CHAPTER 2 Separation between code and data\nTheo It takes a big mindset shift to learn how to separate code from data!\nJoe What was the most challenging thing to accept?\nTheo The fact that data is not encapsulated in objects.\nJoe It was the same for me when I switched from OOP to DOP.\nNow it’s time to eat! Theo takes Joe for lunch at Simple, a nice, small restaurant near the\noffice.\nSummary\n DOP principles are language-agnostic.\n DOP principle #1 is to separate code from data.\n The separation between code and data in DOP systems makes them simpler\n(easier to understand) than traditional OOP systems.\n Data entities are the parts of your system that hold information.\n DOP is against data encapsulation.\n The more flexible a system is, the easier it is to adapt to changing requirements.\n The separation between code and data in DOP systems makes them more flexi-\nble than traditional OOP systems.\n When code is separated from data, we have the freedom to design code and\ndata in isolation.\n We represent data as data entities.\n We discover the data entities of our system and sort them into high-level groups,\neither as a nested list or as a mind map.\n A DOP system is easier to understand than a traditional OOP system because\nthe system is split into two parts: data entities and code modules.\n In DOP, a code module is an aggregation of stateless functions.\n DOP systems are flexible. Quite often they adapt to changing requirements\nwithout changing the system design.\n In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\n Stateless functions receive data they manipulate as an explicit argument.\n The high-level modules of a DOP system correspond to high-level data entities.\n The only kind of relation between code modules is the usage relation.\n The only kinds of relation between data entities are the association and the compo-\nsition relation.\n For a discussion of polymorphism in DOP, see chapter 13.\n--- Page 71 ---\nBasic data manipulation\nMeditation and programming\nThis chapter covers\n Representing records with string maps to improve\nflexibility\n Manipulating data with generic functions\n Accessing each piece of information via its\ninformation path\n Gaining JSON serialization for free\nAfter learning why and how to separate code from data in the previous chapter,\nlet’s talk about data on its own. In contrast to traditional OOP, where system design\ntends to involve a rigid class hierarchy, DOP prescribes that we represent our data\nmodel as a flexible combination of maps and arrays (or lists), where we can access\neach piece of information via an information path. This chapter is a deep dive into\nthe second principle of DOP.\nPRINCIPLE #2 Represent data entities with generic data structures.\n43\n--- Page 72 ---\n44 CHAPTER 3 Basic data manipulation\nWe increase system flexibility when we represent records as string maps and not as\nobjects instantiated from classes. This liberates data from the rigidity of a class-based sys-\ntem. Data becomes a first-class citizen powered by generic functions to add, remove, or\nrename fields.\n NOTE We refer to maps that have strings as keys as string maps.\nThe dependency between the code that manipulates data and the data is a weak\ndependency. The code only needs to know the keys of specific fields in the record it\nwants to manipulate. The code doesn’t even need to know about all the keys in the\nrecord, only the ones relevant to it. In this chapter, we’ll deal only with data query.\nWe’ll discuss managing changes in system state in the next chapter.\n3.1 Designing a data model\nDuring lunch at Simple, Theo and Joe don’t talk about programming. Instead, they start\ngetting to know each other on a personal level. Theo discovers that Joe is married to Kay,\nwho has just opened her creative therapy practice after many years of studying various\nfields related to well-being. Neriah, their 14-year-old son, is passionate about drones, whereas\nAurelia, their 12-year-old daughter, plays the transverse flute.\nJoe tells Theo that he’s been practicing meditation for 10 years. Meditation, he says, has\ntaught him how to break away from being continually lost in a “storm thought” (especially\nnegative thoughts, which can be the source of great suffering) to achieve a more direct\nrelationship with reality. The more he learns to experience reality as it is, the calmer his\nmind. When he first started to practice meditation, it was sometimes difficult and even\nweird, but by persevering, he has increased his feeling of well-being with each passing year.\nWhen they’re back at the office, Joe tells Theo that his next step in their DOP journey\nwill be about data models. This includes data representation.\nJoe When we design the data part of our system, we’re free to do it in isolation.\nTheo What do you mean by isolation?\nJoe I mean that you don’t have to bother with code, only data.\nTheo Oh, right. I remember you telling me how that makes a DOP system simpler\nthan OOP. Separation of concerns is a design principle I’m used to in OOP.\nJoe Indeed.\nTheo And, when we think about data, the only relations we have to think about are\nassociation and composition.\nJoe Correct.\nTheo Will the data model design be significantly different than the data model I’m\nused to designing as an OOP developer?\nJoe Not so much.\nTheo OK. Let me see if I can draw a DOP-style data entity diagram.\nTheo takes a look at the data mind map that he drew earlier in the morning. He then\ndraws the diagram in figure 3.1.\nHe refines the details of the fields of each data entity and the kind of relations between\nentities. Figure 3.2 shows the result of this redefined data entity diagram.\n--- Page 73 ---\n3.1 Designing a data model 45\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 3.1 A data mind map of\nthe Library Management System\nCC Library\nname: String\naddress: String\nCC Catalog CC UserManagement\n* * *\nCC Book CC Librarian CC Member\nemail: String email: String\ntitle : String\npassword: String password: String\npublicationYear: Number\n*\nISBN: String\npublisher: String\n* *\nCC Author CC BookLending\nname: String lendingDate: String\nCC BookItem\n* libld: String\npurchaseDate: String\nFigure 3.2 A data model of the Library Management System\n--- Page 74 ---\n46 CHAPTER 3 Basic data manipulation\nJoe The next step is to be more explicit about the relations between entities.\nTheo What do you mean?\nJoe For example, in your entity diagram, Book and Author are connected by a\nmany-to-many association relation. How is this relation going to be repre-\nsented in your program?\nTheo In the Book entity, there will be a collection of author IDs, and in the Author\nentity, there will be a collection of book IDs.\nJoe Sounds good. And what will the book ID be?\nTheo The book ISBN.\n NOTE The International Standard Book Number (ISBN) is a numeric commercial\nbook identifier that is intended to be unique.\nJoe And where will you hold the index that enables you to retrieve a Book from its\nISBN?\nTheo In the Catalog because the catalog holds a bookByISBN index.\nJoe What about author ID?\nTheo Author ID is the author name in lowercase and with dashes instead of white\nspaces (assuming that we don’t have two authors with the same name).\nJoe And I guess that you also hold the author index in the Catalog?\nTheo Exactly!\nJoe Excellent. You’ve been 100% explicit about the relation between Book and\nAuthor. I’ll ask you to do the same with the other relations of the system.\nIt’s quite easy for Theo to do, as he has done that so many times as an OOP developer. Fig-\nure 3.3 provides the detailed entity diagram of Theo’s system.\n NOTE By positional collection, we mean a collection where the elements are in order\n(like a list or an array). By index, we mean a collection where the elements are accessi-\nble via a key (like a hash map or a dictionary).\nThe Catalog entity contains two indexes:\n booksByIsbn—The keys are book ISBNs, and the values are Book entities. Its type is\nnoted as {Book}.\n authorsById—The keys are author IDs, and the values are Author entities. Its type\nis noted as {Author}.\nInside a Book entity, we have authors, which is a positional collection of author IDs of type\n[String]. Inside an Author entity, we have books, which is a collection of book IDs of\ntype [String].\n NOTE For the notation for collections and index types, a positional collection of\nStrings is noted as [String]. An index of Books is noted as {Book}. In the context of\na data model, the index keys are always strings.\n--- Page 75 ---\n3.1 Designing a data model 47\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: UserManagement\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian\nCC Book i n d a : m S e tr : i n S g tring email: String CC Me * mber\ntitle : String encryptedPassword: String\nbookIsbns: [String] email: String\npublicationYear: Number\nencryptedPassword: String\nisbn: String *\nisBlocked: Boolean\nauthorIds: [String]\nbookLendings: [BookLending]\nbookItems: [BookItem] *\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.3 Library management relation model. Dashed lines (e.g., between Book and Author) denote\nindirect relations, [String] denotes a positional collection of strings, and {Book} denotes an index of\nBooks.\nThere is a dashed line between Book and Author, which means that the relation between\nBook and Author is indirect. To access the collection of Author entities from a Book entity,\nwe’ll use the authorById index defined in the Catalog entity.\nJoe I like your data entity diagram.\nTheo Thank you.\nJoe Can you tell me what the three kinds of data aggregations are in your diagram\n(and, in fact, in any data entity diagram)?\nTheo Let’s see...we have positional collections like authors in Book. We have\nindexes like booksByIsbn in Catalog. I can’t find the third one.\nJoe The third kind of data aggregation is what we’ve called, until now, an “entity”\n(like Library, Catalog, Book, etc.), and the common term for entity in com-\nputer science is record.",
        "sections_found": []
      },
      "accurate_page_range": "56-75"
    },
    {
      "text": "- 2.2 Data entities",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "raw_line": "- 2.2 Data entities (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 16,
      "chapter_info": {
        "page": 56,
        "title": "Separation between code and data",
        "pattern_matched": "Chapter 2",
        "text_preview": "28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his te"
      },
      "chapter_sections": {
        "start_page": 56,
        "end_page": 75,
        "content": "\n--- Page 56 ---\n28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his team have built in Clojure over the last 7\nyears are less complex and more flexible than the systems he used to build in Java. Accord-\ning to Joe, the systems they build now tend to be much simpler because they follow the\nprinciples of DOP.\nTheo I’ve never heard of data-oriented programming. Is it a new concept?\nJoe Yes and no. Most of the foundational ideas of data-oriented programming, or\nDOP as we like to call it, are well known to programmers as best practices. The\nnovelty of DOP, however, is that it combines best practices into a cohesive\nwhole.\nTheo That’s a bit abstract for me. Can you give me an example?\nJoe Sure! Take, for instance, the first insight of DOP. It’s about the relations between\ncode and data.\nTheo You mean the encapsulation of data in objects?\nJoe Actually, DOP is against data encapsulation.\nTheo Why is that? I thought data encapsulation was a positive programming paradigm.\nJoe Data encapsulation has both merits and drawbacks. Think about the way you\ndesigned the Library Management System. According to DOP, the main cause\nof complexity and inflexibility in systems is that code and data are mixed\ntogether in objects.\nTIP DOP is against data encapsulation.\nTheo It sounds similar to what I’ve heard about functional programming. So, if I\nwant to adopt DOP, do I need to get rid of object-oriented programming and\nlearn functional programming?\nJoe No, DOP principles are language-agnostic. They can be applied in both object-\noriented and functional programming languages.\nTheo That’s a relief! I was afraid that you were going to teach me about monads,\nalgebraic data types, and higher order functions.\nJoe No, none of that is required in DOP.\nTIP DOP principles are language-agnostic.\nTheo What does the separation between code and data look like in DOP then?\nJoe Data is represented by data entities that only hold members. Code is aggre-\ngated into modules where all functions are stateless.\nTheo What do you mean by stateless functions?\nJoe Instead of having the state encapsulated in the object, the data entity is passed\nas an argument.\nTheo I don’t get that.\nJoe Here, let’s make it visual.\n--- Page 57 ---\n2.2 Data entities 29\nJoe steps up to a whiteboard and quickly draws a diagram to illustrate his comment. Fig-\nure 2.2 shows Joe’s drawing.\nCode modules Stateless functions\nSeparate code from data\nData entities Only members\nFigure 2.2 The separation between code and data\nTheo It’s still not clear.\nJoe It will become clearer when I show you how it looks in the context of your\nLibrary Management System.\nTheo OK. Shall we start with code or with data?\nJoe Well, it’s data-oriented programming, so let’s start with data.\n2.2 Data entities\nIn DOP, we start the design process by discovering the data entities of our system.\nHere’s what Joe and Theo have to say about data entities.\nJoe What are the data entities of your system?\nTheo What do you mean by data entities?\nJoe I mean the parts of your system that hold information.\n NOTE Data entities are the parts of your system that hold information.\nTheo Well, it’s a Library Management System, so we have books and members.\nJoe Of course, but there are more. One way to discover the data entities of a system\nis to look for nouns and noun phrases in the requirements of the system.\nTheo looks at Nancy’s requirement napkin. He highlights the nouns and noun phrases\nthat seem to represent data entities.\nHighlighting terms in the requirements that correspond to data entities\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n--- Page 58 ---\n30 CHAPTER 2 Separation between code and data\nJoe Excellent. Can you see a natural way to group these entities?\nTheo Not sure, but it seems to me that users, members, and librarians form one\ngroup, whereas books, authors, and book copies form another group.\nJoe Sounds good to me. What would you call each group?\nTheo Probably user management for the first group and catalog for the second\ngroup.\nThe data entities of the system organized in a nested list\n The catalog data\n– Data about books\n– Data about authors\n– Data about book items\n– Data about book lendings\n The user management data\n– Data about users\n– Data about members\n– Data about librarians\nTheo I’m not sure about the relations between books and authors. Should it be asso-\nciation or composition?\nJoe Don’t worry too much about the details for the moment. We’ll refine our data\nentity design later. For now, let’s visualize the two groups in a mind map.\nTheo and Joe confer for a bit. Figure 2.3 shows the mind map they come up with.\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 2.3 The data entities of the\nsystem organized in a mind map\n--- Page 59 ---\n2.3 Code modules 31\nThe most precise way to visualize the data entities of a DOP system is to draw a data\nentity diagram with different arrows for association and composition. We will come\nback to data entity diagrams later.\nTIP Discover the data entities of your system and then sort them into high-level\ngroups, either as a nested list or as a mind map.\nWe will dive deeper into the design and representation of data entities in the next\nchapter. For now, let’s simplify things and say that the data of our library system is\nmade of two high-level groups: user management and catalog.\n2.3 Code modules\nThe second step of the design process in DOP is to define the code modules. Let’s lis-\nten in on Joe and Theo again.\nJoe Now that you have identified the data entities of your system and have\narranged them into high-level groups, it’s time to think about the code part of\nyour system.\nTheo What do you mean by the code part?\nJoe One way to think about that is to identity the functionality of your system.\nTheo looks again at Nancy’s requirements. This time he highlights the verb phrases that\nrepresent functionality.\nHighlighting terms in the requirements that correspond to functionality\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\nIn addition, it’s obvious to Theo that members can also return a book. Moreover, there\nshould be a way to detect whether a user is a librarian or not. He adds those to the require-\nments and then lists the functionality of the system.\nThe functionality of the library system\n Search for a book.\n Add a book item.\n Block a member.\n--- Page 60 ---\n32 CHAPTER 2 Separation between code and data\n(continued)\n Unblock a member.\n Log a user into the system.\n List the books currently lent to a member.\n Borrow a book.\n Return a book.\n Check whether a user is a librarian.\nJoe Excellent! Now, tell me what functionality needs to be exposed to the outside\nworld?\nTheo What do you mean by exposed to the outside world?\nJoe Imagine that the Library Management System exposes an API over HTTP.\nWhat functionality would be exposed by the HTTP endpoints?\nTheo Well, all system functionality would be exposed except checking to see if a user\nis a librarian.\nJoe OK. Now give each exposed function a short name and gather them together\nin a module box called Library.\nThat takes Theo less than a minute. Figure 2.4 shows the module that contains the\nexposed functions of the library devised by Theo.\nC Library\nsearchBook()\naddBookItem()\nblockMember()\nunblockMember()\ngetBookLendings() Figure 2.4 The Library module\ncheckoutBook() contains the exposed functions of the\nreturnBook() Library Management System.\nTIP The first step in designing the code part of a DOP system is to aggregate the\nexposed functions into a single module.\nJoe Beautiful! You just created your first code module.\nTheo To me it looks like a class. What’s the difference between a module and a class?\nJoe A module is an aggregation of functions. In OOP, a module is represented\nbya class, but in other programming languages, it might be a package or a\nnamespace.\nTheo I see.\nJoe The important thing about DOP code modules is that they contain only state-\nless functions.\nTheo You mean like static methods in Java?\nJoe Yes, and the classes of these static methods should not have any data members.\n--- Page 61 ---\n2.3 Code modules 33\nTheo So, how do the functions know what piece of information they operate on?\nJoe Easy. We pass that as the first argument to the function.\nTheo OK. Can you give me an example?\nJoe, biting his nails, takes a look at the list of functions of the Library module in figure 2.4.\nHe spots a likely candidate.\nJoe Let’s take, for example, getBookLendings. In classic OOP, what would its\narguments be?\nTheo A librarian ID and a member ID.\nJoe So, in traditional OOP, getBookLendings would be a method of a Library\nclass that receives two arguments: librarianId and memberId.\nTheo Yep.\nJoe Now comes the subtle part. In DOP, getBookLendings is part of the Library\nmodule, and it receives the LibraryData as an argument.\nTheo Could you show me what you mean?\nJoe Sure.\nJoe goes over to Theo’s keyboard and starts typing. He enters an example of what a class\nmethod looks like in OOP:\nclass Library {\ncatalog\nuserManagement\ngetBookLendings(userId, memberId) {\n// accesses library state via this.catalog and this.userManagement\n}\n}\nTheo Right! The method accesses the state of the object (in our case, the library\ndata) via this.\nJoe Would you say that the object’s state is an argument of the object’s methods?\nTheo I’d say that the object’s state is an implicit argument to the object’s methods.\nTIP In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\nJoe Well, in DOP, we pass data as an explicit argument. The signature of getBook-\nLendings would look like this.\nListing2.1 The signature of getBookLendings\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\n}\n}\n--- Page 62 ---\n34 CHAPTER 2 Separation between code and data\nJoe The state of the library is stored in libraryData, and libraryData is passed\nto the getBookLendings static method as an explicit argument.\nTheo Is that a general rule?\nJoe Absolutely! The same rule applies to the other functions of the Library mod-\nule and to other modules as well. All of the modules are stateless—they receive\nthe library data that they manipulate as an argument.\nTIP In DOP, functions of a code module are stateless. They receive the data that they\nmanipulate as an explicit argument, which is usually the first argument.\n NOTE A module is an aggregation of functions. In DOP, the module functions are\nstateless.\nTheo It reminds me of Python and the way the self argument appears in method\nsignatures. Here, let me show you an example.\nListing2.2 A Python object as an explicit argument in method signatures\nclass Library:\ncatalog = {}\nuserManagement = {}\ndef getBookLendings(self, userId, memberId):\n# accesses library state via self.catalog and self.userManagement\nJoe Indeed, but the difference I’m talking about is much deeper than a syntax\nchange. It’s about the fact that data lives outside the modules.\nTheo I got that. As you said, module functions are stateless.\nJoe Exactly! Would you like to try and apply this principle across the whole\nLibrary module?\nTheo Sure.\nTheo refines the design of the Library module by including the details about the func-\ntions’ arguments. He presents the diagram in figure 2.5 to Joe.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId) Figure 2.5 The Library module\nreturnBook(libraryData, userId, bookItemId)\nwith the functions’ arguments\nJoe Perfect. Now, we’re ready to tackle the high-level design of our system.\nTheo What’s a high-level design in DOP?\n--- Page 63 ---\n2.3 Code modules 35\nJoe A high-level design in DOP is the definition of modules and the interaction\nbetween them.\nTheo I see. Are there any guidelines to help me define the modules?\nJoe Definitely. The high-level modules of the system correspond to the high-level\ndata entities.\nTheo You mean the data entities that appear in the data mind map?\nJoe Exactly!\nTheo looks again at the data mind map (figure 2.6). He focuses on the high-level data enti-\nties library, catalog, and user management. This means that in the system, besides the\nLibrary module, we have two high-level modules:\n The Catalog module deals with catalog data.\n The UserManagement module deals with user management data.\nCatalog\nLibrary data Figure 2.6 A mind map of the high-\nlevel data entities of the Library\nUser management\nManagement System\nTheo then draws the high-level design of the Library Management System with the Catalog\nand UserManagement modules. Figure 2.7 shows the addition of these modules, where:\n Functions of Catalog receive catalogData as their first argument.\n Functions of UserManagement receive userManagementData as their first argument.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.7 The modules of the Library Management System with their functions’ arguments\n--- Page 64 ---\n36 CHAPTER 2 Separation between code and data\nIt’s not 100% clear for Theo at this point how the data entities get passed between mod-\nules. For the moment, he thinks of libraryData as a class with two members:\n catalog holds the catalog data.\n userManagement holds the user management data.\nTheo also sees that the functions of Library share a common pattern. (Later on in this\nchapter, we’ll see the code for some functions of the Library module.)\n They receive libraryData as an argument.\n They pass libraryData.catalog to the functions of Catalog.\n They pass libraryData.userManagement to the functions of UserManagement.\nTIP The high-level modules of a DOP system correspond to the high-level data enti-\nties.\n2.4 DOP systems are easy to understand\nTheo takes a look at the two diagrams that represent the high-level design of his system:\n The data entities in the data mind map in figure 2.8\n The code modules in the module diagram in figure 2.9\nA bit perplexed, Theo asks Joe:\nTheo I’m not sure that this system is better than a traditional OOP system where\nobjects encapsulate data.\nJoe The main benefit of a DOP system over a traditional OOP system is that it’s eas-\nier to understand.\nTheo What makes it easier to understand?\nJoe The fact that the system is split cleanly into code modules and data entities.\nTheo How does that help?\nJoe When you try to understand the data entities of the system, you don’t have to\nthink about the details of the code that manipulates the data entities.\nTheo So, when I look at the data mind map of my Library Management System, I can\nunderstand it on its own?\nJoe Exactly, and similarly, when you try to understand the code modules of the sys-\ntem, you don’t have to think about the details of the data entities manipulated\nby the code. There is a clear separation of concerns between the code and the\ndata.\nTheo looks again at the data mind map in figure 2.8. He has kind of an Aha! moment:\nData lives on its own!\n NOTE A DOP system is easier to understand because the system is split into two\nparts: data entities and code modules.\n--- Page 65 ---\n2.4 DOP systems are easy to understand 37\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nFigure 2.8 A data mind map of the\nLibrarians\nLibrary Management System\nNow, Theo looks at the module diagram in figure 2.9. He feels a bit confused and asks Joe\nfor clarification:\n On one hand, the module diagram looks similar to the class diagrams from classic\nOOP, boxes for classes and arrows for relations between classes.\n On the other hand, the code module diagram looks much simpler than the class\ndiagrams from classic OOP, but he cannot explain why.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.9 The modules of the Library Management System with the function arguments\nTheo The module diagram seems much simpler than the class diagrams I am used to\nin OOP. I feel it, but I can’t put it into words.\nJoe The reason is that module diagrams have constraints.\n--- Page 66 ---\n38 CHAPTER 2 Separation between code and data\nTheo What kind of constraints?\nJoe Constraints on the functions we saw before. All the functions are static (or\nstateless), but there’s also constraints on the relations between the modules.\nTIP All the functions in a DOP module are stateless.\nTheo In what way are the relations between modules constrained?\nJoe There is a single kind of relation between DOP modules—the usage relation. A\nmodule uses code from another module. There’s no association, no composi-\ntion, and no inheritance between modules. That’s what makes a DOP module\ndiagram easy to understand.\nTheo I understand why there is no association and no composition between DOP\nmodules. After all, association and composition are data relations. But why no\ninheritance relation? Does that mean that DOP is against polymorphism?\nJoe That’s a great question! The quick answer is that in DOP, we achieve polymor-\nphism with a different mechanism than class inheritance. We will talk about it\nsome day.\n NOTE For a discussion of polymorphism in DOP, see chapter 13.\nTheo Now, you’ve piqued my curiosity. I thought inheritance was the only way to\nachieve polymorphism.\nTheo looks again at the module diagram in figure 2.9. Now he not only feels that this dia-\ngram is simpler than traditional OOP class diagrams, he understands why it’s simpler: all\nthe functions are static, and all the relations between modules are of type usage. Table 2.1\nsummarizes Theo’s perception.\nTIP The only kind of relation between DOP modules is the usage relation.\nTable 2.1 What makes each part of a DOP system easy to understand\nSystem part Constraint on entities Constraints on relations\nData entities Members only (no code) Association and composition\nCode modules Stateless functions (no members) Usage (no inheritance)\nTIP Each part of a DOP system is easy to understand because it provides constraints.\n2.5 DOP systems are flexible\nTheo I see how a sharp separation between code and data makes DOP systems easier\nto understand than classic OOP systems. But what about adapting to changes\nin requirements?\nJoe Another benefit of DOP systems is that it is easy to extend them and to adapt to\nchanging requirements.\n--- Page 67 ---\n2.5 DOP systems are flexible 39\nTheo I remember that, when Nancy asked me to add Super members and VIP mem-\nbers to the system, it was hard to adapt my OOP system. I had to introduce a\nfew base classes, and the class hierarchy became really complex.\nJoe I know exactly what you mean. I’ve experienced the same kind of struggle so\nmany times. Describe the changes in the requirements for Super members and\nVIP members, and I’m quite sure that you’ll see how easy it would be to extend\nyour DOP system.\nThe requirements for Super members and VIP members\n Super members are members that are allowed to list the book lendings to\nother members.\n VIP members are members that are allowed to add book items to the library.\nTheo opens his IDE and starts to code the getBookLendings function of the Library\nmodule (see listing 2.3), first without addressing the requirements for Super members.\nTheo remembers what Joe told him about module functions in DOP:\n Functions are stateless.\n Functions receive the data they manipulate as their first argument.\nIn terms of functionality, getBookLendings has two parts:\n Checks that the user is a librarian.\n Retrieves the book lendings from the catalog.\nBasically, the code of getBookLendings has two parts as well:\n Calls the isLibrarian function from the UserManagement module and passes it\nthe UserManagementData.\n Calls the getBookLendings function from the Catalog module and passes it the\nCatalogData.\nListing2.3 Getting the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\n}\ngeneric data collections.\n--- Page 68 ---\n40 CHAPTER 2 Separation between code and data\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nIt’s Theo’s first piece of DOP code and passing around all those data objects—library-\nData, libraryData.userManagement, and libraryData.catalog—feels a bit awkward.\nBut he did it! Joe looks at Theo’s code and seems satisfied.\nJoe Now, how would you adapt your code to Super members?\nTheo I would add a function isSuperMember to the UserManagement module and\ncall it from Library.getBookLendings.\nJoe Exactly! It’s as simple as that.\nTheo types the code on his laptop so that he can show it to Joe. Here’s how Theo adapts\nhis code for Super members.\nListing2.4 Allowing Super members to get the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(Usermanagement.isLibrarian(libraryData.userManagement, userId) ||\nUsermanagement.isSuperMember(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isSuperMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nNow, the awkward feeling caused by passing around all those data objects is dominated by\na feeling of relief. Adapting to this change in requirements takes only a few lines of code\nand requires no changes in the system design. Once again, Joe seems satisfied.\nTIP DOP systems are flexible. Quite often they adapt to changing requirements with-\nout changing the system design.\n--- Page 69 ---\n2.5 DOP systems are flexible 41\nTheo starts coding addBookItem. He looks at the signature of Library.addBookItem,\nand the meaning of the third argument bookItemInfo isn’t clear to him. He asks Joe for\nclarification.\nListing2.5 The signature of Library.addBookItem\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\n}\n}\nTheo What is bookItemInfo?\nJoe Let’s call it the book item information. Imagine we have a way to represent this\ninformation in a data entity named bookItemInfo.\nTheo You mean an object?\nJoe For now, it’s OK to think about bookItemInfo as an object. Later on, I will\nshow you how to we represent data in DOP.\nBesides this subtlety about how the book item information is represented by book-\nItemInfo, the code for Library.addBookItem in listing 2.6 is quite similar to the code\nTheo wrote for Library.getBookLendings in listing 2.4. Once again, Theo is amazed by\nthe fact that adding support for VIP members requires no design change.\nListing2.6 Allowing VIP members to add a book item to the library\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId) ||\nUserManagement.isVIPMember(libraryData.userManagement, userId)) {\nreturn Catalog.addBookItem(libraryData.catalog, bookItemInfo);\n} else {\nthrow \"Not allowed to add a book item\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isVIPMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic addBookItem(catalogData, memberId) {\n// will be implemented later\nIn chapter 4, we will see how\n}\nto manage state of the system\n}\nwith immutable data.\n--- Page 70 ---\n42 CHAPTER 2 Separation between code and data\nTheo It takes a big mindset shift to learn how to separate code from data!\nJoe What was the most challenging thing to accept?\nTheo The fact that data is not encapsulated in objects.\nJoe It was the same for me when I switched from OOP to DOP.\nNow it’s time to eat! Theo takes Joe for lunch at Simple, a nice, small restaurant near the\noffice.\nSummary\n DOP principles are language-agnostic.\n DOP principle #1 is to separate code from data.\n The separation between code and data in DOP systems makes them simpler\n(easier to understand) than traditional OOP systems.\n Data entities are the parts of your system that hold information.\n DOP is against data encapsulation.\n The more flexible a system is, the easier it is to adapt to changing requirements.\n The separation between code and data in DOP systems makes them more flexi-\nble than traditional OOP systems.\n When code is separated from data, we have the freedom to design code and\ndata in isolation.\n We represent data as data entities.\n We discover the data entities of our system and sort them into high-level groups,\neither as a nested list or as a mind map.\n A DOP system is easier to understand than a traditional OOP system because\nthe system is split into two parts: data entities and code modules.\n In DOP, a code module is an aggregation of stateless functions.\n DOP systems are flexible. Quite often they adapt to changing requirements\nwithout changing the system design.\n In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\n Stateless functions receive data they manipulate as an explicit argument.\n The high-level modules of a DOP system correspond to high-level data entities.\n The only kind of relation between code modules is the usage relation.\n The only kinds of relation between data entities are the association and the compo-\nsition relation.\n For a discussion of polymorphism in DOP, see chapter 13.\n--- Page 71 ---\nBasic data manipulation\nMeditation and programming\nThis chapter covers\n Representing records with string maps to improve\nflexibility\n Manipulating data with generic functions\n Accessing each piece of information via its\ninformation path\n Gaining JSON serialization for free\nAfter learning why and how to separate code from data in the previous chapter,\nlet’s talk about data on its own. In contrast to traditional OOP, where system design\ntends to involve a rigid class hierarchy, DOP prescribes that we represent our data\nmodel as a flexible combination of maps and arrays (or lists), where we can access\neach piece of information via an information path. This chapter is a deep dive into\nthe second principle of DOP.\nPRINCIPLE #2 Represent data entities with generic data structures.\n43\n--- Page 72 ---\n44 CHAPTER 3 Basic data manipulation\nWe increase system flexibility when we represent records as string maps and not as\nobjects instantiated from classes. This liberates data from the rigidity of a class-based sys-\ntem. Data becomes a first-class citizen powered by generic functions to add, remove, or\nrename fields.\n NOTE We refer to maps that have strings as keys as string maps.\nThe dependency between the code that manipulates data and the data is a weak\ndependency. The code only needs to know the keys of specific fields in the record it\nwants to manipulate. The code doesn’t even need to know about all the keys in the\nrecord, only the ones relevant to it. In this chapter, we’ll deal only with data query.\nWe’ll discuss managing changes in system state in the next chapter.\n3.1 Designing a data model\nDuring lunch at Simple, Theo and Joe don’t talk about programming. Instead, they start\ngetting to know each other on a personal level. Theo discovers that Joe is married to Kay,\nwho has just opened her creative therapy practice after many years of studying various\nfields related to well-being. Neriah, their 14-year-old son, is passionate about drones, whereas\nAurelia, their 12-year-old daughter, plays the transverse flute.\nJoe tells Theo that he’s been practicing meditation for 10 years. Meditation, he says, has\ntaught him how to break away from being continually lost in a “storm thought” (especially\nnegative thoughts, which can be the source of great suffering) to achieve a more direct\nrelationship with reality. The more he learns to experience reality as it is, the calmer his\nmind. When he first started to practice meditation, it was sometimes difficult and even\nweird, but by persevering, he has increased his feeling of well-being with each passing year.\nWhen they’re back at the office, Joe tells Theo that his next step in their DOP journey\nwill be about data models. This includes data representation.\nJoe When we design the data part of our system, we’re free to do it in isolation.\nTheo What do you mean by isolation?\nJoe I mean that you don’t have to bother with code, only data.\nTheo Oh, right. I remember you telling me how that makes a DOP system simpler\nthan OOP. Separation of concerns is a design principle I’m used to in OOP.\nJoe Indeed.\nTheo And, when we think about data, the only relations we have to think about are\nassociation and composition.\nJoe Correct.\nTheo Will the data model design be significantly different than the data model I’m\nused to designing as an OOP developer?\nJoe Not so much.\nTheo OK. Let me see if I can draw a DOP-style data entity diagram.\nTheo takes a look at the data mind map that he drew earlier in the morning. He then\ndraws the diagram in figure 3.1.\nHe refines the details of the fields of each data entity and the kind of relations between\nentities. Figure 3.2 shows the result of this redefined data entity diagram.\n--- Page 73 ---\n3.1 Designing a data model 45\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 3.1 A data mind map of\nthe Library Management System\nCC Library\nname: String\naddress: String\nCC Catalog CC UserManagement\n* * *\nCC Book CC Librarian CC Member\nemail: String email: String\ntitle : String\npassword: String password: String\npublicationYear: Number\n*\nISBN: String\npublisher: String\n* *\nCC Author CC BookLending\nname: String lendingDate: String\nCC BookItem\n* libld: String\npurchaseDate: String\nFigure 3.2 A data model of the Library Management System\n--- Page 74 ---\n46 CHAPTER 3 Basic data manipulation\nJoe The next step is to be more explicit about the relations between entities.\nTheo What do you mean?\nJoe For example, in your entity diagram, Book and Author are connected by a\nmany-to-many association relation. How is this relation going to be repre-\nsented in your program?\nTheo In the Book entity, there will be a collection of author IDs, and in the Author\nentity, there will be a collection of book IDs.\nJoe Sounds good. And what will the book ID be?\nTheo The book ISBN.\n NOTE The International Standard Book Number (ISBN) is a numeric commercial\nbook identifier that is intended to be unique.\nJoe And where will you hold the index that enables you to retrieve a Book from its\nISBN?\nTheo In the Catalog because the catalog holds a bookByISBN index.\nJoe What about author ID?\nTheo Author ID is the author name in lowercase and with dashes instead of white\nspaces (assuming that we don’t have two authors with the same name).\nJoe And I guess that you also hold the author index in the Catalog?\nTheo Exactly!\nJoe Excellent. You’ve been 100% explicit about the relation between Book and\nAuthor. I’ll ask you to do the same with the other relations of the system.\nIt’s quite easy for Theo to do, as he has done that so many times as an OOP developer. Fig-\nure 3.3 provides the detailed entity diagram of Theo’s system.\n NOTE By positional collection, we mean a collection where the elements are in order\n(like a list or an array). By index, we mean a collection where the elements are accessi-\nble via a key (like a hash map or a dictionary).\nThe Catalog entity contains two indexes:\n booksByIsbn—The keys are book ISBNs, and the values are Book entities. Its type is\nnoted as {Book}.\n authorsById—The keys are author IDs, and the values are Author entities. Its type\nis noted as {Author}.\nInside a Book entity, we have authors, which is a positional collection of author IDs of type\n[String]. Inside an Author entity, we have books, which is a collection of book IDs of\ntype [String].\n NOTE For the notation for collections and index types, a positional collection of\nStrings is noted as [String]. An index of Books is noted as {Book}. In the context of\na data model, the index keys are always strings.\n--- Page 75 ---\n3.1 Designing a data model 47\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: UserManagement\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian\nCC Book i n d a : m S e tr : i n S g tring email: String CC Me * mber\ntitle : String encryptedPassword: String\nbookIsbns: [String] email: String\npublicationYear: Number\nencryptedPassword: String\nisbn: String *\nisBlocked: Boolean\nauthorIds: [String]\nbookLendings: [BookLending]\nbookItems: [BookItem] *\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.3 Library management relation model. Dashed lines (e.g., between Book and Author) denote\nindirect relations, [String] denotes a positional collection of strings, and {Book} denotes an index of\nBooks.\nThere is a dashed line between Book and Author, which means that the relation between\nBook and Author is indirect. To access the collection of Author entities from a Book entity,\nwe’ll use the authorById index defined in the Catalog entity.\nJoe I like your data entity diagram.\nTheo Thank you.\nJoe Can you tell me what the three kinds of data aggregations are in your diagram\n(and, in fact, in any data entity diagram)?\nTheo Let’s see...we have positional collections like authors in Book. We have\nindexes like booksByIsbn in Catalog. I can’t find the third one.\nJoe The third kind of data aggregation is what we’ve called, until now, an “entity”\n(like Library, Catalog, Book, etc.), and the common term for entity in com-\nputer science is record.",
        "sections_found": []
      },
      "accurate_page_range": "56-75"
    },
    {
      "text": "- 2.3 Code modules",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "raw_line": "- 2.3 Code modules (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 17,
      "chapter_info": {
        "page": 56,
        "title": "Separation between code and data",
        "pattern_matched": "Chapter 2",
        "text_preview": "28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his te"
      },
      "chapter_sections": {
        "start_page": 56,
        "end_page": 75,
        "content": "\n--- Page 56 ---\n28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his team have built in Clojure over the last 7\nyears are less complex and more flexible than the systems he used to build in Java. Accord-\ning to Joe, the systems they build now tend to be much simpler because they follow the\nprinciples of DOP.\nTheo I’ve never heard of data-oriented programming. Is it a new concept?\nJoe Yes and no. Most of the foundational ideas of data-oriented programming, or\nDOP as we like to call it, are well known to programmers as best practices. The\nnovelty of DOP, however, is that it combines best practices into a cohesive\nwhole.\nTheo That’s a bit abstract for me. Can you give me an example?\nJoe Sure! Take, for instance, the first insight of DOP. It’s about the relations between\ncode and data.\nTheo You mean the encapsulation of data in objects?\nJoe Actually, DOP is against data encapsulation.\nTheo Why is that? I thought data encapsulation was a positive programming paradigm.\nJoe Data encapsulation has both merits and drawbacks. Think about the way you\ndesigned the Library Management System. According to DOP, the main cause\nof complexity and inflexibility in systems is that code and data are mixed\ntogether in objects.\nTIP DOP is against data encapsulation.\nTheo It sounds similar to what I’ve heard about functional programming. So, if I\nwant to adopt DOP, do I need to get rid of object-oriented programming and\nlearn functional programming?\nJoe No, DOP principles are language-agnostic. They can be applied in both object-\noriented and functional programming languages.\nTheo That’s a relief! I was afraid that you were going to teach me about monads,\nalgebraic data types, and higher order functions.\nJoe No, none of that is required in DOP.\nTIP DOP principles are language-agnostic.\nTheo What does the separation between code and data look like in DOP then?\nJoe Data is represented by data entities that only hold members. Code is aggre-\ngated into modules where all functions are stateless.\nTheo What do you mean by stateless functions?\nJoe Instead of having the state encapsulated in the object, the data entity is passed\nas an argument.\nTheo I don’t get that.\nJoe Here, let’s make it visual.\n--- Page 57 ---\n2.2 Data entities 29\nJoe steps up to a whiteboard and quickly draws a diagram to illustrate his comment. Fig-\nure 2.2 shows Joe’s drawing.\nCode modules Stateless functions\nSeparate code from data\nData entities Only members\nFigure 2.2 The separation between code and data\nTheo It’s still not clear.\nJoe It will become clearer when I show you how it looks in the context of your\nLibrary Management System.\nTheo OK. Shall we start with code or with data?\nJoe Well, it’s data-oriented programming, so let’s start with data.\n2.2 Data entities\nIn DOP, we start the design process by discovering the data entities of our system.\nHere’s what Joe and Theo have to say about data entities.\nJoe What are the data entities of your system?\nTheo What do you mean by data entities?\nJoe I mean the parts of your system that hold information.\n NOTE Data entities are the parts of your system that hold information.\nTheo Well, it’s a Library Management System, so we have books and members.\nJoe Of course, but there are more. One way to discover the data entities of a system\nis to look for nouns and noun phrases in the requirements of the system.\nTheo looks at Nancy’s requirement napkin. He highlights the nouns and noun phrases\nthat seem to represent data entities.\nHighlighting terms in the requirements that correspond to data entities\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n--- Page 58 ---\n30 CHAPTER 2 Separation between code and data\nJoe Excellent. Can you see a natural way to group these entities?\nTheo Not sure, but it seems to me that users, members, and librarians form one\ngroup, whereas books, authors, and book copies form another group.\nJoe Sounds good to me. What would you call each group?\nTheo Probably user management for the first group and catalog for the second\ngroup.\nThe data entities of the system organized in a nested list\n The catalog data\n– Data about books\n– Data about authors\n– Data about book items\n– Data about book lendings\n The user management data\n– Data about users\n– Data about members\n– Data about librarians\nTheo I’m not sure about the relations between books and authors. Should it be asso-\nciation or composition?\nJoe Don’t worry too much about the details for the moment. We’ll refine our data\nentity design later. For now, let’s visualize the two groups in a mind map.\nTheo and Joe confer for a bit. Figure 2.3 shows the mind map they come up with.\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 2.3 The data entities of the\nsystem organized in a mind map\n--- Page 59 ---\n2.3 Code modules 31\nThe most precise way to visualize the data entities of a DOP system is to draw a data\nentity diagram with different arrows for association and composition. We will come\nback to data entity diagrams later.\nTIP Discover the data entities of your system and then sort them into high-level\ngroups, either as a nested list or as a mind map.\nWe will dive deeper into the design and representation of data entities in the next\nchapter. For now, let’s simplify things and say that the data of our library system is\nmade of two high-level groups: user management and catalog.\n2.3 Code modules\nThe second step of the design process in DOP is to define the code modules. Let’s lis-\nten in on Joe and Theo again.\nJoe Now that you have identified the data entities of your system and have\narranged them into high-level groups, it’s time to think about the code part of\nyour system.\nTheo What do you mean by the code part?\nJoe One way to think about that is to identity the functionality of your system.\nTheo looks again at Nancy’s requirements. This time he highlights the verb phrases that\nrepresent functionality.\nHighlighting terms in the requirements that correspond to functionality\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\nIn addition, it’s obvious to Theo that members can also return a book. Moreover, there\nshould be a way to detect whether a user is a librarian or not. He adds those to the require-\nments and then lists the functionality of the system.\nThe functionality of the library system\n Search for a book.\n Add a book item.\n Block a member.\n--- Page 60 ---\n32 CHAPTER 2 Separation between code and data\n(continued)\n Unblock a member.\n Log a user into the system.\n List the books currently lent to a member.\n Borrow a book.\n Return a book.\n Check whether a user is a librarian.\nJoe Excellent! Now, tell me what functionality needs to be exposed to the outside\nworld?\nTheo What do you mean by exposed to the outside world?\nJoe Imagine that the Library Management System exposes an API over HTTP.\nWhat functionality would be exposed by the HTTP endpoints?\nTheo Well, all system functionality would be exposed except checking to see if a user\nis a librarian.\nJoe OK. Now give each exposed function a short name and gather them together\nin a module box called Library.\nThat takes Theo less than a minute. Figure 2.4 shows the module that contains the\nexposed functions of the library devised by Theo.\nC Library\nsearchBook()\naddBookItem()\nblockMember()\nunblockMember()\ngetBookLendings() Figure 2.4 The Library module\ncheckoutBook() contains the exposed functions of the\nreturnBook() Library Management System.\nTIP The first step in designing the code part of a DOP system is to aggregate the\nexposed functions into a single module.\nJoe Beautiful! You just created your first code module.\nTheo To me it looks like a class. What’s the difference between a module and a class?\nJoe A module is an aggregation of functions. In OOP, a module is represented\nbya class, but in other programming languages, it might be a package or a\nnamespace.\nTheo I see.\nJoe The important thing about DOP code modules is that they contain only state-\nless functions.\nTheo You mean like static methods in Java?\nJoe Yes, and the classes of these static methods should not have any data members.\n--- Page 61 ---\n2.3 Code modules 33\nTheo So, how do the functions know what piece of information they operate on?\nJoe Easy. We pass that as the first argument to the function.\nTheo OK. Can you give me an example?\nJoe, biting his nails, takes a look at the list of functions of the Library module in figure 2.4.\nHe spots a likely candidate.\nJoe Let’s take, for example, getBookLendings. In classic OOP, what would its\narguments be?\nTheo A librarian ID and a member ID.\nJoe So, in traditional OOP, getBookLendings would be a method of a Library\nclass that receives two arguments: librarianId and memberId.\nTheo Yep.\nJoe Now comes the subtle part. In DOP, getBookLendings is part of the Library\nmodule, and it receives the LibraryData as an argument.\nTheo Could you show me what you mean?\nJoe Sure.\nJoe goes over to Theo’s keyboard and starts typing. He enters an example of what a class\nmethod looks like in OOP:\nclass Library {\ncatalog\nuserManagement\ngetBookLendings(userId, memberId) {\n// accesses library state via this.catalog and this.userManagement\n}\n}\nTheo Right! The method accesses the state of the object (in our case, the library\ndata) via this.\nJoe Would you say that the object’s state is an argument of the object’s methods?\nTheo I’d say that the object’s state is an implicit argument to the object’s methods.\nTIP In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\nJoe Well, in DOP, we pass data as an explicit argument. The signature of getBook-\nLendings would look like this.\nListing2.1 The signature of getBookLendings\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\n}\n}\n--- Page 62 ---\n34 CHAPTER 2 Separation between code and data\nJoe The state of the library is stored in libraryData, and libraryData is passed\nto the getBookLendings static method as an explicit argument.\nTheo Is that a general rule?\nJoe Absolutely! The same rule applies to the other functions of the Library mod-\nule and to other modules as well. All of the modules are stateless—they receive\nthe library data that they manipulate as an argument.\nTIP In DOP, functions of a code module are stateless. They receive the data that they\nmanipulate as an explicit argument, which is usually the first argument.\n NOTE A module is an aggregation of functions. In DOP, the module functions are\nstateless.\nTheo It reminds me of Python and the way the self argument appears in method\nsignatures. Here, let me show you an example.\nListing2.2 A Python object as an explicit argument in method signatures\nclass Library:\ncatalog = {}\nuserManagement = {}\ndef getBookLendings(self, userId, memberId):\n# accesses library state via self.catalog and self.userManagement\nJoe Indeed, but the difference I’m talking about is much deeper than a syntax\nchange. It’s about the fact that data lives outside the modules.\nTheo I got that. As you said, module functions are stateless.\nJoe Exactly! Would you like to try and apply this principle across the whole\nLibrary module?\nTheo Sure.\nTheo refines the design of the Library module by including the details about the func-\ntions’ arguments. He presents the diagram in figure 2.5 to Joe.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId) Figure 2.5 The Library module\nreturnBook(libraryData, userId, bookItemId)\nwith the functions’ arguments\nJoe Perfect. Now, we’re ready to tackle the high-level design of our system.\nTheo What’s a high-level design in DOP?\n--- Page 63 ---\n2.3 Code modules 35\nJoe A high-level design in DOP is the definition of modules and the interaction\nbetween them.\nTheo I see. Are there any guidelines to help me define the modules?\nJoe Definitely. The high-level modules of the system correspond to the high-level\ndata entities.\nTheo You mean the data entities that appear in the data mind map?\nJoe Exactly!\nTheo looks again at the data mind map (figure 2.6). He focuses on the high-level data enti-\nties library, catalog, and user management. This means that in the system, besides the\nLibrary module, we have two high-level modules:\n The Catalog module deals with catalog data.\n The UserManagement module deals with user management data.\nCatalog\nLibrary data Figure 2.6 A mind map of the high-\nlevel data entities of the Library\nUser management\nManagement System\nTheo then draws the high-level design of the Library Management System with the Catalog\nand UserManagement modules. Figure 2.7 shows the addition of these modules, where:\n Functions of Catalog receive catalogData as their first argument.\n Functions of UserManagement receive userManagementData as their first argument.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.7 The modules of the Library Management System with their functions’ arguments\n--- Page 64 ---\n36 CHAPTER 2 Separation between code and data\nIt’s not 100% clear for Theo at this point how the data entities get passed between mod-\nules. For the moment, he thinks of libraryData as a class with two members:\n catalog holds the catalog data.\n userManagement holds the user management data.\nTheo also sees that the functions of Library share a common pattern. (Later on in this\nchapter, we’ll see the code for some functions of the Library module.)\n They receive libraryData as an argument.\n They pass libraryData.catalog to the functions of Catalog.\n They pass libraryData.userManagement to the functions of UserManagement.\nTIP The high-level modules of a DOP system correspond to the high-level data enti-\nties.\n2.4 DOP systems are easy to understand\nTheo takes a look at the two diagrams that represent the high-level design of his system:\n The data entities in the data mind map in figure 2.8\n The code modules in the module diagram in figure 2.9\nA bit perplexed, Theo asks Joe:\nTheo I’m not sure that this system is better than a traditional OOP system where\nobjects encapsulate data.\nJoe The main benefit of a DOP system over a traditional OOP system is that it’s eas-\nier to understand.\nTheo What makes it easier to understand?\nJoe The fact that the system is split cleanly into code modules and data entities.\nTheo How does that help?\nJoe When you try to understand the data entities of the system, you don’t have to\nthink about the details of the code that manipulates the data entities.\nTheo So, when I look at the data mind map of my Library Management System, I can\nunderstand it on its own?\nJoe Exactly, and similarly, when you try to understand the code modules of the sys-\ntem, you don’t have to think about the details of the data entities manipulated\nby the code. There is a clear separation of concerns between the code and the\ndata.\nTheo looks again at the data mind map in figure 2.8. He has kind of an Aha! moment:\nData lives on its own!\n NOTE A DOP system is easier to understand because the system is split into two\nparts: data entities and code modules.\n--- Page 65 ---\n2.4 DOP systems are easy to understand 37\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nFigure 2.8 A data mind map of the\nLibrarians\nLibrary Management System\nNow, Theo looks at the module diagram in figure 2.9. He feels a bit confused and asks Joe\nfor clarification:\n On one hand, the module diagram looks similar to the class diagrams from classic\nOOP, boxes for classes and arrows for relations between classes.\n On the other hand, the code module diagram looks much simpler than the class\ndiagrams from classic OOP, but he cannot explain why.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.9 The modules of the Library Management System with the function arguments\nTheo The module diagram seems much simpler than the class diagrams I am used to\nin OOP. I feel it, but I can’t put it into words.\nJoe The reason is that module diagrams have constraints.\n--- Page 66 ---\n38 CHAPTER 2 Separation between code and data\nTheo What kind of constraints?\nJoe Constraints on the functions we saw before. All the functions are static (or\nstateless), but there’s also constraints on the relations between the modules.\nTIP All the functions in a DOP module are stateless.\nTheo In what way are the relations between modules constrained?\nJoe There is a single kind of relation between DOP modules—the usage relation. A\nmodule uses code from another module. There’s no association, no composi-\ntion, and no inheritance between modules. That’s what makes a DOP module\ndiagram easy to understand.\nTheo I understand why there is no association and no composition between DOP\nmodules. After all, association and composition are data relations. But why no\ninheritance relation? Does that mean that DOP is against polymorphism?\nJoe That’s a great question! The quick answer is that in DOP, we achieve polymor-\nphism with a different mechanism than class inheritance. We will talk about it\nsome day.\n NOTE For a discussion of polymorphism in DOP, see chapter 13.\nTheo Now, you’ve piqued my curiosity. I thought inheritance was the only way to\nachieve polymorphism.\nTheo looks again at the module diagram in figure 2.9. Now he not only feels that this dia-\ngram is simpler than traditional OOP class diagrams, he understands why it’s simpler: all\nthe functions are static, and all the relations between modules are of type usage. Table 2.1\nsummarizes Theo’s perception.\nTIP The only kind of relation between DOP modules is the usage relation.\nTable 2.1 What makes each part of a DOP system easy to understand\nSystem part Constraint on entities Constraints on relations\nData entities Members only (no code) Association and composition\nCode modules Stateless functions (no members) Usage (no inheritance)\nTIP Each part of a DOP system is easy to understand because it provides constraints.\n2.5 DOP systems are flexible\nTheo I see how a sharp separation between code and data makes DOP systems easier\nto understand than classic OOP systems. But what about adapting to changes\nin requirements?\nJoe Another benefit of DOP systems is that it is easy to extend them and to adapt to\nchanging requirements.\n--- Page 67 ---\n2.5 DOP systems are flexible 39\nTheo I remember that, when Nancy asked me to add Super members and VIP mem-\nbers to the system, it was hard to adapt my OOP system. I had to introduce a\nfew base classes, and the class hierarchy became really complex.\nJoe I know exactly what you mean. I’ve experienced the same kind of struggle so\nmany times. Describe the changes in the requirements for Super members and\nVIP members, and I’m quite sure that you’ll see how easy it would be to extend\nyour DOP system.\nThe requirements for Super members and VIP members\n Super members are members that are allowed to list the book lendings to\nother members.\n VIP members are members that are allowed to add book items to the library.\nTheo opens his IDE and starts to code the getBookLendings function of the Library\nmodule (see listing 2.3), first without addressing the requirements for Super members.\nTheo remembers what Joe told him about module functions in DOP:\n Functions are stateless.\n Functions receive the data they manipulate as their first argument.\nIn terms of functionality, getBookLendings has two parts:\n Checks that the user is a librarian.\n Retrieves the book lendings from the catalog.\nBasically, the code of getBookLendings has two parts as well:\n Calls the isLibrarian function from the UserManagement module and passes it\nthe UserManagementData.\n Calls the getBookLendings function from the Catalog module and passes it the\nCatalogData.\nListing2.3 Getting the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\n}\ngeneric data collections.\n--- Page 68 ---\n40 CHAPTER 2 Separation between code and data\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nIt’s Theo’s first piece of DOP code and passing around all those data objects—library-\nData, libraryData.userManagement, and libraryData.catalog—feels a bit awkward.\nBut he did it! Joe looks at Theo’s code and seems satisfied.\nJoe Now, how would you adapt your code to Super members?\nTheo I would add a function isSuperMember to the UserManagement module and\ncall it from Library.getBookLendings.\nJoe Exactly! It’s as simple as that.\nTheo types the code on his laptop so that he can show it to Joe. Here’s how Theo adapts\nhis code for Super members.\nListing2.4 Allowing Super members to get the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(Usermanagement.isLibrarian(libraryData.userManagement, userId) ||\nUsermanagement.isSuperMember(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isSuperMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nNow, the awkward feeling caused by passing around all those data objects is dominated by\na feeling of relief. Adapting to this change in requirements takes only a few lines of code\nand requires no changes in the system design. Once again, Joe seems satisfied.\nTIP DOP systems are flexible. Quite often they adapt to changing requirements with-\nout changing the system design.\n--- Page 69 ---\n2.5 DOP systems are flexible 41\nTheo starts coding addBookItem. He looks at the signature of Library.addBookItem,\nand the meaning of the third argument bookItemInfo isn’t clear to him. He asks Joe for\nclarification.\nListing2.5 The signature of Library.addBookItem\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\n}\n}\nTheo What is bookItemInfo?\nJoe Let’s call it the book item information. Imagine we have a way to represent this\ninformation in a data entity named bookItemInfo.\nTheo You mean an object?\nJoe For now, it’s OK to think about bookItemInfo as an object. Later on, I will\nshow you how to we represent data in DOP.\nBesides this subtlety about how the book item information is represented by book-\nItemInfo, the code for Library.addBookItem in listing 2.6 is quite similar to the code\nTheo wrote for Library.getBookLendings in listing 2.4. Once again, Theo is amazed by\nthe fact that adding support for VIP members requires no design change.\nListing2.6 Allowing VIP members to add a book item to the library\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId) ||\nUserManagement.isVIPMember(libraryData.userManagement, userId)) {\nreturn Catalog.addBookItem(libraryData.catalog, bookItemInfo);\n} else {\nthrow \"Not allowed to add a book item\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isVIPMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic addBookItem(catalogData, memberId) {\n// will be implemented later\nIn chapter 4, we will see how\n}\nto manage state of the system\n}\nwith immutable data.\n--- Page 70 ---\n42 CHAPTER 2 Separation between code and data\nTheo It takes a big mindset shift to learn how to separate code from data!\nJoe What was the most challenging thing to accept?\nTheo The fact that data is not encapsulated in objects.\nJoe It was the same for me when I switched from OOP to DOP.\nNow it’s time to eat! Theo takes Joe for lunch at Simple, a nice, small restaurant near the\noffice.\nSummary\n DOP principles are language-agnostic.\n DOP principle #1 is to separate code from data.\n The separation between code and data in DOP systems makes them simpler\n(easier to understand) than traditional OOP systems.\n Data entities are the parts of your system that hold information.\n DOP is against data encapsulation.\n The more flexible a system is, the easier it is to adapt to changing requirements.\n The separation between code and data in DOP systems makes them more flexi-\nble than traditional OOP systems.\n When code is separated from data, we have the freedom to design code and\ndata in isolation.\n We represent data as data entities.\n We discover the data entities of our system and sort them into high-level groups,\neither as a nested list or as a mind map.\n A DOP system is easier to understand than a traditional OOP system because\nthe system is split into two parts: data entities and code modules.\n In DOP, a code module is an aggregation of stateless functions.\n DOP systems are flexible. Quite often they adapt to changing requirements\nwithout changing the system design.\n In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\n Stateless functions receive data they manipulate as an explicit argument.\n The high-level modules of a DOP system correspond to high-level data entities.\n The only kind of relation between code modules is the usage relation.\n The only kinds of relation between data entities are the association and the compo-\nsition relation.\n For a discussion of polymorphism in DOP, see chapter 13.\n--- Page 71 ---\nBasic data manipulation\nMeditation and programming\nThis chapter covers\n Representing records with string maps to improve\nflexibility\n Manipulating data with generic functions\n Accessing each piece of information via its\ninformation path\n Gaining JSON serialization for free\nAfter learning why and how to separate code from data in the previous chapter,\nlet’s talk about data on its own. In contrast to traditional OOP, where system design\ntends to involve a rigid class hierarchy, DOP prescribes that we represent our data\nmodel as a flexible combination of maps and arrays (or lists), where we can access\neach piece of information via an information path. This chapter is a deep dive into\nthe second principle of DOP.\nPRINCIPLE #2 Represent data entities with generic data structures.\n43\n--- Page 72 ---\n44 CHAPTER 3 Basic data manipulation\nWe increase system flexibility when we represent records as string maps and not as\nobjects instantiated from classes. This liberates data from the rigidity of a class-based sys-\ntem. Data becomes a first-class citizen powered by generic functions to add, remove, or\nrename fields.\n NOTE We refer to maps that have strings as keys as string maps.\nThe dependency between the code that manipulates data and the data is a weak\ndependency. The code only needs to know the keys of specific fields in the record it\nwants to manipulate. The code doesn’t even need to know about all the keys in the\nrecord, only the ones relevant to it. In this chapter, we’ll deal only with data query.\nWe’ll discuss managing changes in system state in the next chapter.\n3.1 Designing a data model\nDuring lunch at Simple, Theo and Joe don’t talk about programming. Instead, they start\ngetting to know each other on a personal level. Theo discovers that Joe is married to Kay,\nwho has just opened her creative therapy practice after many years of studying various\nfields related to well-being. Neriah, their 14-year-old son, is passionate about drones, whereas\nAurelia, their 12-year-old daughter, plays the transverse flute.\nJoe tells Theo that he’s been practicing meditation for 10 years. Meditation, he says, has\ntaught him how to break away from being continually lost in a “storm thought” (especially\nnegative thoughts, which can be the source of great suffering) to achieve a more direct\nrelationship with reality. The more he learns to experience reality as it is, the calmer his\nmind. When he first started to practice meditation, it was sometimes difficult and even\nweird, but by persevering, he has increased his feeling of well-being with each passing year.\nWhen they’re back at the office, Joe tells Theo that his next step in their DOP journey\nwill be about data models. This includes data representation.\nJoe When we design the data part of our system, we’re free to do it in isolation.\nTheo What do you mean by isolation?\nJoe I mean that you don’t have to bother with code, only data.\nTheo Oh, right. I remember you telling me how that makes a DOP system simpler\nthan OOP. Separation of concerns is a design principle I’m used to in OOP.\nJoe Indeed.\nTheo And, when we think about data, the only relations we have to think about are\nassociation and composition.\nJoe Correct.\nTheo Will the data model design be significantly different than the data model I’m\nused to designing as an OOP developer?\nJoe Not so much.\nTheo OK. Let me see if I can draw a DOP-style data entity diagram.\nTheo takes a look at the data mind map that he drew earlier in the morning. He then\ndraws the diagram in figure 3.1.\nHe refines the details of the fields of each data entity and the kind of relations between\nentities. Figure 3.2 shows the result of this redefined data entity diagram.\n--- Page 73 ---\n3.1 Designing a data model 45\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 3.1 A data mind map of\nthe Library Management System\nCC Library\nname: String\naddress: String\nCC Catalog CC UserManagement\n* * *\nCC Book CC Librarian CC Member\nemail: String email: String\ntitle : String\npassword: String password: String\npublicationYear: Number\n*\nISBN: String\npublisher: String\n* *\nCC Author CC BookLending\nname: String lendingDate: String\nCC BookItem\n* libld: String\npurchaseDate: String\nFigure 3.2 A data model of the Library Management System\n--- Page 74 ---\n46 CHAPTER 3 Basic data manipulation\nJoe The next step is to be more explicit about the relations between entities.\nTheo What do you mean?\nJoe For example, in your entity diagram, Book and Author are connected by a\nmany-to-many association relation. How is this relation going to be repre-\nsented in your program?\nTheo In the Book entity, there will be a collection of author IDs, and in the Author\nentity, there will be a collection of book IDs.\nJoe Sounds good. And what will the book ID be?\nTheo The book ISBN.\n NOTE The International Standard Book Number (ISBN) is a numeric commercial\nbook identifier that is intended to be unique.\nJoe And where will you hold the index that enables you to retrieve a Book from its\nISBN?\nTheo In the Catalog because the catalog holds a bookByISBN index.\nJoe What about author ID?\nTheo Author ID is the author name in lowercase and with dashes instead of white\nspaces (assuming that we don’t have two authors with the same name).\nJoe And I guess that you also hold the author index in the Catalog?\nTheo Exactly!\nJoe Excellent. You’ve been 100% explicit about the relation between Book and\nAuthor. I’ll ask you to do the same with the other relations of the system.\nIt’s quite easy for Theo to do, as he has done that so many times as an OOP developer. Fig-\nure 3.3 provides the detailed entity diagram of Theo’s system.\n NOTE By positional collection, we mean a collection where the elements are in order\n(like a list or an array). By index, we mean a collection where the elements are accessi-\nble via a key (like a hash map or a dictionary).\nThe Catalog entity contains two indexes:\n booksByIsbn—The keys are book ISBNs, and the values are Book entities. Its type is\nnoted as {Book}.\n authorsById—The keys are author IDs, and the values are Author entities. Its type\nis noted as {Author}.\nInside a Book entity, we have authors, which is a positional collection of author IDs of type\n[String]. Inside an Author entity, we have books, which is a collection of book IDs of\ntype [String].\n NOTE For the notation for collections and index types, a positional collection of\nStrings is noted as [String]. An index of Books is noted as {Book}. In the context of\na data model, the index keys are always strings.\n--- Page 75 ---\n3.1 Designing a data model 47\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: UserManagement\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian\nCC Book i n d a : m S e tr : i n S g tring email: String CC Me * mber\ntitle : String encryptedPassword: String\nbookIsbns: [String] email: String\npublicationYear: Number\nencryptedPassword: String\nisbn: String *\nisBlocked: Boolean\nauthorIds: [String]\nbookLendings: [BookLending]\nbookItems: [BookItem] *\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.3 Library management relation model. Dashed lines (e.g., between Book and Author) denote\nindirect relations, [String] denotes a positional collection of strings, and {Book} denotes an index of\nBooks.\nThere is a dashed line between Book and Author, which means that the relation between\nBook and Author is indirect. To access the collection of Author entities from a Book entity,\nwe’ll use the authorById index defined in the Catalog entity.\nJoe I like your data entity diagram.\nTheo Thank you.\nJoe Can you tell me what the three kinds of data aggregations are in your diagram\n(and, in fact, in any data entity diagram)?\nTheo Let’s see...we have positional collections like authors in Book. We have\nindexes like booksByIsbn in Catalog. I can’t find the third one.\nJoe The third kind of data aggregation is what we’ve called, until now, an “entity”\n(like Library, Catalog, Book, etc.), and the common term for entity in com-\nputer science is record.",
        "sections_found": []
      },
      "accurate_page_range": "56-75"
    },
    {
      "text": "- 2.4 DOP systems are easy to understand",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "raw_line": "- 2.4 DOP systems are easy to understand (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 18,
      "chapter_info": {
        "page": 56,
        "title": "Separation between code and data",
        "pattern_matched": "Chapter 2",
        "text_preview": "28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his te"
      },
      "chapter_sections": {
        "start_page": 56,
        "end_page": 75,
        "content": "\n--- Page 56 ---\n28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his team have built in Clojure over the last 7\nyears are less complex and more flexible than the systems he used to build in Java. Accord-\ning to Joe, the systems they build now tend to be much simpler because they follow the\nprinciples of DOP.\nTheo I’ve never heard of data-oriented programming. Is it a new concept?\nJoe Yes and no. Most of the foundational ideas of data-oriented programming, or\nDOP as we like to call it, are well known to programmers as best practices. The\nnovelty of DOP, however, is that it combines best practices into a cohesive\nwhole.\nTheo That’s a bit abstract for me. Can you give me an example?\nJoe Sure! Take, for instance, the first insight of DOP. It’s about the relations between\ncode and data.\nTheo You mean the encapsulation of data in objects?\nJoe Actually, DOP is against data encapsulation.\nTheo Why is that? I thought data encapsulation was a positive programming paradigm.\nJoe Data encapsulation has both merits and drawbacks. Think about the way you\ndesigned the Library Management System. According to DOP, the main cause\nof complexity and inflexibility in systems is that code and data are mixed\ntogether in objects.\nTIP DOP is against data encapsulation.\nTheo It sounds similar to what I’ve heard about functional programming. So, if I\nwant to adopt DOP, do I need to get rid of object-oriented programming and\nlearn functional programming?\nJoe No, DOP principles are language-agnostic. They can be applied in both object-\noriented and functional programming languages.\nTheo That’s a relief! I was afraid that you were going to teach me about monads,\nalgebraic data types, and higher order functions.\nJoe No, none of that is required in DOP.\nTIP DOP principles are language-agnostic.\nTheo What does the separation between code and data look like in DOP then?\nJoe Data is represented by data entities that only hold members. Code is aggre-\ngated into modules where all functions are stateless.\nTheo What do you mean by stateless functions?\nJoe Instead of having the state encapsulated in the object, the data entity is passed\nas an argument.\nTheo I don’t get that.\nJoe Here, let’s make it visual.\n--- Page 57 ---\n2.2 Data entities 29\nJoe steps up to a whiteboard and quickly draws a diagram to illustrate his comment. Fig-\nure 2.2 shows Joe’s drawing.\nCode modules Stateless functions\nSeparate code from data\nData entities Only members\nFigure 2.2 The separation between code and data\nTheo It’s still not clear.\nJoe It will become clearer when I show you how it looks in the context of your\nLibrary Management System.\nTheo OK. Shall we start with code or with data?\nJoe Well, it’s data-oriented programming, so let’s start with data.\n2.2 Data entities\nIn DOP, we start the design process by discovering the data entities of our system.\nHere’s what Joe and Theo have to say about data entities.\nJoe What are the data entities of your system?\nTheo What do you mean by data entities?\nJoe I mean the parts of your system that hold information.\n NOTE Data entities are the parts of your system that hold information.\nTheo Well, it’s a Library Management System, so we have books and members.\nJoe Of course, but there are more. One way to discover the data entities of a system\nis to look for nouns and noun phrases in the requirements of the system.\nTheo looks at Nancy’s requirement napkin. He highlights the nouns and noun phrases\nthat seem to represent data entities.\nHighlighting terms in the requirements that correspond to data entities\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n--- Page 58 ---\n30 CHAPTER 2 Separation between code and data\nJoe Excellent. Can you see a natural way to group these entities?\nTheo Not sure, but it seems to me that users, members, and librarians form one\ngroup, whereas books, authors, and book copies form another group.\nJoe Sounds good to me. What would you call each group?\nTheo Probably user management for the first group and catalog for the second\ngroup.\nThe data entities of the system organized in a nested list\n The catalog data\n– Data about books\n– Data about authors\n– Data about book items\n– Data about book lendings\n The user management data\n– Data about users\n– Data about members\n– Data about librarians\nTheo I’m not sure about the relations between books and authors. Should it be asso-\nciation or composition?\nJoe Don’t worry too much about the details for the moment. We’ll refine our data\nentity design later. For now, let’s visualize the two groups in a mind map.\nTheo and Joe confer for a bit. Figure 2.3 shows the mind map they come up with.\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 2.3 The data entities of the\nsystem organized in a mind map\n--- Page 59 ---\n2.3 Code modules 31\nThe most precise way to visualize the data entities of a DOP system is to draw a data\nentity diagram with different arrows for association and composition. We will come\nback to data entity diagrams later.\nTIP Discover the data entities of your system and then sort them into high-level\ngroups, either as a nested list or as a mind map.\nWe will dive deeper into the design and representation of data entities in the next\nchapter. For now, let’s simplify things and say that the data of our library system is\nmade of two high-level groups: user management and catalog.\n2.3 Code modules\nThe second step of the design process in DOP is to define the code modules. Let’s lis-\nten in on Joe and Theo again.\nJoe Now that you have identified the data entities of your system and have\narranged them into high-level groups, it’s time to think about the code part of\nyour system.\nTheo What do you mean by the code part?\nJoe One way to think about that is to identity the functionality of your system.\nTheo looks again at Nancy’s requirements. This time he highlights the verb phrases that\nrepresent functionality.\nHighlighting terms in the requirements that correspond to functionality\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\nIn addition, it’s obvious to Theo that members can also return a book. Moreover, there\nshould be a way to detect whether a user is a librarian or not. He adds those to the require-\nments and then lists the functionality of the system.\nThe functionality of the library system\n Search for a book.\n Add a book item.\n Block a member.\n--- Page 60 ---\n32 CHAPTER 2 Separation between code and data\n(continued)\n Unblock a member.\n Log a user into the system.\n List the books currently lent to a member.\n Borrow a book.\n Return a book.\n Check whether a user is a librarian.\nJoe Excellent! Now, tell me what functionality needs to be exposed to the outside\nworld?\nTheo What do you mean by exposed to the outside world?\nJoe Imagine that the Library Management System exposes an API over HTTP.\nWhat functionality would be exposed by the HTTP endpoints?\nTheo Well, all system functionality would be exposed except checking to see if a user\nis a librarian.\nJoe OK. Now give each exposed function a short name and gather them together\nin a module box called Library.\nThat takes Theo less than a minute. Figure 2.4 shows the module that contains the\nexposed functions of the library devised by Theo.\nC Library\nsearchBook()\naddBookItem()\nblockMember()\nunblockMember()\ngetBookLendings() Figure 2.4 The Library module\ncheckoutBook() contains the exposed functions of the\nreturnBook() Library Management System.\nTIP The first step in designing the code part of a DOP system is to aggregate the\nexposed functions into a single module.\nJoe Beautiful! You just created your first code module.\nTheo To me it looks like a class. What’s the difference between a module and a class?\nJoe A module is an aggregation of functions. In OOP, a module is represented\nbya class, but in other programming languages, it might be a package or a\nnamespace.\nTheo I see.\nJoe The important thing about DOP code modules is that they contain only state-\nless functions.\nTheo You mean like static methods in Java?\nJoe Yes, and the classes of these static methods should not have any data members.\n--- Page 61 ---\n2.3 Code modules 33\nTheo So, how do the functions know what piece of information they operate on?\nJoe Easy. We pass that as the first argument to the function.\nTheo OK. Can you give me an example?\nJoe, biting his nails, takes a look at the list of functions of the Library module in figure 2.4.\nHe spots a likely candidate.\nJoe Let’s take, for example, getBookLendings. In classic OOP, what would its\narguments be?\nTheo A librarian ID and a member ID.\nJoe So, in traditional OOP, getBookLendings would be a method of a Library\nclass that receives two arguments: librarianId and memberId.\nTheo Yep.\nJoe Now comes the subtle part. In DOP, getBookLendings is part of the Library\nmodule, and it receives the LibraryData as an argument.\nTheo Could you show me what you mean?\nJoe Sure.\nJoe goes over to Theo’s keyboard and starts typing. He enters an example of what a class\nmethod looks like in OOP:\nclass Library {\ncatalog\nuserManagement\ngetBookLendings(userId, memberId) {\n// accesses library state via this.catalog and this.userManagement\n}\n}\nTheo Right! The method accesses the state of the object (in our case, the library\ndata) via this.\nJoe Would you say that the object’s state is an argument of the object’s methods?\nTheo I’d say that the object’s state is an implicit argument to the object’s methods.\nTIP In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\nJoe Well, in DOP, we pass data as an explicit argument. The signature of getBook-\nLendings would look like this.\nListing2.1 The signature of getBookLendings\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\n}\n}\n--- Page 62 ---\n34 CHAPTER 2 Separation between code and data\nJoe The state of the library is stored in libraryData, and libraryData is passed\nto the getBookLendings static method as an explicit argument.\nTheo Is that a general rule?\nJoe Absolutely! The same rule applies to the other functions of the Library mod-\nule and to other modules as well. All of the modules are stateless—they receive\nthe library data that they manipulate as an argument.\nTIP In DOP, functions of a code module are stateless. They receive the data that they\nmanipulate as an explicit argument, which is usually the first argument.\n NOTE A module is an aggregation of functions. In DOP, the module functions are\nstateless.\nTheo It reminds me of Python and the way the self argument appears in method\nsignatures. Here, let me show you an example.\nListing2.2 A Python object as an explicit argument in method signatures\nclass Library:\ncatalog = {}\nuserManagement = {}\ndef getBookLendings(self, userId, memberId):\n# accesses library state via self.catalog and self.userManagement\nJoe Indeed, but the difference I’m talking about is much deeper than a syntax\nchange. It’s about the fact that data lives outside the modules.\nTheo I got that. As you said, module functions are stateless.\nJoe Exactly! Would you like to try and apply this principle across the whole\nLibrary module?\nTheo Sure.\nTheo refines the design of the Library module by including the details about the func-\ntions’ arguments. He presents the diagram in figure 2.5 to Joe.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId) Figure 2.5 The Library module\nreturnBook(libraryData, userId, bookItemId)\nwith the functions’ arguments\nJoe Perfect. Now, we’re ready to tackle the high-level design of our system.\nTheo What’s a high-level design in DOP?\n--- Page 63 ---\n2.3 Code modules 35\nJoe A high-level design in DOP is the definition of modules and the interaction\nbetween them.\nTheo I see. Are there any guidelines to help me define the modules?\nJoe Definitely. The high-level modules of the system correspond to the high-level\ndata entities.\nTheo You mean the data entities that appear in the data mind map?\nJoe Exactly!\nTheo looks again at the data mind map (figure 2.6). He focuses on the high-level data enti-\nties library, catalog, and user management. This means that in the system, besides the\nLibrary module, we have two high-level modules:\n The Catalog module deals with catalog data.\n The UserManagement module deals with user management data.\nCatalog\nLibrary data Figure 2.6 A mind map of the high-\nlevel data entities of the Library\nUser management\nManagement System\nTheo then draws the high-level design of the Library Management System with the Catalog\nand UserManagement modules. Figure 2.7 shows the addition of these modules, where:\n Functions of Catalog receive catalogData as their first argument.\n Functions of UserManagement receive userManagementData as their first argument.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.7 The modules of the Library Management System with their functions’ arguments\n--- Page 64 ---\n36 CHAPTER 2 Separation between code and data\nIt’s not 100% clear for Theo at this point how the data entities get passed between mod-\nules. For the moment, he thinks of libraryData as a class with two members:\n catalog holds the catalog data.\n userManagement holds the user management data.\nTheo also sees that the functions of Library share a common pattern. (Later on in this\nchapter, we’ll see the code for some functions of the Library module.)\n They receive libraryData as an argument.\n They pass libraryData.catalog to the functions of Catalog.\n They pass libraryData.userManagement to the functions of UserManagement.\nTIP The high-level modules of a DOP system correspond to the high-level data enti-\nties.\n2.4 DOP systems are easy to understand\nTheo takes a look at the two diagrams that represent the high-level design of his system:\n The data entities in the data mind map in figure 2.8\n The code modules in the module diagram in figure 2.9\nA bit perplexed, Theo asks Joe:\nTheo I’m not sure that this system is better than a traditional OOP system where\nobjects encapsulate data.\nJoe The main benefit of a DOP system over a traditional OOP system is that it’s eas-\nier to understand.\nTheo What makes it easier to understand?\nJoe The fact that the system is split cleanly into code modules and data entities.\nTheo How does that help?\nJoe When you try to understand the data entities of the system, you don’t have to\nthink about the details of the code that manipulates the data entities.\nTheo So, when I look at the data mind map of my Library Management System, I can\nunderstand it on its own?\nJoe Exactly, and similarly, when you try to understand the code modules of the sys-\ntem, you don’t have to think about the details of the data entities manipulated\nby the code. There is a clear separation of concerns between the code and the\ndata.\nTheo looks again at the data mind map in figure 2.8. He has kind of an Aha! moment:\nData lives on its own!\n NOTE A DOP system is easier to understand because the system is split into two\nparts: data entities and code modules.\n--- Page 65 ---\n2.4 DOP systems are easy to understand 37\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nFigure 2.8 A data mind map of the\nLibrarians\nLibrary Management System\nNow, Theo looks at the module diagram in figure 2.9. He feels a bit confused and asks Joe\nfor clarification:\n On one hand, the module diagram looks similar to the class diagrams from classic\nOOP, boxes for classes and arrows for relations between classes.\n On the other hand, the code module diagram looks much simpler than the class\ndiagrams from classic OOP, but he cannot explain why.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.9 The modules of the Library Management System with the function arguments\nTheo The module diagram seems much simpler than the class diagrams I am used to\nin OOP. I feel it, but I can’t put it into words.\nJoe The reason is that module diagrams have constraints.\n--- Page 66 ---\n38 CHAPTER 2 Separation between code and data\nTheo What kind of constraints?\nJoe Constraints on the functions we saw before. All the functions are static (or\nstateless), but there’s also constraints on the relations between the modules.\nTIP All the functions in a DOP module are stateless.\nTheo In what way are the relations between modules constrained?\nJoe There is a single kind of relation between DOP modules—the usage relation. A\nmodule uses code from another module. There’s no association, no composi-\ntion, and no inheritance between modules. That’s what makes a DOP module\ndiagram easy to understand.\nTheo I understand why there is no association and no composition between DOP\nmodules. After all, association and composition are data relations. But why no\ninheritance relation? Does that mean that DOP is against polymorphism?\nJoe That’s a great question! The quick answer is that in DOP, we achieve polymor-\nphism with a different mechanism than class inheritance. We will talk about it\nsome day.\n NOTE For a discussion of polymorphism in DOP, see chapter 13.\nTheo Now, you’ve piqued my curiosity. I thought inheritance was the only way to\nachieve polymorphism.\nTheo looks again at the module diagram in figure 2.9. Now he not only feels that this dia-\ngram is simpler than traditional OOP class diagrams, he understands why it’s simpler: all\nthe functions are static, and all the relations between modules are of type usage. Table 2.1\nsummarizes Theo’s perception.\nTIP The only kind of relation between DOP modules is the usage relation.\nTable 2.1 What makes each part of a DOP system easy to understand\nSystem part Constraint on entities Constraints on relations\nData entities Members only (no code) Association and composition\nCode modules Stateless functions (no members) Usage (no inheritance)\nTIP Each part of a DOP system is easy to understand because it provides constraints.\n2.5 DOP systems are flexible\nTheo I see how a sharp separation between code and data makes DOP systems easier\nto understand than classic OOP systems. But what about adapting to changes\nin requirements?\nJoe Another benefit of DOP systems is that it is easy to extend them and to adapt to\nchanging requirements.\n--- Page 67 ---\n2.5 DOP systems are flexible 39\nTheo I remember that, when Nancy asked me to add Super members and VIP mem-\nbers to the system, it was hard to adapt my OOP system. I had to introduce a\nfew base classes, and the class hierarchy became really complex.\nJoe I know exactly what you mean. I’ve experienced the same kind of struggle so\nmany times. Describe the changes in the requirements for Super members and\nVIP members, and I’m quite sure that you’ll see how easy it would be to extend\nyour DOP system.\nThe requirements for Super members and VIP members\n Super members are members that are allowed to list the book lendings to\nother members.\n VIP members are members that are allowed to add book items to the library.\nTheo opens his IDE and starts to code the getBookLendings function of the Library\nmodule (see listing 2.3), first without addressing the requirements for Super members.\nTheo remembers what Joe told him about module functions in DOP:\n Functions are stateless.\n Functions receive the data they manipulate as their first argument.\nIn terms of functionality, getBookLendings has two parts:\n Checks that the user is a librarian.\n Retrieves the book lendings from the catalog.\nBasically, the code of getBookLendings has two parts as well:\n Calls the isLibrarian function from the UserManagement module and passes it\nthe UserManagementData.\n Calls the getBookLendings function from the Catalog module and passes it the\nCatalogData.\nListing2.3 Getting the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\n}\ngeneric data collections.\n--- Page 68 ---\n40 CHAPTER 2 Separation between code and data\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nIt’s Theo’s first piece of DOP code and passing around all those data objects—library-\nData, libraryData.userManagement, and libraryData.catalog—feels a bit awkward.\nBut he did it! Joe looks at Theo’s code and seems satisfied.\nJoe Now, how would you adapt your code to Super members?\nTheo I would add a function isSuperMember to the UserManagement module and\ncall it from Library.getBookLendings.\nJoe Exactly! It’s as simple as that.\nTheo types the code on his laptop so that he can show it to Joe. Here’s how Theo adapts\nhis code for Super members.\nListing2.4 Allowing Super members to get the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(Usermanagement.isLibrarian(libraryData.userManagement, userId) ||\nUsermanagement.isSuperMember(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isSuperMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nNow, the awkward feeling caused by passing around all those data objects is dominated by\na feeling of relief. Adapting to this change in requirements takes only a few lines of code\nand requires no changes in the system design. Once again, Joe seems satisfied.\nTIP DOP systems are flexible. Quite often they adapt to changing requirements with-\nout changing the system design.\n--- Page 69 ---\n2.5 DOP systems are flexible 41\nTheo starts coding addBookItem. He looks at the signature of Library.addBookItem,\nand the meaning of the third argument bookItemInfo isn’t clear to him. He asks Joe for\nclarification.\nListing2.5 The signature of Library.addBookItem\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\n}\n}\nTheo What is bookItemInfo?\nJoe Let’s call it the book item information. Imagine we have a way to represent this\ninformation in a data entity named bookItemInfo.\nTheo You mean an object?\nJoe For now, it’s OK to think about bookItemInfo as an object. Later on, I will\nshow you how to we represent data in DOP.\nBesides this subtlety about how the book item information is represented by book-\nItemInfo, the code for Library.addBookItem in listing 2.6 is quite similar to the code\nTheo wrote for Library.getBookLendings in listing 2.4. Once again, Theo is amazed by\nthe fact that adding support for VIP members requires no design change.\nListing2.6 Allowing VIP members to add a book item to the library\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId) ||\nUserManagement.isVIPMember(libraryData.userManagement, userId)) {\nreturn Catalog.addBookItem(libraryData.catalog, bookItemInfo);\n} else {\nthrow \"Not allowed to add a book item\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isVIPMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic addBookItem(catalogData, memberId) {\n// will be implemented later\nIn chapter 4, we will see how\n}\nto manage state of the system\n}\nwith immutable data.\n--- Page 70 ---\n42 CHAPTER 2 Separation between code and data\nTheo It takes a big mindset shift to learn how to separate code from data!\nJoe What was the most challenging thing to accept?\nTheo The fact that data is not encapsulated in objects.\nJoe It was the same for me when I switched from OOP to DOP.\nNow it’s time to eat! Theo takes Joe for lunch at Simple, a nice, small restaurant near the\noffice.\nSummary\n DOP principles are language-agnostic.\n DOP principle #1 is to separate code from data.\n The separation between code and data in DOP systems makes them simpler\n(easier to understand) than traditional OOP systems.\n Data entities are the parts of your system that hold information.\n DOP is against data encapsulation.\n The more flexible a system is, the easier it is to adapt to changing requirements.\n The separation between code and data in DOP systems makes them more flexi-\nble than traditional OOP systems.\n When code is separated from data, we have the freedom to design code and\ndata in isolation.\n We represent data as data entities.\n We discover the data entities of our system and sort them into high-level groups,\neither as a nested list or as a mind map.\n A DOP system is easier to understand than a traditional OOP system because\nthe system is split into two parts: data entities and code modules.\n In DOP, a code module is an aggregation of stateless functions.\n DOP systems are flexible. Quite often they adapt to changing requirements\nwithout changing the system design.\n In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\n Stateless functions receive data they manipulate as an explicit argument.\n The high-level modules of a DOP system correspond to high-level data entities.\n The only kind of relation between code modules is the usage relation.\n The only kinds of relation between data entities are the association and the compo-\nsition relation.\n For a discussion of polymorphism in DOP, see chapter 13.\n--- Page 71 ---\nBasic data manipulation\nMeditation and programming\nThis chapter covers\n Representing records with string maps to improve\nflexibility\n Manipulating data with generic functions\n Accessing each piece of information via its\ninformation path\n Gaining JSON serialization for free\nAfter learning why and how to separate code from data in the previous chapter,\nlet’s talk about data on its own. In contrast to traditional OOP, where system design\ntends to involve a rigid class hierarchy, DOP prescribes that we represent our data\nmodel as a flexible combination of maps and arrays (or lists), where we can access\neach piece of information via an information path. This chapter is a deep dive into\nthe second principle of DOP.\nPRINCIPLE #2 Represent data entities with generic data structures.\n43\n--- Page 72 ---\n44 CHAPTER 3 Basic data manipulation\nWe increase system flexibility when we represent records as string maps and not as\nobjects instantiated from classes. This liberates data from the rigidity of a class-based sys-\ntem. Data becomes a first-class citizen powered by generic functions to add, remove, or\nrename fields.\n NOTE We refer to maps that have strings as keys as string maps.\nThe dependency between the code that manipulates data and the data is a weak\ndependency. The code only needs to know the keys of specific fields in the record it\nwants to manipulate. The code doesn’t even need to know about all the keys in the\nrecord, only the ones relevant to it. In this chapter, we’ll deal only with data query.\nWe’ll discuss managing changes in system state in the next chapter.\n3.1 Designing a data model\nDuring lunch at Simple, Theo and Joe don’t talk about programming. Instead, they start\ngetting to know each other on a personal level. Theo discovers that Joe is married to Kay,\nwho has just opened her creative therapy practice after many years of studying various\nfields related to well-being. Neriah, their 14-year-old son, is passionate about drones, whereas\nAurelia, their 12-year-old daughter, plays the transverse flute.\nJoe tells Theo that he’s been practicing meditation for 10 years. Meditation, he says, has\ntaught him how to break away from being continually lost in a “storm thought” (especially\nnegative thoughts, which can be the source of great suffering) to achieve a more direct\nrelationship with reality. The more he learns to experience reality as it is, the calmer his\nmind. When he first started to practice meditation, it was sometimes difficult and even\nweird, but by persevering, he has increased his feeling of well-being with each passing year.\nWhen they’re back at the office, Joe tells Theo that his next step in their DOP journey\nwill be about data models. This includes data representation.\nJoe When we design the data part of our system, we’re free to do it in isolation.\nTheo What do you mean by isolation?\nJoe I mean that you don’t have to bother with code, only data.\nTheo Oh, right. I remember you telling me how that makes a DOP system simpler\nthan OOP. Separation of concerns is a design principle I’m used to in OOP.\nJoe Indeed.\nTheo And, when we think about data, the only relations we have to think about are\nassociation and composition.\nJoe Correct.\nTheo Will the data model design be significantly different than the data model I’m\nused to designing as an OOP developer?\nJoe Not so much.\nTheo OK. Let me see if I can draw a DOP-style data entity diagram.\nTheo takes a look at the data mind map that he drew earlier in the morning. He then\ndraws the diagram in figure 3.1.\nHe refines the details of the fields of each data entity and the kind of relations between\nentities. Figure 3.2 shows the result of this redefined data entity diagram.\n--- Page 73 ---\n3.1 Designing a data model 45\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 3.1 A data mind map of\nthe Library Management System\nCC Library\nname: String\naddress: String\nCC Catalog CC UserManagement\n* * *\nCC Book CC Librarian CC Member\nemail: String email: String\ntitle : String\npassword: String password: String\npublicationYear: Number\n*\nISBN: String\npublisher: String\n* *\nCC Author CC BookLending\nname: String lendingDate: String\nCC BookItem\n* libld: String\npurchaseDate: String\nFigure 3.2 A data model of the Library Management System\n--- Page 74 ---\n46 CHAPTER 3 Basic data manipulation\nJoe The next step is to be more explicit about the relations between entities.\nTheo What do you mean?\nJoe For example, in your entity diagram, Book and Author are connected by a\nmany-to-many association relation. How is this relation going to be repre-\nsented in your program?\nTheo In the Book entity, there will be a collection of author IDs, and in the Author\nentity, there will be a collection of book IDs.\nJoe Sounds good. And what will the book ID be?\nTheo The book ISBN.\n NOTE The International Standard Book Number (ISBN) is a numeric commercial\nbook identifier that is intended to be unique.\nJoe And where will you hold the index that enables you to retrieve a Book from its\nISBN?\nTheo In the Catalog because the catalog holds a bookByISBN index.\nJoe What about author ID?\nTheo Author ID is the author name in lowercase and with dashes instead of white\nspaces (assuming that we don’t have two authors with the same name).\nJoe And I guess that you also hold the author index in the Catalog?\nTheo Exactly!\nJoe Excellent. You’ve been 100% explicit about the relation between Book and\nAuthor. I’ll ask you to do the same with the other relations of the system.\nIt’s quite easy for Theo to do, as he has done that so many times as an OOP developer. Fig-\nure 3.3 provides the detailed entity diagram of Theo’s system.\n NOTE By positional collection, we mean a collection where the elements are in order\n(like a list or an array). By index, we mean a collection where the elements are accessi-\nble via a key (like a hash map or a dictionary).\nThe Catalog entity contains two indexes:\n booksByIsbn—The keys are book ISBNs, and the values are Book entities. Its type is\nnoted as {Book}.\n authorsById—The keys are author IDs, and the values are Author entities. Its type\nis noted as {Author}.\nInside a Book entity, we have authors, which is a positional collection of author IDs of type\n[String]. Inside an Author entity, we have books, which is a collection of book IDs of\ntype [String].\n NOTE For the notation for collections and index types, a positional collection of\nStrings is noted as [String]. An index of Books is noted as {Book}. In the context of\na data model, the index keys are always strings.\n--- Page 75 ---\n3.1 Designing a data model 47\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: UserManagement\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian\nCC Book i n d a : m S e tr : i n S g tring email: String CC Me * mber\ntitle : String encryptedPassword: String\nbookIsbns: [String] email: String\npublicationYear: Number\nencryptedPassword: String\nisbn: String *\nisBlocked: Boolean\nauthorIds: [String]\nbookLendings: [BookLending]\nbookItems: [BookItem] *\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.3 Library management relation model. Dashed lines (e.g., between Book and Author) denote\nindirect relations, [String] denotes a positional collection of strings, and {Book} denotes an index of\nBooks.\nThere is a dashed line between Book and Author, which means that the relation between\nBook and Author is indirect. To access the collection of Author entities from a Book entity,\nwe’ll use the authorById index defined in the Catalog entity.\nJoe I like your data entity diagram.\nTheo Thank you.\nJoe Can you tell me what the three kinds of data aggregations are in your diagram\n(and, in fact, in any data entity diagram)?\nTheo Let’s see...we have positional collections like authors in Book. We have\nindexes like booksByIsbn in Catalog. I can’t find the third one.\nJoe The third kind of data aggregation is what we’ve called, until now, an “entity”\n(like Library, Catalog, Book, etc.), and the common term for entity in com-\nputer science is record.",
        "sections_found": []
      },
      "accurate_page_range": "56-75"
    },
    {
      "text": "- 2.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "raw_line": "- 2.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 19,
      "chapter_info": {
        "page": 56,
        "title": "Separation between code and data",
        "pattern_matched": "Chapter 2",
        "text_preview": "28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his te"
      },
      "chapter_sections": {
        "start_page": 56,
        "end_page": 75,
        "content": "\n--- Page 56 ---\n28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his team have built in Clojure over the last 7\nyears are less complex and more flexible than the systems he used to build in Java. Accord-\ning to Joe, the systems they build now tend to be much simpler because they follow the\nprinciples of DOP.\nTheo I’ve never heard of data-oriented programming. Is it a new concept?\nJoe Yes and no. Most of the foundational ideas of data-oriented programming, or\nDOP as we like to call it, are well known to programmers as best practices. The\nnovelty of DOP, however, is that it combines best practices into a cohesive\nwhole.\nTheo That’s a bit abstract for me. Can you give me an example?\nJoe Sure! Take, for instance, the first insight of DOP. It’s about the relations between\ncode and data.\nTheo You mean the encapsulation of data in objects?\nJoe Actually, DOP is against data encapsulation.\nTheo Why is that? I thought data encapsulation was a positive programming paradigm.\nJoe Data encapsulation has both merits and drawbacks. Think about the way you\ndesigned the Library Management System. According to DOP, the main cause\nof complexity and inflexibility in systems is that code and data are mixed\ntogether in objects.\nTIP DOP is against data encapsulation.\nTheo It sounds similar to what I’ve heard about functional programming. So, if I\nwant to adopt DOP, do I need to get rid of object-oriented programming and\nlearn functional programming?\nJoe No, DOP principles are language-agnostic. They can be applied in both object-\noriented and functional programming languages.\nTheo That’s a relief! I was afraid that you were going to teach me about monads,\nalgebraic data types, and higher order functions.\nJoe No, none of that is required in DOP.\nTIP DOP principles are language-agnostic.\nTheo What does the separation between code and data look like in DOP then?\nJoe Data is represented by data entities that only hold members. Code is aggre-\ngated into modules where all functions are stateless.\nTheo What do you mean by stateless functions?\nJoe Instead of having the state encapsulated in the object, the data entity is passed\nas an argument.\nTheo I don’t get that.\nJoe Here, let’s make it visual.\n--- Page 57 ---\n2.2 Data entities 29\nJoe steps up to a whiteboard and quickly draws a diagram to illustrate his comment. Fig-\nure 2.2 shows Joe’s drawing.\nCode modules Stateless functions\nSeparate code from data\nData entities Only members\nFigure 2.2 The separation between code and data\nTheo It’s still not clear.\nJoe It will become clearer when I show you how it looks in the context of your\nLibrary Management System.\nTheo OK. Shall we start with code or with data?\nJoe Well, it’s data-oriented programming, so let’s start with data.\n2.2 Data entities\nIn DOP, we start the design process by discovering the data entities of our system.\nHere’s what Joe and Theo have to say about data entities.\nJoe What are the data entities of your system?\nTheo What do you mean by data entities?\nJoe I mean the parts of your system that hold information.\n NOTE Data entities are the parts of your system that hold information.\nTheo Well, it’s a Library Management System, so we have books and members.\nJoe Of course, but there are more. One way to discover the data entities of a system\nis to look for nouns and noun phrases in the requirements of the system.\nTheo looks at Nancy’s requirement napkin. He highlights the nouns and noun phrases\nthat seem to represent data entities.\nHighlighting terms in the requirements that correspond to data entities\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n--- Page 58 ---\n30 CHAPTER 2 Separation between code and data\nJoe Excellent. Can you see a natural way to group these entities?\nTheo Not sure, but it seems to me that users, members, and librarians form one\ngroup, whereas books, authors, and book copies form another group.\nJoe Sounds good to me. What would you call each group?\nTheo Probably user management for the first group and catalog for the second\ngroup.\nThe data entities of the system organized in a nested list\n The catalog data\n– Data about books\n– Data about authors\n– Data about book items\n– Data about book lendings\n The user management data\n– Data about users\n– Data about members\n– Data about librarians\nTheo I’m not sure about the relations between books and authors. Should it be asso-\nciation or composition?\nJoe Don’t worry too much about the details for the moment. We’ll refine our data\nentity design later. For now, let’s visualize the two groups in a mind map.\nTheo and Joe confer for a bit. Figure 2.3 shows the mind map they come up with.\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 2.3 The data entities of the\nsystem organized in a mind map\n--- Page 59 ---\n2.3 Code modules 31\nThe most precise way to visualize the data entities of a DOP system is to draw a data\nentity diagram with different arrows for association and composition. We will come\nback to data entity diagrams later.\nTIP Discover the data entities of your system and then sort them into high-level\ngroups, either as a nested list or as a mind map.\nWe will dive deeper into the design and representation of data entities in the next\nchapter. For now, let’s simplify things and say that the data of our library system is\nmade of two high-level groups: user management and catalog.\n2.3 Code modules\nThe second step of the design process in DOP is to define the code modules. Let’s lis-\nten in on Joe and Theo again.\nJoe Now that you have identified the data entities of your system and have\narranged them into high-level groups, it’s time to think about the code part of\nyour system.\nTheo What do you mean by the code part?\nJoe One way to think about that is to identity the functionality of your system.\nTheo looks again at Nancy’s requirements. This time he highlights the verb phrases that\nrepresent functionality.\nHighlighting terms in the requirements that correspond to functionality\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\nIn addition, it’s obvious to Theo that members can also return a book. Moreover, there\nshould be a way to detect whether a user is a librarian or not. He adds those to the require-\nments and then lists the functionality of the system.\nThe functionality of the library system\n Search for a book.\n Add a book item.\n Block a member.\n--- Page 60 ---\n32 CHAPTER 2 Separation between code and data\n(continued)\n Unblock a member.\n Log a user into the system.\n List the books currently lent to a member.\n Borrow a book.\n Return a book.\n Check whether a user is a librarian.\nJoe Excellent! Now, tell me what functionality needs to be exposed to the outside\nworld?\nTheo What do you mean by exposed to the outside world?\nJoe Imagine that the Library Management System exposes an API over HTTP.\nWhat functionality would be exposed by the HTTP endpoints?\nTheo Well, all system functionality would be exposed except checking to see if a user\nis a librarian.\nJoe OK. Now give each exposed function a short name and gather them together\nin a module box called Library.\nThat takes Theo less than a minute. Figure 2.4 shows the module that contains the\nexposed functions of the library devised by Theo.\nC Library\nsearchBook()\naddBookItem()\nblockMember()\nunblockMember()\ngetBookLendings() Figure 2.4 The Library module\ncheckoutBook() contains the exposed functions of the\nreturnBook() Library Management System.\nTIP The first step in designing the code part of a DOP system is to aggregate the\nexposed functions into a single module.\nJoe Beautiful! You just created your first code module.\nTheo To me it looks like a class. What’s the difference between a module and a class?\nJoe A module is an aggregation of functions. In OOP, a module is represented\nbya class, but in other programming languages, it might be a package or a\nnamespace.\nTheo I see.\nJoe The important thing about DOP code modules is that they contain only state-\nless functions.\nTheo You mean like static methods in Java?\nJoe Yes, and the classes of these static methods should not have any data members.\n--- Page 61 ---\n2.3 Code modules 33\nTheo So, how do the functions know what piece of information they operate on?\nJoe Easy. We pass that as the first argument to the function.\nTheo OK. Can you give me an example?\nJoe, biting his nails, takes a look at the list of functions of the Library module in figure 2.4.\nHe spots a likely candidate.\nJoe Let’s take, for example, getBookLendings. In classic OOP, what would its\narguments be?\nTheo A librarian ID and a member ID.\nJoe So, in traditional OOP, getBookLendings would be a method of a Library\nclass that receives two arguments: librarianId and memberId.\nTheo Yep.\nJoe Now comes the subtle part. In DOP, getBookLendings is part of the Library\nmodule, and it receives the LibraryData as an argument.\nTheo Could you show me what you mean?\nJoe Sure.\nJoe goes over to Theo’s keyboard and starts typing. He enters an example of what a class\nmethod looks like in OOP:\nclass Library {\ncatalog\nuserManagement\ngetBookLendings(userId, memberId) {\n// accesses library state via this.catalog and this.userManagement\n}\n}\nTheo Right! The method accesses the state of the object (in our case, the library\ndata) via this.\nJoe Would you say that the object’s state is an argument of the object’s methods?\nTheo I’d say that the object’s state is an implicit argument to the object’s methods.\nTIP In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\nJoe Well, in DOP, we pass data as an explicit argument. The signature of getBook-\nLendings would look like this.\nListing2.1 The signature of getBookLendings\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\n}\n}\n--- Page 62 ---\n34 CHAPTER 2 Separation between code and data\nJoe The state of the library is stored in libraryData, and libraryData is passed\nto the getBookLendings static method as an explicit argument.\nTheo Is that a general rule?\nJoe Absolutely! The same rule applies to the other functions of the Library mod-\nule and to other modules as well. All of the modules are stateless—they receive\nthe library data that they manipulate as an argument.\nTIP In DOP, functions of a code module are stateless. They receive the data that they\nmanipulate as an explicit argument, which is usually the first argument.\n NOTE A module is an aggregation of functions. In DOP, the module functions are\nstateless.\nTheo It reminds me of Python and the way the self argument appears in method\nsignatures. Here, let me show you an example.\nListing2.2 A Python object as an explicit argument in method signatures\nclass Library:\ncatalog = {}\nuserManagement = {}\ndef getBookLendings(self, userId, memberId):\n# accesses library state via self.catalog and self.userManagement\nJoe Indeed, but the difference I’m talking about is much deeper than a syntax\nchange. It’s about the fact that data lives outside the modules.\nTheo I got that. As you said, module functions are stateless.\nJoe Exactly! Would you like to try and apply this principle across the whole\nLibrary module?\nTheo Sure.\nTheo refines the design of the Library module by including the details about the func-\ntions’ arguments. He presents the diagram in figure 2.5 to Joe.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId) Figure 2.5 The Library module\nreturnBook(libraryData, userId, bookItemId)\nwith the functions’ arguments\nJoe Perfect. Now, we’re ready to tackle the high-level design of our system.\nTheo What’s a high-level design in DOP?\n--- Page 63 ---\n2.3 Code modules 35\nJoe A high-level design in DOP is the definition of modules and the interaction\nbetween them.\nTheo I see. Are there any guidelines to help me define the modules?\nJoe Definitely. The high-level modules of the system correspond to the high-level\ndata entities.\nTheo You mean the data entities that appear in the data mind map?\nJoe Exactly!\nTheo looks again at the data mind map (figure 2.6). He focuses on the high-level data enti-\nties library, catalog, and user management. This means that in the system, besides the\nLibrary module, we have two high-level modules:\n The Catalog module deals with catalog data.\n The UserManagement module deals with user management data.\nCatalog\nLibrary data Figure 2.6 A mind map of the high-\nlevel data entities of the Library\nUser management\nManagement System\nTheo then draws the high-level design of the Library Management System with the Catalog\nand UserManagement modules. Figure 2.7 shows the addition of these modules, where:\n Functions of Catalog receive catalogData as their first argument.\n Functions of UserManagement receive userManagementData as their first argument.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.7 The modules of the Library Management System with their functions’ arguments\n--- Page 64 ---\n36 CHAPTER 2 Separation between code and data\nIt’s not 100% clear for Theo at this point how the data entities get passed between mod-\nules. For the moment, he thinks of libraryData as a class with two members:\n catalog holds the catalog data.\n userManagement holds the user management data.\nTheo also sees that the functions of Library share a common pattern. (Later on in this\nchapter, we’ll see the code for some functions of the Library module.)\n They receive libraryData as an argument.\n They pass libraryData.catalog to the functions of Catalog.\n They pass libraryData.userManagement to the functions of UserManagement.\nTIP The high-level modules of a DOP system correspond to the high-level data enti-\nties.\n2.4 DOP systems are easy to understand\nTheo takes a look at the two diagrams that represent the high-level design of his system:\n The data entities in the data mind map in figure 2.8\n The code modules in the module diagram in figure 2.9\nA bit perplexed, Theo asks Joe:\nTheo I’m not sure that this system is better than a traditional OOP system where\nobjects encapsulate data.\nJoe The main benefit of a DOP system over a traditional OOP system is that it’s eas-\nier to understand.\nTheo What makes it easier to understand?\nJoe The fact that the system is split cleanly into code modules and data entities.\nTheo How does that help?\nJoe When you try to understand the data entities of the system, you don’t have to\nthink about the details of the code that manipulates the data entities.\nTheo So, when I look at the data mind map of my Library Management System, I can\nunderstand it on its own?\nJoe Exactly, and similarly, when you try to understand the code modules of the sys-\ntem, you don’t have to think about the details of the data entities manipulated\nby the code. There is a clear separation of concerns between the code and the\ndata.\nTheo looks again at the data mind map in figure 2.8. He has kind of an Aha! moment:\nData lives on its own!\n NOTE A DOP system is easier to understand because the system is split into two\nparts: data entities and code modules.\n--- Page 65 ---\n2.4 DOP systems are easy to understand 37\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nFigure 2.8 A data mind map of the\nLibrarians\nLibrary Management System\nNow, Theo looks at the module diagram in figure 2.9. He feels a bit confused and asks Joe\nfor clarification:\n On one hand, the module diagram looks similar to the class diagrams from classic\nOOP, boxes for classes and arrows for relations between classes.\n On the other hand, the code module diagram looks much simpler than the class\ndiagrams from classic OOP, but he cannot explain why.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.9 The modules of the Library Management System with the function arguments\nTheo The module diagram seems much simpler than the class diagrams I am used to\nin OOP. I feel it, but I can’t put it into words.\nJoe The reason is that module diagrams have constraints.\n--- Page 66 ---\n38 CHAPTER 2 Separation between code and data\nTheo What kind of constraints?\nJoe Constraints on the functions we saw before. All the functions are static (or\nstateless), but there’s also constraints on the relations between the modules.\nTIP All the functions in a DOP module are stateless.\nTheo In what way are the relations between modules constrained?\nJoe There is a single kind of relation between DOP modules—the usage relation. A\nmodule uses code from another module. There’s no association, no composi-\ntion, and no inheritance between modules. That’s what makes a DOP module\ndiagram easy to understand.\nTheo I understand why there is no association and no composition between DOP\nmodules. After all, association and composition are data relations. But why no\ninheritance relation? Does that mean that DOP is against polymorphism?\nJoe That’s a great question! The quick answer is that in DOP, we achieve polymor-\nphism with a different mechanism than class inheritance. We will talk about it\nsome day.\n NOTE For a discussion of polymorphism in DOP, see chapter 13.\nTheo Now, you’ve piqued my curiosity. I thought inheritance was the only way to\nachieve polymorphism.\nTheo looks again at the module diagram in figure 2.9. Now he not only feels that this dia-\ngram is simpler than traditional OOP class diagrams, he understands why it’s simpler: all\nthe functions are static, and all the relations between modules are of type usage. Table 2.1\nsummarizes Theo’s perception.\nTIP The only kind of relation between DOP modules is the usage relation.\nTable 2.1 What makes each part of a DOP system easy to understand\nSystem part Constraint on entities Constraints on relations\nData entities Members only (no code) Association and composition\nCode modules Stateless functions (no members) Usage (no inheritance)\nTIP Each part of a DOP system is easy to understand because it provides constraints.\n2.5 DOP systems are flexible\nTheo I see how a sharp separation between code and data makes DOP systems easier\nto understand than classic OOP systems. But what about adapting to changes\nin requirements?\nJoe Another benefit of DOP systems is that it is easy to extend them and to adapt to\nchanging requirements.\n--- Page 67 ---\n2.5 DOP systems are flexible 39\nTheo I remember that, when Nancy asked me to add Super members and VIP mem-\nbers to the system, it was hard to adapt my OOP system. I had to introduce a\nfew base classes, and the class hierarchy became really complex.\nJoe I know exactly what you mean. I’ve experienced the same kind of struggle so\nmany times. Describe the changes in the requirements for Super members and\nVIP members, and I’m quite sure that you’ll see how easy it would be to extend\nyour DOP system.\nThe requirements for Super members and VIP members\n Super members are members that are allowed to list the book lendings to\nother members.\n VIP members are members that are allowed to add book items to the library.\nTheo opens his IDE and starts to code the getBookLendings function of the Library\nmodule (see listing 2.3), first without addressing the requirements for Super members.\nTheo remembers what Joe told him about module functions in DOP:\n Functions are stateless.\n Functions receive the data they manipulate as their first argument.\nIn terms of functionality, getBookLendings has two parts:\n Checks that the user is a librarian.\n Retrieves the book lendings from the catalog.\nBasically, the code of getBookLendings has two parts as well:\n Calls the isLibrarian function from the UserManagement module and passes it\nthe UserManagementData.\n Calls the getBookLendings function from the Catalog module and passes it the\nCatalogData.\nListing2.3 Getting the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\n}\ngeneric data collections.\n--- Page 68 ---\n40 CHAPTER 2 Separation between code and data\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nIt’s Theo’s first piece of DOP code and passing around all those data objects—library-\nData, libraryData.userManagement, and libraryData.catalog—feels a bit awkward.\nBut he did it! Joe looks at Theo’s code and seems satisfied.\nJoe Now, how would you adapt your code to Super members?\nTheo I would add a function isSuperMember to the UserManagement module and\ncall it from Library.getBookLendings.\nJoe Exactly! It’s as simple as that.\nTheo types the code on his laptop so that he can show it to Joe. Here’s how Theo adapts\nhis code for Super members.\nListing2.4 Allowing Super members to get the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(Usermanagement.isLibrarian(libraryData.userManagement, userId) ||\nUsermanagement.isSuperMember(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isSuperMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nNow, the awkward feeling caused by passing around all those data objects is dominated by\na feeling of relief. Adapting to this change in requirements takes only a few lines of code\nand requires no changes in the system design. Once again, Joe seems satisfied.\nTIP DOP systems are flexible. Quite often they adapt to changing requirements with-\nout changing the system design.\n--- Page 69 ---\n2.5 DOP systems are flexible 41\nTheo starts coding addBookItem. He looks at the signature of Library.addBookItem,\nand the meaning of the third argument bookItemInfo isn’t clear to him. He asks Joe for\nclarification.\nListing2.5 The signature of Library.addBookItem\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\n}\n}\nTheo What is bookItemInfo?\nJoe Let’s call it the book item information. Imagine we have a way to represent this\ninformation in a data entity named bookItemInfo.\nTheo You mean an object?\nJoe For now, it’s OK to think about bookItemInfo as an object. Later on, I will\nshow you how to we represent data in DOP.\nBesides this subtlety about how the book item information is represented by book-\nItemInfo, the code for Library.addBookItem in listing 2.6 is quite similar to the code\nTheo wrote for Library.getBookLendings in listing 2.4. Once again, Theo is amazed by\nthe fact that adding support for VIP members requires no design change.\nListing2.6 Allowing VIP members to add a book item to the library\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId) ||\nUserManagement.isVIPMember(libraryData.userManagement, userId)) {\nreturn Catalog.addBookItem(libraryData.catalog, bookItemInfo);\n} else {\nthrow \"Not allowed to add a book item\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isVIPMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic addBookItem(catalogData, memberId) {\n// will be implemented later\nIn chapter 4, we will see how\n}\nto manage state of the system\n}\nwith immutable data.\n--- Page 70 ---\n42 CHAPTER 2 Separation between code and data\nTheo It takes a big mindset shift to learn how to separate code from data!\nJoe What was the most challenging thing to accept?\nTheo The fact that data is not encapsulated in objects.\nJoe It was the same for me when I switched from OOP to DOP.\nNow it’s time to eat! Theo takes Joe for lunch at Simple, a nice, small restaurant near the\noffice.\nSummary\n DOP principles are language-agnostic.\n DOP principle #1 is to separate code from data.\n The separation between code and data in DOP systems makes them simpler\n(easier to understand) than traditional OOP systems.\n Data entities are the parts of your system that hold information.\n DOP is against data encapsulation.\n The more flexible a system is, the easier it is to adapt to changing requirements.\n The separation between code and data in DOP systems makes them more flexi-\nble than traditional OOP systems.\n When code is separated from data, we have the freedom to design code and\ndata in isolation.\n We represent data as data entities.\n We discover the data entities of our system and sort them into high-level groups,\neither as a nested list or as a mind map.\n A DOP system is easier to understand than a traditional OOP system because\nthe system is split into two parts: data entities and code modules.\n In DOP, a code module is an aggregation of stateless functions.\n DOP systems are flexible. Quite often they adapt to changing requirements\nwithout changing the system design.\n In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\n Stateless functions receive data they manipulate as an explicit argument.\n The high-level modules of a DOP system correspond to high-level data entities.\n The only kind of relation between code modules is the usage relation.\n The only kinds of relation between data entities are the association and the compo-\nsition relation.\n For a discussion of polymorphism in DOP, see chapter 13.\n--- Page 71 ---\nBasic data manipulation\nMeditation and programming\nThis chapter covers\n Representing records with string maps to improve\nflexibility\n Manipulating data with generic functions\n Accessing each piece of information via its\ninformation path\n Gaining JSON serialization for free\nAfter learning why and how to separate code from data in the previous chapter,\nlet’s talk about data on its own. In contrast to traditional OOP, where system design\ntends to involve a rigid class hierarchy, DOP prescribes that we represent our data\nmodel as a flexible combination of maps and arrays (or lists), where we can access\neach piece of information via an information path. This chapter is a deep dive into\nthe second principle of DOP.\nPRINCIPLE #2 Represent data entities with generic data structures.\n43\n--- Page 72 ---\n44 CHAPTER 3 Basic data manipulation\nWe increase system flexibility when we represent records as string maps and not as\nobjects instantiated from classes. This liberates data from the rigidity of a class-based sys-\ntem. Data becomes a first-class citizen powered by generic functions to add, remove, or\nrename fields.\n NOTE We refer to maps that have strings as keys as string maps.\nThe dependency between the code that manipulates data and the data is a weak\ndependency. The code only needs to know the keys of specific fields in the record it\nwants to manipulate. The code doesn’t even need to know about all the keys in the\nrecord, only the ones relevant to it. In this chapter, we’ll deal only with data query.\nWe’ll discuss managing changes in system state in the next chapter.\n3.1 Designing a data model\nDuring lunch at Simple, Theo and Joe don’t talk about programming. Instead, they start\ngetting to know each other on a personal level. Theo discovers that Joe is married to Kay,\nwho has just opened her creative therapy practice after many years of studying various\nfields related to well-being. Neriah, their 14-year-old son, is passionate about drones, whereas\nAurelia, their 12-year-old daughter, plays the transverse flute.\nJoe tells Theo that he’s been practicing meditation for 10 years. Meditation, he says, has\ntaught him how to break away from being continually lost in a “storm thought” (especially\nnegative thoughts, which can be the source of great suffering) to achieve a more direct\nrelationship with reality. The more he learns to experience reality as it is, the calmer his\nmind. When he first started to practice meditation, it was sometimes difficult and even\nweird, but by persevering, he has increased his feeling of well-being with each passing year.\nWhen they’re back at the office, Joe tells Theo that his next step in their DOP journey\nwill be about data models. This includes data representation.\nJoe When we design the data part of our system, we’re free to do it in isolation.\nTheo What do you mean by isolation?\nJoe I mean that you don’t have to bother with code, only data.\nTheo Oh, right. I remember you telling me how that makes a DOP system simpler\nthan OOP. Separation of concerns is a design principle I’m used to in OOP.\nJoe Indeed.\nTheo And, when we think about data, the only relations we have to think about are\nassociation and composition.\nJoe Correct.\nTheo Will the data model design be significantly different than the data model I’m\nused to designing as an OOP developer?\nJoe Not so much.\nTheo OK. Let me see if I can draw a DOP-style data entity diagram.\nTheo takes a look at the data mind map that he drew earlier in the morning. He then\ndraws the diagram in figure 3.1.\nHe refines the details of the fields of each data entity and the kind of relations between\nentities. Figure 3.2 shows the result of this redefined data entity diagram.\n--- Page 73 ---\n3.1 Designing a data model 45\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 3.1 A data mind map of\nthe Library Management System\nCC Library\nname: String\naddress: String\nCC Catalog CC UserManagement\n* * *\nCC Book CC Librarian CC Member\nemail: String email: String\ntitle : String\npassword: String password: String\npublicationYear: Number\n*\nISBN: String\npublisher: String\n* *\nCC Author CC BookLending\nname: String lendingDate: String\nCC BookItem\n* libld: String\npurchaseDate: String\nFigure 3.2 A data model of the Library Management System\n--- Page 74 ---\n46 CHAPTER 3 Basic data manipulation\nJoe The next step is to be more explicit about the relations between entities.\nTheo What do you mean?\nJoe For example, in your entity diagram, Book and Author are connected by a\nmany-to-many association relation. How is this relation going to be repre-\nsented in your program?\nTheo In the Book entity, there will be a collection of author IDs, and in the Author\nentity, there will be a collection of book IDs.\nJoe Sounds good. And what will the book ID be?\nTheo The book ISBN.\n NOTE The International Standard Book Number (ISBN) is a numeric commercial\nbook identifier that is intended to be unique.\nJoe And where will you hold the index that enables you to retrieve a Book from its\nISBN?\nTheo In the Catalog because the catalog holds a bookByISBN index.\nJoe What about author ID?\nTheo Author ID is the author name in lowercase and with dashes instead of white\nspaces (assuming that we don’t have two authors with the same name).\nJoe And I guess that you also hold the author index in the Catalog?\nTheo Exactly!\nJoe Excellent. You’ve been 100% explicit about the relation between Book and\nAuthor. I’ll ask you to do the same with the other relations of the system.\nIt’s quite easy for Theo to do, as he has done that so many times as an OOP developer. Fig-\nure 3.3 provides the detailed entity diagram of Theo’s system.\n NOTE By positional collection, we mean a collection where the elements are in order\n(like a list or an array). By index, we mean a collection where the elements are accessi-\nble via a key (like a hash map or a dictionary).\nThe Catalog entity contains two indexes:\n booksByIsbn—The keys are book ISBNs, and the values are Book entities. Its type is\nnoted as {Book}.\n authorsById—The keys are author IDs, and the values are Author entities. Its type\nis noted as {Author}.\nInside a Book entity, we have authors, which is a positional collection of author IDs of type\n[String]. Inside an Author entity, we have books, which is a collection of book IDs of\ntype [String].\n NOTE For the notation for collections and index types, a positional collection of\nStrings is noted as [String]. An index of Books is noted as {Book}. In the context of\na data model, the index keys are always strings.\n--- Page 75 ---\n3.1 Designing a data model 47\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: UserManagement\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian\nCC Book i n d a : m S e tr : i n S g tring email: String CC Me * mber\ntitle : String encryptedPassword: String\nbookIsbns: [String] email: String\npublicationYear: Number\nencryptedPassword: String\nisbn: String *\nisBlocked: Boolean\nauthorIds: [String]\nbookLendings: [BookLending]\nbookItems: [BookItem] *\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.3 Library management relation model. Dashed lines (e.g., between Book and Author) denote\nindirect relations, [String] denotes a positional collection of strings, and {Book} denotes an index of\nBooks.\nThere is a dashed line between Book and Author, which means that the relation between\nBook and Author is indirect. To access the collection of Author entities from a Book entity,\nwe’ll use the authorById index defined in the Catalog entity.\nJoe I like your data entity diagram.\nTheo Thank you.\nJoe Can you tell me what the three kinds of data aggregations are in your diagram\n(and, in fact, in any data entity diagram)?\nTheo Let’s see...we have positional collections like authors in Book. We have\nindexes like booksByIsbn in Catalog. I can’t find the third one.\nJoe The third kind of data aggregation is what we’ve called, until now, an “entity”\n(like Library, Catalog, Book, etc.), and the common term for entity in com-\nputer science is record.",
        "sections_found": []
      },
      "accurate_page_range": "56-75"
    },
    {
      "text": "- 2.5 DOP systems are flexible",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "raw_line": "- 2.5 DOP systems are flexible (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 20,
      "chapter_info": {
        "page": 56,
        "title": "Separation between code and data",
        "pattern_matched": "Chapter 2",
        "text_preview": "28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his te"
      },
      "chapter_sections": {
        "start_page": 56,
        "end_page": 75,
        "content": "\n--- Page 56 ---\n28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his team have built in Clojure over the last 7\nyears are less complex and more flexible than the systems he used to build in Java. Accord-\ning to Joe, the systems they build now tend to be much simpler because they follow the\nprinciples of DOP.\nTheo I’ve never heard of data-oriented programming. Is it a new concept?\nJoe Yes and no. Most of the foundational ideas of data-oriented programming, or\nDOP as we like to call it, are well known to programmers as best practices. The\nnovelty of DOP, however, is that it combines best practices into a cohesive\nwhole.\nTheo That’s a bit abstract for me. Can you give me an example?\nJoe Sure! Take, for instance, the first insight of DOP. It’s about the relations between\ncode and data.\nTheo You mean the encapsulation of data in objects?\nJoe Actually, DOP is against data encapsulation.\nTheo Why is that? I thought data encapsulation was a positive programming paradigm.\nJoe Data encapsulation has both merits and drawbacks. Think about the way you\ndesigned the Library Management System. According to DOP, the main cause\nof complexity and inflexibility in systems is that code and data are mixed\ntogether in objects.\nTIP DOP is against data encapsulation.\nTheo It sounds similar to what I’ve heard about functional programming. So, if I\nwant to adopt DOP, do I need to get rid of object-oriented programming and\nlearn functional programming?\nJoe No, DOP principles are language-agnostic. They can be applied in both object-\noriented and functional programming languages.\nTheo That’s a relief! I was afraid that you were going to teach me about monads,\nalgebraic data types, and higher order functions.\nJoe No, none of that is required in DOP.\nTIP DOP principles are language-agnostic.\nTheo What does the separation between code and data look like in DOP then?\nJoe Data is represented by data entities that only hold members. Code is aggre-\ngated into modules where all functions are stateless.\nTheo What do you mean by stateless functions?\nJoe Instead of having the state encapsulated in the object, the data entity is passed\nas an argument.\nTheo I don’t get that.\nJoe Here, let’s make it visual.\n--- Page 57 ---\n2.2 Data entities 29\nJoe steps up to a whiteboard and quickly draws a diagram to illustrate his comment. Fig-\nure 2.2 shows Joe’s drawing.\nCode modules Stateless functions\nSeparate code from data\nData entities Only members\nFigure 2.2 The separation between code and data\nTheo It’s still not clear.\nJoe It will become clearer when I show you how it looks in the context of your\nLibrary Management System.\nTheo OK. Shall we start with code or with data?\nJoe Well, it’s data-oriented programming, so let’s start with data.\n2.2 Data entities\nIn DOP, we start the design process by discovering the data entities of our system.\nHere’s what Joe and Theo have to say about data entities.\nJoe What are the data entities of your system?\nTheo What do you mean by data entities?\nJoe I mean the parts of your system that hold information.\n NOTE Data entities are the parts of your system that hold information.\nTheo Well, it’s a Library Management System, so we have books and members.\nJoe Of course, but there are more. One way to discover the data entities of a system\nis to look for nouns and noun phrases in the requirements of the system.\nTheo looks at Nancy’s requirement napkin. He highlights the nouns and noun phrases\nthat seem to represent data entities.\nHighlighting terms in the requirements that correspond to data entities\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n--- Page 58 ---\n30 CHAPTER 2 Separation between code and data\nJoe Excellent. Can you see a natural way to group these entities?\nTheo Not sure, but it seems to me that users, members, and librarians form one\ngroup, whereas books, authors, and book copies form another group.\nJoe Sounds good to me. What would you call each group?\nTheo Probably user management for the first group and catalog for the second\ngroup.\nThe data entities of the system organized in a nested list\n The catalog data\n– Data about books\n– Data about authors\n– Data about book items\n– Data about book lendings\n The user management data\n– Data about users\n– Data about members\n– Data about librarians\nTheo I’m not sure about the relations between books and authors. Should it be asso-\nciation or composition?\nJoe Don’t worry too much about the details for the moment. We’ll refine our data\nentity design later. For now, let’s visualize the two groups in a mind map.\nTheo and Joe confer for a bit. Figure 2.3 shows the mind map they come up with.\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 2.3 The data entities of the\nsystem organized in a mind map\n--- Page 59 ---\n2.3 Code modules 31\nThe most precise way to visualize the data entities of a DOP system is to draw a data\nentity diagram with different arrows for association and composition. We will come\nback to data entity diagrams later.\nTIP Discover the data entities of your system and then sort them into high-level\ngroups, either as a nested list or as a mind map.\nWe will dive deeper into the design and representation of data entities in the next\nchapter. For now, let’s simplify things and say that the data of our library system is\nmade of two high-level groups: user management and catalog.\n2.3 Code modules\nThe second step of the design process in DOP is to define the code modules. Let’s lis-\nten in on Joe and Theo again.\nJoe Now that you have identified the data entities of your system and have\narranged them into high-level groups, it’s time to think about the code part of\nyour system.\nTheo What do you mean by the code part?\nJoe One way to think about that is to identity the functionality of your system.\nTheo looks again at Nancy’s requirements. This time he highlights the verb phrases that\nrepresent functionality.\nHighlighting terms in the requirements that correspond to functionality\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\nIn addition, it’s obvious to Theo that members can also return a book. Moreover, there\nshould be a way to detect whether a user is a librarian or not. He adds those to the require-\nments and then lists the functionality of the system.\nThe functionality of the library system\n Search for a book.\n Add a book item.\n Block a member.\n--- Page 60 ---\n32 CHAPTER 2 Separation between code and data\n(continued)\n Unblock a member.\n Log a user into the system.\n List the books currently lent to a member.\n Borrow a book.\n Return a book.\n Check whether a user is a librarian.\nJoe Excellent! Now, tell me what functionality needs to be exposed to the outside\nworld?\nTheo What do you mean by exposed to the outside world?\nJoe Imagine that the Library Management System exposes an API over HTTP.\nWhat functionality would be exposed by the HTTP endpoints?\nTheo Well, all system functionality would be exposed except checking to see if a user\nis a librarian.\nJoe OK. Now give each exposed function a short name and gather them together\nin a module box called Library.\nThat takes Theo less than a minute. Figure 2.4 shows the module that contains the\nexposed functions of the library devised by Theo.\nC Library\nsearchBook()\naddBookItem()\nblockMember()\nunblockMember()\ngetBookLendings() Figure 2.4 The Library module\ncheckoutBook() contains the exposed functions of the\nreturnBook() Library Management System.\nTIP The first step in designing the code part of a DOP system is to aggregate the\nexposed functions into a single module.\nJoe Beautiful! You just created your first code module.\nTheo To me it looks like a class. What’s the difference between a module and a class?\nJoe A module is an aggregation of functions. In OOP, a module is represented\nbya class, but in other programming languages, it might be a package or a\nnamespace.\nTheo I see.\nJoe The important thing about DOP code modules is that they contain only state-\nless functions.\nTheo You mean like static methods in Java?\nJoe Yes, and the classes of these static methods should not have any data members.\n--- Page 61 ---\n2.3 Code modules 33\nTheo So, how do the functions know what piece of information they operate on?\nJoe Easy. We pass that as the first argument to the function.\nTheo OK. Can you give me an example?\nJoe, biting his nails, takes a look at the list of functions of the Library module in figure 2.4.\nHe spots a likely candidate.\nJoe Let’s take, for example, getBookLendings. In classic OOP, what would its\narguments be?\nTheo A librarian ID and a member ID.\nJoe So, in traditional OOP, getBookLendings would be a method of a Library\nclass that receives two arguments: librarianId and memberId.\nTheo Yep.\nJoe Now comes the subtle part. In DOP, getBookLendings is part of the Library\nmodule, and it receives the LibraryData as an argument.\nTheo Could you show me what you mean?\nJoe Sure.\nJoe goes over to Theo’s keyboard and starts typing. He enters an example of what a class\nmethod looks like in OOP:\nclass Library {\ncatalog\nuserManagement\ngetBookLendings(userId, memberId) {\n// accesses library state via this.catalog and this.userManagement\n}\n}\nTheo Right! The method accesses the state of the object (in our case, the library\ndata) via this.\nJoe Would you say that the object’s state is an argument of the object’s methods?\nTheo I’d say that the object’s state is an implicit argument to the object’s methods.\nTIP In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\nJoe Well, in DOP, we pass data as an explicit argument. The signature of getBook-\nLendings would look like this.\nListing2.1 The signature of getBookLendings\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\n}\n}\n--- Page 62 ---\n34 CHAPTER 2 Separation between code and data\nJoe The state of the library is stored in libraryData, and libraryData is passed\nto the getBookLendings static method as an explicit argument.\nTheo Is that a general rule?\nJoe Absolutely! The same rule applies to the other functions of the Library mod-\nule and to other modules as well. All of the modules are stateless—they receive\nthe library data that they manipulate as an argument.\nTIP In DOP, functions of a code module are stateless. They receive the data that they\nmanipulate as an explicit argument, which is usually the first argument.\n NOTE A module is an aggregation of functions. In DOP, the module functions are\nstateless.\nTheo It reminds me of Python and the way the self argument appears in method\nsignatures. Here, let me show you an example.\nListing2.2 A Python object as an explicit argument in method signatures\nclass Library:\ncatalog = {}\nuserManagement = {}\ndef getBookLendings(self, userId, memberId):\n# accesses library state via self.catalog and self.userManagement\nJoe Indeed, but the difference I’m talking about is much deeper than a syntax\nchange. It’s about the fact that data lives outside the modules.\nTheo I got that. As you said, module functions are stateless.\nJoe Exactly! Would you like to try and apply this principle across the whole\nLibrary module?\nTheo Sure.\nTheo refines the design of the Library module by including the details about the func-\ntions’ arguments. He presents the diagram in figure 2.5 to Joe.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId) Figure 2.5 The Library module\nreturnBook(libraryData, userId, bookItemId)\nwith the functions’ arguments\nJoe Perfect. Now, we’re ready to tackle the high-level design of our system.\nTheo What’s a high-level design in DOP?\n--- Page 63 ---\n2.3 Code modules 35\nJoe A high-level design in DOP is the definition of modules and the interaction\nbetween them.\nTheo I see. Are there any guidelines to help me define the modules?\nJoe Definitely. The high-level modules of the system correspond to the high-level\ndata entities.\nTheo You mean the data entities that appear in the data mind map?\nJoe Exactly!\nTheo looks again at the data mind map (figure 2.6). He focuses on the high-level data enti-\nties library, catalog, and user management. This means that in the system, besides the\nLibrary module, we have two high-level modules:\n The Catalog module deals with catalog data.\n The UserManagement module deals with user management data.\nCatalog\nLibrary data Figure 2.6 A mind map of the high-\nlevel data entities of the Library\nUser management\nManagement System\nTheo then draws the high-level design of the Library Management System with the Catalog\nand UserManagement modules. Figure 2.7 shows the addition of these modules, where:\n Functions of Catalog receive catalogData as their first argument.\n Functions of UserManagement receive userManagementData as their first argument.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.7 The modules of the Library Management System with their functions’ arguments\n--- Page 64 ---\n36 CHAPTER 2 Separation between code and data\nIt’s not 100% clear for Theo at this point how the data entities get passed between mod-\nules. For the moment, he thinks of libraryData as a class with two members:\n catalog holds the catalog data.\n userManagement holds the user management data.\nTheo also sees that the functions of Library share a common pattern. (Later on in this\nchapter, we’ll see the code for some functions of the Library module.)\n They receive libraryData as an argument.\n They pass libraryData.catalog to the functions of Catalog.\n They pass libraryData.userManagement to the functions of UserManagement.\nTIP The high-level modules of a DOP system correspond to the high-level data enti-\nties.\n2.4 DOP systems are easy to understand\nTheo takes a look at the two diagrams that represent the high-level design of his system:\n The data entities in the data mind map in figure 2.8\n The code modules in the module diagram in figure 2.9\nA bit perplexed, Theo asks Joe:\nTheo I’m not sure that this system is better than a traditional OOP system where\nobjects encapsulate data.\nJoe The main benefit of a DOP system over a traditional OOP system is that it’s eas-\nier to understand.\nTheo What makes it easier to understand?\nJoe The fact that the system is split cleanly into code modules and data entities.\nTheo How does that help?\nJoe When you try to understand the data entities of the system, you don’t have to\nthink about the details of the code that manipulates the data entities.\nTheo So, when I look at the data mind map of my Library Management System, I can\nunderstand it on its own?\nJoe Exactly, and similarly, when you try to understand the code modules of the sys-\ntem, you don’t have to think about the details of the data entities manipulated\nby the code. There is a clear separation of concerns between the code and the\ndata.\nTheo looks again at the data mind map in figure 2.8. He has kind of an Aha! moment:\nData lives on its own!\n NOTE A DOP system is easier to understand because the system is split into two\nparts: data entities and code modules.\n--- Page 65 ---\n2.4 DOP systems are easy to understand 37\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nFigure 2.8 A data mind map of the\nLibrarians\nLibrary Management System\nNow, Theo looks at the module diagram in figure 2.9. He feels a bit confused and asks Joe\nfor clarification:\n On one hand, the module diagram looks similar to the class diagrams from classic\nOOP, boxes for classes and arrows for relations between classes.\n On the other hand, the code module diagram looks much simpler than the class\ndiagrams from classic OOP, but he cannot explain why.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.9 The modules of the Library Management System with the function arguments\nTheo The module diagram seems much simpler than the class diagrams I am used to\nin OOP. I feel it, but I can’t put it into words.\nJoe The reason is that module diagrams have constraints.\n--- Page 66 ---\n38 CHAPTER 2 Separation between code and data\nTheo What kind of constraints?\nJoe Constraints on the functions we saw before. All the functions are static (or\nstateless), but there’s also constraints on the relations between the modules.\nTIP All the functions in a DOP module are stateless.\nTheo In what way are the relations between modules constrained?\nJoe There is a single kind of relation between DOP modules—the usage relation. A\nmodule uses code from another module. There’s no association, no composi-\ntion, and no inheritance between modules. That’s what makes a DOP module\ndiagram easy to understand.\nTheo I understand why there is no association and no composition between DOP\nmodules. After all, association and composition are data relations. But why no\ninheritance relation? Does that mean that DOP is against polymorphism?\nJoe That’s a great question! The quick answer is that in DOP, we achieve polymor-\nphism with a different mechanism than class inheritance. We will talk about it\nsome day.\n NOTE For a discussion of polymorphism in DOP, see chapter 13.\nTheo Now, you’ve piqued my curiosity. I thought inheritance was the only way to\nachieve polymorphism.\nTheo looks again at the module diagram in figure 2.9. Now he not only feels that this dia-\ngram is simpler than traditional OOP class diagrams, he understands why it’s simpler: all\nthe functions are static, and all the relations between modules are of type usage. Table 2.1\nsummarizes Theo’s perception.\nTIP The only kind of relation between DOP modules is the usage relation.\nTable 2.1 What makes each part of a DOP system easy to understand\nSystem part Constraint on entities Constraints on relations\nData entities Members only (no code) Association and composition\nCode modules Stateless functions (no members) Usage (no inheritance)\nTIP Each part of a DOP system is easy to understand because it provides constraints.\n2.5 DOP systems are flexible\nTheo I see how a sharp separation between code and data makes DOP systems easier\nto understand than classic OOP systems. But what about adapting to changes\nin requirements?\nJoe Another benefit of DOP systems is that it is easy to extend them and to adapt to\nchanging requirements.\n--- Page 67 ---\n2.5 DOP systems are flexible 39\nTheo I remember that, when Nancy asked me to add Super members and VIP mem-\nbers to the system, it was hard to adapt my OOP system. I had to introduce a\nfew base classes, and the class hierarchy became really complex.\nJoe I know exactly what you mean. I’ve experienced the same kind of struggle so\nmany times. Describe the changes in the requirements for Super members and\nVIP members, and I’m quite sure that you’ll see how easy it would be to extend\nyour DOP system.\nThe requirements for Super members and VIP members\n Super members are members that are allowed to list the book lendings to\nother members.\n VIP members are members that are allowed to add book items to the library.\nTheo opens his IDE and starts to code the getBookLendings function of the Library\nmodule (see listing 2.3), first without addressing the requirements for Super members.\nTheo remembers what Joe told him about module functions in DOP:\n Functions are stateless.\n Functions receive the data they manipulate as their first argument.\nIn terms of functionality, getBookLendings has two parts:\n Checks that the user is a librarian.\n Retrieves the book lendings from the catalog.\nBasically, the code of getBookLendings has two parts as well:\n Calls the isLibrarian function from the UserManagement module and passes it\nthe UserManagementData.\n Calls the getBookLendings function from the Catalog module and passes it the\nCatalogData.\nListing2.3 Getting the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\n}\ngeneric data collections.\n--- Page 68 ---\n40 CHAPTER 2 Separation between code and data\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nIt’s Theo’s first piece of DOP code and passing around all those data objects—library-\nData, libraryData.userManagement, and libraryData.catalog—feels a bit awkward.\nBut he did it! Joe looks at Theo’s code and seems satisfied.\nJoe Now, how would you adapt your code to Super members?\nTheo I would add a function isSuperMember to the UserManagement module and\ncall it from Library.getBookLendings.\nJoe Exactly! It’s as simple as that.\nTheo types the code on his laptop so that he can show it to Joe. Here’s how Theo adapts\nhis code for Super members.\nListing2.4 Allowing Super members to get the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(Usermanagement.isLibrarian(libraryData.userManagement, userId) ||\nUsermanagement.isSuperMember(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isSuperMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nNow, the awkward feeling caused by passing around all those data objects is dominated by\na feeling of relief. Adapting to this change in requirements takes only a few lines of code\nand requires no changes in the system design. Once again, Joe seems satisfied.\nTIP DOP systems are flexible. Quite often they adapt to changing requirements with-\nout changing the system design.\n--- Page 69 ---\n2.5 DOP systems are flexible 41\nTheo starts coding addBookItem. He looks at the signature of Library.addBookItem,\nand the meaning of the third argument bookItemInfo isn’t clear to him. He asks Joe for\nclarification.\nListing2.5 The signature of Library.addBookItem\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\n}\n}\nTheo What is bookItemInfo?\nJoe Let’s call it the book item information. Imagine we have a way to represent this\ninformation in a data entity named bookItemInfo.\nTheo You mean an object?\nJoe For now, it’s OK to think about bookItemInfo as an object. Later on, I will\nshow you how to we represent data in DOP.\nBesides this subtlety about how the book item information is represented by book-\nItemInfo, the code for Library.addBookItem in listing 2.6 is quite similar to the code\nTheo wrote for Library.getBookLendings in listing 2.4. Once again, Theo is amazed by\nthe fact that adding support for VIP members requires no design change.\nListing2.6 Allowing VIP members to add a book item to the library\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId) ||\nUserManagement.isVIPMember(libraryData.userManagement, userId)) {\nreturn Catalog.addBookItem(libraryData.catalog, bookItemInfo);\n} else {\nthrow \"Not allowed to add a book item\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isVIPMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic addBookItem(catalogData, memberId) {\n// will be implemented later\nIn chapter 4, we will see how\n}\nto manage state of the system\n}\nwith immutable data.\n--- Page 70 ---\n42 CHAPTER 2 Separation between code and data\nTheo It takes a big mindset shift to learn how to separate code from data!\nJoe What was the most challenging thing to accept?\nTheo The fact that data is not encapsulated in objects.\nJoe It was the same for me when I switched from OOP to DOP.\nNow it’s time to eat! Theo takes Joe for lunch at Simple, a nice, small restaurant near the\noffice.\nSummary\n DOP principles are language-agnostic.\n DOP principle #1 is to separate code from data.\n The separation between code and data in DOP systems makes them simpler\n(easier to understand) than traditional OOP systems.\n Data entities are the parts of your system that hold information.\n DOP is against data encapsulation.\n The more flexible a system is, the easier it is to adapt to changing requirements.\n The separation between code and data in DOP systems makes them more flexi-\nble than traditional OOP systems.\n When code is separated from data, we have the freedom to design code and\ndata in isolation.\n We represent data as data entities.\n We discover the data entities of our system and sort them into high-level groups,\neither as a nested list or as a mind map.\n A DOP system is easier to understand than a traditional OOP system because\nthe system is split into two parts: data entities and code modules.\n In DOP, a code module is an aggregation of stateless functions.\n DOP systems are flexible. Quite often they adapt to changing requirements\nwithout changing the system design.\n In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\n Stateless functions receive data they manipulate as an explicit argument.\n The high-level modules of a DOP system correspond to high-level data entities.\n The only kind of relation between code modules is the usage relation.\n The only kinds of relation between data entities are the association and the compo-\nsition relation.\n For a discussion of polymorphism in DOP, see chapter 13.\n--- Page 71 ---\nBasic data manipulation\nMeditation and programming\nThis chapter covers\n Representing records with string maps to improve\nflexibility\n Manipulating data with generic functions\n Accessing each piece of information via its\ninformation path\n Gaining JSON serialization for free\nAfter learning why and how to separate code from data in the previous chapter,\nlet’s talk about data on its own. In contrast to traditional OOP, where system design\ntends to involve a rigid class hierarchy, DOP prescribes that we represent our data\nmodel as a flexible combination of maps and arrays (or lists), where we can access\neach piece of information via an information path. This chapter is a deep dive into\nthe second principle of DOP.\nPRINCIPLE #2 Represent data entities with generic data structures.\n43\n--- Page 72 ---\n44 CHAPTER 3 Basic data manipulation\nWe increase system flexibility when we represent records as string maps and not as\nobjects instantiated from classes. This liberates data from the rigidity of a class-based sys-\ntem. Data becomes a first-class citizen powered by generic functions to add, remove, or\nrename fields.\n NOTE We refer to maps that have strings as keys as string maps.\nThe dependency between the code that manipulates data and the data is a weak\ndependency. The code only needs to know the keys of specific fields in the record it\nwants to manipulate. The code doesn’t even need to know about all the keys in the\nrecord, only the ones relevant to it. In this chapter, we’ll deal only with data query.\nWe’ll discuss managing changes in system state in the next chapter.\n3.1 Designing a data model\nDuring lunch at Simple, Theo and Joe don’t talk about programming. Instead, they start\ngetting to know each other on a personal level. Theo discovers that Joe is married to Kay,\nwho has just opened her creative therapy practice after many years of studying various\nfields related to well-being. Neriah, their 14-year-old son, is passionate about drones, whereas\nAurelia, their 12-year-old daughter, plays the transverse flute.\nJoe tells Theo that he’s been practicing meditation for 10 years. Meditation, he says, has\ntaught him how to break away from being continually lost in a “storm thought” (especially\nnegative thoughts, which can be the source of great suffering) to achieve a more direct\nrelationship with reality. The more he learns to experience reality as it is, the calmer his\nmind. When he first started to practice meditation, it was sometimes difficult and even\nweird, but by persevering, he has increased his feeling of well-being with each passing year.\nWhen they’re back at the office, Joe tells Theo that his next step in their DOP journey\nwill be about data models. This includes data representation.\nJoe When we design the data part of our system, we’re free to do it in isolation.\nTheo What do you mean by isolation?\nJoe I mean that you don’t have to bother with code, only data.\nTheo Oh, right. I remember you telling me how that makes a DOP system simpler\nthan OOP. Separation of concerns is a design principle I’m used to in OOP.\nJoe Indeed.\nTheo And, when we think about data, the only relations we have to think about are\nassociation and composition.\nJoe Correct.\nTheo Will the data model design be significantly different than the data model I’m\nused to designing as an OOP developer?\nJoe Not so much.\nTheo OK. Let me see if I can draw a DOP-style data entity diagram.\nTheo takes a look at the data mind map that he drew earlier in the morning. He then\ndraws the diagram in figure 3.1.\nHe refines the details of the fields of each data entity and the kind of relations between\nentities. Figure 3.2 shows the result of this redefined data entity diagram.\n--- Page 73 ---\n3.1 Designing a data model 45\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 3.1 A data mind map of\nthe Library Management System\nCC Library\nname: String\naddress: String\nCC Catalog CC UserManagement\n* * *\nCC Book CC Librarian CC Member\nemail: String email: String\ntitle : String\npassword: String password: String\npublicationYear: Number\n*\nISBN: String\npublisher: String\n* *\nCC Author CC BookLending\nname: String lendingDate: String\nCC BookItem\n* libld: String\npurchaseDate: String\nFigure 3.2 A data model of the Library Management System\n--- Page 74 ---\n46 CHAPTER 3 Basic data manipulation\nJoe The next step is to be more explicit about the relations between entities.\nTheo What do you mean?\nJoe For example, in your entity diagram, Book and Author are connected by a\nmany-to-many association relation. How is this relation going to be repre-\nsented in your program?\nTheo In the Book entity, there will be a collection of author IDs, and in the Author\nentity, there will be a collection of book IDs.\nJoe Sounds good. And what will the book ID be?\nTheo The book ISBN.\n NOTE The International Standard Book Number (ISBN) is a numeric commercial\nbook identifier that is intended to be unique.\nJoe And where will you hold the index that enables you to retrieve a Book from its\nISBN?\nTheo In the Catalog because the catalog holds a bookByISBN index.\nJoe What about author ID?\nTheo Author ID is the author name in lowercase and with dashes instead of white\nspaces (assuming that we don’t have two authors with the same name).\nJoe And I guess that you also hold the author index in the Catalog?\nTheo Exactly!\nJoe Excellent. You’ve been 100% explicit about the relation between Book and\nAuthor. I’ll ask you to do the same with the other relations of the system.\nIt’s quite easy for Theo to do, as he has done that so many times as an OOP developer. Fig-\nure 3.3 provides the detailed entity diagram of Theo’s system.\n NOTE By positional collection, we mean a collection where the elements are in order\n(like a list or an array). By index, we mean a collection where the elements are accessi-\nble via a key (like a hash map or a dictionary).\nThe Catalog entity contains two indexes:\n booksByIsbn—The keys are book ISBNs, and the values are Book entities. Its type is\nnoted as {Book}.\n authorsById—The keys are author IDs, and the values are Author entities. Its type\nis noted as {Author}.\nInside a Book entity, we have authors, which is a positional collection of author IDs of type\n[String]. Inside an Author entity, we have books, which is a collection of book IDs of\ntype [String].\n NOTE For the notation for collections and index types, a positional collection of\nStrings is noted as [String]. An index of Books is noted as {Book}. In the context of\na data model, the index keys are always strings.\n--- Page 75 ---\n3.1 Designing a data model 47\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: UserManagement\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian\nCC Book i n d a : m S e tr : i n S g tring email: String CC Me * mber\ntitle : String encryptedPassword: String\nbookIsbns: [String] email: String\npublicationYear: Number\nencryptedPassword: String\nisbn: String *\nisBlocked: Boolean\nauthorIds: [String]\nbookLendings: [BookLending]\nbookItems: [BookItem] *\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.3 Library management relation model. Dashed lines (e.g., between Book and Author) denote\nindirect relations, [String] denotes a positional collection of strings, and {Book} denotes an index of\nBooks.\nThere is a dashed line between Book and Author, which means that the relation between\nBook and Author is indirect. To access the collection of Author entities from a Book entity,\nwe’ll use the authorById index defined in the Catalog entity.\nJoe I like your data entity diagram.\nTheo Thank you.\nJoe Can you tell me what the three kinds of data aggregations are in your diagram\n(and, in fact, in any data entity diagram)?\nTheo Let’s see...we have positional collections like authors in Book. We have\nindexes like booksByIsbn in Catalog. I can’t find the third one.\nJoe The third kind of data aggregation is what we’ve called, until now, an “entity”\n(like Library, Catalog, Book, etc.), and the common term for entity in com-\nputer science is record.",
        "sections_found": []
      },
      "accurate_page_range": "56-75"
    },
    {
      "text": "- Summary",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "raw_line": "- Summary (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 21,
      "chapter_info": {
        "page": 56,
        "title": "Separation between code and data",
        "pattern_matched": "Chapter 2",
        "text_preview": "28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his te"
      },
      "chapter_sections": {
        "start_page": 56,
        "end_page": 75,
        "content": "\n--- Page 56 ---\n28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his team have built in Clojure over the last 7\nyears are less complex and more flexible than the systems he used to build in Java. Accord-\ning to Joe, the systems they build now tend to be much simpler because they follow the\nprinciples of DOP.\nTheo I’ve never heard of data-oriented programming. Is it a new concept?\nJoe Yes and no. Most of the foundational ideas of data-oriented programming, or\nDOP as we like to call it, are well known to programmers as best practices. The\nnovelty of DOP, however, is that it combines best practices into a cohesive\nwhole.\nTheo That’s a bit abstract for me. Can you give me an example?\nJoe Sure! Take, for instance, the first insight of DOP. It’s about the relations between\ncode and data.\nTheo You mean the encapsulation of data in objects?\nJoe Actually, DOP is against data encapsulation.\nTheo Why is that? I thought data encapsulation was a positive programming paradigm.\nJoe Data encapsulation has both merits and drawbacks. Think about the way you\ndesigned the Library Management System. According to DOP, the main cause\nof complexity and inflexibility in systems is that code and data are mixed\ntogether in objects.\nTIP DOP is against data encapsulation.\nTheo It sounds similar to what I’ve heard about functional programming. So, if I\nwant to adopt DOP, do I need to get rid of object-oriented programming and\nlearn functional programming?\nJoe No, DOP principles are language-agnostic. They can be applied in both object-\noriented and functional programming languages.\nTheo That’s a relief! I was afraid that you were going to teach me about monads,\nalgebraic data types, and higher order functions.\nJoe No, none of that is required in DOP.\nTIP DOP principles are language-agnostic.\nTheo What does the separation between code and data look like in DOP then?\nJoe Data is represented by data entities that only hold members. Code is aggre-\ngated into modules where all functions are stateless.\nTheo What do you mean by stateless functions?\nJoe Instead of having the state encapsulated in the object, the data entity is passed\nas an argument.\nTheo I don’t get that.\nJoe Here, let’s make it visual.\n--- Page 57 ---\n2.2 Data entities 29\nJoe steps up to a whiteboard and quickly draws a diagram to illustrate his comment. Fig-\nure 2.2 shows Joe’s drawing.\nCode modules Stateless functions\nSeparate code from data\nData entities Only members\nFigure 2.2 The separation between code and data\nTheo It’s still not clear.\nJoe It will become clearer when I show you how it looks in the context of your\nLibrary Management System.\nTheo OK. Shall we start with code or with data?\nJoe Well, it’s data-oriented programming, so let’s start with data.\n2.2 Data entities\nIn DOP, we start the design process by discovering the data entities of our system.\nHere’s what Joe and Theo have to say about data entities.\nJoe What are the data entities of your system?\nTheo What do you mean by data entities?\nJoe I mean the parts of your system that hold information.\n NOTE Data entities are the parts of your system that hold information.\nTheo Well, it’s a Library Management System, so we have books and members.\nJoe Of course, but there are more. One way to discover the data entities of a system\nis to look for nouns and noun phrases in the requirements of the system.\nTheo looks at Nancy’s requirement napkin. He highlights the nouns and noun phrases\nthat seem to represent data entities.\nHighlighting terms in the requirements that correspond to data entities\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n--- Page 58 ---\n30 CHAPTER 2 Separation between code and data\nJoe Excellent. Can you see a natural way to group these entities?\nTheo Not sure, but it seems to me that users, members, and librarians form one\ngroup, whereas books, authors, and book copies form another group.\nJoe Sounds good to me. What would you call each group?\nTheo Probably user management for the first group and catalog for the second\ngroup.\nThe data entities of the system organized in a nested list\n The catalog data\n– Data about books\n– Data about authors\n– Data about book items\n– Data about book lendings\n The user management data\n– Data about users\n– Data about members\n– Data about librarians\nTheo I’m not sure about the relations between books and authors. Should it be asso-\nciation or composition?\nJoe Don’t worry too much about the details for the moment. We’ll refine our data\nentity design later. For now, let’s visualize the two groups in a mind map.\nTheo and Joe confer for a bit. Figure 2.3 shows the mind map they come up with.\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 2.3 The data entities of the\nsystem organized in a mind map\n--- Page 59 ---\n2.3 Code modules 31\nThe most precise way to visualize the data entities of a DOP system is to draw a data\nentity diagram with different arrows for association and composition. We will come\nback to data entity diagrams later.\nTIP Discover the data entities of your system and then sort them into high-level\ngroups, either as a nested list or as a mind map.\nWe will dive deeper into the design and representation of data entities in the next\nchapter. For now, let’s simplify things and say that the data of our library system is\nmade of two high-level groups: user management and catalog.\n2.3 Code modules\nThe second step of the design process in DOP is to define the code modules. Let’s lis-\nten in on Joe and Theo again.\nJoe Now that you have identified the data entities of your system and have\narranged them into high-level groups, it’s time to think about the code part of\nyour system.\nTheo What do you mean by the code part?\nJoe One way to think about that is to identity the functionality of your system.\nTheo looks again at Nancy’s requirements. This time he highlights the verb phrases that\nrepresent functionality.\nHighlighting terms in the requirements that correspond to functionality\n There are two kinds of users: library members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\nIn addition, it’s obvious to Theo that members can also return a book. Moreover, there\nshould be a way to detect whether a user is a librarian or not. He adds those to the require-\nments and then lists the functionality of the system.\nThe functionality of the library system\n Search for a book.\n Add a book item.\n Block a member.\n--- Page 60 ---\n32 CHAPTER 2 Separation between code and data\n(continued)\n Unblock a member.\n Log a user into the system.\n List the books currently lent to a member.\n Borrow a book.\n Return a book.\n Check whether a user is a librarian.\nJoe Excellent! Now, tell me what functionality needs to be exposed to the outside\nworld?\nTheo What do you mean by exposed to the outside world?\nJoe Imagine that the Library Management System exposes an API over HTTP.\nWhat functionality would be exposed by the HTTP endpoints?\nTheo Well, all system functionality would be exposed except checking to see if a user\nis a librarian.\nJoe OK. Now give each exposed function a short name and gather them together\nin a module box called Library.\nThat takes Theo less than a minute. Figure 2.4 shows the module that contains the\nexposed functions of the library devised by Theo.\nC Library\nsearchBook()\naddBookItem()\nblockMember()\nunblockMember()\ngetBookLendings() Figure 2.4 The Library module\ncheckoutBook() contains the exposed functions of the\nreturnBook() Library Management System.\nTIP The first step in designing the code part of a DOP system is to aggregate the\nexposed functions into a single module.\nJoe Beautiful! You just created your first code module.\nTheo To me it looks like a class. What’s the difference between a module and a class?\nJoe A module is an aggregation of functions. In OOP, a module is represented\nbya class, but in other programming languages, it might be a package or a\nnamespace.\nTheo I see.\nJoe The important thing about DOP code modules is that they contain only state-\nless functions.\nTheo You mean like static methods in Java?\nJoe Yes, and the classes of these static methods should not have any data members.\n--- Page 61 ---\n2.3 Code modules 33\nTheo So, how do the functions know what piece of information they operate on?\nJoe Easy. We pass that as the first argument to the function.\nTheo OK. Can you give me an example?\nJoe, biting his nails, takes a look at the list of functions of the Library module in figure 2.4.\nHe spots a likely candidate.\nJoe Let’s take, for example, getBookLendings. In classic OOP, what would its\narguments be?\nTheo A librarian ID and a member ID.\nJoe So, in traditional OOP, getBookLendings would be a method of a Library\nclass that receives two arguments: librarianId and memberId.\nTheo Yep.\nJoe Now comes the subtle part. In DOP, getBookLendings is part of the Library\nmodule, and it receives the LibraryData as an argument.\nTheo Could you show me what you mean?\nJoe Sure.\nJoe goes over to Theo’s keyboard and starts typing. He enters an example of what a class\nmethod looks like in OOP:\nclass Library {\ncatalog\nuserManagement\ngetBookLendings(userId, memberId) {\n// accesses library state via this.catalog and this.userManagement\n}\n}\nTheo Right! The method accesses the state of the object (in our case, the library\ndata) via this.\nJoe Would you say that the object’s state is an argument of the object’s methods?\nTheo I’d say that the object’s state is an implicit argument to the object’s methods.\nTIP In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\nJoe Well, in DOP, we pass data as an explicit argument. The signature of getBook-\nLendings would look like this.\nListing2.1 The signature of getBookLendings\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\n}\n}\n--- Page 62 ---\n34 CHAPTER 2 Separation between code and data\nJoe The state of the library is stored in libraryData, and libraryData is passed\nto the getBookLendings static method as an explicit argument.\nTheo Is that a general rule?\nJoe Absolutely! The same rule applies to the other functions of the Library mod-\nule and to other modules as well. All of the modules are stateless—they receive\nthe library data that they manipulate as an argument.\nTIP In DOP, functions of a code module are stateless. They receive the data that they\nmanipulate as an explicit argument, which is usually the first argument.\n NOTE A module is an aggregation of functions. In DOP, the module functions are\nstateless.\nTheo It reminds me of Python and the way the self argument appears in method\nsignatures. Here, let me show you an example.\nListing2.2 A Python object as an explicit argument in method signatures\nclass Library:\ncatalog = {}\nuserManagement = {}\ndef getBookLendings(self, userId, memberId):\n# accesses library state via self.catalog and self.userManagement\nJoe Indeed, but the difference I’m talking about is much deeper than a syntax\nchange. It’s about the fact that data lives outside the modules.\nTheo I got that. As you said, module functions are stateless.\nJoe Exactly! Would you like to try and apply this principle across the whole\nLibrary module?\nTheo Sure.\nTheo refines the design of the Library module by including the details about the func-\ntions’ arguments. He presents the diagram in figure 2.5 to Joe.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId) Figure 2.5 The Library module\nreturnBook(libraryData, userId, bookItemId)\nwith the functions’ arguments\nJoe Perfect. Now, we’re ready to tackle the high-level design of our system.\nTheo What’s a high-level design in DOP?\n--- Page 63 ---\n2.3 Code modules 35\nJoe A high-level design in DOP is the definition of modules and the interaction\nbetween them.\nTheo I see. Are there any guidelines to help me define the modules?\nJoe Definitely. The high-level modules of the system correspond to the high-level\ndata entities.\nTheo You mean the data entities that appear in the data mind map?\nJoe Exactly!\nTheo looks again at the data mind map (figure 2.6). He focuses on the high-level data enti-\nties library, catalog, and user management. This means that in the system, besides the\nLibrary module, we have two high-level modules:\n The Catalog module deals with catalog data.\n The UserManagement module deals with user management data.\nCatalog\nLibrary data Figure 2.6 A mind map of the high-\nlevel data entities of the Library\nUser management\nManagement System\nTheo then draws the high-level design of the Library Management System with the Catalog\nand UserManagement modules. Figure 2.7 shows the addition of these modules, where:\n Functions of Catalog receive catalogData as their first argument.\n Functions of UserManagement receive userManagementData as their first argument.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.7 The modules of the Library Management System with their functions’ arguments\n--- Page 64 ---\n36 CHAPTER 2 Separation between code and data\nIt’s not 100% clear for Theo at this point how the data entities get passed between mod-\nules. For the moment, he thinks of libraryData as a class with two members:\n catalog holds the catalog data.\n userManagement holds the user management data.\nTheo also sees that the functions of Library share a common pattern. (Later on in this\nchapter, we’ll see the code for some functions of the Library module.)\n They receive libraryData as an argument.\n They pass libraryData.catalog to the functions of Catalog.\n They pass libraryData.userManagement to the functions of UserManagement.\nTIP The high-level modules of a DOP system correspond to the high-level data enti-\nties.\n2.4 DOP systems are easy to understand\nTheo takes a look at the two diagrams that represent the high-level design of his system:\n The data entities in the data mind map in figure 2.8\n The code modules in the module diagram in figure 2.9\nA bit perplexed, Theo asks Joe:\nTheo I’m not sure that this system is better than a traditional OOP system where\nobjects encapsulate data.\nJoe The main benefit of a DOP system over a traditional OOP system is that it’s eas-\nier to understand.\nTheo What makes it easier to understand?\nJoe The fact that the system is split cleanly into code modules and data entities.\nTheo How does that help?\nJoe When you try to understand the data entities of the system, you don’t have to\nthink about the details of the code that manipulates the data entities.\nTheo So, when I look at the data mind map of my Library Management System, I can\nunderstand it on its own?\nJoe Exactly, and similarly, when you try to understand the code modules of the sys-\ntem, you don’t have to think about the details of the data entities manipulated\nby the code. There is a clear separation of concerns between the code and the\ndata.\nTheo looks again at the data mind map in figure 2.8. He has kind of an Aha! moment:\nData lives on its own!\n NOTE A DOP system is easier to understand because the system is split into two\nparts: data entities and code modules.\n--- Page 65 ---\n2.4 DOP systems are easy to understand 37\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nFigure 2.8 A data mind map of the\nLibrarians\nLibrary Management System\nNow, Theo looks at the module diagram in figure 2.9. He feels a bit confused and asks Joe\nfor clarification:\n On one hand, the module diagram looks similar to the class diagrams from classic\nOOP, boxes for classes and arrows for relations between classes.\n On the other hand, the code module diagram looks much simpler than the class\ndiagrams from classic OOP, but he cannot explain why.\nC Library\nsearchBook(libraryData, searchQuery)\naddBookItem(libraryData, bookItemInfo)\nblockMember(libraryData, memberId)\nunblockMember(libraryData, memberId)\nlogin(libraryData, loginInfo)\ngetBookLendings(libraryData, userId)\ncheckoutBook(libraryData, userId, bookItemId)\nreturnBook(libraryData, userId, bookItemId)\nC Catalog\nC UserManagement\nsearchBook(catalogData, searchQuery)\nblockMember(userManagementData, memberId)\naddBookItem(catalogData, bookItemInfo)\nunblockMember(userManagementData, memberId)\ncheckoutBook(catalogData, bookItemId)\nlogin(userManagementData, loginInfo)\nreturnBook(catalogData, bookItemId)\nisLibrarian(userManagementData, userId)\ngetBookLendings(catalogData, userId)\nFigure 2.9 The modules of the Library Management System with the function arguments\nTheo The module diagram seems much simpler than the class diagrams I am used to\nin OOP. I feel it, but I can’t put it into words.\nJoe The reason is that module diagrams have constraints.\n--- Page 66 ---\n38 CHAPTER 2 Separation between code and data\nTheo What kind of constraints?\nJoe Constraints on the functions we saw before. All the functions are static (or\nstateless), but there’s also constraints on the relations between the modules.\nTIP All the functions in a DOP module are stateless.\nTheo In what way are the relations between modules constrained?\nJoe There is a single kind of relation between DOP modules—the usage relation. A\nmodule uses code from another module. There’s no association, no composi-\ntion, and no inheritance between modules. That’s what makes a DOP module\ndiagram easy to understand.\nTheo I understand why there is no association and no composition between DOP\nmodules. After all, association and composition are data relations. But why no\ninheritance relation? Does that mean that DOP is against polymorphism?\nJoe That’s a great question! The quick answer is that in DOP, we achieve polymor-\nphism with a different mechanism than class inheritance. We will talk about it\nsome day.\n NOTE For a discussion of polymorphism in DOP, see chapter 13.\nTheo Now, you’ve piqued my curiosity. I thought inheritance was the only way to\nachieve polymorphism.\nTheo looks again at the module diagram in figure 2.9. Now he not only feels that this dia-\ngram is simpler than traditional OOP class diagrams, he understands why it’s simpler: all\nthe functions are static, and all the relations between modules are of type usage. Table 2.1\nsummarizes Theo’s perception.\nTIP The only kind of relation between DOP modules is the usage relation.\nTable 2.1 What makes each part of a DOP system easy to understand\nSystem part Constraint on entities Constraints on relations\nData entities Members only (no code) Association and composition\nCode modules Stateless functions (no members) Usage (no inheritance)\nTIP Each part of a DOP system is easy to understand because it provides constraints.\n2.5 DOP systems are flexible\nTheo I see how a sharp separation between code and data makes DOP systems easier\nto understand than classic OOP systems. But what about adapting to changes\nin requirements?\nJoe Another benefit of DOP systems is that it is easy to extend them and to adapt to\nchanging requirements.\n--- Page 67 ---\n2.5 DOP systems are flexible 39\nTheo I remember that, when Nancy asked me to add Super members and VIP mem-\nbers to the system, it was hard to adapt my OOP system. I had to introduce a\nfew base classes, and the class hierarchy became really complex.\nJoe I know exactly what you mean. I’ve experienced the same kind of struggle so\nmany times. Describe the changes in the requirements for Super members and\nVIP members, and I’m quite sure that you’ll see how easy it would be to extend\nyour DOP system.\nThe requirements for Super members and VIP members\n Super members are members that are allowed to list the book lendings to\nother members.\n VIP members are members that are allowed to add book items to the library.\nTheo opens his IDE and starts to code the getBookLendings function of the Library\nmodule (see listing 2.3), first without addressing the requirements for Super members.\nTheo remembers what Joe told him about module functions in DOP:\n Functions are stateless.\n Functions receive the data they manipulate as their first argument.\nIn terms of functionality, getBookLendings has two parts:\n Checks that the user is a librarian.\n Retrieves the book lendings from the catalog.\nBasically, the code of getBookLendings has two parts as well:\n Calls the isLibrarian function from the UserManagement module and passes it\nthe UserManagementData.\n Calls the getBookLendings function from the Catalog module and passes it the\nCatalogData.\nListing2.3 Getting the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\n}\ngeneric data collections.\n--- Page 68 ---\n40 CHAPTER 2 Separation between code and data\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nIt’s Theo’s first piece of DOP code and passing around all those data objects—library-\nData, libraryData.userManagement, and libraryData.catalog—feels a bit awkward.\nBut he did it! Joe looks at Theo’s code and seems satisfied.\nJoe Now, how would you adapt your code to Super members?\nTheo I would add a function isSuperMember to the UserManagement module and\ncall it from Library.getBookLendings.\nJoe Exactly! It’s as simple as that.\nTheo types the code on his laptop so that he can show it to Joe. Here’s how Theo adapts\nhis code for Super members.\nListing2.4 Allowing Super members to get the book lendings of a member\nclass Library {\nstatic getBookLendings(libraryData, userId, memberId) {\nif(Usermanagement.isLibrarian(libraryData.userManagement, userId) ||\nUsermanagement.isSuperMember(libraryData.userManagement, userId)) {\nreturn Catalog.getBookLendings(libraryData.catalog, memberId);\n} else {\nthrow \"Not allowed to get book lendings\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isSuperMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nNow, the awkward feeling caused by passing around all those data objects is dominated by\na feeling of relief. Adapting to this change in requirements takes only a few lines of code\nand requires no changes in the system design. Once again, Joe seems satisfied.\nTIP DOP systems are flexible. Quite often they adapt to changing requirements with-\nout changing the system design.\n--- Page 69 ---\n2.5 DOP systems are flexible 41\nTheo starts coding addBookItem. He looks at the signature of Library.addBookItem,\nand the meaning of the third argument bookItemInfo isn’t clear to him. He asks Joe for\nclarification.\nListing2.5 The signature of Library.addBookItem\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\n}\n}\nTheo What is bookItemInfo?\nJoe Let’s call it the book item information. Imagine we have a way to represent this\ninformation in a data entity named bookItemInfo.\nTheo You mean an object?\nJoe For now, it’s OK to think about bookItemInfo as an object. Later on, I will\nshow you how to we represent data in DOP.\nBesides this subtlety about how the book item information is represented by book-\nItemInfo, the code for Library.addBookItem in listing 2.6 is quite similar to the code\nTheo wrote for Library.getBookLendings in listing 2.4. Once again, Theo is amazed by\nthe fact that adding support for VIP members requires no design change.\nListing2.6 Allowing VIP members to add a book item to the library\nclass Library {\nstatic addBookItem(libraryData, userId, bookItemInfo) {\nif(UserManagement.isLibrarian(libraryData.userManagement, userId) ||\nUserManagement.isVIPMember(libraryData.userManagement, userId)) {\nreturn Catalog.addBookItem(libraryData.catalog, bookItemInfo);\n} else {\nthrow \"Not allowed to add a book item\";\nThere are other\n}\nways to manage\n}\nerrors.\n}\nclass UserManagement {\nstatic isLibrarian(userManagementData, userId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto manage permissions with\nstatic isVIPMember(userManagementData, userId) {\ngeneric data collections.\n// will be implemented later\n}\n}\nclass Catalog {\nstatic addBookItem(catalogData, memberId) {\n// will be implemented later\nIn chapter 4, we will see how\n}\nto manage state of the system\n}\nwith immutable data.\n--- Page 70 ---\n42 CHAPTER 2 Separation between code and data\nTheo It takes a big mindset shift to learn how to separate code from data!\nJoe What was the most challenging thing to accept?\nTheo The fact that data is not encapsulated in objects.\nJoe It was the same for me when I switched from OOP to DOP.\nNow it’s time to eat! Theo takes Joe for lunch at Simple, a nice, small restaurant near the\noffice.\nSummary\n DOP principles are language-agnostic.\n DOP principle #1 is to separate code from data.\n The separation between code and data in DOP systems makes them simpler\n(easier to understand) than traditional OOP systems.\n Data entities are the parts of your system that hold information.\n DOP is against data encapsulation.\n The more flexible a system is, the easier it is to adapt to changing requirements.\n The separation between code and data in DOP systems makes them more flexi-\nble than traditional OOP systems.\n When code is separated from data, we have the freedom to design code and\ndata in isolation.\n We represent data as data entities.\n We discover the data entities of our system and sort them into high-level groups,\neither as a nested list or as a mind map.\n A DOP system is easier to understand than a traditional OOP system because\nthe system is split into two parts: data entities and code modules.\n In DOP, a code module is an aggregation of stateless functions.\n DOP systems are flexible. Quite often they adapt to changing requirements\nwithout changing the system design.\n In traditional OOP, the state of the object is an implicit argument to the meth-\nods of the object.\n Stateless functions receive data they manipulate as an explicit argument.\n The high-level modules of a DOP system correspond to high-level data entities.\n The only kind of relation between code modules is the usage relation.\n The only kinds of relation between data entities are the association and the compo-\nsition relation.\n For a discussion of polymorphism in DOP, see chapter 13.\n--- Page 71 ---\nBasic data manipulation\nMeditation and programming\nThis chapter covers\n Representing records with string maps to improve\nflexibility\n Manipulating data with generic functions\n Accessing each piece of information via its\ninformation path\n Gaining JSON serialization for free\nAfter learning why and how to separate code from data in the previous chapter,\nlet’s talk about data on its own. In contrast to traditional OOP, where system design\ntends to involve a rigid class hierarchy, DOP prescribes that we represent our data\nmodel as a flexible combination of maps and arrays (or lists), where we can access\neach piece of information via an information path. This chapter is a deep dive into\nthe second principle of DOP.\nPRINCIPLE #2 Represent data entities with generic data structures.\n43\n--- Page 72 ---\n44 CHAPTER 3 Basic data manipulation\nWe increase system flexibility when we represent records as string maps and not as\nobjects instantiated from classes. This liberates data from the rigidity of a class-based sys-\ntem. Data becomes a first-class citizen powered by generic functions to add, remove, or\nrename fields.\n NOTE We refer to maps that have strings as keys as string maps.\nThe dependency between the code that manipulates data and the data is a weak\ndependency. The code only needs to know the keys of specific fields in the record it\nwants to manipulate. The code doesn’t even need to know about all the keys in the\nrecord, only the ones relevant to it. In this chapter, we’ll deal only with data query.\nWe’ll discuss managing changes in system state in the next chapter.\n3.1 Designing a data model\nDuring lunch at Simple, Theo and Joe don’t talk about programming. Instead, they start\ngetting to know each other on a personal level. Theo discovers that Joe is married to Kay,\nwho has just opened her creative therapy practice after many years of studying various\nfields related to well-being. Neriah, their 14-year-old son, is passionate about drones, whereas\nAurelia, their 12-year-old daughter, plays the transverse flute.\nJoe tells Theo that he’s been practicing meditation for 10 years. Meditation, he says, has\ntaught him how to break away from being continually lost in a “storm thought” (especially\nnegative thoughts, which can be the source of great suffering) to achieve a more direct\nrelationship with reality. The more he learns to experience reality as it is, the calmer his\nmind. When he first started to practice meditation, it was sometimes difficult and even\nweird, but by persevering, he has increased his feeling of well-being with each passing year.\nWhen they’re back at the office, Joe tells Theo that his next step in their DOP journey\nwill be about data models. This includes data representation.\nJoe When we design the data part of our system, we’re free to do it in isolation.\nTheo What do you mean by isolation?\nJoe I mean that you don’t have to bother with code, only data.\nTheo Oh, right. I remember you telling me how that makes a DOP system simpler\nthan OOP. Separation of concerns is a design principle I’m used to in OOP.\nJoe Indeed.\nTheo And, when we think about data, the only relations we have to think about are\nassociation and composition.\nJoe Correct.\nTheo Will the data model design be significantly different than the data model I’m\nused to designing as an OOP developer?\nJoe Not so much.\nTheo OK. Let me see if I can draw a DOP-style data entity diagram.\nTheo takes a look at the data mind map that he drew earlier in the morning. He then\ndraws the diagram in figure 3.1.\nHe refines the details of the fields of each data entity and the kind of relations between\nentities. Figure 3.2 shows the result of this redefined data entity diagram.\n--- Page 73 ---\n3.1 Designing a data model 45\nBooks\nAuthors\nCatalog\nBook items\nLibrary data Book lendings\nUsers\nUser management Members\nLibrarians Figure 3.1 A data mind map of\nthe Library Management System\nCC Library\nname: String\naddress: String\nCC Catalog CC UserManagement\n* * *\nCC Book CC Librarian CC Member\nemail: String email: String\ntitle : String\npassword: String password: String\npublicationYear: Number\n*\nISBN: String\npublisher: String\n* *\nCC Author CC BookLending\nname: String lendingDate: String\nCC BookItem\n* libld: String\npurchaseDate: String\nFigure 3.2 A data model of the Library Management System\n--- Page 74 ---\n46 CHAPTER 3 Basic data manipulation\nJoe The next step is to be more explicit about the relations between entities.\nTheo What do you mean?\nJoe For example, in your entity diagram, Book and Author are connected by a\nmany-to-many association relation. How is this relation going to be repre-\nsented in your program?\nTheo In the Book entity, there will be a collection of author IDs, and in the Author\nentity, there will be a collection of book IDs.\nJoe Sounds good. And what will the book ID be?\nTheo The book ISBN.\n NOTE The International Standard Book Number (ISBN) is a numeric commercial\nbook identifier that is intended to be unique.\nJoe And where will you hold the index that enables you to retrieve a Book from its\nISBN?\nTheo In the Catalog because the catalog holds a bookByISBN index.\nJoe What about author ID?\nTheo Author ID is the author name in lowercase and with dashes instead of white\nspaces (assuming that we don’t have two authors with the same name).\nJoe And I guess that you also hold the author index in the Catalog?\nTheo Exactly!\nJoe Excellent. You’ve been 100% explicit about the relation between Book and\nAuthor. I’ll ask you to do the same with the other relations of the system.\nIt’s quite easy for Theo to do, as he has done that so many times as an OOP developer. Fig-\nure 3.3 provides the detailed entity diagram of Theo’s system.\n NOTE By positional collection, we mean a collection where the elements are in order\n(like a list or an array). By index, we mean a collection where the elements are accessi-\nble via a key (like a hash map or a dictionary).\nThe Catalog entity contains two indexes:\n booksByIsbn—The keys are book ISBNs, and the values are Book entities. Its type is\nnoted as {Book}.\n authorsById—The keys are author IDs, and the values are Author entities. Its type\nis noted as {Author}.\nInside a Book entity, we have authors, which is a positional collection of author IDs of type\n[String]. Inside an Author entity, we have books, which is a collection of book IDs of\ntype [String].\n NOTE For the notation for collections and index types, a positional collection of\nStrings is noted as [String]. An index of Books is noted as {Book}. In the context of\na data model, the index keys are always strings.\n--- Page 75 ---\n3.1 Designing a data model 47\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: UserManagement\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian\nCC Book i n d a : m S e tr : i n S g tring email: String CC Me * mber\ntitle : String encryptedPassword: String\nbookIsbns: [String] email: String\npublicationYear: Number\nencryptedPassword: String\nisbn: String *\nisBlocked: Boolean\nauthorIds: [String]\nbookLendings: [BookLending]\nbookItems: [BookItem] *\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.3 Library management relation model. Dashed lines (e.g., between Book and Author) denote\nindirect relations, [String] denotes a positional collection of strings, and {Book} denotes an index of\nBooks.\nThere is a dashed line between Book and Author, which means that the relation between\nBook and Author is indirect. To access the collection of Author entities from a Book entity,\nwe’ll use the authorById index defined in the Catalog entity.\nJoe I like your data entity diagram.\nTheo Thank you.\nJoe Can you tell me what the three kinds of data aggregations are in your diagram\n(and, in fact, in any data entity diagram)?\nTheo Let’s see...we have positional collections like authors in Book. We have\nindexes like booksByIsbn in Catalog. I can’t find the third one.\nJoe The third kind of data aggregation is what we’ve called, until now, an “entity”\n(like Library, Catalog, Book, etc.), and the common term for entity in com-\nputer science is record.",
        "sections_found": []
      },
      "accurate_page_range": "56-75"
    }
  ]
}