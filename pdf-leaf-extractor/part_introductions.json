{
  "part_introductions": [
    {
      "text": "- Part1 Introduction content",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "Part1 Introduction (사용자 추가)",
      "raw_line": "- Part1 Introduction content (node3) **[LEAF]**",
      "is_part_intro": true,
      "id": 1,
      "accurate_page_range": "30-31",
      "extracted_content": "\n=== Page 30 ===\n2 PART 1 Flexibility\nThe requirements for the Klafim prototype\n Two kinds of library users are members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n The book belongs to a physical library.\nTheo Well, that’s pretty clear.\nNancy How much time would it take for your company to deliver the prototype?\nTheo I think we should be able to deliver within a month. Let’s say Wednesday the\n30th.\nNancy That’s too long. We need it in two weeks!\nTheo That’s tough! Can you cut a feature or two?\nNancy Unfortunately, we cannot cut any feature, but if you like, you can make the\nsearch very basic.\n(Theo really doesn’t want to lose this contract, so he’s willing to work hard and sleep later.)\nTheo I think it should be doable by Wednesday the 16th.\nNancy Perfect!\n\n=== Page 31 ===\nComplexity of object-\noriented programming\nA capricious entrepreneur\nThis chapter covers\n The tendency of OOP to increase system\ncomplexity\n What makes OOP systems hard to understand\n The cost of mixing code and data together into\nobjects\nIn this chapter, we’ll explore why object-oriented programming (OOP) systems tend to\nbe complex. This complexity is not related to the syntax or the semantics of a specific\nOOP language. It is something that is inherent to OOP’s fundamental insight—\nprograms should be composed from objects, which consist of some state, together\nwith methods for accessing and manipulating that state.\nOver the years, OOP ecosystems have alleviated this complexity by adding new\nfeatures to the language (e.g., anonymous classes and anonymous functions) and\nby developing frameworks that hide some of this complexity, providing a simpler\ninterface for developers (e.g., Spring and Jackson in Java). Internally, the frame-\nworks rely on the advanced features of the language such as reflection and custom\nannotations.\n3"
    },
    {
      "text": "- Part2 Introduction content",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "6 Unit tests",
      "raw_line": "- Part2 Introduction content (node3) **[LEAF]**",
      "is_part_intro": true,
      "id": 55,
      "accurate_page_range": "171-175",
      "extracted_content": "\n=== Page 171 ===\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n\n=== Page 172 ===\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n\n=== Page 173 ===\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n\n=== Page 174 ===\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\n=== Page 175 ===\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer"
    },
    {
      "text": "- Part2 Introduction content",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "Part2 Introduction (사용자 추가)",
      "raw_line": "- Part2 Introduction content (node3) **[LEAF]**",
      "is_part_intro": true,
      "id": 56,
      "accurate_page_range": "171-175",
      "extracted_content": "\n=== Page 171 ===\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n\n=== Page 172 ===\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n\n=== Page 173 ===\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n\n=== Page 174 ===\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\n=== Page 175 ===\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer"
    },
    {
      "text": "- Part3 Introduction content",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "Part3 Introduction (사용자 추가)",
      "raw_line": "- Part3 Introduction content (node3) **[LEAF]**",
      "is_part_intro": true,
      "id": 97,
      "accurate_page_range": "298-302",
      "extracted_content": "\n=== Page 298 ===\n270 CHAPTER 12 Advanced data validation\n\"myLetters\": {\nmyLetters is a string with\n\"type\": \"string\",\nletters only (lowercase or\n\"pattern\": \"[a-zA-Z]*\"\nuppercase).\n}\n\"myNumberMap\": {\nmyNumberMap is an homogeneous\n\"type\": \"object\",\nstring map where all the values are\n\"additionalProperties\": {\"type\": \"number\"}\nnumbers.\n},\n\"myTuple\": {\nmyTuple is a tuple where the first\n\"type\": \"array\",\nelement is a string and the second\n\"prefixItems\": [\nelement is a number.\n{ \"type\": \"string\" },\n{ \"type\": \"number\" }\n]\n} The mandatory fields in the map\nare myNumber and myString.\n},\nOther fields are optional.\n\"required\": [\"myNumber\", \"myString\"],\n\"additionalProperties\": false\nWe don’t allow fields that\n}\nare not explicitly mentioned\n}\nin the schema.\nListing12.31 An example of valid data\n[\n{\n\"myNumber\": 42,\n\"myString\": \"I-love-you\",\n\"myEnum\": \"myVal\",\n\"myBool\": true,\n\"myTuple\": [\"Hello\", 42]\n},\n{\n\"myNumber\": 54,\n\"myString\": \"Happy\",\n\"myAge\": 42,\n\"myBirthday\": \"1978-11-23\",\n\"myLetters\": \"Hello\",\n\"myNumberMap\": {\n\"banana\": 23,\n\"apple\": 34\n}\n}\n]\nSummary\n We define data schemas using a language like JSON Schema for function argu-\nments and return values.\n Function argument schemas allow developers to figure out the expected shape of\nthe function arguments they want to call.\n When invalid data is passed, data validation third-party libraries give meaning-\nful errors with detailed information about the data parts that are not valid.\n\n=== Page 299 ===\nSummary 271\n Unlike data validation at system boundaries, data validation inside the system is\nsupposed to run only at development time and should be disabled in production.\n We visualize a data schema by generating a data model diagram out of a JSON\nSchema.\n For functions that have data schemas for their arguments and return values, we\ncan automatically generate schema-based unit tests.\n Data validation is executed at run time.\n We can define advanced data validation conditions that go beyond static types,\nlike checking whether a number is within a range or if a string matches a regu-\nlar expression.\n Data validation inside the system should be disabled in production.\n Records are represented as heterogeneous maps, and indexes are represented as\nhomogeneous maps.\n When you define a complex data schema, it is advised to store nested schemas\nin variables to make the schemas easier to read.\n We treat data validation like unit tests.\n\n=== Page 300 ===\nPolymorphism\nPlaying with the animals\nin the countryside\nThis chapter covers\n Mimicking objects with multimethods (single\ndispatch)\n Implementing multimethod on several argument\ntypes (multiple dispatch)\n Implementing multimethods dynamically on\nseveral arguments (dynamic dispatch)\nOOP is well-known for allowing different classes to be called with the same inter-\nface via a mechanism called polymorphism. It may seem that the only way to have\npolymorphism in a program is with objects. In fact, in this chapter, we are going to\nsee that it is possible to have polymorphism without objects, thanks to multimeth-\nods. Moreover, multimethods provide a more advanced polymorphism than OOP\npolymorphism because they support cases where the chosen implementation\ndepends on several argument types (multiple dispatch) and even on the dynamic\nvalue of the arguments (dynamic dispatch).\n272\n\n=== Page 301 ===\n13.1 The essence of polymorphism 273\n13.1 The essence of polymorphism\nFor today’s session, Dave has invited Theo to come and visit him at his parents’ house in\nthe countryside. As Theo’s drive across the Golden Gate Bridge takes him from the freeway\nto increasingly rural country roads, he lets himself be carried away by the beauty of the\nlandscape, the smell of fresh earth, and the sounds of animals in nature. This “nature\nbath” puts him in an excellent mood. What a way to start the week!\nDave receives Theo in jeans and a T-shirt, a marked contrast with the elegant clothes he\nwears at the office. A straw hat completes his country look. Theo says hello to Dave’s par-\nents, now retired. Dave suggests that they go pick a few oranges in the field to squeeze for\njuice. After drinking a much more flavorful orange juice than they are used to in San Fran-\ncisco, Theo and Dave get to work.\nDave When I was waiting for you this morning, I thought of another thing I miss\nfrom OOP.\nTheo What’s that?\nDave Polymorphism.\nTheo What kind of polymorphism?\nDave You know, you define an interface, and different classes implement the same\ninterface in different ways.\nTheo I see. And why do you think polymorphism is valuable?\nDave Because it allows us to decouple an interface from its implementations.\nTheo Would you mind illustrating that with a concrete example?\nDave Sure. Because we’re in the country, I’ll use the classic OOP polymorphism\nexample with animals.\nTheo Good idea!\nDave Let’s say that each animal has its own greeting by making a sound and saying\nits name.\nTheo Oh cool, like in anthropomorphic comics books.\nDave Anthro what?\nTheo You know, comics books where animals can walk, speak, and so forth—like\nMickey Mouse.\nDave Of course, but I don’t know that term. Where does it come from?\nTheo Anthropomorphism comes from the Greek ánthro–pos, which means human, and\nmorphe–, which means form.\nDave I see. So an anthropomorphic book is a book where animals have human traits.\nThe word sounds related to polymorphism.\nTheo Absolutely. Polymorphism comes from the Greek polús, which means many, and\nmorphe–, which, again, means form.\nDave That makes sense. Polymorphism is the ability of different objects to imple-\nment the same method in different ways. That brings me back to my animal\nexample. In OOP, I’d define an IAnimal interface with a greet method, and\neach animal class would implement greet in its own way. Here, I happen to\nhave an example.\n\n=== Page 302 ===\n274 CHAPTER 13 Polymorphism\nListing13.1 OOP polymorphism illustrated with animals\ninterface IAnimal {\npublic void greet();\n}\nclass Dog implements IAnimal {\nprivate String name;\npublic void greet() {\nSystem.out.println(\"Woof woof! My name is \" + animal.name);\n}\n}\nclass Cat implements IAnimal {\nprivate String name;\npublic void greet() {\nSystem.out.println(\"Meow! I am \" + animal.name);\n}\n}\nclass Cow implements IAnimal {\nprivate String name;\npublic void greet() {\nSystem.out.println(\"Moo! Call me \" + animal.name);\n}\n}\nTheo Let me challenge you a bit. What is the fundamental difference between OOP\npolymorphism and a switch statement?\nDave What do you mean?\nTheo I could, for instance, represent an animal with a map having two fields, name\nand type, and call a different piece of code, depending on the value of type.\nTheo pulls his laptop from its bag and fires it up. While the laptop is booting up, he enjoys\nanother taste of that wonderful orange juice. When the laptop is ready, he quickly types in\nthe example switch case. Meanwhile, Dave has finished his glass of orange juice.\nListing13.2 A switch case where behavior depends on type\nfunction greet(animal) {\nswitch (animal.type) {\ncase \"dog\":\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\nbreak;\ncase \"cat\":\nconsole.log(\"Meow! I am: \" + animal.name);\nbreak;\ncase \"cow\":\nconsole.log(\"Moo! Call me \" + animal.name);\nbreak;\n};\n}"
    }
  ],
  "total_count": 4
}