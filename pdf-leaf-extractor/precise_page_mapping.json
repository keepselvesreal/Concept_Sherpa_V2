{
  "pdf_file": "/home/nadle/projects/Knowledge_Sherpa/v2/2022_Data-Oriented Programming_Manning.pdf",
  "total_pages": 426,
  "chapter_pages_found": {
    "1": {
      "page": 29,
      "text": "Part 1",
      "pattern_type": "part",
      "line_position": 0,
      "full_text_preview": "Part 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development ag"
    },
    "2": {
      "page": 30,
      "text": "2 PART 1 Flexibility",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "2 PART 1 Flexibility\nThe requirements for the Klafim prototype\n Two kinds of library users are members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock"
    },
    "4": {
      "page": 32,
      "text": "4 CHAPTER 1 Complexity of object-orientedprogramming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different prog"
    },
    "6": {
      "page": 34,
      "text": "6 CHAPTER 1 Complexity of object-orientedprogramming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(m"
    },
    "8": {
      "page": 36,
      "text": "8 CHAPTER 1 Complexity of object-orientedprogramming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at bot"
    },
    "10": {
      "page": 38,
      "text": "10 CHAPTER 1 Complexity of object-orientedprogramming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE"
    },
    "12": {
      "page": 40,
      "text": "12 CHAPTER 1 Complexity of object-orientedprogramming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Fi"
    },
    "14": {
      "page": 42,
      "text": "14 CHAPTER 1 Complexity of object-orientedprogramming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable"
    },
    "16": {
      "page": 44,
      "text": "16 CHAPTER 1 Complexity of object-orientedprogramming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "16 CHAPTER 1 Complexity of object-orientedprogramming\nThe class diagram where Member is split into MemberCode and MemberData is made of\ntwo independent parts. Each part is easier to understand than the original diagram.\nLet’s split every class of our original class diagram into code and data entitie"
    },
    "18": {
      "page": 46,
      "text": "18 CHAPTER 1 Complexity of object-orientedprogramming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "18 CHAPTER 1 Complexity of object-orientedprogramming\nThis unpredictable behavior of the second listing is one of the annoying conse-\nquences of OOP. Unlike primitive types, which are usually immutable, object mem-\nbers are mutable. One way to solve this problem in OOP is to protect sensitive code\nw"
    },
    "20": {
      "page": 48,
      "text": "20 CHAPTER 1 Complexity of object-orientedprogramming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "20 CHAPTER 1 Complexity of object-orientedprogramming\nThe bad news is that Theo would have to repeat the same process for every end-\npoint of the system. Each time he encounters a new kind of JSON input or output,\nhe would have to create a new class and write code. Theo’s dream is turning into a\nnig"
    },
    "22": {
      "page": 50,
      "text": "22 CHAPTER 1 Complexity of object-orientedprogramming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "22 CHAPTER 1 Complexity of object-orientedprogramming\n VIP members are library members.\n VIP members are allowed to add book items to the library by themselves.\nTheo then decides that he needs a new class, VIPMember. For the first requirement\n(VIP members are library members), it seems reasonable "
    },
    "24": {
      "page": 52,
      "text": "24 CHAPTER 1 Complexity of object-orientedprogramming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "24 CHAPTER 1 Complexity of object-orientedprogramming\nDiamonds of Death” as OOP developers sometimes name the ambiguity that arises when a\nclass D inherits from two classes B and C, where both inherit from class A!\nHe tries to avoid the diamonds by transforming the User class into an interface and\nu"
    },
    "26": {
      "page": 54,
      "text": "26",
      "pattern_type": "chapter",
      "line_position": 17,
      "full_text_preview": "Separation between\ncode and data\nA whole new world\nThis chapter covers\n The benefits of separating code from data\n Designing a system where code and data are\nseparate\n Implementing a system that respects the\nseparation between code and data\nThe first insight of DOP is that we can decrease the com"
    },
    "28": {
      "page": 56,
      "text": "28 CHAPTER 2 Separation between code and data",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "28 CHAPTER 2 Separation between code and data\nhe designed and built, and about his struggles to adapt to changing requirements, Joe is\nnot surprised.\nJoe tells Theo that the systems that he and his team have built in Clojure over the last 7\nyears are less complex and more flexible than the systems h"
    },
    "30": {
      "page": 58,
      "text": "30 CHAPTER 2 Separation between code and data",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "30 CHAPTER 2 Separation between code and data\nJoe Excellent. Can you see a natural way to group these entities?\nTheo Not sure, but it seems to me that users, members, and librarians form one\ngroup, whereas books, authors, and book copies form another group.\nJoe Sounds good to me. What would you call"
    },
    "32": {
      "page": 60,
      "text": "32 CHAPTER 2 Separation between code and data",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "32 CHAPTER 2 Separation between code and data\n(continued)\n Unblock a member.\n Log a user into the system.\n List the books currently lent to a member.\n Borrow a book.\n Return a book.\n Check whether a user is a librarian.\nJoe Excellent! Now, tell me what functionality needs to be exposed to the "
    },
    "34": {
      "page": 62,
      "text": "34 CHAPTER 2 Separation between code and data",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "34 CHAPTER 2 Separation between code and data\nJoe The state of the library is stored in libraryData, and libraryData is passed\nto the getBookLendings static method as an explicit argument.\nTheo Is that a general rule?\nJoe Absolutely! The same rule applies to the other functions of the Library mod-\nu"
    },
    "36": {
      "page": 64,
      "text": "36 CHAPTER 2 Separation between code and data",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "36 CHAPTER 2 Separation between code and data\nIt’s not 100% clear for Theo at this point how the data entities get passed between mod-\nules. For the moment, he thinks of libraryData as a class with two members:\n catalog holds the catalog data.\n userManagement holds the user management data.\nTheo a"
    },
    "38": {
      "page": 66,
      "text": "38 CHAPTER 2 Separation between code and data",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "38 CHAPTER 2 Separation between code and data\nTheo What kind of constraints?\nJoe Constraints on the functions we saw before. All the functions are static (or\nstateless), but there’s also constraints on the relations between the modules.\nTIP All the functions in a DOP module are stateless.\nTheo In wh"
    },
    "13": {
      "page": 66,
      "text": " NOTE For a discussion of polymorphism in DOP, see chapter 13.",
      "pattern_type": "chapter",
      "line_position": 16,
      "full_text_preview": "38 CHAPTER 2 Separation between code and data\nTheo What kind of constraints?\nJoe Constraints on the functions we saw before. All the functions are static (or\nstateless), but there’s also constraints on the relations between the modules.\nTIP All the functions in a DOP module are stateless.\nTheo In wh"
    },
    "40": {
      "page": 68,
      "text": "40 CHAPTER 2 Separation between code and data",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "40 CHAPTER 2 Separation between code and data\nclass Catalog {\nstatic getBookLendings(catalogData, memberId) {\n// will be implemented later\nIn chapter 3, we will see how\n}\nto query data with generic\n}\ndata collections.\nIt’s Theo’s first piece of DOP code and passing around all those data objects—libr"
    },
    "3": {
      "page": 273,
      "text": "Part 3",
      "pattern_type": "part",
      "line_position": 0,
      "full_text_preview": "Part 3\nMaintainability\nA\nfter a month, the Klafim project enters what Alabatross calls the mainte-\nnance phase. Small new features need to be added on a weekly basis. Bugs need to be\nfixed; nothing dramatic....\nMonica, Theo’s boss, decides to allocate Dave to the maintenance of the Klafim\nproject. I"
    },
    "42": {
      "page": 70,
      "text": "42 CHAPTER 2 Separation between code and data",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "42 CHAPTER 2 Separation between code and data\nTheo It takes a big mindset shift to learn how to separate code from data!\nJoe What was the most challenging thing to accept?\nTheo The fact that data is not encapsulated in objects.\nJoe It was the same for me when I switched from OOP to DOP.\nNow it’s tim"
    },
    "43": {
      "page": 71,
      "text": "43",
      "pattern_type": "chapter",
      "line_position": 16,
      "full_text_preview": "Basic data manipulation\nMeditation and programming\nThis chapter covers\n Representing records with string maps to improve\nflexibility\n Manipulating data with generic functions\n Accessing each piece of information via its\ninformation path\n Gaining JSON serialization for free\nAfter learning why and"
    },
    "44": {
      "page": 72,
      "text": "44 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "44 CHAPTER 3 Basic data manipulation\nWe increase system flexibility when we represent records as string maps and not as\nobjects instantiated from classes. This liberates data from the rigidity of a class-based sys-\ntem. Data becomes a first-class citizen powered by generic functions to add, remove, "
    },
    "46": {
      "page": 74,
      "text": "46 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "46 CHAPTER 3 Basic data manipulation\nJoe The next step is to be more explicit about the relations between entities.\nTheo What do you mean?\nJoe For example, in your entity diagram, Book and Author are connected by a\nmany-to-many association relation. How is this relation going to be repre-\nsented in "
    },
    "48": {
      "page": 76,
      "text": "48 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to say that a data entity diagram consists only of records, positional\ncollections, and indexes?\nJoe T"
    },
    "50": {
      "page": 78,
      "text": "50 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "50 CHAPTER 3 Basic data manipulation\nListing3.1 An instance of a Book record represented as a map\n{\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{"
    },
    "52": {
      "page": 80,
      "text": "52 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "52 CHAPTER 3 Basic data manipulation\n}\n}\nclass BookItem {\nid;\nlibId;\nisLent;\nconstructor(id, libId, isLent) {\nthis.id = id;\nthis.libId = libId;\nthis.isLent = isLent;\n}\n}\nvar watchmenBook = new Book(\"978-1779501127\",\n\"Watchmen\",\n1987,\n[\"alan-moore\", \"dave-gibbons\"],\n[new BookItem(\"book-item-1\", \"nyc-"
    },
    "54": {
      "page": 82,
      "text": "54 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "54 CHAPTER 3 Basic data manipulation\nTIP DOP compromises on data safety to gain flexibility and genericity.\nAt the whiteboard, Joe quickly sketches the tradeoffs (see table 3.1).\nTable 3.1 The tradeoff among safety, flexibility, and genericity\nOOP DOP\nSafety High Low\nFlexibility Low High\nGenericity "
    },
    "56": {
      "page": 84,
      "text": "56 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "56 CHAPTER 3 Basic data manipulation\nAfter a few minutes of trial and error, Theo is able to produce his implementation. He\nshows Joe the code.\nListing3.7 Custom implementation of get\nfunction get(m, path) {\nvar res = m;\nfor(var i = 0; i < path.length; i++) {\nWe could use\nvar key = path[i];\nforEach "
    },
    "58": {
      "page": 86,
      "text": "58 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "58 CHAPTER 3 Basic data manipulation\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave G"
    },
    "1987": {
      "page": 86,
      "text": "1987",
      "pattern_type": "chapter",
      "line_position": 7,
      "full_text_preview": "58 CHAPTER 3 Basic data manipulation\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave G"
    },
    "60": {
      "page": 88,
      "text": "60 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "60 CHAPTER 3 Basic data manipulation\nJoe Well done!\nTheo You were right! It wasn’t hard.\nJoe Now, let’s implement authorNames using _.map.\nIt takes a few minutes for Theo to come up with the implementation of authorNames.\nWhen he’s finished, he turns his laptop to Joe.\nListing3.14 Calculating the au"
    },
    "62": {
      "page": 90,
      "text": "62 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "62 CHAPTER 3 Basic data manipulation\nTheo Being language-agnostic has a price!\nJoe Right, would you like to test searchBooksByTitle?\nTheo Absolutely! Let me call searchBooksByTitle to search the books whose title\ncontain the string Watch.\nListing3.19 Testing searchBooksByTitle\nsearchBooksByTitle(cat"
    },
    "64": {
      "page": 92,
      "text": "64 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "64 CHAPTER 3 Basic data manipulation\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nThere’s no need\nreturn bookInfo;\nto create a class\n}\nfor bookInfo.\nstatic searchBooksByTitle"
    },
    "66": {
      "page": 94,
      "text": "66 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "66 CHAPTER 3 Basic data manipulation\n\"membersByEmail\": {\n\"samantha@gmail.com\": {\n\"email\": \"samantha@gmail.com\",\n\"encryptedPassword\": \"c2VjcmV0\",\nThe base-64\n\"isBlocked\": false,\nencoding of\n\"bookLendings\": [\n\"secret\"\n{\n\"bookItemId\": \"book-item-1\",\n\"bookIsbn\": \"978-1779501127\",\n\"lendingDate\": \"2020-04"
    },
    "68": {
      "page": 96,
      "text": "68 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "68 CHAPTER 3 Basic data manipulation\nTheo Can we use feature fields to differentiate between librarians and members?\nJoe You mean having an isLibrarian and an isMember field?\nTheo Yes, and having a common User record type for both librarians and members.\nJoe We can, but I think it’s simpler to have "
    },
    "70": {
      "page": 98,
      "text": "70 CHAPTER 3 Basic data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "70 CHAPTER 3 Basic data manipulation\n The data part of a DOP system is flexible, and each piece of information is\naccessible via its information path.\n There is a tradeoff between flexibility and safety in a data model.\n DOP compromises on data safety to gain flexibility and genericity.\n In DOP,"
    },
    "71": {
      "page": 99,
      "text": "71",
      "pattern_type": "chapter",
      "line_position": 16,
      "full_text_preview": "State management\nTime travel\nThis chapter covers\n A multi-version approach to state management\n The calculation phase of a mutation\n The commit phase of a mutation\n Keeping a history of previous state versions\nSo far, we have seen how DOP handles queries via generic functions that access sys-\nte"
    },
    "72": {
      "page": 100,
      "text": "72 CHAPTER 4 State management",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "72 CHAPTER 4 State management\ntechnique called structural sharing, where parts of the data that are common between\ntwo versions are shared instead of being copied. In DOP, a mutation is split into two\ndistinct phases:\n In the calculation phase, we compute the next version of the system data.\n In t"
    },
    "74": {
      "page": 102,
      "text": "74 CHAPTER 4 State management",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead of being copied.\nThis technique efficiently creates new versions of the system data, both in\nterms "
    },
    "76": {
      "page": 104,
      "text": "76 CHAPTER 4 State management",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "76 CHAPTER 4 State management\nthe signature of the immutable functions is exactly the same as the mutable\nfunctions.\nListing4.1 Configuring Lodash so immutable and mutable functions have same signature\n_ = fp.convert({\n\"cap\": false,\n\"curry\": false,\n\"fixed\": false,\n\"immutable\": true,\n\"rearg\": false\n}"
    },
    "78": {
      "page": 106,
      "text": "78 CHAPTER 4 State management",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "78 CHAPTER 4 State management\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.4 Structural sharing provides an efficient way"
    },
    "80": {
      "page": 108,
      "text": "80 CHAPTER 4 State management",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "80 CHAPTER 4 State management\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library,\n\"userManagement\",\nnextUserManagement);\nCreat"
    },
    "82": {
      "page": 110,
      "text": "82 CHAPTER 4 State management",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "82 CHAPTER 4 State management\n4.4 Data safety\nJoe is about to start the day’s lesson. Theo asks him a question about yesterday’s material\ninstead.\nTheo Something isn’t clear to me regarding this structural sharing stuff. What hap-\npens if we write code that modifies the data part that’s shared betwe"
    },
    "84": {
      "page": 112,
      "text": "84 CHAPTER 4 State management",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "84 CHAPTER 4 State management\nJoe That’s an excellent question. Library.addMember deals only with data calcula-\ntion and is stateless. The state is updated in the commit phase by moving for-\nward the version of the state that the system state refers to.\nTheo What do you mean by that?\nJoe Here’s what"
    },
    "86": {
      "page": 114,
      "text": "86 CHAPTER 4 State management",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "86 CHAPTER 4 State management\nstate to be committed is valid. If the data is invalid, the commit is rejected.\nHere let me show you.\nListing4.9 Data validation inside the commit phase\nSystemState.commit = function(previous, next) {\nif(!SystemValidity.validate(previous, next)) { // not implemented for"
    },
    "88": {
      "page": 116,
      "text": "88 CHAPTER 4 State management",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "88 CHAPTER 4 State management\nTheo I suppose that when we undo the mutation, both references move backward.\nJoe In theory, yes, but in practice, it’s necessary to maintain a stack of all the state\nreferences. For now, to simplify things, we’ll maintain only a reference to the\nprevious version. As a "
    },
    "90": {
      "page": 118,
      "text": "90 CHAPTER 4 State management",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "90 CHAPTER 4 State management\n In order to use Lodash immutable functions, we use the Lodash FP module\n(https://github.com/lodash/lodash/wiki/FP-Guide).\nLodash functions introduced in this chapter\nFunction Description\nset(map, path, value) Creates a map with the same fields as map with the addition"
    },
    "91": {
      "page": 119,
      "text": "91",
      "pattern_type": "chapter",
      "line_position": 19,
      "full_text_preview": "Basic concurrency control\nConflicts at home\nThis chapter covers\n Managing concurrent mutations with a lock-free\noptimistic concurrency control strategy\n Supporting high throughput of reads and writes\n Reconciliation between concurrent mutations\nThe changes required for system manage concurrency a"
    },
    "92": {
      "page": 120,
      "text": "92 CHAPTER 5 Basic concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "92 CHAPTER 5 Basic concurrency control\nIn DOP, because only the code of the commit phase is stateful, that allows us to use\nan optimistic concurrency control strategy that doesn’t involve any locking mechanism. As\na consequence, the throughput of reads and writes is high. The modifications to the\nco"
    },
    "94": {
      "page": 122,
      "text": "94 CHAPTER 5 Basic concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "94 CHAPTER 5 Basic concurrency control\nCalculation phase\nCapturesystem state\nComputenext version\nCommit phase\nYes No\nConcurrent mutations?\nYes No\nConflict?\nUpdatesystem state\nAbortmutation Reconcilemutations\nUpdatesystem state\nFigure 5.1 The logic flow\nof optimistic concurrency\ncontrol\n5.2 Reconcili"
    },
    "96": {
      "page": 124,
      "text": "96 CHAPTER 5 Basic concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "96 CHAPTER 5 Basic concurrency control\nJoe We calculate the diff between previous and next and between previous and\ncurrent. If the two diffs have no fields in common, then there is no conflict\nbetween the mutations that have run concurrently. We can safely apply the\nchanges from previous to next in"
    },
    "98": {
      "page": 126,
      "text": "98 CHAPTER 5 Basic concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. It means that the first call to f will be f(0, 1). Then,\nwe’ll have f(f(0, 1), 2) and, finally, f(f("
    },
    "100": {
      "page": 128,
      "text": "100 CHAPTER 5 Basic concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "100 CHAPTER 5 Basic concurrency control\nTable 5.4 Kinds of structural differences between maps with nested fields (continued)\nKind First map Second map Diff\nAddition { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 1, \"y\": 2\n} \"y\": 2, }\n} } }\n}\nDeletion { { Not supported\n\"a\": { \"a\": {\n\"x\": 1, \"y\": 2\n\"y\": 2, }"
    },
    "102": {
      "page": 130,
      "text": "102 CHAPTER 5 Basic concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "102 CHAPTER 5 Basic concurrency control\ndiff(data1, data2);\n//{\n// \"a\": {\n// \"x\": 2,\n// \"y\": [\n// undefined,\n// 4\n// ]\n// }\n//}\nTheo What about the performance of the structural diff algorithm? It seems that the\nalgorithm goes over the leaves of both pieces of data?\nJoe In the general case, that’s t"
    },
    "104": {
      "page": 132,
      "text": "104 CHAPTER 5 Basic concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "104 CHAPTER 5 Basic concurrency control\n// }\n// },\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\n//\nJoe Can you give me the information path of the single field in the structural diff\nbetween previous and next?\nTheo It’s [\"catalog\", \"booksBy"
    },
    "106": {
      "page": 134,
      "text": "106 CHAPTER 5 Basic concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "106 CHAPTER 5 Basic concurrency control\n// \"catalog\": {\n// \"authorsById\": {\n// \"alan-moore\": {\n// \"bookIsbns\": [\"978-1779501127\"]\n// \"name\": \"Alan Moore\"\n// },\n// \"dave-gibbons\": {\n// \"bookIsbns\": [\"978-1779501127\"],\n// \"name\": \"Dave Gibbons\"\n// },\n// },\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n//"
    },
    "108": {
      "page": 136,
      "text": "108 CHAPTER 5 Basic concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "108 CHAPTER 5 Basic concurrency control\nTheo I think the code for SystemConsistency class is not thread-safe! If there’s a\ncontext switch between checking whether the system has changed in the\nSystemConsistency class and the updating of the state in SystemData class, a\nmutation might override the ch"
    },
    "112": {
      "page": 140,
      "text": "112 CHAPTER 6 Unit tests",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "112 CHAPTER 6 Unit tests\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n});\n// → true\nListing6.2 Comparing a non-equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"bad-isbn\"]\n});\n// → false\nTheo Ni"
    },
    "114": {
      "page": 142,
      "text": "114 CHAPTER 6 Unit tests",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "114 CHAPTER 6 Unit tests\nLibrary.searchBooksByTitleJSON\n_.get JSON.stringify Catalog.searchBooksByTitle\n_.get _.map _.filter Catalog.bookInfo\n_.get Catalog.authorNames\n_.get _.map\nFigure 6.1 The tree of function calls for the search query code flow\nTheo Nice! Can you teach me how to draw a tree of f"
    },
    "116": {
      "page": 144,
      "text": "116 CHAPTER 6 Unit tests",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "116 CHAPTER 6 Unit tests\nTable 6.1 The table of test cases for Catalog.authorNames\ncatalogData authorIds authorNames\nCatalog with two authors Empty array Empty array\nCatalog with two authors Array with one author ID Array with one author name\nCatalog with two authors Array with two author IDs Array "
    },
    "118": {
      "page": 146,
      "text": "118 CHAPTER 6 Unit tests",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "118 CHAPTER 6 Unit tests\nTIP We can compare the output and the expected output of our functions with\n_.isEqual.\nTheo Sounds good! Let me write the test cases.\nTheo starts typing on his laptop. After a few minutes, he has some test cases for Catalog\n.authorNames, each made from a function call to Cat"
    },
    "120": {
      "page": 148,
      "text": "120 CHAPTER 6 Unit tests",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "120 CHAPTER 6 Unit tests\nTheo I would use the same catalog data as for Catalog.authorNames and a book\nrecord. I’d test that the function behaves as expected by comparing its return\nvalue with a book info record using _.isEqual. Here, let me show you.\nIt takes Theo a bit more time to write the unit t"
    },
    "122": {
      "page": 150,
      "text": "122 CHAPTER 6 Unit tests",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "122 CHAPTER 6 Unit tests\nTheo In cases where the query string matches, the expected result is a JSON string\nwith the book info. In cases where the query string doesn’t match, the\nexpected result is a JSON string with an empty array.\nJoe Hmm...\nTheo What?\nJoe I don’t like your answer.\nTheo Why?\nJoe B"
    },
    "124": {
      "page": 152,
      "text": "124 CHAPTER 6 Unit tests",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again at the\ncode for Catalog.searchBooksByTitle.\nListing6.16 The code of Catalog.searchBooksByTitle\nCatal"
    },
    "126": {
      "page": 154,
      "text": "126 CHAPTER 6 Unit tests",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "126 CHAPTER 6 Unit tests\n6.4 Unit tests for mutations\nJoe Before writing unit tests for the add member mutation, let’s draw the tree of\nfunction calls for System.addMember.\nTheo I can do that.\nTheo takes a look at the code for the functions involved in the add member mutation. He\nnotices the code is"
    },
    "128": {
      "page": 156,
      "text": "128 CHAPTER 6 Unit tests",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "128 CHAPTER 6 Unit tests\nmanagement map and to check that the resulting map is as expected. When he’s finished,\nhe shows his code to Joe.\nListing6.22 Test case for Catalog.addMember without members\nvar member = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore ="
    },
    "130": {
      "page": 158,
      "text": "130 CHAPTER 6 Unit tests",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "130 CHAPTER 6 Unit tests\nvar expectedException = \"Member already exists.\";\nvar exceptionInMutation;\ntry {\nUserManagement.addMember(userManagementStateBefore, jessie);\n} catch (e) {\nexceptionInMutation = e;\n}\n_.isEqual(exceptionInMutation, expectedException);\nTheo Now, I think I’m ready to move forwa"
    },
    "132": {
      "page": 160,
      "text": "132 CHAPTER 6 Unit tests",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "132 CHAPTER 6 Unit tests\nTheo Then how do we validate that the code works as expected?\nJoe We’ll retrieve the system state after the code is executed and compare it to the\nexpected value of the state.\nTheo OK. I’ll try to write the unit test.\nJoe Writing unit tests for stateful code is more complica"
    },
    "134": {
      "page": 162,
      "text": "134 CHAPTER 6 Unit tests",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "134 CHAPTER 6 Unit tests\nMoving forward\nThe meeting with Nancy went well. Albatross got the deal, Monica (Theo’s boss) is\npleased, and it’s going to be a long-term project with a nice budget. They’ll need to hire a\nteam of developers in order to meet the tough deadlines. While driving back to the of"
    },
    "138": {
      "page": 166,
      "text": "138 PART 2 Scalability",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "138 PART 2 Scalability\nTheo First of all, let me tell you that I feel lot of gratitude for all the teaching you\nshared with me. Reimplementing the Klafim prototype with DOP was really\nfun and productive due to the flexibility this paradigm offers.\nJoe I’m happy that you found it valuable.\nTheo But, "
    },
    "141": {
      "page": 169,
      "text": "141",
      "pattern_type": "chapter",
      "line_position": 18,
      "full_text_preview": "Basic data validation\nA solemn gift\nThis chapter covers\n The importance of validating data at system\nboundaries\n Validating data using the JSON Schema language\n Integrating data validation into an existing code\nbase\n Getting detailed information about data validation\nfailures\nAt first glance, it"
    },
    "142": {
      "page": 170,
      "text": "142 CHAPTER 7 Basic data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "142 CHAPTER 7 Basic data validation\n7.1 Data validation in DOP\nTheo has rescheduled his meetings. With such an imposing deadline, he’s still not sure if\nhe’s made a big mistake giving DOP a second chance.\n NOTE The reason why Theo rescheduled his meetings is explained in the opener\nfor part 2. Take"
    },
    "144": {
      "page": 172,
      "text": "144 CHAPTER 7 Basic data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the "
    },
    "146": {
      "page": 174,
      "text": "146 CHAPTER 7 Basic data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing "
    },
    "148": {
      "page": 176,
      "text": "148 CHAPTER 7 Basic data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "148 CHAPTER 7 Basic data validation\nTheo So, if I call validate with this search request and that schema, it will return\ntrue?\nTheo indicates the search request example from listing 7.7 and the schema from listing 7.6.\nListing7.7 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\","
    },
    "150": {
      "page": 178,
      "text": "150 CHAPTER 7 Basic data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "150 CHAPTER 7 Basic data validation\n{\n\"title\": \"The Power of Habit\",\n\"available\": false,\n\"isbn_13\": \"978-1982137274\",\n\"subtitle\": \"Why We Do What We Do in Life and Business\",\n\"subjects\": [\n\"Social aspects\",\n\"Habit\",\n\"Change (Psychology)\"\n]\n}\n]\nJoe It’s funny that you mention The Power of Habit. I’m "
    },
    "152": {
      "page": 180,
      "text": "152 CHAPTER 7 Basic data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "152 CHAPTER 7 Basic data validation\nTheo When we query books from the database, we expect to receive an array of\nbooks with three fields: title, isbn, and available. The first two values should\nbe strings, and the third one should be a Boolean.\nJoe Are those fields optional or required?\nTheo What do"
    },
    "154": {
      "page": 182,
      "text": "154 CHAPTER 7 Basic data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "154 CHAPTER 7 Basic data validation\n7.4 Schema composition\nTheo What about validating data that comes from an external web service?\nJoe Can you give me an example?\nTheo In the near future, we’ll have to integrate with a service called Open Library\nBooks API that provides detailed information about b"
    },
    "156": {
      "page": 184,
      "text": "156 CHAPTER 7 Basic data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "156 CHAPTER 7 Basic data validation\nisbn_13 is required; and mandatoryIsb10, a schema where only isbn_10 is\nrequired?\nTheo I think it should be basicBookInfoSchema AND (mandatoryIsbn13 OR\nmandatoryIsbn10).\nJoe Exactly! The only thing is that in JSON Schema, we use allOf instead of AND,\nand anyOf ins"
    },
    "158": {
      "page": 186,
      "text": "158 CHAPTER 7 Basic data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "158 CHAPTER 7 Basic data validation\n7.5 Details about data validation failures\nJoe So far, we’ve treated JSON Schema validation as though it were binary: either a\npiece of data is valid or it isn’t.\nTheo Right...\nJoe But, in fact, when a piece of data is not valid, we can get details about the\nreaso"
    },
    "160": {
      "page": 188,
      "text": "160 CHAPTER 7 Basic data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "160 CHAPTER 7 Basic data validation\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nA request with\nthree failures\nvar invalidSearchBooksRequest = {\n\"myTitle\": \"habit\",\n\"fields\": [1, 2]\n}; Instantiates the Ajv constructor\nwith allErrors: true in order to\ncatch more than one failure\nvar ajv = new Ajv({allErro"
    },
    "162": {
      "page": 190,
      "text": "162 CHAPTER 7 Basic data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "162 CHAPTER 7 Basic data validation\n It’s good practice to be strict regarding data that you send and to be flexible\nregarding data that you receive.\n Ajv is a JSON Schema library in JavaScript.\n By default, Ajv catches only the first validation failure.\n Advanced validation is covered in chapte"
    },
    "164": {
      "page": 192,
      "text": "164 CHAPTER 8 Advanced concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "164 CHAPTER 8 Advanced concurrency control\n8.1 The complexity of locks\nThis Sunday afternoon, while riding his bike across the Golden Gate Bridge, Theo thinks\nabout the Klafim project with concern, not yet sure that betting on DOP was a good\nchoice. Suddenly, Theo realizes that he hasn’t yet schedul"
    },
    "166": {
      "page": 194,
      "text": "166 CHAPTER 8 Advanced concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "166 CHAPTER 8 Advanced concurrency control\nconsole.log('Number of database accesses: ' + counter);\nmutex.unlock();\n}\nJoe Excellent. Now, I am going to show you how to write the same code with atoms.\nAn atom provides three methods:\n get returns the current value of the atom.\n set overwrites the cur"
    },
    "168": {
      "page": 196,
      "text": "168 CHAPTER 8 Advanced concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "168 CHAPTER 8 Advanced concurrency control\nstateSnapshot,\nnextState)) {\nUses a special thread-safe comparison operation\ncontinue;\nas this.state might have changed in another\n}\nthread during execution of the function f.\nreturn nextState;\n}\n}\n}\nTheo comes closer to the whiteboard. He modifies Joe’s di"
    },
    "170": {
      "page": 198,
      "text": "170 CHAPTER 8 Advanced concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "170 CHAPTER 8 Advanced concurrency control\nListing8.5 Using an Atom in Java\nAtom<Integer> counter = new Atom<Integer>();\ncounter.set(0);\ncounter.swap(x -> x + 1);\ncounter.get();\nTheo takes a couple of minutes to meditate about this atom stuff and to digest what he’s\njust learned. Then, he asks Joe:\n"
    },
    "172": {
      "page": 200,
      "text": "172 CHAPTER 8 Advanced concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "172 CHAPTER 8 Advanced concurrency control\nreturn _.set(oldCache, query, result);\n});\nreturn result;\n}\nTheo I don’t understand the function you’re passing to the swap method.\nJoe The function passed to swap receives the current value of the cache, which is a\nstring map, and returns a new version of "
    },
    "174": {
      "page": 202,
      "text": "174 CHAPTER 8 Advanced concurrency control",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "174 CHAPTER 8 Advanced concurrency control\nJoe Perfect.\nTheo This atom stuff makes me think about what happened to us yesterday, when we\ntried to call each other at the exact same time.\nJoe What do you mean?\nTheo I don’t know, but I am under the impression that mutexes are like phone calls,\nand atom"
    },
    "175": {
      "page": 203,
      "text": "175",
      "pattern_type": "chapter",
      "line_position": 19,
      "full_text_preview": "Persistent data structures\nStanding on the shoulders of giants\nThis chapter covers\n The internal details of persistent data\nstructures\n The time and memory efficiency of persistent\ndata structures\n Using persistent data structures in an\napplication\nIn part 1, we illustrated how to manage the stat"
    },
    "176": {
      "page": 204,
      "text": "176 CHAPTER 9 Persistent data structures",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "176 CHAPTER 9 Persistent data structures\nresearcher named Phil Bagwell.1 In 2007, Rich Hickey, the creator of Clojure, used this dis-\ncovery as the foundation of persistent data structures in Clojure. Unveiling the secrets of\nthese data structures to Theo in a university classroom is a way for Joe t"
    },
    "178": {
      "page": 206,
      "text": "178 CHAPTER 9 Persistent data structures",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "178 CHAPTER 9 Persistent data structures\nreturn Object.freeze(object);\n}\nTheo I see that it’s possible to ensure that data is never mutated, which answers my\nconcerns about safety. Now, let me share my concerns about performance.\nTIP It’s possible to manually ensure that our data isn’t mutated, but "
    },
    "180": {
      "page": 208,
      "text": "180 CHAPTER 9 Persistent data structures",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "180 CHAPTER 9 Persistent data structures\nTheo I understand how to use structural sharing at the level of the data structure for\nlinked lists and prepend operations, but how would it work with operations\nlike appending or modifying an element in a list?\nJoe For that purpose, we need to be smarter and"
    },
    "182": {
      "page": 210,
      "text": "182 CHAPTER 9 Persistent data structures",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "182 CHAPTER 9 Persistent data structures\nTheo That’s true: 2 to the power of 5 is 32.\nJoe Back to our list of 100,000 elements, can you tell me how many operations are\nrequired to access an element if the branching factor is 32?\nTheo With a branching factor of 2, it was 16.6. If I divide 16.6 by 5, "
    },
    "184": {
      "page": 212,
      "text": "184 CHAPTER 9 Persistent data structures",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "184 CHAPTER 9 Persistent data structures\n9.3 Persistent data structures libraries\nOn their way back to the office, Theo and Joe don’t talk too much. Theo’s thoughts take\nhim back to what he learned in the university classroom. He feels a lot of respect for Phil\nBagwell, who discovered how to manipul"
    },
    "186": {
      "page": 214,
      "text": "186 CHAPTER 9 Persistent data structures",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "186 CHAPTER 9 Persistent data structures\nListing9.8 Creating a modified version of a Paguro map\nvar myMap = PersistentHashMap.of(Map.of(\"aa\", 1, \"bb\", 2)\n.entrySet());\nCreates a Paguro map\nfrom a Java map entry set\nvar myNextMap = myMap.assoc(\"aa\", 42);\nTheo Yes! Now I see how to use persistent data"
    },
    "188": {
      "page": 216,
      "text": "188 CHAPTER 9 Persistent data structures",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "188 CHAPTER 9 Persistent data structures\nTheo But if I have a huge collection, it could take lots of time to convert it, right?\nJoe True. We need a better solution. Hopefully, Immutable.js provides its own set\nof data manipulation functions like map(), filter(), and reduce().\nTheo What if I need mor"
    },
    "190": {
      "page": 218,
      "text": "190 CHAPTER 9 Persistent data structures",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "190 CHAPTER 9 Persistent data structures\nreturn Immutable.get(book, \"title\").\ntoLowerCase().\nincludes(queryLowerCased);\n});\nvar bookInfos = Immutable.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nListing9.14 Testing book search with persist"
    },
    "192": {
      "page": 220,
      "text": "192 CHAPTER 9 Persistent data structures",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "192 CHAPTER 9 Persistent data structures\n}\n}\n});\nvar result = UserManagement.addMember(userManagementStateBefore, jessie);\nImmutable.isEqual(result, expectedUserManagementStateAfter);\n// → true\nJoe Great!\n9.4.3 Serialization and deserialization\nTheo Does Immutable.js also support JSON serialization "
    },
    "5": {
      "page": 221,
      "text": " NOTE Chapter 5 introduces structural diff.",
      "pattern_type": "chapter",
      "line_position": 5,
      "full_text_preview": "9.4 Persistent data structures in action 193\n9.4.4 Structural diff\nTheo So far, we have ported pieces of code that dealt with simple data manipula-\ntions. I’m curious to see how it goes with complex data manipulations such as\nthe code that computes the structural diff between two maps.\n NOTE Chapte"
    },
    "194": {
      "page": 222,
      "text": "194 CHAPTER 9 Persistent data structures",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "194 CHAPTER 9 Persistent data structures\nImmutable.fromJS({});\nif(data1 == data2) {\nreturn emptyObject;\n}\nvar keys = Immutable.union(Immutable.keys(data1), Immutable.keys(data2));\nreturn Immutable.reduce(keys,\nfunction (acc, k) {\nvar res = diff(Immutable.get(data1, k),\nImmutable.get(data2, k));\nif(("
    },
    "196": {
      "page": 224,
      "text": "196 CHAPTER 9 Persistent data structures",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "196 CHAPTER 9 Persistent data structures\n Persistent data structures represent data internally in such a way that structural\nsharing scales well, both in terms of memory and computation.\n When data is immutable, it is safe to share it.\n Internally, persistence uses a branching factor of 32.\n In "
    },
    "197": {
      "page": 225,
      "text": "197",
      "pattern_type": "chapter",
      "line_position": 17,
      "full_text_preview": "Database operations\nA cloud is a cloud\nThis chapter covers\n Fetching data from the database\n Storing data in the database\n Manipulating data fetched from the database\nTraditionally in OOP, we use design patterns and complex layers of objects to struc-\nture access to the database. In DOP, we prefe"
    },
    "198": {
      "page": 226,
      "text": "198 CHAPTER 10 Database operations",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "198 CHAPTER 10 Database operations\nApplications that run on the server usually store data in a database. In DOP, we\nrepresent data retrieved from the database the same way we represent any other data\nin our application—with generic data collections. This leads to\n Reduced system complexity.\n Incre"
    },
    "200": {
      "page": 228,
      "text": "200 CHAPTER 10 Database operations",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "200 CHAPTER 10 Database operations\nJoe Great! Let’s start with the simplest case. We’re going to write code that searches\nfor books matching a title and that returns basic information about the books.\nBy basic information, I mean title, ISBN, and publication year.\nTheo What about the book authors?\nJ"
    },
    "202": {
      "page": 230,
      "text": "202 CHAPTER 10 Database operations",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "202 CHAPTER 10 Database operations\nqueries to fetch the state from the database. In terms of data representation\nand manipulation, it’s exactly the same.\nJoe goes to the whiteboard and sketches out the data flow in figure 10.2. Theo studies the\ndiagram.\nDatabase\nDatabase driver\nData (list of maps)\nD"
    },
    "204": {
      "page": 232,
      "text": "204 CHAPTER 10 Database operations",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "204 CHAPTER 10 Database operations\nListing10.6 Searching books in the database, returning the results in JSON\ndbClient holds the Initializes Ajv (a JSON schema validation\nvar dbClient; DB connection. library) with allErrors: true to catch all\nthe data validation errors\nvar ajv = new Ajv({allErrors: "
    },
    "206": {
      "page": 234,
      "text": "206 CHAPTER 10 Database operations",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "206 CHAPTER 10 Database operations\nTheo What does this _.at function do?\nJoe It receives a map m, a list keyList, and returns a list made of the values in m\nassociated with the keys in keyList.\nTheo How about an example?\nJoe Sure. We create a list made of the fields email and encryptedPassword of a\n"
    },
    "208": {
      "page": 236,
      "text": "208 CHAPTER 10 Database operations",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "208 CHAPTER 10 Database operations\n\"bookTitle\": _.get(bookInfo, \"title\"),\n\"isbn\": _.get(bookInfo, \"isbn\"),\n\"publicationYear\": _.get(bookInfo, \"publication_year\")\n};\n}\nvar bookResults = [\n{\n\"title\": \"7 Habits of Highly Effective People\",\n\"isbn\": \"978-1982137274\",\n\"publication_year\": 1989\n},\n{\n\"title\""
    },
    "210": {
      "page": 238,
      "text": "210 CHAPTER 10 Database operations",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "210 CHAPTER 10 Database operations\n\"publication_year\": 1989\n},\n{\n\"title\": \"The Power of Habit\",\n\"isbn\": \"978-0812981605\",\n\"publication_year\": 2012\n}\n];\nvar expectedResults = [\n{\n\"bookTitle\": \"7 Habits of Highly Effective People\",\n\"isbn\": \"978-1982137274\",\n\"publicationYear\": 1989\n},\n{\n\"bookTitle\": \"T"
    },
    "212": {
      "page": 240,
      "text": "212 CHAPTER 10 Database operations",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "212 CHAPTER 10 Database operations\nON books.isbn = book_authors.book_isbn\nINNER JOIN\nauthors\nON book_authors.author_id = authors.id\nWHERE books.title LIKE '%habit%';\nJoe How many rows are in the results?\nTheo goes to the whiteboard. He quickly sketches a table showing the results, then he\nanswers Jo"
    },
    "7": {
      "page": 240,
      "text": "7 Habits of Highly Effective People 978-1982137274 Sean Covey",
      "pattern_type": "chapter",
      "line_position": 13,
      "full_text_preview": "212 CHAPTER 10 Database operations\nON books.isbn = book_authors.book_isbn\nINNER JOIN\nauthors\nON book_authors.author_id = authors.id\nWHERE books.title LIKE '%habit%';\nJoe How many rows are in the results?\nTheo goes to the whiteboard. He quickly sketches a table showing the results, then he\nanswers Jo"
    },
    "214": {
      "page": 242,
      "text": "214 CHAPTER 10 Database operations",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "214 CHAPTER 10 Database operations\ntitle7 Habits of Highly Effective People title7 Habits of Highly Effective People\nisbn978-1982137274 isbn978-1982137274\nauthor_name Sean Covey author_name StephenCovey\ntitleThe Power of Habit\nisbn978-0812981605\nauthor_nameCharles Duhigg\ngroup byisbn\n978-1982137274 "
    },
    "216": {
      "page": 244,
      "text": "216 CHAPTER 10 Database operations",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "216 CHAPTER 10 Database operations\nTheo I’ll call the function aggregateField. It will receive three arguments: the\nrows, the name of the field to aggregate, and the name of the field that holds\nthe aggregation.\nTheo turns to his laptop. After a couple of minutes, his screen displays the implementat"
    },
    "218": {
      "page": 246,
      "text": "218 CHAPTER 10 Database operations",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "218 CHAPTER 10 Database operations\n}\n];\n_.isEqual(aggregateFields(sqlRows,\n\"isbn\",\n\"author_name\",\n\"authorNames\"),\nexpectedResults);\nTheo I think I’ve got it.\nJoe Congratulations! I’m proud of you, Theo.\nNow Theo understands what Joe meant when he told him “a cloud is cloud” when they\nwere walking ba"
    },
    "220": {
      "page": 248,
      "text": "220",
      "pattern_type": "chapter",
      "line_position": 18,
      "full_text_preview": "Web services\nA faithful messenger\nThis chapter covers\n Representing a client request as a map\n Representing a server response as a map\n Passing data forward\n Combining data from different sources\nThe architecture of modern information systems is made of software components\nwritten in various pro"
    },
    "222": {
      "page": 250,
      "text": "222 CHAPTER 11 Web services",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "222 CHAPTER 11 Web services\n11.2 Building the insides like the outsides\nWhile Theo drinks his macchiato, Joe draws a diagram on a whiteboard. Figure 11.1 shows\nJoe’s diagram.\nWeb browser\nData\nWeb server\nData Data\nWeb service Database Figure 11.1 The high-level architecture\nof a modern information sy"
    },
    "224": {
      "page": 252,
      "text": "224 CHAPTER 11 Web services",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "224 CHAPTER 11 Web services\nJSON parse/serialize\nData\nBusiness logic\nData manipulation\nData\nFigure 11.2 The internals of a\nJSON parse/serialize\ndata-oriented web service\nTheo stands alone for a few minutes in front of the whiteboard, meditating about “build-\ning the insides of our systems like we bu"
    },
    "226": {
      "page": 254,
      "text": "226 CHAPTER 11 Web services",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "226 CHAPTER 11 Web services\nTheo Wait! What do you mean by the web server framework?\nJoe Stuff like Express in Node.js, Spring in Java, Django in Python, Ruby on Rails,\nASP.net in C#, and so forth.\nTheo Oh, I see. So, how do you manually parse a JSON string into a map?\nJoe In JavaScript, we use JSON"
    },
    "228": {
      "page": 256,
      "text": "228 CHAPTER 11 Web services",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "228 CHAPTER 11 Web services\n// \"isbn_13\": [\n// \"9781982137274\",\n// ],\n// \"key\": \"/books/OL28896586M\",\n// \"languages\": [\n// {\n// \"key\": \"/languages/eng\",\n// },\n// ],\n// \"last_modified\": {\n// \"type\": \"/type/datetime\",\n// \"value\": \"2021-09-08T19:07:57.049009\",\n// },\n// \"latest_revision\": 3,\n// \"lc_clas"
    },
    "230": {
      "page": 258,
      "text": "230 CHAPTER 11 Web services",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "230 CHAPTER 11 Web services\nvar mandatoryIsbn10 = {\n\"type\": \"object\",\n\"required\": [\"isbn_10\"]\n};\nvar bookInfoSchema = {\n\"allOf\": [\nbasicBookInfoSchema,\n{\n\"anyOf\": [mandatoryIsbn13, mandatoryIsbn10]\n}\n]\n};\nTheo Now, assuming that I have a fetchResponseBody function that sends a request\nand retrieves "
    },
    "232": {
      "page": 260,
      "text": "232 CHAPTER 11 Web services",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "232 CHAPTER 11 Web services\nJoe That’s exactly the point of the story! In a sense, traditional OOP is like Hugo’s\nfriend, Willy. In order to pass information forward, OOP developers think they\nneed to “open the letter” and represent information with specific classes.\nTheo Oh, I see. And DOP develope"
    },
    "234": {
      "page": 262,
      "text": "234 CHAPTER 11 Web services",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "234 CHAPTER 11 Web services\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn\": {\"type\": \"string\"},\n\"publish_date\": {\"type\": \"string\"},\n\"physical_dimensions\": {\"type\": \"string\"}\n}\n};\nTheo Yes! I think we now have all the pieces to enrich our s"
    },
    "236": {
      "page": 264,
      "text": "236 CHAPTER 11 Web services",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "236 CHAPTER 11 Web services\n\"physical_dimensions\", \"genre\",\n\"subjects\", \"number_of_pages\"];\nvar rawInfo = rawBookInfo(isbn);\nif(!ajv.validate(dbSearchResultSchema, bookInfoSchema)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow \"Internal error: Unexpected result from Open Books API: \" +\nerrors;\n}\n"
    },
    "238": {
      "page": 266,
      "text": "238 CHAPTER 11 Web services",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "238 CHAPTER 11 Web services\nListing11.19 A unit test for joinArrays\nvar dbBookInfos = [\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"available\": true\n},\n{\n\"isbn\": \"978-0812981605\",\n\"title\": \"The Power of Habit\",\n\"available\": false\n}\n];\nvar openLibBookInfos = [\n{\n\"isbn"
    },
    "240": {
      "page": 268,
      "text": "240 CHAPTER 11 Web services",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "240 CHAPTER 11 Web services\n\"number_of_pages\": {\"type\": \"integer\"},\n\"weight\": {\"type\": \"string\"},\n\"physical_format\": {\"type\": \"string\"},\n\"subjects\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_13\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"isbn_10\": {\n\"type\": \"array\",\n\"items\": {"
    },
    "242": {
      "page": 270,
      "text": "242 CHAPTER 11 Web services",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "242 CHAPTER 11 Web services\nListing11.24 Schema for the implementation of the extended search endpoint\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"type\": [\n\"title\",\n\"full_title\",\n\"subtitle\",\n\"publisher\",\n\"pu"
    },
    "244": {
      "page": 272,
      "text": "244 CHAPTER 11 Web services",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "244 CHAPTER 11 Web services\nDelivering on time\nJoe was right! Theo recalls Joe’s story about the young woodcutter and the old man. Theo\nwas able to learn DOP and deliver the project on time! He’s pleased that he took the time\n“to sharpen his saw and commit to a deeper level of practice.”\n NOTE If y"
    },
    "246": {
      "page": 274,
      "text": "246 PART 3 Maintainability",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "246 PART 3 Maintainability\nJoe You see, DOP is such a simple paradigm that it’s fertile material for innovation.\nPart of the material I taught you I learned from others, and part of it was an\ninvention of mine. If you keep practicing DOP, I’m quite sure you, too, will\ncome up with some inventions of"
    },
    "247": {
      "page": 275,
      "text": "247",
      "pattern_type": "chapter",
      "line_position": 19,
      "full_text_preview": "Advanced data\nvalidation\nA self-made gift\nThis chapter covers\n Validating function arguments\n Validating function return values\n Data validation beyond static types\n Automatic generation of data model diagrams\n Automatic generation of schema-based unit tests\nAs the size of a code base grows in "
    },
    "248": {
      "page": 276,
      "text": "248 CHAPTER 12 Advanced data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "248 CHAPTER 12 Advanced data validation\n12.1 Function arguments validation\nDave’s first task is to implement a couple of new HTTP endpoints to download the catalog\nas a CSV file, search books by author, and rate the books. Once he is done with the tasks,\nDave calls Theo for a code review.\n NOTE The"
    },
    "250": {
      "page": 278,
      "text": "250 CHAPTER 12 Advanced data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "250 CHAPTER 12 Advanced data validation\nTheo Dave, please remind me of the expected shapes for catalogData and query.\nDave Sure. query should be a string, and catalogData should be a map that con-\nforms to the catalog data model.\nTheo What is the catalog data model?\nDave Let me see. I have seen a di"
    },
    "252": {
      "page": 280,
      "text": "252 CHAPTER 12 Advanced data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "252 CHAPTER 12 Advanced data validation\n\"isbn\": {\"type\": \"string\"},\n\"authorIds\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n},\n\"bookItems\": {\n\"type\": \"array\",\n\"items\": bookItemSchema\n}\n}\n};\nTIP When you define a complex data schema, it is advisable to store nested schemas\nin variables to make th"
    },
    "254": {
      "page": 282,
      "text": "254 CHAPTER 12 Advanced data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "254 CHAPTER 12 Advanced data validation\nTheo Do you know what a tuple is?\nDave I think I know, but I can’t define it formally.\nTheo A tuple is an array where the size is fixed, and the elements can be of different\nshapes.\nDave OK. So, how do we define tuples in JSON Schema?\nOnce again, Theo explores"
    },
    "256": {
      "page": 284,
      "text": "256 CHAPTER 12 Advanced data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "256 CHAPTER 12 Advanced data validation\nAfter a few minutes, Dave comes up with the schema. Taking a deep breath, then releasing\nit, he shows the code to Theo.\nListing12.10 The schema for the return value of Catalog.searchBooksByTitle\nvar searchBooksResponseSchema = {\n\"type\": \"array\",\n\"items\": {\n\"ty"
    },
    "258": {
      "page": 286,
      "text": "258 CHAPTER 12 Advanced data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "258 CHAPTER 12 Advanced data validation\nDave googles “UUID regex” and finds something he thinks just might work. He shows the\nregular expression to Theo.\nListing12.13 The regular expression for a valid UUID\n[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\nDave Now, how do "
    },
    "260": {
      "page": 288,
      "text": "260 CHAPTER 12 Advanced data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "260 CHAPTER 12 Advanced data validation\n\"bookIsbns\": {\n\"items\": isbnSchema\n}\n}\n};\nvar catalogSchema = {\n\"type\": \"object\",\n\"properties\": {\n\"booksByIsbn\": {\n\"type\": \"object\",\n\"additionalProperties\": bookSchema\n},\n\"authorsById\": {\n\"type\": \"object\",\n\"additionalProperties\": authorSchema\n}\n},\n\"required\": "
    },
    "262": {
      "page": 290,
      "text": "262 CHAPTER 12 Advanced data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "262 CHAPTER 12 Advanced data validation\nC Entity1\nbooksByIsbn: {Entity2}\nauthorsById: {Entity3}\nC Entity2 C Entity4\ntitle : String id: String\npublicationYear: Number name: String\nisbn: String booklsbns: [String]\nauthorlds: [String]\nbookltems: [Entity3]\nC Entity3\nid: String\nlibld: String\nFigure 12.2 "
    },
    "264": {
      "page": 292,
      "text": "264 CHAPTER 12 Advanced data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "264 CHAPTER 12 Advanced data validation\nWhen Dave calls JSONSchemaFaker.generate with the catalog schema, he gets some\nquite long random data. He’s a bit surprised by the results.\nListing12.20 Generating random data that conforms to the catalog schema\n{\n\"booksByIsbn\": {\n\"Excepteur7\": {\n\"title\": \"eli"
    },
    "266": {
      "page": 294,
      "text": "266 CHAPTER 12 Advanced data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "266 CHAPTER 12 Advanced data validation\nif(dev()) {\nif(!ajv.validate(searchBooksResponseSchema, bookInfos)) {\nvar errors = ajv.errorsText(ajv.errors);\nthrow (\"searchBooksByTitle returned an invalid value: \" +\nerrors);\n}\n}\nreturn bookInfos;\n};\nDave Of course! It’s in the code of Catalog.searchBooksBy"
    },
    "268": {
      "page": 296,
      "text": "268 CHAPTER 12 Advanced data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "268 CHAPTER 12 Advanced data validation\nListing12.27 Running the schema-based unit test again\nsearchBooksTest();\n// → searchBooksByTitle returned a value that doesn\\'t conform to schema:\n// data[0].authorNames[0] should be string,\n// data[0].authorNames[1] should be string,\n// data[1].authorNames[0]"
    },
    "270": {
      "page": 298,
      "text": "270 CHAPTER 12 Advanced data validation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "270 CHAPTER 12 Advanced data validation\n\"myLetters\": {\nmyLetters is a string with\n\"type\": \"string\",\nletters only (lowercase or\n\"pattern\": \"[a-zA-Z]*\"\nuppercase).\n}\n\"myNumberMap\": {\nmyNumberMap is an homogeneous\n\"type\": \"object\",\nstring map where all the values are\n\"additionalProperties\": {\"type\": \"n"
    },
    "272": {
      "page": 300,
      "text": "272",
      "pattern_type": "chapter",
      "line_position": 18,
      "full_text_preview": "Polymorphism\nPlaying with the animals\nin the countryside\nThis chapter covers\n Mimicking objects with multimethods (single\ndispatch)\n Implementing multimethod on several argument\ntypes (multiple dispatch)\n Implementing multimethods dynamically on\nseveral arguments (dynamic dispatch)\nOOP is well-kn"
    },
    "274": {
      "page": 302,
      "text": "274 CHAPTER 13 Polymorphism",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "274 CHAPTER 13 Polymorphism\nListing13.1 OOP polymorphism illustrated with animals\ninterface IAnimal {\npublic void greet();\n}\nclass Dog implements IAnimal {\nprivate String name;\npublic void greet() {\nSystem.out.println(\"Woof woof! My name is \" + animal.name);\n}\n}\nclass Cat implements IAnimal {\nprivat"
    },
    "276": {
      "page": 304,
      "text": "276 CHAPTER 13 Polymorphism",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "276 CHAPTER 13 Polymorphism\nconsole.log(\"Woof Woof! My name is: \" + animal.name);\nbreak;\ncase \"cat\":\nconsole.log(\"Meow! I am: \" + animal.name);\nbreak;\ncase \"cow\":\nconsole.log(\"Moo! Call me \" + animal.name);\nbreak;\n};\n}\n NOTE You should not use switch statements like this in your production code.\nWe"
    },
    "278": {
      "page": 306,
      "text": "278 CHAPTER 13 Polymorphism",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "278 CHAPTER 13 Polymorphism\nhandled by a specific method: \"dog\" by greetDog, \"cat\" by greetCat, and\n\"cow\" by greetCow.\nTheo takes out his notebook and opens it to a blank piece of paper. He draws a diagram\nlike the one in figure 13.1.\n\"dog\" greetDog\nGreet as a dog\ngreetDispatch \"cat\" greetCat\nEmit t"
    },
    "280": {
      "page": 308,
      "text": "280 CHAPTER 13 Polymorphism",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "280 CHAPTER 13 Polymorphism\nListing13.9 Implementation of greet method for cows\nfunction greetCow(animal) {\nconsole.log(\"Moo! Call me \" + animal.name);\n}\ngreet = method(\"cow\", greetCow)(greet);\nTIP In the context of multimethods, a method is a function that provides an imple-\nmentation for a dispatc"
    },
    "282": {
      "page": 310,
      "text": "282 CHAPTER 13 Polymorphism",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "282 CHAPTER 13 Polymorphism\nTheo Excellent! I hope you see that the dispatch function can emit any value.\nDave Like what?\nTheo Like emitting the type of two arguments!\nDave What do you mean?\nTheo Imagine that our animals are polyglot.\nDave Poly what?\nTheo Polyglot comes from the Greek polús, meaning"
    },
    "284": {
      "page": 312,
      "text": "284 CHAPTER 13 Polymorphism",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "284 CHAPTER 13 Polymorphism\nif(!ajv.validate(greetLangArgsSchema, [animal, language])) {\nthrow (\"greetLang called with invalid arguments: \" +\najv.errorsText(ajv.errors));\n}\n}\nreturn [animal.type, language.type];\n};\nvar greetLang = multi(greetLangDispatch);\nDave Does the order of the elements in the "
    },
    "286": {
      "page": 314,
      "text": "286 CHAPTER 13 Polymorphism",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "286 CHAPTER 13 Polymorphism\ngreetLang(myCat, english);\n// → \"Meow! I am Milo and I speak English\"\ngreetLang(myCow, french);\n// → \"Meuh! Appelle moi Clarabelle et je parle Français\"\ngreetLang(myCow, english);\n// → \"Moo! Call me Clarabelle and I speak English\"\nTheo Now do you agree that multimethods w"
    },
    "288": {
      "page": 316,
      "text": "288 CHAPTER 13 Polymorphism",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "288 CHAPTER 13 Polymorphism\nfunction dysGreetDogShort(animal) {\nconsole.log(\"Woof woof!\");\n}\ndysGreet = method([\"dog\", false], dysGreetDogShort)(dysGreet);\nfunction dysGreetCatLong(animal) {\nconsole.log(\"Meow! I am \" + animal.name);\n}\ndysGreet = method([\"cat\", true], dysGreetCatLong)(dysGreet);\nfunc"
    },
    "290": {
      "page": 318,
      "text": "290 CHAPTER 13 Polymorphism",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "290 CHAPTER 13 Polymorphism\nTheo It doesn’t sound too complicated.\nNancy Also, I need a bit of text formatting.\nTheo What kind of text formatting?\nNancy Depending on the number of books an author has written, their name should\nbe in bold and italic fonts.\nTheo Could you send me an email with all the"
    },
    "292": {
      "page": 320,
      "text": "292 CHAPTER 13 Polymorphism",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "292 CHAPTER 13 Polymorphism\nThen Dave works on the methods: first, the HTML format methods. In HTML, bold text is\nwrapped inside a <b> tag, and italic text is wrapped in a <i> tag. For instance, in HTML,\nthree authors with different levels of prolificity would be written like this.\nListing13.24 Exam"
    },
    "294": {
      "page": 322,
      "text": "294 CHAPTER 13 Polymorphism",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "294 CHAPTER 13 Polymorphism\nSummary\n The main benefit of polymorphism is extensibility.\n Multimethods make it possible to benefit from polymorphism when data is repre-\nsented with generic maps.\n A multimethod is made of a dispatch function and multiple methods.\n The dispatch function of a multim"
    },
    "295": {
      "page": 323,
      "text": "295",
      "pattern_type": "chapter",
      "line_position": 19,
      "full_text_preview": "Advanced data\nmanipulation\nWhatever is well-conceived\nis clearly said\nThis chapter covers\n Manipulating nested data\n Writing clear and concise code for business\nlogic\n Separating business logic and generic data\nmanipulation\n Building custom data manipulation tools\n Using the best tool for the j"
    },
    "296": {
      "page": 324,
      "text": "296 CHAPTER 14 Advanced data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "296 CHAPTER 14 Advanced data manipulation\n14.1 Updating a value in a map with eloquence\nDave is more and more autonomous on the Klafim project. He can implement most fea-\ntures on his own, typically turning to Theo only for code reviews. Dave’s code quality stan-\ndards are quite high. Even when his "
    },
    "298": {
      "page": 326,
      "text": "298 CHAPTER 14 Advanced data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "298 CHAPTER 14 Advanced data manipulation\nListing14.2 The code that removes duplicates in an elegant way\nfunction removeAuthorDuplicates(book) {\nreturn update(book, \"authors\", _.uniq);\n}\nTheo Looks good to me!\nDave Wow! Now the code with update is much more elegant than the code with\n_.get and _.set"
    },
    "300": {
      "page": 328,
      "text": "300 CHAPTER 14 Advanced data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "300 CHAPTER 14 Advanced data manipulation\nListing14.5 Retrieving the author IDs in books as an array of arrays\nfunction authorIdsInBooks(books) {\nreturn _.map(books, \"authorIds\");\n}\nTheo What’s the problem?\nDave The problem is that it returns an array of arrays of author IDs instead of an\narray of a"
    },
    "302": {
      "page": 330,
      "text": "302 CHAPTER 14 Advanced data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "302 CHAPTER 14 Advanced data manipulation\n\"title\": \"Watchmen\",\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n}\n]\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n\"bookItems\": [\n{\n\"id\": \"book-item-123\",\n\"libId\": \"hudson-park-lib\",\n\"isLe"
    },
    "304": {
      "page": 332,
      "text": "304 CHAPTER 14 Advanced data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "304 CHAPTER 14 Advanced data manipulation\nTheo Dealing with map fields instead of variables allows us to get rid of reduce in\nour business logic code.\nDave How could you iterate over a collection without forEach and without reduce?\nTheo I can’t avoid the iteration over a collection, but I can hide r"
    },
    "306": {
      "page": 334,
      "text": "306 CHAPTER 14 Advanced data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "306 CHAPTER 14 Advanced data manipulation\nListing14.16 Unit test for grouping books by a library\nvar books = [\n{\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n}\n]\n},\n{\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Hi"
    },
    "308": {
      "page": 336,
      "text": "308 CHAPTER 14 Advanced data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "308 CHAPTER 14 Advanced data manipulation\n{\n\"customer-id\" : \"joe\",\n// Other fields\n\"items\" : [\n{\n\"item\" : \"phone\",\n\"quantity\" : 1\n},\n{\n\"item\" : \"pencil\",\n\"quantity\" : 10 \"items\"\n}\n] map path\n}\nunwind\n{ {\n\"customer-id\" : \"joe\", \"customer-id\" : \"joe\",\n// Other fields // Other fields\n\"items\" : { res \"i"
    },
    "310": {
      "page": 338,
      "text": "310 CHAPTER 14 Advanced data manipulation",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "310 CHAPTER 14 Advanced data manipulation\nSummary\n Maintain a clear separation between the code that deals with business logic and\nthe implementation of the data manipulation.\n Separating business logic from data manipulation makes our code not only con-\ncise, but also easy to read because it conv"
    },
    "311": {
      "page": 339,
      "text": "311",
      "pattern_type": "chapter",
      "line_position": 18,
      "full_text_preview": "Debugging\nInnovation at the museum\nThis chapter covers\n Reproducing a bug in code that involves\nprimitive data types\n Reproducing a bug in code that involves\naggregated data\n Replaying a scenario in the REPL\n Creating unit tests from bugs\nWhen our programs don’t behave as expected, we need to in"
    },
    "312": {
      "page": 340,
      "text": "312 CHAPTER 15 Debugging",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "312 CHAPTER 15 Debugging\n15.1 Determinism in programming\nAfter a few months, Theo calls Dave to tell him that he’s leaving Albatross. After Dave\nrecovers from this first surprise, he’s given another, more pleasant one. Theo informs Dave\nthat after consulting with the management team, they have decid"
    },
    "314": {
      "page": 342,
      "text": "314 CHAPTER 15 Debugging",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "314 CHAPTER 15 Debugging\nDave OK. For the number and the string, I can simply copy their values to the clip-\nboard, paste them to the REPL, and execute foo in the REPL with the same\narguments.\nTheo That’s the easy part. What about the nested map?\nDave I don’t know. I don’t think I can copy a nested "
    },
    "316": {
      "page": 344,
      "text": "316 CHAPTER 15 Debugging",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "316 CHAPTER 15 Debugging\nDave Why would anyone ever need such a weird function?\nTheo It could be useful for the Library Management System when a user wants to\nfind books whose title contains a prefix.\nDave Interesting. I’ll talk about that with Nancy. Anyway, coding such a function\nseems quite obvio"
    },
    "318": {
      "page": 346,
      "text": "318 CHAPTER 15 Debugging",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "318 CHAPTER 15 Debugging\nTheo It works. In fact, it works well with any data, whether it’s a primitive data type or\na collection.\nDave Nice!\nTheo Next, I’ll show you how to use this approach to reproduce a real scenario that\nhappens in the context of the Library Management System.\nDave No more digit"
    },
    "320": {
      "page": 348,
      "text": "320 CHAPTER 15 Debugging",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "320 CHAPTER 15 Debugging\nDave Cool! In the catalog, we have the book, 7 Habits of Highly Effective People. Let’s\nsee what happens when we search books that match the word Habit.\nTheo replaces the value of the query in listing 15.10 with \"Habit\". The code now\nreturns an empty array as in listing 15.1"
    },
    "322": {
      "page": 350,
      "text": "322 CHAPTER 15 Debugging",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "322 CHAPTER 15 Debugging\nvar result = Catalog.searchBooksByTitle(catalogData, query);\nvar expectedResult = [\n{\n\"authorNames\": [\n\"Sean Covey\",\n\"Stephen Covey\",\n],\n\"isbn\": \"978-1982137274\",\n\"title\": \"7 Habits of Highly Effective People\",\n}\n];\n_.isEqual(result, expectedResult);\n// → true\nTheo Well done"
    },
    "324": {
      "page": 352,
      "text": "324 CHAPTER 15 Debugging",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "324 CHAPTER 15 Debugging\nreturn bookInfos;\n};\nTheo Trigger the endpoint to see if it works.\nDave triggers the search endpoint once again and views the output in the console. When he\nopens the file mentioned in the log message, he sees a single line that is hard to decipher.\nListing15.18 Console outp"
    },
    "326": {
      "page": 354,
      "text": "326 CHAPTER 15 Debugging",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "326 CHAPTER 15 Debugging\nDave While looking at the contents of the JSON file, I thought about the fact that we\nwrite data to the file in an asynchronous way. It means that data is written con-\ncurrently to the execution of the function code, right?\nTheo Right! As I told you, we don’t want to slow do"
    },
    "328": {
      "page": 356,
      "text": "328 CHAPTER 15 Debugging",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "328 CHAPTER 15 Debugging\nvar prefixRegExp = new RegExp(\"\\\\b\" +\nWhen passing \\b to the\nprefixLowerCase);\nRegExp constructor, we\nreturn sentenceLowerCase.match(prefixRegExp) != null; need an extra backslash.\n}\nTheo Now, let me write unit tests for all the cases.\nDave One test per query?\nTheo You could"
    },
    "330": {
      "page": 358,
      "text": "330 CHAPTER 15 Debugging",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "330 CHAPTER 15 Debugging\nDave Are there databases like that for real?\nTheo Yes. For instance, the Datomic immutable database is used by some digital\nbanks.\n NOTE See https://www.datomic.com for more information on the Datomic transac-\ntional database.\nDave But most databases don’t provide such a gu"
    },
    "332": {
      "page": 360,
      "text": "332 CHAPTER 15 Debugging",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "332 CHAPTER 15 Debugging\n Reproducibility allows us to reproduce a scenario in a pristine environment.\n The two conditions for reproducibility in programming are immutability and\nease of (de)serialization.\nLodash functions introduced in this chapter\nFunction Description\nfind(coll, pred) Iterates o"
    },
    "A": {
      "page": 361,
      "text": "appendix A",
      "pattern_type": "appendix",
      "line_position": 0,
      "full_text_preview": "appendix A\nPrinciples of data-oriented\nprogramming\nData-oriented programming (DOP) is a programming paradigm aimed at simplify-\ning the design and implementation of software systems, where information is at the\ncenter in systems such as frontend or backend web applications and web services,\nfor exam"
    },
    "334": {
      "page": 362,
      "text": "334 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "334 APPENDIX A Principles of data-oriented programming\nPrinciple #2: Represent Immutable\ndata with generic data\nstructures.\nGeneric\nMutable\nRepresentation\nPrinciple #3:\nSpecific\nData is\nData immutable.\nSchema\nPrinciple #4: Separate\ndata schema from data\nData-oriented\nrepresentation.\nprogramming\nFunc"
    },
    "336": {
      "page": 364,
      "text": "336 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "336 APPENDIX A Principles of data-oriented programming\nvar obj = new Author(\"Isaac\", \"Asimov\", 500);\nIsaac Asimov really\nobj.fullName();\nwrote around 500\n// → \"Isaac Asimov\" books!\nBREAKING PRINCIPLE #1 IN FP\nBreaking this principle without classes in FP means hiding data in the lexical scope of\na f"
    },
    "338": {
      "page": 366,
      "text": "338 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "338 APPENDIX A Principles of data-oriented programming\nthis.firstName = firstName;\nthis.lastName = lastName;\nthis.books = books;\n}\nfullName() {\nreturn this.firstName + \" \" + this.lastName;\n}\nisProlific() {\nreturn this.books > 100;\n}\n}\nOne way to achieve code reusability when code and data are mixed "
    },
    "340": {
      "page": 368,
      "text": "340 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "340 APPENDIX A Principles of data-oriented programming\n}\n}\nvar userData = new UserData(\"John\", \"Doe\", \"john@doe.com\");\nNameCalculation.fullName(userData);\nvar authorData = new AuthorData(\"Isaac\", \"Asimov\", 500);\nNameCalculation.fullName(authorData);\n// → \"John Doe\"\nTIP When code is separate from dat"
    },
    "342": {
      "page": 370,
      "text": "342 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "342 APPENDIX A Principles of data-oriented programming\nthis in the sense that it is hard to understand. The system is hard to understand because\nthere are many dependencies between the entities that compose the system.\nThe most complex entity of the system in figure A.2 is the Librarian entity, whic"
    },
    "344": {
      "page": 372,
      "text": "344 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "344 APPENDIX A Principles of data-oriented programming\nclass inheritance and composition. Therefore, the number of classes in the resulting\nsystem will probably be somewhere between N and 2N.\nOn one hand, when adhering to Principle #1, the entities of the system are sim-\npler. On the other hand, the"
    },
    "346": {
      "page": 374,
      "text": "346 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "346 APPENDIX A Principles of data-oriented programming\ndata.books = books;\nreturn data;\n}\nIn a language like JavaScript, we can also instantiate a map via a data literal, which is a\nbit more convenient. The following listing shows an example.\nListingA.14 Following Principle #2 with map literals\nfunc"
    },
    "348": {
      "page": 376,
      "text": "348 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "348 APPENDIX A Principles of data-oriented programming\nassociated to a key in a map, for example, is a bit slower than retrieving the value of a\nclass member. Similarly, setting the value of an arbitrary key in a map is a bit slower\nthan setting the value of a class member. In most programming langu"
    },
    "350": {
      "page": 378,
      "text": "350 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "350 APPENDIX A Principles of data-oriented programming\nauthor is prolific, the books field can be accessed as though it were declared as an\ninteger as in this listing.\nListingA.23 Type casting is not needed when accessing dynamic fields in C#\nclass AuthorRating {\npublic static bool isProlific (Dicti"
    },
    "352": {
      "page": 380,
      "text": "352 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "352 APPENDIX A Principles of data-oriented programming\nreturn res;\n}\nvar myData = {num: 42};\nvar yourData = changeValue(myData, \"num\", myData.num + 1);\nconsole.log(myData.num);\n// → 43\nEmbracing immutability in an efficient way, both in terms of computation and mem-\nory, requires a third-party libra"
    },
    "354": {
      "page": 382,
      "text": "354 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "354 APPENDIX A Principles of data-oriented programming\nTIP Adherence to data immutability eliminates the need for a concurrency mecha-\nnism. The data you have in hand never changes!\nA.3.3 Cost for Principle #3\nAs with the previous principles, applying Principle #3 comes at a price. The following\nsec"
    },
    "356": {
      "page": 384,
      "text": "356 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "356 APPENDIX A Principles of data-oriented programming\n\"properties\": {\n\"firstName\": {\"type\": \"string\"},\nfirstName must\n\"lastName\": {\"type\": \"string\"},\nbe a string.\n\"books\": {\"type\": \"integer\"}\n}\nbooks must be a number lastName must\n};\n(when it is provided). be a string.\nA data validation library is "
    },
    "358": {
      "page": 386,
      "text": "358 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "358 APPENDIX A Principles of data-oriented programming\n\"required\": [\"firstName\", \"lastName\"],\n\"properties\": {\n\"firstName\": {\"type\": \"string\"},\n\"lastName\": {\"type\": \"string\"},\n\"books\": {\"type\": \"integer\"}\n}\n};\nfunction displayAuthorInfo(authorData) {\nif(!ajv.validate(authorSchema, authorData)) {\nthro"
    },
    "360": {
      "page": 388,
      "text": "360 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "360 APPENDIX A Principles of data-oriented programming\nListingA.35 An invalid map with an invalid optional field\nvar authorDataInvalidBooks = {\n\"firstName\": \"Albert\",\n\"lastName\": \"Einstein\",\n\"books\": \"Five\"\n}; The validation fails,\nas books is not a\nnumber.\nvalidate(authorSchema, authorDataInvalidBo"
    },
    "362": {
      "page": 390,
      "text": "362 APPENDIX A Principles of data-oriented programming",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "362 APPENDIX A Principles of data-oriented programming\nprogramming language. It is up to the developer to decide where data validation is\nnecessary and where it is superfluous. As the idiom says, with great power comes great\nresponsibility.\nCOST #2: LIGHT PERFORMANCE HIT\nAs mentioned earlier, implem"
    },
    "B": {
      "page": 392,
      "text": "appendix B",
      "pattern_type": "appendix",
      "line_position": 0,
      "full_text_preview": "appendix B\nGeneric data access in\nstatically-typed languages\nRepresenting data with generic data structures fits naturally in dynamically-typed\nprogramming languages like JavaScript, Ruby, or Python. However, in statically-\ntyped programming languages like Java or C#, representing data as string map"
    },
    "e": {
      "page": 392,
      "text": "This appendix explores various ways to improve access to generic data in statically-",
      "pattern_type": "appendix",
      "line_position": 10,
      "full_text_preview": "appendix B\nGeneric data access in\nstatically-typed languages\nRepresenting data with generic data structures fits naturally in dynamically-typed\nprogramming languages like JavaScript, Ruby, or Python. However, in statically-\ntyped programming languages like Java or C#, representing data as string map"
    },
    "366": {
      "page": 394,
      "text": "366 APPENDIX B Generic data access in statically-typed languages",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "366 APPENDIX B Generic data access in statically-typed languages\nListingB.4 Mapping a map field with a dynamic getter and type casting\nvar books = List.of(watchmenMap, sevenHabitsMap);\nvar fieldName = \"title\";\nbooks.stream()\n.map(x -> DynamicAccess.get(x, fieldName))\n.map(x -> ((String)x).toUpperCas"
    },
    "368": {
      "page": 396,
      "text": "368 APPENDIX B Generic data access in statically-typed languages",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "368 APPENDIX B Generic data access in statically-typed languages\nThe value getter approach is used by Java libraries like Apache Wicket (http://\nmng.bz/wnqQ) and Gson (https://github.com/google/gson). Listing B.9 shows an\nimplementation for getAsString that retrieves a map field value as a string.\nL"
    },
    "370": {
      "page": 398,
      "text": "370 APPENDIX B Generic data access in statically-typed languages",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "370 APPENDIX B Generic data access in statically-typed languages\nValue getters make data access a bit more convenient when avoiding type casting. The\nnext section shows how typed getters make it possible to benefit from compile-time\nchecks, even when data is represented as string maps.\nB.3 Typed get"
    },
    "372": {
      "page": 400,
      "text": "372 APPENDIX B Generic data access in statically-typed languages",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "372 APPENDIX B Generic data access in statically-typed languages\nIn order to support nested map fields, a constructor is added to the Getter class,\nwhich receives a list of strings that represents the information path. The following list-\ning shows this implementation.\nListingB.20 A nested typed get"
    },
    "374": {
      "page": 402,
      "text": "374 APPENDIX B Generic data access in statically-typed languages",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "374 APPENDIX B Generic data access in statically-typed languages\npublic int hashCode() {\n// Omitted for sake of simplicity\n}\npublic String toString() {\n// Omitted for sake of simplicity\n}\n}\nSince Java 14, there is a simpler way to represent data using data records (http://\nmng.bz/q2q2) as listing B."
    },
    "376": {
      "page": 404,
      "text": "376 APPENDIX B Generic data access in statically-typed languages",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "376 APPENDIX B Generic data access in statically-typed languages\nListingB.29 Mapping over a list of objects with a value getter\nvar books = List.of(watchmenRecord, sevenHabitsRecord);\nbooks.stream()\n.map(x -> DynamicAccess.getAsString(x, \"title\"))\n.map(x -> x.toUpperCase())\n.collect(Collectors.toLis"
    },
    "c": {
      "page": 404,
      "text": "The typed getters we introduced earlier in the appendix can be used on objects. Take",
      "pattern_type": "appendix",
      "line_position": 8,
      "full_text_preview": "376 APPENDIX B Generic data access in statically-typed languages\nListingB.29 Mapping over a list of objects with a value getter\nvar books = List.of(watchmenRecord, sevenHabitsRecord);\nbooks.stream()\n.map(x -> DynamicAccess.getAsString(x, \"title\"))\n.map(x -> x.toUpperCase())\n.collect(Collectors.toLis"
    },
    "378": {
      "page": 406,
      "text": "378 APPENDIX B Generic data access in statically-typed languages",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "378 APPENDIX B Generic data access in statically-typed languages\nthis.numberOfPages = numberOfPages;\nthis.language = language;\n}\n}\npublic class BookWithAttributes {\npublic String isbn;\npublic String title;\npublic Integer publicationYear;\npublic BookAttributes attributes;\npublic Book (\nString isbn,\nS"
    },
    "2020": {
      "page": 407,
      "text": "2020",
      "pattern_type": "chapter",
      "line_position": 7,
      "full_text_preview": "B.4 Generic access to class members 379\nListingB.37 JSON serialization of an object with Gson\nimport com.google.gson.*;\nvar gson = new Gson();\nBookData sevenHabitsRecord = new BookData(\n\"978-1982137274\",\n\"7 Habits of Highly Effective People\",\n2020\n);\nSystem.out.println(gson.toJson(sevenHabitsRecord)"
    },
    "380": {
      "page": 408,
      "text": "380 APPENDIX B Generic data access in statically-typed languages",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "380 APPENDIX B Generic data access in statically-typed languages\nSummary\nThis appendix has presented various ways to provide generic data access in statically-\ntyped programming languages. Table B.1 summarizes the benefits and drawbacks of\neach approach. As you incorporate DOP practices in your prog"
    },
    "h": {
      "page": 408,
      "text": "This appendix has presented various ways to provide generic data access in statically-",
      "pattern_type": "appendix",
      "line_position": 2,
      "full_text_preview": "380 APPENDIX B Generic data access in statically-typed languages\nSummary\nThis appendix has presented various ways to provide generic data access in statically-\ntyped programming languages. Table B.1 summarizes the benefits and drawbacks of\neach approach. As you incorporate DOP practices in your prog"
    },
    "C": {
      "page": 409,
      "text": "appendix C",
      "pattern_type": "appendix",
      "line_position": 0,
      "full_text_preview": "appendix C\nData-oriented programming:\nA link in the chain of\nprogramming paradigms\nData-oriented programming (DOP) has its origins in the 1950s with the invention\nof the programming language Lisp. DOP is based on a set of best practices that can\nbe found in both functional programming (FP) and objec"
    },
    "t": {
      "page": 409,
      "text": "tures. This appendix traces the major ideas and discoveries which, over the years,",
      "pattern_type": "appendix",
      "line_position": 9,
      "full_text_preview": "appendix C\nData-oriented programming:\nA link in the chain of\nprogramming paradigms\nData-oriented programming (DOP) has its origins in the 1950s with the invention\nof the programming language Lisp. DOP is based on a set of best practices that can\nbe found in both functional programming (FP) and objec"
    },
    "382": {
      "page": 410,
      "text": "382 APPENDIX C Data-oriented programming: A link in the chain of programming paradigms",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "382 APPENDIX C Data-oriented programming: A link in the chain of programming paradigms\nLISP\nJohn McCarthy invents a\n1958\nlanguage designed for\nprocessing immutable lists.\nValues and Objects\nIn his beautiful paper“Values and Objects\n1981 in Programming Languages,”Bruce\nMacLennan clarifies the distinc"
    },
    "1958": {
      "page": 410,
      "text": "1958",
      "pattern_type": "chapter",
      "line_position": 3,
      "full_text_preview": "382 APPENDIX C Data-oriented programming: A link in the chain of programming paradigms\nLISP\nJohn McCarthy invents a\n1958\nlanguage designed for\nprocessing immutable lists.\nValues and Objects\nIn his beautiful paper“Values and Objects\n1981 in Programming Languages,”Bruce\nMacLennan clarifies the distinc"
    },
    "1981": {
      "page": 410,
      "text": "1981 in Programming Languages,”Bruce",
      "pattern_type": "chapter",
      "line_position": 8,
      "full_text_preview": "382 APPENDIX C Data-oriented programming: A link in the chain of programming paradigms\nLISP\nJohn McCarthy invents a\n1958\nlanguage designed for\nprocessing immutable lists.\nValues and Objects\nIn his beautiful paper“Values and Objects\n1981 in Programming Languages,”Bruce\nMacLennan clarifies the distinc"
    },
    "2000": {
      "page": 410,
      "text": "2000",
      "pattern_type": "chapter",
      "line_position": 13,
      "full_text_preview": "382 APPENDIX C Data-oriented programming: A link in the chain of programming paradigms\nLISP\nJohn McCarthy invents a\n1958\nlanguage designed for\nprocessing immutable lists.\nValues and Objects\nIn his beautiful paper“Values and Objects\n1981 in Programming Languages,”Bruce\nMacLennan clarifies the distinc"
    },
    "2006": {
      "page": 410,
      "text": "2006",
      "pattern_type": "chapter",
      "line_position": 19,
      "full_text_preview": "382 APPENDIX C Data-oriented programming: A link in the chain of programming paradigms\nLISP\nJohn McCarthy invents a\n1958\nlanguage designed for\nprocessing immutable lists.\nValues and Objects\nIn his beautiful paper“Values and Objects\n1981 in Programming Languages,”Bruce\nMacLennan clarifies the distinc"
    },
    "9": {
      "page": 411,
      "text": "chapter 9, HAMT and ideal hash trees are the foundation of efficient persistent data",
      "pattern_type": "chapter",
      "line_position": 5,
      "full_text_preview": "C.2 DOP principles as best practices 383\nC.1.3 2000: Ideal hash trees\nPhil Bagwell invented a data structure called Hash Array Mapped Trie (HAMT). In his\npaper, “Ideal Hash Trees,” he used HAMT to implement hash maps with nearly ideal\ncharacteristics both in terms of computation and memory usage. As"
    },
    "384": {
      "page": 412,
      "text": "384 APPENDIX C Data-oriented programming: A link in the chain of programming paradigms",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "384 APPENDIX C Data-oriented programming: A link in the chain of programming paradigms\nDOP is the combination of those principles into a cohesive whole. In this section, we\nput each of the four DOP principles into its broader scope.\nC.2.1 Principle #1: Separate code from data\nSeparating code from da"
    },
    "386": {
      "page": 414,
      "text": "386 APPENDIX C Data-oriented programming: A link in the chain of programming paradigms",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "386 APPENDIX C Data-oriented programming: A link in the chain of programming paradigms\nC.3.1 Data-oriented design\nData-oriented design is a program optimization approach motivated by efficient usage\nof the CPU cache. It’s used mostly in video game development. This approach focuses\non the data layou"
    },
    "D": {
      "page": 415,
      "text": "appendix D",
      "pattern_type": "appendix",
      "line_position": 0,
      "full_text_preview": "appendix D\nLodash reference\nThroughout the book, we have used Lodash (https://lodash.com/) to illustrate\nhow to manipulate data with generic functions. But there is nothing unique about\nLodash. The exact same approach could be implemented via other data manipula-\ntion libraries or custom code.\nMoreo"
    },
    "l": {
      "page": 415,
      "text": "This short appendix lists the 28 Lodash functions used in the book to help you, in",
      "pattern_type": "appendix",
      "line_position": 19,
      "full_text_preview": "appendix D\nLodash reference\nThroughout the book, we have used Lodash (https://lodash.com/) to illustrate\nhow to manipulate data with generic functions. But there is nothing unique about\nLodash. The exact same approach could be implemented via other data manipula-\ntion libraries or custom code.\nMoreo"
    },
    "388": {
      "page": 416,
      "text": "388 APPENDIX D Lodash reference",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "388 APPENDIX D Lodash reference\nEach table has three columns:\n Function shows the function with its signature.\n Description provides a brief description of the function.\n Chapter is the chapter number where the function appears for the first time.\nTable D.1 Lodash functions on maps\nFunction Descr"
    },
    "392": {
      "page": 420,
      "text": "392 INDEX",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "392 INDEX\nconcurrency control 91–92, 163 deepFreeze() function 177\ncomplexity of locks 164–165 design phase, OOP 4–5\nimplementation of reconciliation determinism 312–314\nalgorithm 106–108 displayAuthorInfo function 357\noptimistic concurrency control 92–93 displayFullName function 358–359\nreconciliat"
    },
    "394": {
      "page": 422,
      "text": "394 INDEX",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "394 INDEX\nLodash functions Member class 5, 10–11, 15\nat 205–206, 388 MemberCode entity 15\nconcat 388 MemberData entity 15\nevery 389 Member objects 7, 10\nfilter 188, 201, 389 Member record type 68\nfind 389 membersByEmail index 65\nflatMap 300–301 Member user type 65\nflatten 388 multimethod library 278"
    },
    "396": {
      "page": 424,
      "text": "396 INDEX",
      "pattern_type": "chapter",
      "line_position": 0,
      "full_text_preview": "396 INDEX\nU UserManagement record 65–66\nUser record type 68\nUML class diagrams 6–12 uuid third-party library 322\nunit tests 110 UUID (universal unique identifier) 322\nautomatic generation of 262–269\ndebugging 321–329 V\nfor data manipulation code 112–121\ntree of function calls 113–115 validate functi"
    },
    "185": {
      "page": 424,
      "text": "185 W",
      "pattern_type": "chapter",
      "line_position": 14,
      "full_text_preview": "396 INDEX\nU UserManagement record 65–66\nUser record type 68\nUML class diagrams 6–12 uuid third-party library 322\nunit tests 110 UUID (universal unique identifier) 322\nautomatic generation of 262–269\ndebugging 321–329 V\nfor data manipulation code 112–121\ntree of function calls 113–115 validate functi"
    }
  },
  "toc_pages_found": {
    "8": "brief contents\nPART 1 FLEXIBILITY..................................................................1\n1 ■ Complexity of object-orientedprogramming 3\n2 ■ Separation between code and data 26\n3 ■ Basic data manipulation 43\n4 ■ State management 71\n5 ■ Basic concurrency control 91\n6 ■ Unit tests 110\nPART 2 SCALABILITY .............................................................137\n7 ■ Basic data validation 141\n8 ■ Advanced concurrency control 163\n9 ■ Persistent data structures 175\n10 ■ Database opera",
    "9": "BRIEF CONTENTS vii\nPART 3 MAINTAINABILITY......................................................245\n12 ■ Advanced data validation 247\n13 ■ Polymorphism 272\n14 ■ Advanced data manipulation 295\n15 ■ Debugging 311",
    "10": "contents\nforewords xiii\npreface xvii\nacknowledgments xviii\nabout this book xx\nabout the author xxiv\nabout the cover illustration xxv\ndramatis personae xxvi\nPART 1 FLEXIBILITY........................................................1\n1 Complexity of object-oriented programming 3\n1.1 OOP design: Classic or classical? 4\nThe design phase 4 ■ UML 101 6 ■ Explaining each piece of\nthe class diagram 9 ■ The implementation phase 12\n1.2 Sources of complexity 13\nMany relations between classes 14 ■ Unpredict",
    "11": "CONTENTS ix\n2.3 Code modules 31\n2.4 DOP systems are easy to understand 36\n2.5 DOP systems are flexible 38\n3 Basic data manipulation 43\n3.1 Designing a data model 44\n3.2 Representing records as maps 48\n3.3 Manipulating data with generic functions 54\n3.4 Calculating search results 58\n3.5 Handling records of different types 65\n4 State management 71\n4.1 Multiple versions of the system data 72\n4.2 Structural sharing 74\n4.3 Implementing structural sharing 80\n4.4 Data safety 82\n4.5 The commit phase of ",
    "12": "x CONTENTS\nPART 2 SCALABILITY....................................................137\n7 Basic data validation 141\n7.1 Data validation in DOP 142\n7.2 JSON Schema in a nutshell 143\n7.3 Schema flexibility and strictness 149\n7.4 Schema composition 154\n7.5 Details about data validation failures 158\n8 Advanced concurrency control 163\n8.1 The complexity of locks 164\n8.2 Thread-safe counter with atoms 165\n8.3 Thread-safe cache with atoms 170\n8.4 State management with atoms 172\n9 Persistent data structure",
    "13": "CONTENTS xi\n11.4 Representing a server response as a map 227\n11.5 Passing information forward 231\n11.6 Search result enrichment in action 234\nPART 3 MAINTAINABILITY............................................245\n12 Advanced data validation 247\n12.1 Function arguments validation 248\n12.2 Return value validation 255\n12.3 Advanced data validation 257\n12.4 Automatic generation of data model diagrams 260\n12.5 Automatic generation of schema-based unit tests 262\n12.6 A new gift 269\n13 Polymorphism 272\n",
    "14": "xii CONTENTS\nappendix A Principles of data-oriented programming 333\nappendix B Generic data access in statically-typed languages 364\nappendix C Data-oriented programming: A link in the chain of programming\nparadigms 381\nappendix D Lodash reference 387\nindex 391",
    "23": "ABOUT THIS BOOK xxi\nuses a Lodash function that you are unfamiliar with, you can refer to appendix D to\nunderstand the behavior of the function.\nPart 1, Flexibility, contains six chapters and shines a spotlight on the challenges of\ntraditional object-oriented programming (OOP) and puts data-oriented program-\nming (DOP) center stage, revealing how to build flexible systems by using DOP’s basic\nprinciples. The chapters line up this way:\n In chapter 1, Complexity of object-oriented programming, we",
    "24": "xxii ABOUT THIS BOOK\n Chapter 9, Persistent data structures, moves to a more academic setting where our\nfriend Joe unveils the internal details of a safer and more scalable way to pre-\nserve data immutability as well as how to implement it efficiently, no matter the\ndata size. Class is now in session!\n Chapter 10, Database operations, teaches us how to represent, access, and manip-\nulate data from the database in a way that offers added flexibility, and—you\nguessed it!—less complexity.\n Chapt",
    "29": "Part 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development agency that seeks to regain the trust of startups.\nNancy and her business partner have raised seed money for Klafim, a social net-\nwork for books. Klafim’s unique value proposition is to combine the onl",
    "30": "2 PART 1 Flexibility\nThe requirements for the Klafim prototype\n Two kinds of library users are members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n The book belongs to a physical libra"
  },
  "total_leaf_nodes": 181,
  "mapped_leaf_nodes": [
    {
      "id": 1,
      "text": "- Part1 Introduction content",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "Part1 Introduction (사용자 추가)",
      "is_part_intro": true,
      "estimated_page_range": "26-28",
      "content_preview": "",
      "special_note": "Part와 Chapter 사이의 서론 내용",
      "accurate_page_range": "30-28"
    },
    {
      "id": 2,
      "text": "- 1.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 29 ===\n\nPart 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development agency that seeks to regain the trust of startups.\nNancy and her business partner have raised seed money for Klafim, a social net-\nwork for books. Klafim’s unique value proposition is ",
      "accurate_page_range": "29-29",
      "chapter_start_page": 29
    },
    {
      "id": 3,
      "text": "- 1.1.0 Introduction (사용자 추가)",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 29 ===\n\nPart 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development agency that seeks to regain the trust of startups.\nNancy and her business partner have raised seed money for Klafim, a social net-\nwork for books. Klafim’s unique value proposition is ",
      "accurate_page_range": "29-29",
      "chapter_start_page": 29
    },
    {
      "id": 4,
      "text": "- 1.1.1 The design phase",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 29 ===\n\nPart 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development agency that seeks to regain the trust of startups.\nNancy and her business partner have raised seed money for Klafim, a social net-\nwork for books. Klafim’s unique value proposition is ",
      "accurate_page_range": "29-29",
      "chapter_start_page": 29
    },
    {
      "id": 5,
      "text": "- 1.1.2 UML 101",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 29 ===\n\nPart 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development agency that seeks to regain the trust of startups.\nNancy and her business partner have raised seed money for Klafim, a social net-\nwork for books. Klafim’s unique value proposition is ",
      "accurate_page_range": "29-29",
      "chapter_start_page": 29
    },
    {
      "id": 6,
      "text": "- 1.1.3 Explaining each piece of the class diagram",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 29 ===\n\nPart 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development agency that seeks to regain the trust of startups.\nNancy and her business partner have raised seed money for Klafim, a social net-\nwork for books. Klafim’s unique value proposition is ",
      "accurate_page_range": "29-29",
      "chapter_start_page": 29
    },
    {
      "id": 7,
      "text": "- 1.1.4 The implementation phase",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 29 ===\n\nPart 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development agency that seeks to regain the trust of startups.\nNancy and her business partner have raised seed money for Klafim, a social net-\nwork for books. Klafim’s unique value proposition is ",
      "accurate_page_range": "29-29",
      "chapter_start_page": 29
    },
    {
      "id": 8,
      "text": "- 1.2.0 Introduction (사용자 추가)",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 29 ===\n\nPart 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development agency that seeks to regain the trust of startups.\nNancy and her business partner have raised seed money for Klafim, a social net-\nwork for books. Klafim’s unique value proposition is ",
      "accurate_page_range": "29-29",
      "chapter_start_page": 29
    },
    {
      "id": 9,
      "text": "- 1.2.1 Many relations between classes",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 29 ===\n\nPart 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development agency that seeks to regain the trust of startups.\nNancy and her business partner have raised seed money for Klafim, a social net-\nwork for books. Klafim’s unique value proposition is ",
      "accurate_page_range": "29-29",
      "chapter_start_page": 29
    },
    {
      "id": 10,
      "text": "- 1.2.2 Unpredictable code behavior",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 29 ===\n\nPart 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development agency that seeks to regain the trust of startups.\nNancy and her business partner have raised seed money for Klafim, a social net-\nwork for books. Klafim’s unique value proposition is ",
      "accurate_page_range": "29-29",
      "chapter_start_page": 29
    },
    {
      "id": 11,
      "text": "- 1.2.3 Not trivial data serialization",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 29 ===\n\nPart 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development agency that seeks to regain the trust of startups.\nNancy and her business partner have raised seed money for Klafim, a social net-\nwork for books. Klafim’s unique value proposition is ",
      "accurate_page_range": "29-29",
      "chapter_start_page": 29
    },
    {
      "id": 12,
      "text": "- 1.2.4 Complex class hierarchies",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 29 ===\n\nPart 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development agency that seeks to regain the trust of startups.\nNancy and her business partner have raised seed money for Klafim, a social net-\nwork for books. Klafim’s unique value proposition is ",
      "accurate_page_range": "29-29",
      "chapter_start_page": 29
    },
    {
      "id": 13,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "1 Complexity of object-oriented programming",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 29 ===\n\nPart 1\nFlexibility\nI\nt’s Monday morning. Theodore is sitting with Nancy on the terrace of La Vita è\nBella, an Italian coffee shop near the San Francisco Zoo. Nancy is an entrepreneur\nlooking for a development agency for her startup company, Klafim. Theo works for\nAlbatross, a software development agency that seeks to regain the trust of startups.\nNancy and her business partner have raised seed money for Klafim, a social net-\nwork for books. Klafim’s unique value proposition is ",
      "accurate_page_range": "29-29",
      "chapter_start_page": 29
    },
    {
      "id": 14,
      "text": "- 2.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 30 ===\n\n2 PART 1 Flexibility\nThe requirements for the Klafim prototype\n Two kinds of library users are members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n The book belongs t",
      "accurate_page_range": "30-272",
      "chapter_start_page": 30
    },
    {
      "id": 15,
      "text": "- 2.1 The two parts of a DOP system",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 30 ===\n\n2 PART 1 Flexibility\nThe requirements for the Klafim prototype\n Two kinds of library users are members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n The book belongs t",
      "accurate_page_range": "30-272",
      "chapter_start_page": 30
    },
    {
      "id": 16,
      "text": "- 2.2 Data entities",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 30 ===\n\n2 PART 1 Flexibility\nThe requirements for the Klafim prototype\n Two kinds of library users are members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n The book belongs t",
      "accurate_page_range": "30-272",
      "chapter_start_page": 30
    },
    {
      "id": 17,
      "text": "- 2.3 Code modules",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 30 ===\n\n2 PART 1 Flexibility\nThe requirements for the Klafim prototype\n Two kinds of library users are members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n The book belongs t",
      "accurate_page_range": "30-272",
      "chapter_start_page": 30
    },
    {
      "id": 18,
      "text": "- 2.4 DOP systems are easy to understand",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 30 ===\n\n2 PART 1 Flexibility\nThe requirements for the Klafim prototype\n Two kinds of library users are members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n The book belongs t",
      "accurate_page_range": "30-272",
      "chapter_start_page": 30
    },
    {
      "id": 19,
      "text": "- 2.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 30 ===\n\n2 PART 1 Flexibility\nThe requirements for the Klafim prototype\n Two kinds of library users are members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n The book belongs t",
      "accurate_page_range": "30-272",
      "chapter_start_page": 30
    },
    {
      "id": 20,
      "text": "- 2.5 DOP systems are flexible",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 30 ===\n\n2 PART 1 Flexibility\nThe requirements for the Klafim prototype\n Two kinds of library users are members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n The book belongs t",
      "accurate_page_range": "30-272",
      "chapter_start_page": 30
    },
    {
      "id": 21,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "2 Separation between code and data",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 30 ===\n\n2 PART 1 Flexibility\nThe requirements for the Klafim prototype\n Two kinds of library users are members and librarians.\n Users log in to the system via email and password.\n Members can borrow books.\n Members and librarians can search books by title or by author.\n Librarians can block and unblock members (e.g., when they are late in return-\ning a book).\n Librarians can list the books currently lent to a member.\n There could be several copies of a book.\n The book belongs t",
      "accurate_page_range": "30-272",
      "chapter_start_page": 30
    },
    {
      "id": 22,
      "text": "- 3.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "273-31",
      "chapter_start_page": 273
    },
    {
      "id": 23,
      "text": "- 3.1 Designing a data model",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "273-31",
      "chapter_start_page": 273
    },
    {
      "id": 24,
      "text": "- 3.2 Representing records as maps",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "273-31",
      "chapter_start_page": 273
    },
    {
      "id": 25,
      "text": "- 3.3 Manipulating data with generic functions",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "273-31",
      "chapter_start_page": 273
    },
    {
      "id": 26,
      "text": "- 3.4 Calculating search results",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "273-31",
      "chapter_start_page": 273
    },
    {
      "id": 27,
      "text": "- 3.5 Handling records of different types",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "273-31",
      "chapter_start_page": 273
    },
    {
      "id": 28,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "273-31",
      "chapter_start_page": 273
    },
    {
      "id": 29,
      "text": "- 4.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 32 ===\n\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, ",
      "accurate_page_range": "32-220",
      "chapter_start_page": 32
    },
    {
      "id": 30,
      "text": "- 4.1 Multiple versions of the system data",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 32 ===\n\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, ",
      "accurate_page_range": "32-220",
      "chapter_start_page": 32
    },
    {
      "id": 31,
      "text": "- 4.2 Structural sharing",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 32 ===\n\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, ",
      "accurate_page_range": "32-220",
      "chapter_start_page": 32
    },
    {
      "id": 32,
      "text": "- 4.3 Implementing structural sharing",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 32 ===\n\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, ",
      "accurate_page_range": "32-220",
      "chapter_start_page": 32
    },
    {
      "id": 33,
      "text": "- 4.4 Data safety",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 32 ===\n\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, ",
      "accurate_page_range": "32-220",
      "chapter_start_page": 32
    },
    {
      "id": 34,
      "text": "- 4.5 The commit phase of a mutation",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 32 ===\n\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, ",
      "accurate_page_range": "32-220",
      "chapter_start_page": 32
    },
    {
      "id": 35,
      "text": "- 4.6 Ensuring system state integrity",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 32 ===\n\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, ",
      "accurate_page_range": "32-220",
      "chapter_start_page": 32
    },
    {
      "id": 36,
      "text": "- 4.7 Restoring previous states",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 32 ===\n\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, ",
      "accurate_page_range": "32-220",
      "chapter_start_page": 32
    },
    {
      "id": 37,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 32 ===\n\n4 CHAPTER 1 Complexity of object-orientedprogramming\nThis chapter is not meant to be read as a critical analysis of OOP. Its purpose is to\nraise your awareness of the tendency towards OOP’s increased complexity as a pro-\ngramming paradigm. Hopefully, it will motivate you to discover a different program-\nming paradigm, where system complexity tends to be reduced. This paradigm is\nknown as data-oriented programming (DOP).\n1.1 OOP design: Classic or classical?\n NOTE Theo, Nancy, ",
      "accurate_page_range": "32-220",
      "chapter_start_page": 32
    },
    {
      "id": 38,
      "text": "- 5.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "221-33",
      "chapter_start_page": 221
    },
    {
      "id": 39,
      "text": "- 5.1 Optimistic concurrency control",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "221-33",
      "chapter_start_page": 221
    },
    {
      "id": 40,
      "text": "- 5.2 Reconciliation between concurrent mutations",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "221-33",
      "chapter_start_page": 221
    },
    {
      "id": 41,
      "text": "- 5.3 Reducing collections",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "221-33",
      "chapter_start_page": 221
    },
    {
      "id": 42,
      "text": "- 5.4 Structural difference",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "221-33",
      "chapter_start_page": 221
    },
    {
      "id": 43,
      "text": "- 5.5 Implementing the reconciliation algorithm",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "221-33",
      "chapter_start_page": 221
    },
    {
      "id": 44,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "221-33",
      "chapter_start_page": 221
    },
    {
      "id": 45,
      "text": "- 6.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 34 ===\n\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool",
      "accurate_page_range": "34-239",
      "chapter_start_page": 34
    },
    {
      "id": 46,
      "text": "- 6.1 The simplicity of data-oriented test cases",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 34 ===\n\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool",
      "accurate_page_range": "34-239",
      "chapter_start_page": 34
    },
    {
      "id": 47,
      "text": "- 6.2.0 Introduction (사용자 추가)",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 34 ===\n\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool",
      "accurate_page_range": "34-239",
      "chapter_start_page": 34
    },
    {
      "id": 48,
      "text": "- 6.2.1 The tree of function calls",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 34 ===\n\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool",
      "accurate_page_range": "34-239",
      "chapter_start_page": 34
    },
    {
      "id": 49,
      "text": "- 6.2.2 Unit tests for functions down the tree",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 34 ===\n\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool",
      "accurate_page_range": "34-239",
      "chapter_start_page": 34
    },
    {
      "id": 50,
      "text": "- 6.2.3 Unit tests for nodes in the tree",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 34 ===\n\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool",
      "accurate_page_range": "34-239",
      "chapter_start_page": 34
    },
    {
      "id": 51,
      "text": "- 6.3 Unit tests for queries",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 34 ===\n\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool",
      "accurate_page_range": "34-239",
      "chapter_start_page": 34
    },
    {
      "id": 52,
      "text": "- 6.4 Unit tests for mutations",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 34 ===\n\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool",
      "accurate_page_range": "34-239",
      "chapter_start_page": 34
    },
    {
      "id": 53,
      "text": "- Moving forward",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 34 ===\n\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool",
      "accurate_page_range": "34-239",
      "chapter_start_page": 34
    },
    {
      "id": 54,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 34 ===\n\n6 CHAPTER 1 Complexity of object-orientedprogramming\nC Library\nname : String\naddress : String\nC Catalog\nsearch(searchCriteria, queryStr) : List<Book>\naddBookItem(librarian: Librarian, bookItem: BookItem) : BookItem\n*\n* C Librarian\nC Book\nblockMember(member: Member) : Bool\nid : String unblockMember(member: Member) : Bool\ntitle : String addBookItem(bookItem: BookItem) : BookItem\ngetBookLendingsOfMember(member: Member) : List<BookLending>\n*\n*\nC Member\n*\nC Author isBlocked() : Bool",
      "accurate_page_range": "34-239",
      "chapter_start_page": 34
    },
    {
      "id": 55,
      "text": "- Part2 Introduction content",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "6 Unit tests",
      "is_part_intro": true,
      "estimated_page_range": "9-11",
      "content_preview": "\n=== Page 237 ===\n\n10.3 Simple data manipulation 209\nTheo Awesome! Can you show me the implementation of renameResultKeys?\nJoe Sure, it’s only about map and reduce, so I’d do something like the following.\nListing10.14 Renaming the keys in SQL results\nfunction renameKeys(map, keyMap) {\nreturn _.reduce(keyMap,\nfunction(res, newKey, oldKey) {\nvar value = _.get(map, oldKey);\nvar resWithNewKey = _.set(res, newKey, value);\nvar resWithoutOldKey = _.omit(resWithNewKey, oldKey);\nreturn resWithoutOldKey;\n",
      "special_note": "Part와 Chapter 사이의 서론 내용",
      "accurate_page_range": "235-239"
    },
    {
      "id": 56,
      "text": "- Part2 Introduction content",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "Part2 Introduction (사용자 추가)",
      "is_part_intro": true,
      "estimated_page_range": "9-11",
      "content_preview": "\n=== Page 237 ===\n\n10.3 Simple data manipulation 209\nTheo Awesome! Can you show me the implementation of renameResultKeys?\nJoe Sure, it’s only about map and reduce, so I’d do something like the following.\nListing10.14 Renaming the keys in SQL results\nfunction renameKeys(map, keyMap) {\nreturn _.reduce(keyMap,\nfunction(res, newKey, oldKey) {\nvar value = _.get(map, oldKey);\nvar resWithNewKey = _.set(res, newKey, value);\nvar resWithoutOldKey = _.omit(resWithNewKey, oldKey);\nreturn resWithoutOldKey;\n",
      "special_note": "Part와 Chapter 사이의 서론 내용",
      "accurate_page_range": "235-239"
    },
    {
      "id": 57,
      "text": "- 7.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "240-35",
      "chapter_start_page": 240
    },
    {
      "id": 58,
      "text": "- 7.1 Data validation in DOP",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "240-35",
      "chapter_start_page": 240
    },
    {
      "id": 59,
      "text": "- 7.2 JSON Schema in a nutshell",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "240-35",
      "chapter_start_page": 240
    },
    {
      "id": 60,
      "text": "- 7.3 Schema flexibility and strictness",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "240-35",
      "chapter_start_page": 240
    },
    {
      "id": 61,
      "text": "- 7.4 Schema composition",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "240-35",
      "chapter_start_page": 240
    },
    {
      "id": 62,
      "text": "- 7.5 Details about data validation failures",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "240-35",
      "chapter_start_page": 240
    },
    {
      "id": 63,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "7 Basic data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "240-35",
      "chapter_start_page": 240
    },
    {
      "id": 64,
      "text": "- 8.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "8 Advanced concurrency control",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 36 ===\n\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the",
      "accurate_page_range": "36-410",
      "chapter_start_page": 36
    },
    {
      "id": 65,
      "text": "- 8.1 The complexity of locks",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "8 Advanced concurrency control",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 36 ===\n\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the",
      "accurate_page_range": "36-410",
      "chapter_start_page": 36
    },
    {
      "id": 66,
      "text": "- 8.2 Thread-safe counter with atoms",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "8 Advanced concurrency control",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 36 ===\n\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the",
      "accurate_page_range": "36-410",
      "chapter_start_page": 36
    },
    {
      "id": 67,
      "text": "- 8.3 Thread-safe cache with atoms",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "8 Advanced concurrency control",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 36 ===\n\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the",
      "accurate_page_range": "36-410",
      "chapter_start_page": 36
    },
    {
      "id": 68,
      "text": "- 8.4 State management with atoms",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "8 Advanced concurrency control",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 36 ===\n\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the",
      "accurate_page_range": "36-410",
      "chapter_start_page": 36
    },
    {
      "id": 69,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "8 Advanced concurrency control",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 36 ===\n\n8 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\ntitle : String\n*\n*\nC Author\nid : String Figure 1.3 Many-to-many association relation:\nfullName: String\neach object lives independently.\nTIP A many-to-many association relation is represented by an empty diamond and a\nstar at both edges.\nDave I also see a bunch of dashed arrows in your diagram.\nTheo Dashed arrows are for usage relations: when a class uses a method of another\nclass. Consider, for example, the",
      "accurate_page_range": "36-410",
      "chapter_start_page": 36
    },
    {
      "id": 70,
      "text": "- 9.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "9 Persistent data structures",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "411-37",
      "chapter_start_page": 411
    },
    {
      "id": 71,
      "text": "- 9.1 The need for persistent data structures",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "9 Persistent data structures",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "411-37",
      "chapter_start_page": 411
    },
    {
      "id": 72,
      "text": "- 9.2 The efficiency of persistent data structures",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "9 Persistent data structures",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "411-37",
      "chapter_start_page": 411
    },
    {
      "id": 73,
      "text": "- 9.3.0 Introduction (사용자 추가)",
      "node_level": 4,
      "part": "Part2—Scalability",
      "chapter": "9 Persistent data structures",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "411-37",
      "chapter_start_page": 411
    },
    {
      "id": 74,
      "text": "- 9.3.1 Persistent data structures in Java",
      "node_level": 4,
      "part": "Part2—Scalability",
      "chapter": "9 Persistent data structures",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "411-37",
      "chapter_start_page": 411
    },
    {
      "id": 75,
      "text": "- 9.3.2 Persistent data structures in JavaScript",
      "node_level": 4,
      "part": "Part2—Scalability",
      "chapter": "9 Persistent data structures",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "411-37",
      "chapter_start_page": 411
    },
    {
      "id": 76,
      "text": "- 9.4.0 Introduction (사용자 추가)",
      "node_level": 4,
      "part": "Part2—Scalability",
      "chapter": "9 Persistent data structures",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "411-37",
      "chapter_start_page": 411
    },
    {
      "id": 77,
      "text": "- 9.4.1 Writing queries with persistent data structures",
      "node_level": 4,
      "part": "Part2—Scalability",
      "chapter": "9 Persistent data structures",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "411-37",
      "chapter_start_page": 411
    },
    {
      "id": 78,
      "text": "- 9.4.2 Writing mutations with persistent data structures",
      "node_level": 4,
      "part": "Part2—Scalability",
      "chapter": "9 Persistent data structures",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "411-37",
      "chapter_start_page": 411
    },
    {
      "id": 79,
      "text": "- 9.4.3 Serialization and deserialization",
      "node_level": 4,
      "part": "Part2—Scalability",
      "chapter": "9 Persistent data structures",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "411-37",
      "chapter_start_page": 411
    },
    {
      "id": 80,
      "text": "- 9.4.4 Structural diff",
      "node_level": 4,
      "part": "Part2—Scalability",
      "chapter": "9 Persistent data structures",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "411-37",
      "chapter_start_page": 411
    },
    {
      "id": 81,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "9 Persistent data structures",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "411-37",
      "chapter_start_page": 411
    },
    {
      "id": 82,
      "text": "- 10.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "10 Database operations",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 38 ===\n\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC M",
      "accurate_page_range": "38-58",
      "chapter_start_page": 38
    },
    {
      "id": 83,
      "text": "- 10.1 Fetching data from the database",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "10 Database operations",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 38 ===\n\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC M",
      "accurate_page_range": "38-58",
      "chapter_start_page": 38
    },
    {
      "id": 84,
      "text": "- 10.2 Storing data in the database",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "10 Database operations",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 38 ===\n\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC M",
      "accurate_page_range": "38-58",
      "chapter_start_page": 38
    },
    {
      "id": 85,
      "text": "- 10.3 Simple data manipulation",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "10 Database operations",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 38 ===\n\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC M",
      "accurate_page_range": "38-58",
      "chapter_start_page": 38
    },
    {
      "id": 86,
      "text": "- 10.4 Advanced data manipulation",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "10 Database operations",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 38 ===\n\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC M",
      "accurate_page_range": "38-58",
      "chapter_start_page": 38
    },
    {
      "id": 87,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "10 Database operations",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 38 ===\n\n10 CHAPTER 1 Complexity of object-orientedprogramming\nIn terms of code (behavior), a Library object does nothing on its own. It delegates\neverything to the objects it owns. In terms of data, a Library object owns\n Multiple Member objects\n Multiple Librarian objects\n A single Catalog object\n NOTE In this book, we use the terms code and behavior interchangeably.\nLIBRARIAN, MEMBER, AND USER CLASSES\nLibrarian and Member both derive from User. Figure 1.7 shows this relation.\nC M",
      "accurate_page_range": "38-58",
      "chapter_start_page": 38
    },
    {
      "id": 88,
      "text": "- 11.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 89,
      "text": "- 11.1 Another feature request",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 90,
      "text": "- 11.2 Building the insides like the outsides",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 91,
      "text": "- 11.3 Representing a client request as a map",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 92,
      "text": "- 11.4 Representing a server response as a map",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 93,
      "text": "- 11.5 Passing information forward",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 94,
      "text": "- 11.6 Search result enrichment in action",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 95,
      "text": "- Delivering on time",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 96,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "11 Web services",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 97,
      "text": "- Part3 Introduction content",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "Part3 Introduction (사용자 추가)",
      "is_part_intro": true,
      "estimated_page_range": "37-39",
      "content_preview": "\n=== Page 37 ===\n\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasu",
      "special_note": "Part와 Chapter 사이의 서론 내용",
      "accurate_page_range": "35-39"
    },
    {
      "id": 98,
      "text": "- 12.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 40 ===\n\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare",
      "accurate_page_range": "40-65",
      "chapter_start_page": 40
    },
    {
      "id": 99,
      "text": "- 12.1 Function arguments validation",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 40 ===\n\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare",
      "accurate_page_range": "40-65",
      "chapter_start_page": 40
    },
    {
      "id": 100,
      "text": "- 12.2 Return value validation",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 40 ===\n\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare",
      "accurate_page_range": "40-65",
      "chapter_start_page": 40
    },
    {
      "id": 101,
      "text": "- 12.3 Advanced data validation",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 40 ===\n\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare",
      "accurate_page_range": "40-65",
      "chapter_start_page": 40
    },
    {
      "id": 102,
      "text": "- 12.4 Automatic generation of data model diagrams",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 40 ===\n\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare",
      "accurate_page_range": "40-65",
      "chapter_start_page": 40
    },
    {
      "id": 103,
      "text": "- 12.5 Automatic generation of schema-based unit tests",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 40 ===\n\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare",
      "accurate_page_range": "40-65",
      "chapter_start_page": 40
    },
    {
      "id": 104,
      "text": "- 12.6 A new gift",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 40 ===\n\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare",
      "accurate_page_range": "40-65",
      "chapter_start_page": 40
    },
    {
      "id": 105,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "12 Advanced data validation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 40 ===\n\n12 CHAPTER 1 Complexity of object-orientedprogramming\nC Book\nid : String\n*\ntitle : String\n* *\nC BookItem C Author\nid : String id : String\nIibld: String fullName: String\nBookLending checkout(member: Member)\nC BookLending\nid : String\nlendingDate : date\ndueDate : date\nBool isLate()\nBool returnBook() Figure 1.9 The Book class\nTHE BOOKITEM CLASS\nThe BookItem class represents a book copy, and a book could have many copies. In\nterms of data, a BookItem object\n Should have as its bare",
      "accurate_page_range": "40-65",
      "chapter_start_page": 40
    },
    {
      "id": 106,
      "text": "- 13.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "66-41",
      "chapter_start_page": 66
    },
    {
      "id": 107,
      "text": "- 13.1 The essence of polymorphism",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "66-41",
      "chapter_start_page": 66
    },
    {
      "id": 108,
      "text": "- 13.2 Multimethods with single dispatch",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "66-41",
      "chapter_start_page": 66
    },
    {
      "id": 109,
      "text": "- 13.3 Multimethods with multiple dispatch",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "66-41",
      "chapter_start_page": 66
    },
    {
      "id": 110,
      "text": "- 13.4 Multimethods with dynamic dispatch",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "66-41",
      "chapter_start_page": 66
    },
    {
      "id": 111,
      "text": "- 13.5 Integrating multimethods in a production system",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "66-41",
      "chapter_start_page": 66
    },
    {
      "id": 112,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "13 Polymorphism",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "",
      "accurate_page_range": "66-41",
      "chapter_start_page": 66
    },
    {
      "id": 113,
      "text": "- 14.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "14 Advanced data manipulation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 42 ===\n\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Ext",
      "accurate_page_range": "42-62",
      "chapter_start_page": 42
    },
    {
      "id": 114,
      "text": "- 14.1 Updating a value in a map with eloquence",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "14 Advanced data manipulation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 42 ===\n\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Ext",
      "accurate_page_range": "42-62",
      "chapter_start_page": 42
    },
    {
      "id": 115,
      "text": "- 14.2 Manipulating nested data",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "14 Advanced data manipulation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 42 ===\n\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Ext",
      "accurate_page_range": "42-62",
      "chapter_start_page": 42
    },
    {
      "id": 116,
      "text": "- 14.3 Using the best tool for the job",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "14 Advanced data manipulation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 42 ===\n\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Ext",
      "accurate_page_range": "42-62",
      "chapter_start_page": 42
    },
    {
      "id": 117,
      "text": "- 14.4 Unwinding at ease",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "14 Advanced data manipulation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 42 ===\n\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Ext",
      "accurate_page_range": "42-62",
      "chapter_start_page": 42
    },
    {
      "id": 118,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "14 Advanced data manipulation",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": "\n=== Page 42 ===\n\n14 CHAPTER 1 Complexity of object-orientedprogramming\nIn the remaining sections of this chapter, we will illustrate each of the previous\naspects, summarized in table 1.1. We’ll look at this in the context of the Klafim project\nand explain in what sense these aspects are a source of complexity.\nTable 1.1 Aspects of OOP and their impact on system complexity\nAspect Impact on complexity\nCode and data are mixed. Classes tend to be involved in many relations.\nObjects are mutable. Ext",
      "accurate_page_range": "42-62",
      "chapter_start_page": 42
    },
    {
      "id": 119,
      "text": "- 15.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 120,
      "text": "- 15.1 Determinism in programming",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 121,
      "text": "- 15.2 Reproducibility with numbers and strings",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 122,
      "text": "- 15.3 Reproducibility with any data",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 123,
      "text": "- 15.4 Unit tests",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 124,
      "text": "- 15.5 Dealing with external data sources",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 125,
      "text": "- Farewell",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 126,
      "text": "- Summary",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 127,
      "text": "- A.0 Introduction (사용자 추가)",
      "node_level": 2,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 128,
      "text": "- A.1.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 129,
      "text": "- A.1.1 Illustration of Principle #1",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 130,
      "text": "- A.1.2 Benefits of Principle #1",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 131,
      "text": "- A.1.3 Cost for Principle #1",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 132,
      "text": "- A.1.4 Summary of Principle #1",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 133,
      "text": "- A.2.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 134,
      "text": "- A.2.1 Illustration of Principle #2",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 135,
      "text": "- A.2.2 Benefits of Principle #2",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 136,
      "text": "- A.2.3 Cost for Principle #2",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 137,
      "text": "- A.2.4 Summary of Principle #2",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 138,
      "text": "- A.3.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 139,
      "text": "- A.3.1 Illustration of Principle #3",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 140,
      "text": "- A.3.2 Benefits of Principle #3",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 141,
      "text": "- A.3.3 Cost for Principle #3",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 142,
      "text": "- A.3.4 Summary of Principle #3",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 143,
      "text": "- A.4.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 144,
      "text": "- A.4.1 Illustration of Principle #4",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 145,
      "text": "- A.4.2 Benefits of Principle #4",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 146,
      "text": "- A.4.3 Cost for Principle #4",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 147,
      "text": "- A.4.4 Summary of Principle #4",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 148,
      "text": "- Conclusion",
      "node_level": 2,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 149,
      "text": "- B.0 Introduction (사용자 추가)",
      "node_level": 2,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 150,
      "text": "- B.1.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 151,
      "text": "- B.1.1 Accessing non-nested map fields with dynamic getters",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 152,
      "text": "- B.1.2 Accessing nested map fields with dynamic getters",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 153,
      "text": "- B.2.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 154,
      "text": "- B.2.1 Accessing non-nested map fields with value getters",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 155,
      "text": "- B.2.2 Accessing nested map fields with value getters",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 156,
      "text": "- B.3.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 157,
      "text": "- B.3.1 Accessing non-nested map fields with typed getters",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 158,
      "text": "- B.3.2 Accessing nested map fields with typed getters",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 159,
      "text": "- B.4.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 160,
      "text": "- B.4.1 Generic access to non-nested class members",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 161,
      "text": "- B.4.2 Generic access to nested class members",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 162,
      "text": "- B.4.3 Automatic JSON serialization of objects",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 163,
      "text": "- Summary",
      "node_level": 2,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 164,
      "text": "- C.0 Introduction (사용자 추가)",
      "node_level": 2,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 165,
      "text": "- C.1.1 1958: Lisp",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 166,
      "text": "- C.1.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 167,
      "text": "- C.1.2 1981: Values and objects",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 168,
      "text": "- C.1.3 2000: Ideal hash trees",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 169,
      "text": "- C.1.4 2006: Out of the Tar Pit",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 170,
      "text": "- C.1.5 2007: Clojure",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 171,
      "text": "- C.1.6 2009: Immutability for all",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 172,
      "text": "- C.2.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 173,
      "text": "- C.2.1 Principle #1: Separate code from data",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 174,
      "text": "- C.2.2 Principle #2: Represent data with generic data structures",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 175,
      "text": "- C.2.3 Principle #3: Data is immutable",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 176,
      "text": "- C.2.4 Principle #4: Separate data schema from data representation",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 177,
      "text": "- C.3.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 178,
      "text": "- C.3.1 Data-oriented design",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 179,
      "text": "- C.3.2 Data-driven programming",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 180,
      "text": "- C.3.3 Data-oriented programming (DOP)",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    },
    {
      "id": 181,
      "text": "- Summary",
      "node_level": 2,
      "part": "Part3—Maintainability",
      "chapter": "15 Debugging",
      "is_part_intro": false,
      "estimated_page_range": null,
      "content_preview": null
    }
  ],
  "special_part_intro_nodes": [
    {
      "id": 1,
      "text": "- Part1 Introduction content",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "Part1 Introduction (사용자 추가)",
      "is_part_intro": true,
      "estimated_page_range": "26-28",
      "content_preview": "",
      "special_note": "Part와 Chapter 사이의 서론 내용",
      "accurate_page_range": "30-28"
    },
    {
      "id": 55,
      "text": "- Part2 Introduction content",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "6 Unit tests",
      "is_part_intro": true,
      "estimated_page_range": "9-11",
      "content_preview": "\n=== Page 237 ===\n\n10.3 Simple data manipulation 209\nTheo Awesome! Can you show me the implementation of renameResultKeys?\nJoe Sure, it’s only about map and reduce, so I’d do something like the following.\nListing10.14 Renaming the keys in SQL results\nfunction renameKeys(map, keyMap) {\nreturn _.reduce(keyMap,\nfunction(res, newKey, oldKey) {\nvar value = _.get(map, oldKey);\nvar resWithNewKey = _.set(res, newKey, value);\nvar resWithoutOldKey = _.omit(resWithNewKey, oldKey);\nreturn resWithoutOldKey;\n",
      "special_note": "Part와 Chapter 사이의 서론 내용",
      "accurate_page_range": "235-239"
    },
    {
      "id": 56,
      "text": "- Part2 Introduction content",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "Part2 Introduction (사용자 추가)",
      "is_part_intro": true,
      "estimated_page_range": "9-11",
      "content_preview": "\n=== Page 237 ===\n\n10.3 Simple data manipulation 209\nTheo Awesome! Can you show me the implementation of renameResultKeys?\nJoe Sure, it’s only about map and reduce, so I’d do something like the following.\nListing10.14 Renaming the keys in SQL results\nfunction renameKeys(map, keyMap) {\nreturn _.reduce(keyMap,\nfunction(res, newKey, oldKey) {\nvar value = _.get(map, oldKey);\nvar resWithNewKey = _.set(res, newKey, value);\nvar resWithoutOldKey = _.omit(resWithNewKey, oldKey);\nreturn resWithoutOldKey;\n",
      "special_note": "Part와 Chapter 사이의 서론 내용",
      "accurate_page_range": "235-239"
    },
    {
      "id": 97,
      "text": "- Part3 Introduction content",
      "node_level": 3,
      "part": "Part3—Maintainability",
      "chapter": "Part3 Introduction (사용자 추가)",
      "is_part_intro": true,
      "estimated_page_range": "37-39",
      "content_preview": "\n=== Page 37 ===\n\n1.1 OOP design: Classic or classical? 9\nCC Member\nisBlocked() : Bool\nblock() : Bool\nunblock() : Bool\nreturnBook(bookLending : BookLending) : Bool\ncheckout(bookItem: BookItem) : BookLending\nC User\nid : String\nemail : String\npassword : String Figure 1.5 Inheritance relation: a class\nlogin() : Bool derives from another class.\n1.1.3 Explaining each piece of the class diagram\nDave Thanks for the UML refresher! Now I think I can remember what the different\narrows mean.\nTheo My pleasu",
      "special_note": "Part와 Chapter 사이의 서론 내용",
      "accurate_page_range": "35-39"
    }
  ]
}