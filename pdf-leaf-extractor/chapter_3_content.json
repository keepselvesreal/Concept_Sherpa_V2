{
  "chapter": "3",
  "title": "Basic data manipulation",
  "page_info": {
    "page": 76,
    "title": "Basic data manipulation",
    "pattern_matched": "Chapter 3",
    "text_preview": "48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to"
  },
  "leaf_nodes": [
    {
      "text": "- 3.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "raw_line": "- 3.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 22,
      "chapter_info": {
        "page": 76,
        "title": "Basic data manipulation",
        "pattern_matched": "Chapter 3",
        "text_preview": "48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to"
      },
      "chapter_sections": {
        "start_page": 76,
        "end_page": 101,
        "content": "\n--- Page 76 ---\n48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to say that a data entity diagram consists only of records, positional\ncollections, and indexes?\nJoe That’s correct. Can you make a similar statement about the relations between\nentities?\nTheo The relations in a data entity diagram are either composition (solid line with a\nfull diamond) or association (dashed line with an empty diamond). Both types\nof relations can be either one-to-one, one-to-many, or many-to-many.\nJoe Excellent!\nTIP A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes. The relation between records is either composition or\nassociation.\n3.2 Representing records as maps\nSo far, we’ve illustrated the benefits we gain from the separation between code and\ndata at a high-system level. There’s a separation of concerns between code and data,\nand each part has clear constraints:\n Code consists of static functions that receive data as an explicit argument.\n Data entities are modeled as records, and the relations between records are\nrepresented by positional collections and indexes.\nNow comes the question of the representation of the data. DOP has nothing special\ntosay about collections and indexes. However, it’s strongly opinionated about the\nrepresentation of records: records should be represented by generic data structures\nsuch as maps.\nThis applies to both OOP and FP languages. In dynamically-typed languages like\nJavaScript, Python, and Ruby, data representation feels natural. While in statically-\ntyped languages like Java and C#, it is a bit more cumbersome.\nTheo I’m really curious to know how we represent positional collections, indexes,\nand records in DOP.\nJoe Let’s start with positional collections. DOP has nothing special to say about the\nrepresentation of collections. They can be linked lists, arrays, vectors, sets, or\nother collections best suited for the use case.\nTheo It’s like in OOP.\nJoe Right! For now, to keep things simple, we’ll use arrays to represent positional\ncollections.\nTheo What about indexes?\nJoe Indexes are represented as homogeneous string maps.\nTheo What do you mean by a homogeneous map?\n--- Page 77 ---\n3.2 Representing records as maps 49\nJoe I mean that all the values of the map are of the same kind. For example, in a\nBook index, all the values are Book, and in an author index, all the values are\nAuthor, and so forth.\nTheo Again, it’s like in OOP.\n NOTE A homogeneous map is a map where all the values are of the same type. A hetero-\ngeneous map is a map where the values are of different types.\nJoe Now, here’s the big surprise. In DOP, records are represented as maps, more\nprecisely, heterogeneous string maps.\nJoe goes to the whiteboard and begins to draw. When he’s finished, he shows Theo the dia-\ngram in figure 3.4.\nRecord Heterogeneous map\nLinked list\nArray\nData representation Collection\nSet\nVector\nFigure 3.4 The building blocks\nIndex Homogeneous map\nof data representation\nTheo stays silent for a while. He is shocked to hear that the data entities of a system can be\nrepresented as a generic data structure, where the field names and value types are not\nspecified in a class. Then, Theo asks Joe:\nTheo What are the benefits of this folly?\nJoe Flexibility and genericity.\nTheo Could you explain, please?\nJoe I’ll explain in a moment, but before that, I’d like to show you what an instance\nof a record in a DOP system looks like.\nTheo OK.\nJoe Let’s take as an example, Watchmen, by Alan Moore and Dave Gibbons, which is\nmy favorite graphic novel. This masterpiece was published in 1987. I’m going\nto assume that, in a physical library, there are two copies of this book, whose ID\nis nyc-central-lib, and that one of the two copies is currently out. Here’s\nhow I’d represent the Book record for Watchmen in DOP.\nJoe comes closer to Theo’s laptop. He opens a text editor (not an IDE!) and types the Book\nrecord for Theo.\n--- Page 78 ---\n50 CHAPTER 3 Basic data manipulation\nListing3.1 An instance of a Book record represented as a map\n{\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\nTheo looks at the laptop screen. He has a question.\nTheo How am I supposed to instantiate the Book record for Watchmen programmat-\nically?\nJoe It depends on the facilities that your programming language offers to instantiate\nmaps. With dynamic languages like JavaScript, Ruby, or Python, it’s straight-\nforward, because we can use literals for maps and arrays. Here, let me show\nyou how.\nJoe jots down the JavaScript code that creates an instance of a Book record, which rep-\nresents as a map in JavaScript. He shows the code to Theo.\nListing3.2 A Book record represented as a map in JavaScript\nvar watchmenBook = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n--- Page 79 ---\n3.2 Representing records as maps 51\nTheo And, if I’m in Java?\nJoe It’s a bit more tedious, but still doable with the immutable Map and List static\nfactory methods.\n NOTE See “Creating Immutable Lists, Sets, and Maps” at http://mng.bz/voGm for\nmore information on this Java core library.\nJoe types the Java code to create an instance of a Book record represented as a map. He\nshows Theo the Java code.\nListing3.3 A Book record represented as a map in Java\nMap watchmen = Map.of(\n\"isbn\", \"978-1779501127\",\n\"title\", \"Watchmen\",\n\"publicationYear\", 1987,\n\"authors\", List.of(\"alan-moore\", \"dave-gibbons\"),\n\"bookItems\", List.of(\nMap.of(\n\"id\", \"book-item-1\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", true\n),\nMap.of (\n\"id\", \"book-item-2\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", false\n)\n)\n);\nTIP In DOP, we represent a record as a heterogeneous string map.\nTheo I’d definitely prefer to create a Book record using a Book class and a BookItem\nclass.\nTheo opens his IDE. He types the JavaScript code to represent a Book record as an instance\nof a Book class.\nListing3.4 A Book record as an instance of a Book class in JavaScript\nclass Book {\nisbn;\ntitle;\npublicationYear;\nauthors;\nbookItems;\nconstructor(isbn, title, publicationYear, authors, bookItems) {\nthis.isbn = isbn;\nthis.title = title;\nthis.publicationYear = publicationYear;\nthis.authors = authors;\nthis.bookItems = bookItems;\n--- Page 80 ---\n52 CHAPTER 3 Basic data manipulation\n}\n}\nclass BookItem {\nid;\nlibId;\nisLent;\nconstructor(id, libId, isLent) {\nthis.id = id;\nthis.libId = libId;\nthis.isLent = isLent;\n}\n}\nvar watchmenBook = new Book(\"978-1779501127\",\n\"Watchmen\",\n1987,\n[\"alan-moore\", \"dave-gibbons\"],\n[new BookItem(\"book-item-1\", \"nyc-central-lib\", true),\nnew BookItem(\"book-item-2\", \"nyc-central-lib\", false)]);\nJoe Theo, why do you prefer classes over maps for representing records?\nTheo It makes the data shape of the record part of my program. As a result, the IDE\ncan auto-complete field names, and errors are caught at compile time.\nJoe Fair enough. Can I show you some drawbacks for this approach?\nTheo Sure.\nJoe Imagine that you want to display the information about a book in the context\nof search results. In that case, instead of author IDs, you want to display\nauthor names, and you don’t need the book item information. How would\nyou handle that?\nTheo I’d create a class BookInSearchResults without a bookItems member and\nwith an authorNames member instead of the authorIds member of the Book\nclass. Also, I would need to write a copy constructor that receives a Book object.\nJoe In classic OOP, the fact that data is instantiated only via classes brings safety.\nBut this safety comes at the cost of flexibility.\nTIP There’s a tradeoff between flexibility and safety in a data model.\nTheo So, how can it be different?\nJoe In the DOP approach, where records are represented as maps, we don’t need\nto create a class for each variation of the data. We’re free to add, remove, and\nrename record fields dynamically. Our data model is flexible.\nTheo Interesting!\nTIP In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\nJoe Now, let me talk about genericity. How would you serialize the content of a\nBook object to JSON?\n--- Page 81 ---\n3.2 Representing records as maps 53\nTIP In DOP, records are manipulated with generic functions.\nTheo Oh no! I remember that while working on the Klafim prototype, I had a night-\nmare about JSON serialization when I was developing the first version of the\nLibrary Management System.\nJoe Well, in DOP, serializing a record to JSON is super easy.\nTheo Does it require the usage of reflection in order to go over the fields of the\nrecord like the Gson Java library does?\n NOTE See https://github.com/google/gson for more information on Gson.\nJoe Not at all! Remember that in DOP, a record is nothing more than data. We can\nwrite a generic JSON serialization function that works with any record. It can\nbe a Book, an Author, a BookItem, or anything else.\nTheo Amazing!\nTIP In DOP, you get JSON serialization for free.\nJoe Actually, as I’ll show you in a moment, lots of data manipulation stuff can be\ndone using generic functions.\nTheo Are the generic functions part of the language?\nJoe It depends on the functions and on the language. For example, JavaScript pro-\nvides a JSON serialization function called JSON.stringify out of the box, but\nnone for omitting multiple keys or for renaming keys.\nTheo That’s annoying.\nJoe Not so much; there are third-party libraries that provide data-manipulation facil-\nities. A popular data manipulation library in the JavaScript ecosystem is Lodash.\n NOTE See https://lodash.com/ to find out more about Lodash.\nTheo What about other languages?\nJoe Lodash has been ported to Java, C#, Python, and Ruby. Let me bookmark some\nsites for you.\nJoe bookmarks these sites for Theo:\n https://javalibs.com/artifact/com.github.javadev/underscore-lodash for Java\n https://www.nuget.org/packages/lodash/ for C#\n https://github.com/dgilland/pydash for Python\n https://rudash-website.now.sh/ for Ruby\n NOTE Throughout the book, we use Lodash to show how to manipulate data with\ngeneric functions, but there is nothing special about Lodash. The exact same approach\ncould be implemented via other data manipulation libraries or custom code.\nTheo Cool!\nJoe Actually, Lodash and its rich set of data manipulation functions can be ported\nto any language. That’s why it’s so beneficial to represent records as maps.\n--- Page 82 ---\n54 CHAPTER 3 Basic data manipulation\nTIP DOP compromises on data safety to gain flexibility and genericity.\nAt the whiteboard, Joe quickly sketches the tradeoffs (see table 3.1).\nTable 3.1 The tradeoff among safety, flexibility, and genericity\nOOP DOP\nSafety High Low\nFlexibility Low High\nGenericity Low High\n3.3 Manipulating data with generic functions\nJoe Now let me show you how to manipulate data in DOP with generic functions.\nTheo Yes, I’m quite curious to see how you’ll implement the search functionality of\nthe Library Management System.\nJoe OK. First, let’s instantiate a Catalog record for the catalog data of a library,\nwhere we have a single book, Watchmen.\nJoe instantiates a Catalog record according to Theo’s data model in figure 3.3. Here’s\nwhat Joe shows to Theo.\nListing3.5 A Catalog record\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n--- Page 83 ---\n3.3 Manipulating data with generic functions 55\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\nTheo I see the two indexes we talked about, booksByIsbn and authorsById. How\ndo you differentiate a record from an index in DOP?\nJoe In an entity diagram, there’s a clear distinction between records and indexes.\nBut in our code, both are plain data.\nTheo I guess that’s why this approach is called data-oriented programming.\nJoe See how straightforward it is to visualize any part of the system data inside a\nprogram? The reason is that data is represented as data!\nTIP In DOP, data is represented as data.\nTheo That sounds like a lapalissade.1\nJoe Oh, does it? I’m not so sure! In OOP, data is usually represented by objects,\nwhich makes it more challenging to visualize data inside a program.\nTIP In DOP, we can visualize any part of the system data.\nTheo How would you retrieve the title of a specific book from the catalog data?\nJoe Great question! In fact, in a DOP system, every piece of information has an\ninformation path from which we can retrieve the information.\nTheo Information path?\nJoe For example, the information path to the title of the Watchmen book in the\ncatalog is [\"booksByIsbn\", \"978-1779501127\", \"title\"].\nTheo Ah, I see. So, is an information path sort of like a file path, but that names in\nan information path correspond to nested entities?\nJoe You’re exactly right. And once we have the path of a piece of information, we\ncan retrieve the information with Lodash’s _.get function.\nJoe types a few characters on Theo’s laptop. Theo is amazed at how little code is needed to\nget the book title.\nListing3.6 Retrieving the title of a book from its information path\n_.get(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"])\n// → \"Watchmen\"\nTheo Neat. I wonder how hard it would be to implement a function like _.get\nmyself.\n1 A lapalissade is an obvious truth—a truism or tautology—that produces a comical effect.\n--- Page 84 ---\n56 CHAPTER 3 Basic data manipulation\nAfter a few minutes of trial and error, Theo is able to produce his implementation. He\nshows Joe the code.\nListing3.7 Custom implementation of get\nfunction get(m, path) {\nvar res = m;\nfor(var i = 0; i < path.length; i++) {\nWe could use\nvar key = path[i];\nforEach instead\nres = res[key];\nof a for loop.\n}\nreturn res;\n}\nAfter testing Theo’s implementation of get, Joe compliments Theo. He’s grateful that\nTheo is catching on so quickly.\nListing3.8 Testing the custom implementation of get\nget(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"]);\n// → \"Watchmen\"\nJoe Well done!\nTheo I wonder if a function like _.get works smoothly in a statically-typed language\nlike Java?\nJoe It depends on whether you only need to pass the value around or to access the\nvalue concretely.\nTheo I don’t follow.\nJoe Imagine that once you get the title of a book, you want to convert the string\ninto an uppercase string. You need to do a static cast to String, right? Here,\nlet me show you an example that casts a field value to a string, then we can\nmanipulate it as a string.\nListing3.9 Casting a field value to a string\n((String)watchmen.get(\"title\")).toUpperCase()\nTheo That makes sense. The values of the map are of different types, so the compiler\ndeclares it as a Map<String,Object>. The information of the type of the field\nis lost.\nJoe It’s a bit annoying, but quite often our code just passes the data around. In that\ncase, we don’t have to deal with static casting. Moreover, in a language like C#,\nwhen using the dynamic data type, type casting can be avoided.2,3\n2 See http://mng.bz/4jo5 for the C# documentation on the built-in reference to dynamic types.\n3 See appendix A for details about dynamic fields and type casting in C#.\n--- Page 85 ---\n3.3 Manipulating data with generic functions 57\nTIP In statically-typed languages, we sometimes need to statically cast the field values.\nTheo What about performance?\nJoe In most programming languages, maps are quite efficient. Accessing a field\nin a map is slightly slower than accessing a class member. Usually, it’s not\nsignificant.\nTIP There’s no significant performance hit for accessing a field in a map instead of as\na class member.\nTheo Let’s get back to this idea of information path. It works in OOP too. I could\naccess the title of the Watchmen book with catalogData.booksByIsbn[\"978-\n1779501127\"].title. I’d use class members for record fields and strings for\nindex keys.\nJoe There’s a fundamental difference, though. When records are represented as\nmaps, the information can be retrieved via its information path using a generic\nfunction like _.get. But when records are represented as objects, you need to\nwrite specific code for each type of information path.\nTheo What do you mean by specific code? What’s specific in catalogData.books-\nByIsbn[\"978-1779501127\"].title?\nJoe In a statically-typed language like Java, you’d need to import the class defini-\ntions for Catalog and Book.\nTheo And, in a dynamically-typed language like JavaScript...?\nJoe Even in JavaScript, when you represent records with objects instantiated from\nclasses, you can’t easily write a function that receives a path as an argument\nand display the information that corresponds to this path. You would have to\nwrite specific code for each kind of path. You’d access class members with dot\nnotation and map fields with bracket notation.\nTheo Would you say that in DOP, the information path is a first-class citizen?\nJoe Absolutely! The information path can be stored in a variable and passed as an\nargument to a function.\nTIP In DOP, you can retrieve every piece of information via a path and a generic\nfunction.\nJoe goes to the whiteboard. He draws a diagram like that in figure 3.5, which shows the\ncatalog data as a tree.\nJoe You see, Theo, each piece of information is accessible via a path made of\nstrings and integers. For example, the path of Alan Moore’s first book is\n[\"catalog\", \"authorsById\", \"alan-moore\", \"bookIsbns\", 0].\n--- Page 86 ---\n58 CHAPTER 3 Basic data manipulation\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 3.5 The catalog data as a tree\n3.4 Calculating search results\nTheo Interesting. I’m starting to feel the power of expression of DOP!\nJoe Wait, that’s just the beginning. Let me show you how simple it is to write code\nthat retrieves book information and displays it in search results. Can you tell\nme exactly what information has to appear in the search results?\nTheo Searching for book information should return isbn, title, and author-\nNames.\nJoe And what would a BookInfo record look like for Watchmen?\nTheo quickly enters the code on his laptop. He then shows it to Joe.\nListing3.10 A BookInfo record for Watchmen in the context of search result\n{\n\"title\": \"Watchmen\",\n\"isbn\": \"978-1779501127\",\n\"authorNames\": [\n\"Alan Moore\",\n\"Dave Gibbons\",\n]\n}\n--- Page 87 ---\n3.4 Calculating search results 59\nJoe Now I’ll show you step by step how to write a function that returns search\nresults matching a title in JSON format. I’ll use generic data manipulation\nfunctions from Lodash.\nTheo I’m ready!\nJoe Let’s start with an authorNames function that calculates the author names of a\nBook record by looking at the authorsById index. Could you tell me what’s\nthe information path for the name of an author whose ID is authorId?\nTheo It’s [\"authorsById\", authorId, \"name\"].\nJoe Now, let me show you how to retrieve the name of several authors using _.map.\nJoe types the code to map the author IDs to the author names. Theo nonchalantly peeks\nover Joe’s shoulder.\nListing3.11 Mapping author IDs to author names\n_.map([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\nTheo What’s this _.map function? It smells like functional programming! You said I\nwouldn’t have to learn FP to implement DOP!\nJoe No need to learn functional programming in order to use _.map, which is a\nfunction that transforms the values of a collection. You can implement it with\na simple for loop.\nTheo spends a couple of minutes in front of his computer figuring out how to implement\n_.map. Now he’s got it!\nListing3.12 Custom implementation of map\nfunction map(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nres[i] = f(coll[i]);\nforEach instead\n}\nof a for loop.\nreturn res;\n}\nAfter testing Theo’s implementation of map, Joe shows Theo the test. Joe again compli-\nments Theo.\nListing3.13 Testing the custom implementation of map\nmap([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\n--- Page 88 ---\n60 CHAPTER 3 Basic data manipulation\nJoe Well done!\nTheo You were right! It wasn’t hard.\nJoe Now, let’s implement authorNames using _.map.\nIt takes a few minutes for Theo to come up with the implementation of authorNames.\nWhen he’s finished, he turns his laptop to Joe.\nListing3.14 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nJoe We also need a bookInfo function that converts a Book record into a Book-\nInfo record. Let me show you the code for that.\nListing3.15 Converting a Book record into a BookInfo record\nfunction bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": authorNames(catalogData, book)\n};\nThere’s no need to create\nreturn bookInfo;\na class for bookInfo.\n}\nTheo Looking at the code, I see that a BookInfo record has three fields: title,\nisbn, and authorNames. Is there a way to get this information without looking\nat the code?\nJoe You can either add it to the data entity diagram or write it in the documenta-\ntion of the bookInfo function, or both.\nTheo I have to get used to the idea that in DOP, the record field information is not\npart of the program.\nJoe Indeed, it’s not part of the program, but it gives us a lot of flexibility.\nTheo Is there any way for me to have my cake and eat it too?\nJoe Yes, and someday I’ll show you how to make record field information part of a\nDOP program (see chapters 7 and 12).\nTheo Sounds intriguing!\nJoe Now that we have all the pieces in place, we can write our searchBooksBy-\nTitle function, which returns the book information about the books that\nmatch the query. First, we find the Book records that match the query with\n_.filter and then we transform each Book record into a BookInfo record\nwith _.map and bookInfo.\n--- Page 89 ---\n3.4 Calculating search results 61\nListing3.16 Searching books that match a query\nfunction searchBooksByTitle(catalogData, query) {\nvar allBooks = _.values(_.get(catalogData, \"booksByIsbn\"));\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\nThe includes JavaScript\n});\nfunction checks whether\na string includes a string\nvar bookInfos = _.map(matchingBooks, function(book) { as a substring.\nreturn bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\nTheo You’re using Lodash functions without any explanation again!\nJoe Sorry about that. I am so used to basic data manipulation functions that I con-\nsider them as part of the language. What functions are new to you?\nTheo _.values and _.filter\nJoe Well, _.values returns a collection made of the values of a map, and _.filter\nreturns a collection made of the values that satisfy a predicate.\nTheo _.values seems trivial. Let me try to implement _.filter.\nThe implementation of _.filter takes a bit more time. Eventually, Theo manages to get\nit right, then he is able to test it.\nListing3.17 Custom implementation of filter\nfunction filter(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nif(f(coll[i])) {\nforEach instead\nres.push(coll[i]);\nof a for loop.\n}\n}\nreturn res;\n}\nListing3.18 Testing the custom implementation of filter\nfilter([\"Watchmen\", \"Batman\"], function (title) {\nreturn title.includes(\"Watch\");\n});\n// → [\"Watchmen\"]\nTheo To me, it’s a bit weird that to access the title of a book record, I need to write\n_.get(book, \"title\"). I’d expect it to be book.title in dot notation or\nbook[\"title\"] in bracket notation.\nJoe Remember that book is a record that’s not represented as an object. It’s a map.\nIndeed, in JavaScript, you can write _.get(book, \"title\"), book.title, or\nbook[\"title\"]. But I prefer to use Lodash’s _.get function. In some lan-\nguages, the dot and the bracket notations might not work on maps.\n--- Page 90 ---\n62 CHAPTER 3 Basic data manipulation\nTheo Being language-agnostic has a price!\nJoe Right, would you like to test searchBooksByTitle?\nTheo Absolutely! Let me call searchBooksByTitle to search the books whose title\ncontain the string Watch.\nListing3.19 Testing searchBooksByTitle\nsearchBooksByTitle(catalogData, \"Wat\");\n//[\n// {\n// \"authorNames\": [\n// \"Alan Moore\",\n// \"Dave Gibbons\"\n// ],\n// \"isbn\": \"978-1779501127\",\n// \"title\": \"Watchmen\"\n// }\n//]\nTheo It seems to work! Are we done with the search implementation?\nJoe Almost. The searchBooksByTitle function we wrote is going to be part of the\nCatalog module, and it returns a collection of records. We have to write a\nfunction that’s part of the Library module, and that returns a JSON string.\nTheo You told me earlier that JSON serialization was straightforward in DOP.\nJoe Correct. The code for searchBooksByTitleJSON retrieves the Catalog record,\npasses it to searchBooksByTitle, and converts the results to JSON with\nJSON.stringify. That’s part of JavaScript. Here, let me show you.\nListing3.20 Implementation of searching books in a library as JSON\nfunction searchBooksByTitleJSON(libraryData, query) {\nvar results = searchBooksByTitle(_.get(libraryData, \"catalog\"), query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\nJoe In order to test our code, we need to create a Library record that contains our\nCatalog record. Could you do that for me, please?\nTheo Should the Library record contain all the Library fields (name, address,\nand UserManagement)?\nJoe That’s not necessary. For now, we only need the catalog field, then the test\nfor searching books.\nListing3.21 A Library record\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n--- Page 91 ---\n3.4 Calculating search results 63\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nListing3.22 Test for searching books in a library as JSON\nsearchBooksByTitleJSON(libraryData, \"Wat\");\nTheo How are we going to combine the four functions that we’ve written so far?\nJoe The functions authorNames, bookInfo, and searchBooksByTitle go into\nthe Catalog module, and searchBooksByTitleJSON goes into the Library\nmodule.\nTheo looks at the resulting code of the two modules, Library and Catalog. He’s quite\namazed by its conciseness.\nListing3.23 Calculating search results for Library and Catalog\nclass Catalog {\nstatic authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\n--- Page 92 ---\n64 CHAPTER 3 Basic data manipulation\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nThere’s no need\nreturn bookInfo;\nto create a class\n}\nfor bookInfo.\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nWhen _.filter is\nvar matchingBooks = _.filter(allBooks,\npassed a map, it\nfunction(book) {\ngoes over the values\nreturn _.get(book, \"title\").includes(query);\nof the map.\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nConverts data\nreturn resultsJSON;\nto JSON (part\n}\nof JavaScript)\n}\nAfter testing the final code in listing 3.24, Theo looks again at the source code from list-\ning 3.23. After a few seconds, he feels like he’s having another Aha! moment.\nListing3.24 Search results in JSON\nLibrary.searchBooksByTitleJSON(libraryData, \"Watchmen\");\n// → \"[{\\\"title\\\":\\\"Watchmen\\\",\\\"isbn\\\":\\\"978-1779501127\\\",\n// → \\\"authorNames\\\":[\\\"Alan Moore\\\",\\\"Dave Gibbons\\\"]}]\"\nTheo The important thing is not that the code is concise, but that the code contains\nno abstractions. It’s just data manipulation!\nJoe responds with a smile that says, “You got it, my friend!”\nJoe It reminds me of what my first meditation teacher told me 10 years ago:\nmeditation guides the mind to grasp the reality as it is without the abstractions\ncreated by our thoughts.\nTIP In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\n--- Page 93 ---\n3.5 Handling records of different types 65\n3.5 Handling records of different types\nWe’ve seen how DOP enables us to treat records as first-class citizens that can be\nmanipulated in a flexible way using generic functions. But if a record is nothing more\nthan an aggregation of fields, how do we know what the type of the record is? DOP has\na surprising answer to this question.\nTheo I have a question. If a record is nothing more than a map, how do you know\nthe type of the record?\nJoe That’s a great question with a surprising answer.\nTheo I’m curious.\nJoe Most of the time, there’s no need to know the record type.\nTheo What! What do you mean?\nJoe I mean that what matters most are the values of the fields. For example, take a\nlook at the Catalog.authorNames source code. It operates on a Book record,\nbut the only thing that matters is the value of the authorIds field.\nDoubtful, Theo looks at the source code for Catalog.authorNames. This is what Theo sees.\nListing3.25 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nTheo What about differentiating between various user types like Member versus\nLibrarian? I mean, they both have email and encryptedPassword. How do\nyou know if a record represents a Member or a Librarian?\nJoe Simple. You check to see if the record is found in the librariansByEmail\nindex or in the membersByEmail index of the Catalog.\nTheo Could you be more specific?\nJoe Sure! Let me write what the user management data of our tiny library might\nlook like, assuming we have one librarian and one member. To keep things\nsimple, I’m encrypting passwords through naive base-64 encoding for the User-\nManagement record.\nListing3.26 A UserManagement record\nvar userManagementData = {\n\"librariansByEmail\": {\n\"franck@gmail.com\" : { The base-64\nencoding of\n\"email\": \"franck@gmail.com\",\n\"mypassword\"\n\"encryptedPassword\": \"bXlwYXNzd29yZA==\"\n}\n},\n--- Page 94 ---\n66 CHAPTER 3 Basic data manipulation\n\"membersByEmail\": {\n\"samantha@gmail.com\": {\n\"email\": \"samantha@gmail.com\",\n\"encryptedPassword\": \"c2VjcmV0\",\nThe base-64\n\"isBlocked\": false,\nencoding of\n\"bookLendings\": [\n\"secret\"\n{\n\"bookItemId\": \"book-item-1\",\n\"bookIsbn\": \"978-1779501127\",\n\"lendingDate\": \"2020-04-23\"\n}\n]\n}\n}\n}\nTIP Most of the time, there’s no need to know the record type.\nTheo This morning, you told me you’d show me the code for UserManagement\n.isLibrarian function this afternoon.\nJoe So, here we are. It’s afternoon, and I’m going to fulfill my promise.\nJoe implements isLibrarian. With a slight pause, he then issues the test for isLibrarian.\nListing3.27 Checking if a user is a librarian\nfunction isLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nListing3.28 Testing isLibrarian\nisLibrarian(userManagementData, \"franck@gmail.com\");\n// → true\nTheo I’m assuming that _.has is a function that checks whether a key exists in a\nmap. Right?\nJoe Correct.\nTheo OK. You simply check whether the librariansByEmail map contains the\nemail field.\nJoe Yep.\nTheo Would you use the same pattern to check whether a member is a Super mem-\nber or a VIP member?\nJoe Sure. We could have SuperMembersByEmail and VIPMembersByEmail indexes.\nBut there’s a better way.\nTheo How?\nJoe When a member is a VIP member, we add a field, isVIP, with the value true to\nits record. To check if a member is a VIP member, we check whether the\nisVIP field is set to true in the member record. Here’s how I would code\nisVIPMember.\n--- Page 95 ---\n3.5 Handling records of different types 67\nListing3.29 Checking whether a member is a VIP member\nfunction isVIPMember(userManagement, email) {\nreturn _.get(userManagement, [\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nTheo I see that you access the isVIP field via its information path, [\"membersBy-\nEmail\", email, \"isVIP\"].\nJoe Yes, I think it makes the code crystal clear.\nTheo I agree. I guess we can do the same for isSuperMember and set an isSuper\nfield to true when a member is a Super member?\nJoe Yes, just like this.\nJoe assembles all the pieces in a UserManagement class. He then shows the code to Theo.\nListing3.30 The code of UserManagement module\nclass UserManagement {\nisLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nisVIPMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nisSuperMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isSuper\"]) == true;\n}\n}\nTheo looks at the UserManagement module code for a couple of seconds. Suddenly, an\nidea comes to his mind.\nTheo Why not have a type field in member record whose value would be either VIP\nor Super?\nJoe I assume that, according to the product requirements, a member can be both a\nVIP and a Super member.\nTheo Hmm...then the types field could be a collection containing VIP or Super\nor both.\nJoe In some situations, having a types field is helpful, but I find it simpler to have\na Boolean field for each feature that the record supports.\nTheo Is there a name for fields like isVIP and isSuper?\nJoe I call them feature fields.\nTIP Instead of maintaining type information about a record, use a feature field (e.g.,\nisVIP).\n--- Page 96 ---\n68 CHAPTER 3 Basic data manipulation\nTheo Can we use feature fields to differentiate between librarians and members?\nJoe You mean having an isLibrarian and an isMember field?\nTheo Yes, and having a common User record type for both librarians and members.\nJoe We can, but I think it’s simpler to have different record types for librarians and\nmembers: Librarian for librarians and Member for members.\nTheo Why?\nJoe Because there’s a clear distinction between librarians and members in terms of\ndata. For example, members can have book lendings but librarians don’t.\nTheo I agree. Now, we need to mention the two Member feature fields in our entity\ndiagram.\nWith that, Theo adds these fields to his diagram on the whiteboard. When he’s finished, he\nshows Joe his additions (figure 3.6).\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: Catalog\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian *\nCC Book id: String email: String CC Member\nname: String\ntitle : String encryptedPassword: String email: String\nbookIsbns: [String]\npublicationYear: Number encryptedPassword: String\nisbn: String * isBlocked: Boolean\nauthorIds: [String] bookLendings: [BookLending]\nbookItems: [BookItem] * isVIP: Boolean\nisSuper: Boolean\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.6 A library management data model with the Member feature fields isVIP and isSuper\nJoe Do you like the data model that we have designed together?\nTheo I find it quite simple and clear.\n--- Page 97 ---\nSummary 69\nJoe That’s the main goal of DOP.\nTheo Also, I’m pleasantly surprised how easy it is to adapt to changing requirements,\nboth in terms of code and the data model.\nJoe I suppose you’re also happy to get rid of complex class hierarchy diagrams.\nTheo Absolutely! Also, I think I’ve found an interesting connection between DOP\nand meditation.\nJoe Really?\nTheo When we were eating at Simple, you told me that meditation helped you expe-\nrience reality as it is without the filter of your thoughts.\nJoe Right.\nTheo From what you taught me today, I understand that in DOP, we are encouraged\nto treat data as data without the filter of our classes.\nJoe Clever! I never noticed that connection between those two disciplines that are\nso important for me. I guess you’d like to continue your journey in the realm\nof DOP.\nTheo Definitely. Let’s meet again tomorrow.\nJoe Unfortunately, tomorrow I’m taking my family to the beach to celebrate the\ntwelfth birthday of my eldest daughter, Aurelia.\nTheo Happy birthday, Aurelia!\nJoe We could meet again next Monday, if that’s OK with you.\nTheo With pleasure!\nSummary\n DOP principle #2 is to represent data entities with generic data structures.\n We refer to maps that have strings as keys as string maps.\n Representing data as data means representing records with string maps.\n By positional collection, we mean a collection where the elements are in order\n(like a list or an array).\n A positional collection of Strings is noted as [String].\n By index, we mean a collection where the elements are accessible via a key (like\na hash map or a dictionary).\n An index of Books is noted as {Book}.\n In the context of a data model, the index keys are always strings.\n A record is a data structure that groups together related data items. It’s a collec-\ntion of fields, possibly of different data types.\n A homogeneous map is a map where all the values are of the same type.\n A heterogeneous map is a map where the values are of different types.\n In DOP, we represent a record as a heterogeneous string map.\n A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes.\n The relation between records in a data entity diagram is either composition or\nassociation.\n--- Page 98 ---\n70 CHAPTER 3 Basic data manipulation\n The data part of a DOP system is flexible, and each piece of information is\naccessible via its information path.\n There is a tradeoff between flexibility and safety in a data model.\n DOP compromises on data safety to gain flexibility and genericity.\n In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\n We manipulate data with generic functions.\n Generic functions are provided either by the language itself or by third-party\nlibraries like Lodash.\n JSON serialization is implemented in terms of a generic function.\n On the one hand, we’ve lost the safety of accessing record fields via members\ndefined at compile time. On the other hand, we’ve liberated data from the lim-\nitation of classes and objects. Data is represented as data!\n The weak dependency between code and data makes it is easier to adapt to\nchanging requirements.\n When data is represented as data, it is straightforward to visualize system data.\n Usually, we do not need to maintain type information about a record.\n We can visualize any part of the system data.\n In statically-typed languages, we sometimes need to statically cast the field values.\n Instead of maintaining type information about a record, we use a feature field.\n There is no significant performance hit for accessing a field in a map instead of\na class member.\n In DOP, you can retrieve every piece of information via an information path and\na generic function.\n In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\nLodash functions introduced in this chapter\nFunction Description\nget(map, path) Gets the value of map at path\nhas(map, path) Checks if map has a field at path\nmerge(mapA, mapB) Creates a map resulting from the recursive merges between mapA and mapB\nvalues(map) Creates an array of values of map\nfilter(coll, pred) Iterates over elements of coll, returning an array of all elements for which\npred returns true\nmap(coll, f) Creates an array of values by running each element in coll through f\n--- Page 99 ---\nState management\nTime travel\nThis chapter covers\n A multi-version approach to state management\n The calculation phase of a mutation\n The commit phase of a mutation\n Keeping a history of previous state versions\nSo far, we have seen how DOP handles queries via generic functions that access sys-\ntem data, which is represented as a hash map. In this chapter, we illustrate how\nDOP deals with mutations (requests that change the system state). Instead of updat-\ning the state in place, we maintain multiple versions of the system data. At a specific\npoint in time, the system state refers to a specific version of the system data. This\nchapter is a deep dive in the third principle of DOP.\nPRINCIPLE #3 Data is immutable.\nThe maintenance of multiple versions of the system data requires the data to be\nimmutable. This is made efficient both in terms of computation and memory via a\n71\n--- Page 100 ---\n72 CHAPTER 4 State management\ntechnique called structural sharing, where parts of the data that are common between\ntwo versions are shared instead of being copied. In DOP, a mutation is split into two\ndistinct phases:\n In the calculation phase, we compute the next version of the system data.\n In the commit phase, we move the system state forward so that it refers to the\nversion of the system data computed by the calculation phase.\nThis distinction between calculation and commit phases allows us to reduce the part\nof our system that is stateful to its bare minimum. Only the code of the commit phase\nis stateful, while the code in the calculation phase of a mutation is stateless and is\nmade of generic functions similar to the code of a query. The implementation of the\ncommit phase is common to all mutations. As a consequence, inside the commit\nphase, we have the ability to ensure that the state always refers to a valid version of the\nsystem data.\nAnother benefit of this state management approach is that we can keep track of\nthe history of previous versions of the system data. Restoring the system to a previous\nstate (if needed) becomes straightforward. Table 4.1 shows the two phases.\nTable 4.1 The two phases of a mutation\nPhase Responsibility State Implementation\nCalculation Computes the next version of system data Stateless Specific\nCommit Moves the system state forward Stateful Common\nIn this chapter, we assume that no mutations occur concurrently in our system. In the\nnext chapter, we will deal with concurrency control.\n4.1 Multiple versions of the system data\nWhen Joe comes in to the office on Monday, he tells Theo that he needs to exercise before\nstarting to work with his mind. Theo and Joe go for a walk around the block, and the dis-\ncussion turns toward version control systems. They discuss how Git keeps track of the\nwhole commit history and how easy and fast it is to restore the code to a previous state.\nWhen Theo tells Joe that Git’s ability to “time travel” reminds him one of his favorite mov-\nies, Back to the Future, Joe shares that a month ago he watched the Back to the Future trilogy\nwith Neriah, his 14-year-old son.\nTheir walk complete, they arrive back at Theo’s office. Theo and Joe partake of the\nespresso machine in the kitchen before they begin today’s lesson.\nJoe So far, we’ve seen how we manage queries that retrieve information from the\nsystem in DOP. Now I’m going to show you how we manage mutations. By a\nmutation, I mean an operation that changes the state of the system.\n NOTE A mutation is an operation that changes the state of the system.\n--- Page 101 ---\n4.1 Multiple versions of the system data 73\nTheo Is there a fundamental difference between queries and mutations in DOP?\nAfter all, the whole state of the system is represented as a hash map. I could\neasily write code that modifies part of the hash map, and it would be similar to\nthe code that retrieves information from the hash map.\nJoe You could mutate the data in place, but then it would be challenging to ensure\nthat the code of a mutation doesn’t put the system into an invalid date. You\nwould also lose the ability to track previous versions of the system state.\nTheo I see. So, how do you handle mutations in DOP?\nJoe We adopt a multi-version state approach, similar to what a version control sys-\ntem like Git does; we manage different versions of the system data. At a specific\npoint in time, the state of the system refers to a version of the system data. After\na mutation is executed, we move the reference forward.\nTheo I’m confused. Is the system state mutable or immutable?\nJoe The data is immutable, but the state reference is mutable.\nTIP The data is immutable, but the state reference is mutable.\nNoticing the look of confusion on Theo’s face, Joe draws a quick diagram on the white-\nboard. He then shows Theo figure 4.1, hoping that it will clear up Theo’s perplexity.\nAfter mutation B After mutation C\nData V10 Data V10\nMutationA MutationA\nData V11 Data V11\nMutation B Mutation B\nSystem State Data V12 Data V12\nMutation C\nSystem State Data V13\nFigure 4.1 After mutation B is executed, the system state refers to Data V12. After\nmutation C is executed, the system state refers to Data V13.\nTheo Does that mean that before the code of a mutation runs, we make a copy of the\nsystem data?\nJoe No, that would be inefficient, as we would have to do a deep copy of the data.",
        "sections_found": []
      },
      "accurate_page_range": "76-101"
    },
    {
      "text": "- 3.1 Designing a data model",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "raw_line": "- 3.1 Designing a data model (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 23,
      "chapter_info": {
        "page": 76,
        "title": "Basic data manipulation",
        "pattern_matched": "Chapter 3",
        "text_preview": "48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to"
      },
      "chapter_sections": {
        "start_page": 76,
        "end_page": 101,
        "content": "\n--- Page 76 ---\n48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to say that a data entity diagram consists only of records, positional\ncollections, and indexes?\nJoe That’s correct. Can you make a similar statement about the relations between\nentities?\nTheo The relations in a data entity diagram are either composition (solid line with a\nfull diamond) or association (dashed line with an empty diamond). Both types\nof relations can be either one-to-one, one-to-many, or many-to-many.\nJoe Excellent!\nTIP A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes. The relation between records is either composition or\nassociation.\n3.2 Representing records as maps\nSo far, we’ve illustrated the benefits we gain from the separation between code and\ndata at a high-system level. There’s a separation of concerns between code and data,\nand each part has clear constraints:\n Code consists of static functions that receive data as an explicit argument.\n Data entities are modeled as records, and the relations between records are\nrepresented by positional collections and indexes.\nNow comes the question of the representation of the data. DOP has nothing special\ntosay about collections and indexes. However, it’s strongly opinionated about the\nrepresentation of records: records should be represented by generic data structures\nsuch as maps.\nThis applies to both OOP and FP languages. In dynamically-typed languages like\nJavaScript, Python, and Ruby, data representation feels natural. While in statically-\ntyped languages like Java and C#, it is a bit more cumbersome.\nTheo I’m really curious to know how we represent positional collections, indexes,\nand records in DOP.\nJoe Let’s start with positional collections. DOP has nothing special to say about the\nrepresentation of collections. They can be linked lists, arrays, vectors, sets, or\nother collections best suited for the use case.\nTheo It’s like in OOP.\nJoe Right! For now, to keep things simple, we’ll use arrays to represent positional\ncollections.\nTheo What about indexes?\nJoe Indexes are represented as homogeneous string maps.\nTheo What do you mean by a homogeneous map?\n--- Page 77 ---\n3.2 Representing records as maps 49\nJoe I mean that all the values of the map are of the same kind. For example, in a\nBook index, all the values are Book, and in an author index, all the values are\nAuthor, and so forth.\nTheo Again, it’s like in OOP.\n NOTE A homogeneous map is a map where all the values are of the same type. A hetero-\ngeneous map is a map where the values are of different types.\nJoe Now, here’s the big surprise. In DOP, records are represented as maps, more\nprecisely, heterogeneous string maps.\nJoe goes to the whiteboard and begins to draw. When he’s finished, he shows Theo the dia-\ngram in figure 3.4.\nRecord Heterogeneous map\nLinked list\nArray\nData representation Collection\nSet\nVector\nFigure 3.4 The building blocks\nIndex Homogeneous map\nof data representation\nTheo stays silent for a while. He is shocked to hear that the data entities of a system can be\nrepresented as a generic data structure, where the field names and value types are not\nspecified in a class. Then, Theo asks Joe:\nTheo What are the benefits of this folly?\nJoe Flexibility and genericity.\nTheo Could you explain, please?\nJoe I’ll explain in a moment, but before that, I’d like to show you what an instance\nof a record in a DOP system looks like.\nTheo OK.\nJoe Let’s take as an example, Watchmen, by Alan Moore and Dave Gibbons, which is\nmy favorite graphic novel. This masterpiece was published in 1987. I’m going\nto assume that, in a physical library, there are two copies of this book, whose ID\nis nyc-central-lib, and that one of the two copies is currently out. Here’s\nhow I’d represent the Book record for Watchmen in DOP.\nJoe comes closer to Theo’s laptop. He opens a text editor (not an IDE!) and types the Book\nrecord for Theo.\n--- Page 78 ---\n50 CHAPTER 3 Basic data manipulation\nListing3.1 An instance of a Book record represented as a map\n{\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\nTheo looks at the laptop screen. He has a question.\nTheo How am I supposed to instantiate the Book record for Watchmen programmat-\nically?\nJoe It depends on the facilities that your programming language offers to instantiate\nmaps. With dynamic languages like JavaScript, Ruby, or Python, it’s straight-\nforward, because we can use literals for maps and arrays. Here, let me show\nyou how.\nJoe jots down the JavaScript code that creates an instance of a Book record, which rep-\nresents as a map in JavaScript. He shows the code to Theo.\nListing3.2 A Book record represented as a map in JavaScript\nvar watchmenBook = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n--- Page 79 ---\n3.2 Representing records as maps 51\nTheo And, if I’m in Java?\nJoe It’s a bit more tedious, but still doable with the immutable Map and List static\nfactory methods.\n NOTE See “Creating Immutable Lists, Sets, and Maps” at http://mng.bz/voGm for\nmore information on this Java core library.\nJoe types the Java code to create an instance of a Book record represented as a map. He\nshows Theo the Java code.\nListing3.3 A Book record represented as a map in Java\nMap watchmen = Map.of(\n\"isbn\", \"978-1779501127\",\n\"title\", \"Watchmen\",\n\"publicationYear\", 1987,\n\"authors\", List.of(\"alan-moore\", \"dave-gibbons\"),\n\"bookItems\", List.of(\nMap.of(\n\"id\", \"book-item-1\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", true\n),\nMap.of (\n\"id\", \"book-item-2\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", false\n)\n)\n);\nTIP In DOP, we represent a record as a heterogeneous string map.\nTheo I’d definitely prefer to create a Book record using a Book class and a BookItem\nclass.\nTheo opens his IDE. He types the JavaScript code to represent a Book record as an instance\nof a Book class.\nListing3.4 A Book record as an instance of a Book class in JavaScript\nclass Book {\nisbn;\ntitle;\npublicationYear;\nauthors;\nbookItems;\nconstructor(isbn, title, publicationYear, authors, bookItems) {\nthis.isbn = isbn;\nthis.title = title;\nthis.publicationYear = publicationYear;\nthis.authors = authors;\nthis.bookItems = bookItems;\n--- Page 80 ---\n52 CHAPTER 3 Basic data manipulation\n}\n}\nclass BookItem {\nid;\nlibId;\nisLent;\nconstructor(id, libId, isLent) {\nthis.id = id;\nthis.libId = libId;\nthis.isLent = isLent;\n}\n}\nvar watchmenBook = new Book(\"978-1779501127\",\n\"Watchmen\",\n1987,\n[\"alan-moore\", \"dave-gibbons\"],\n[new BookItem(\"book-item-1\", \"nyc-central-lib\", true),\nnew BookItem(\"book-item-2\", \"nyc-central-lib\", false)]);\nJoe Theo, why do you prefer classes over maps for representing records?\nTheo It makes the data shape of the record part of my program. As a result, the IDE\ncan auto-complete field names, and errors are caught at compile time.\nJoe Fair enough. Can I show you some drawbacks for this approach?\nTheo Sure.\nJoe Imagine that you want to display the information about a book in the context\nof search results. In that case, instead of author IDs, you want to display\nauthor names, and you don’t need the book item information. How would\nyou handle that?\nTheo I’d create a class BookInSearchResults without a bookItems member and\nwith an authorNames member instead of the authorIds member of the Book\nclass. Also, I would need to write a copy constructor that receives a Book object.\nJoe In classic OOP, the fact that data is instantiated only via classes brings safety.\nBut this safety comes at the cost of flexibility.\nTIP There’s a tradeoff between flexibility and safety in a data model.\nTheo So, how can it be different?\nJoe In the DOP approach, where records are represented as maps, we don’t need\nto create a class for each variation of the data. We’re free to add, remove, and\nrename record fields dynamically. Our data model is flexible.\nTheo Interesting!\nTIP In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\nJoe Now, let me talk about genericity. How would you serialize the content of a\nBook object to JSON?\n--- Page 81 ---\n3.2 Representing records as maps 53\nTIP In DOP, records are manipulated with generic functions.\nTheo Oh no! I remember that while working on the Klafim prototype, I had a night-\nmare about JSON serialization when I was developing the first version of the\nLibrary Management System.\nJoe Well, in DOP, serializing a record to JSON is super easy.\nTheo Does it require the usage of reflection in order to go over the fields of the\nrecord like the Gson Java library does?\n NOTE See https://github.com/google/gson for more information on Gson.\nJoe Not at all! Remember that in DOP, a record is nothing more than data. We can\nwrite a generic JSON serialization function that works with any record. It can\nbe a Book, an Author, a BookItem, or anything else.\nTheo Amazing!\nTIP In DOP, you get JSON serialization for free.\nJoe Actually, as I’ll show you in a moment, lots of data manipulation stuff can be\ndone using generic functions.\nTheo Are the generic functions part of the language?\nJoe It depends on the functions and on the language. For example, JavaScript pro-\nvides a JSON serialization function called JSON.stringify out of the box, but\nnone for omitting multiple keys or for renaming keys.\nTheo That’s annoying.\nJoe Not so much; there are third-party libraries that provide data-manipulation facil-\nities. A popular data manipulation library in the JavaScript ecosystem is Lodash.\n NOTE See https://lodash.com/ to find out more about Lodash.\nTheo What about other languages?\nJoe Lodash has been ported to Java, C#, Python, and Ruby. Let me bookmark some\nsites for you.\nJoe bookmarks these sites for Theo:\n https://javalibs.com/artifact/com.github.javadev/underscore-lodash for Java\n https://www.nuget.org/packages/lodash/ for C#\n https://github.com/dgilland/pydash for Python\n https://rudash-website.now.sh/ for Ruby\n NOTE Throughout the book, we use Lodash to show how to manipulate data with\ngeneric functions, but there is nothing special about Lodash. The exact same approach\ncould be implemented via other data manipulation libraries or custom code.\nTheo Cool!\nJoe Actually, Lodash and its rich set of data manipulation functions can be ported\nto any language. That’s why it’s so beneficial to represent records as maps.\n--- Page 82 ---\n54 CHAPTER 3 Basic data manipulation\nTIP DOP compromises on data safety to gain flexibility and genericity.\nAt the whiteboard, Joe quickly sketches the tradeoffs (see table 3.1).\nTable 3.1 The tradeoff among safety, flexibility, and genericity\nOOP DOP\nSafety High Low\nFlexibility Low High\nGenericity Low High\n3.3 Manipulating data with generic functions\nJoe Now let me show you how to manipulate data in DOP with generic functions.\nTheo Yes, I’m quite curious to see how you’ll implement the search functionality of\nthe Library Management System.\nJoe OK. First, let’s instantiate a Catalog record for the catalog data of a library,\nwhere we have a single book, Watchmen.\nJoe instantiates a Catalog record according to Theo’s data model in figure 3.3. Here’s\nwhat Joe shows to Theo.\nListing3.5 A Catalog record\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n--- Page 83 ---\n3.3 Manipulating data with generic functions 55\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\nTheo I see the two indexes we talked about, booksByIsbn and authorsById. How\ndo you differentiate a record from an index in DOP?\nJoe In an entity diagram, there’s a clear distinction between records and indexes.\nBut in our code, both are plain data.\nTheo I guess that’s why this approach is called data-oriented programming.\nJoe See how straightforward it is to visualize any part of the system data inside a\nprogram? The reason is that data is represented as data!\nTIP In DOP, data is represented as data.\nTheo That sounds like a lapalissade.1\nJoe Oh, does it? I’m not so sure! In OOP, data is usually represented by objects,\nwhich makes it more challenging to visualize data inside a program.\nTIP In DOP, we can visualize any part of the system data.\nTheo How would you retrieve the title of a specific book from the catalog data?\nJoe Great question! In fact, in a DOP system, every piece of information has an\ninformation path from which we can retrieve the information.\nTheo Information path?\nJoe For example, the information path to the title of the Watchmen book in the\ncatalog is [\"booksByIsbn\", \"978-1779501127\", \"title\"].\nTheo Ah, I see. So, is an information path sort of like a file path, but that names in\nan information path correspond to nested entities?\nJoe You’re exactly right. And once we have the path of a piece of information, we\ncan retrieve the information with Lodash’s _.get function.\nJoe types a few characters on Theo’s laptop. Theo is amazed at how little code is needed to\nget the book title.\nListing3.6 Retrieving the title of a book from its information path\n_.get(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"])\n// → \"Watchmen\"\nTheo Neat. I wonder how hard it would be to implement a function like _.get\nmyself.\n1 A lapalissade is an obvious truth—a truism or tautology—that produces a comical effect.\n--- Page 84 ---\n56 CHAPTER 3 Basic data manipulation\nAfter a few minutes of trial and error, Theo is able to produce his implementation. He\nshows Joe the code.\nListing3.7 Custom implementation of get\nfunction get(m, path) {\nvar res = m;\nfor(var i = 0; i < path.length; i++) {\nWe could use\nvar key = path[i];\nforEach instead\nres = res[key];\nof a for loop.\n}\nreturn res;\n}\nAfter testing Theo’s implementation of get, Joe compliments Theo. He’s grateful that\nTheo is catching on so quickly.\nListing3.8 Testing the custom implementation of get\nget(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"]);\n// → \"Watchmen\"\nJoe Well done!\nTheo I wonder if a function like _.get works smoothly in a statically-typed language\nlike Java?\nJoe It depends on whether you only need to pass the value around or to access the\nvalue concretely.\nTheo I don’t follow.\nJoe Imagine that once you get the title of a book, you want to convert the string\ninto an uppercase string. You need to do a static cast to String, right? Here,\nlet me show you an example that casts a field value to a string, then we can\nmanipulate it as a string.\nListing3.9 Casting a field value to a string\n((String)watchmen.get(\"title\")).toUpperCase()\nTheo That makes sense. The values of the map are of different types, so the compiler\ndeclares it as a Map<String,Object>. The information of the type of the field\nis lost.\nJoe It’s a bit annoying, but quite often our code just passes the data around. In that\ncase, we don’t have to deal with static casting. Moreover, in a language like C#,\nwhen using the dynamic data type, type casting can be avoided.2,3\n2 See http://mng.bz/4jo5 for the C# documentation on the built-in reference to dynamic types.\n3 See appendix A for details about dynamic fields and type casting in C#.\n--- Page 85 ---\n3.3 Manipulating data with generic functions 57\nTIP In statically-typed languages, we sometimes need to statically cast the field values.\nTheo What about performance?\nJoe In most programming languages, maps are quite efficient. Accessing a field\nin a map is slightly slower than accessing a class member. Usually, it’s not\nsignificant.\nTIP There’s no significant performance hit for accessing a field in a map instead of as\na class member.\nTheo Let’s get back to this idea of information path. It works in OOP too. I could\naccess the title of the Watchmen book with catalogData.booksByIsbn[\"978-\n1779501127\"].title. I’d use class members for record fields and strings for\nindex keys.\nJoe There’s a fundamental difference, though. When records are represented as\nmaps, the information can be retrieved via its information path using a generic\nfunction like _.get. But when records are represented as objects, you need to\nwrite specific code for each type of information path.\nTheo What do you mean by specific code? What’s specific in catalogData.books-\nByIsbn[\"978-1779501127\"].title?\nJoe In a statically-typed language like Java, you’d need to import the class defini-\ntions for Catalog and Book.\nTheo And, in a dynamically-typed language like JavaScript...?\nJoe Even in JavaScript, when you represent records with objects instantiated from\nclasses, you can’t easily write a function that receives a path as an argument\nand display the information that corresponds to this path. You would have to\nwrite specific code for each kind of path. You’d access class members with dot\nnotation and map fields with bracket notation.\nTheo Would you say that in DOP, the information path is a first-class citizen?\nJoe Absolutely! The information path can be stored in a variable and passed as an\nargument to a function.\nTIP In DOP, you can retrieve every piece of information via a path and a generic\nfunction.\nJoe goes to the whiteboard. He draws a diagram like that in figure 3.5, which shows the\ncatalog data as a tree.\nJoe You see, Theo, each piece of information is accessible via a path made of\nstrings and integers. For example, the path of Alan Moore’s first book is\n[\"catalog\", \"authorsById\", \"alan-moore\", \"bookIsbns\", 0].\n--- Page 86 ---\n58 CHAPTER 3 Basic data manipulation\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 3.5 The catalog data as a tree\n3.4 Calculating search results\nTheo Interesting. I’m starting to feel the power of expression of DOP!\nJoe Wait, that’s just the beginning. Let me show you how simple it is to write code\nthat retrieves book information and displays it in search results. Can you tell\nme exactly what information has to appear in the search results?\nTheo Searching for book information should return isbn, title, and author-\nNames.\nJoe And what would a BookInfo record look like for Watchmen?\nTheo quickly enters the code on his laptop. He then shows it to Joe.\nListing3.10 A BookInfo record for Watchmen in the context of search result\n{\n\"title\": \"Watchmen\",\n\"isbn\": \"978-1779501127\",\n\"authorNames\": [\n\"Alan Moore\",\n\"Dave Gibbons\",\n]\n}\n--- Page 87 ---\n3.4 Calculating search results 59\nJoe Now I’ll show you step by step how to write a function that returns search\nresults matching a title in JSON format. I’ll use generic data manipulation\nfunctions from Lodash.\nTheo I’m ready!\nJoe Let’s start with an authorNames function that calculates the author names of a\nBook record by looking at the authorsById index. Could you tell me what’s\nthe information path for the name of an author whose ID is authorId?\nTheo It’s [\"authorsById\", authorId, \"name\"].\nJoe Now, let me show you how to retrieve the name of several authors using _.map.\nJoe types the code to map the author IDs to the author names. Theo nonchalantly peeks\nover Joe’s shoulder.\nListing3.11 Mapping author IDs to author names\n_.map([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\nTheo What’s this _.map function? It smells like functional programming! You said I\nwouldn’t have to learn FP to implement DOP!\nJoe No need to learn functional programming in order to use _.map, which is a\nfunction that transforms the values of a collection. You can implement it with\na simple for loop.\nTheo spends a couple of minutes in front of his computer figuring out how to implement\n_.map. Now he’s got it!\nListing3.12 Custom implementation of map\nfunction map(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nres[i] = f(coll[i]);\nforEach instead\n}\nof a for loop.\nreturn res;\n}\nAfter testing Theo’s implementation of map, Joe shows Theo the test. Joe again compli-\nments Theo.\nListing3.13 Testing the custom implementation of map\nmap([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\n--- Page 88 ---\n60 CHAPTER 3 Basic data manipulation\nJoe Well done!\nTheo You were right! It wasn’t hard.\nJoe Now, let’s implement authorNames using _.map.\nIt takes a few minutes for Theo to come up with the implementation of authorNames.\nWhen he’s finished, he turns his laptop to Joe.\nListing3.14 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nJoe We also need a bookInfo function that converts a Book record into a Book-\nInfo record. Let me show you the code for that.\nListing3.15 Converting a Book record into a BookInfo record\nfunction bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": authorNames(catalogData, book)\n};\nThere’s no need to create\nreturn bookInfo;\na class for bookInfo.\n}\nTheo Looking at the code, I see that a BookInfo record has three fields: title,\nisbn, and authorNames. Is there a way to get this information without looking\nat the code?\nJoe You can either add it to the data entity diagram or write it in the documenta-\ntion of the bookInfo function, or both.\nTheo I have to get used to the idea that in DOP, the record field information is not\npart of the program.\nJoe Indeed, it’s not part of the program, but it gives us a lot of flexibility.\nTheo Is there any way for me to have my cake and eat it too?\nJoe Yes, and someday I’ll show you how to make record field information part of a\nDOP program (see chapters 7 and 12).\nTheo Sounds intriguing!\nJoe Now that we have all the pieces in place, we can write our searchBooksBy-\nTitle function, which returns the book information about the books that\nmatch the query. First, we find the Book records that match the query with\n_.filter and then we transform each Book record into a BookInfo record\nwith _.map and bookInfo.\n--- Page 89 ---\n3.4 Calculating search results 61\nListing3.16 Searching books that match a query\nfunction searchBooksByTitle(catalogData, query) {\nvar allBooks = _.values(_.get(catalogData, \"booksByIsbn\"));\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\nThe includes JavaScript\n});\nfunction checks whether\na string includes a string\nvar bookInfos = _.map(matchingBooks, function(book) { as a substring.\nreturn bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\nTheo You’re using Lodash functions without any explanation again!\nJoe Sorry about that. I am so used to basic data manipulation functions that I con-\nsider them as part of the language. What functions are new to you?\nTheo _.values and _.filter\nJoe Well, _.values returns a collection made of the values of a map, and _.filter\nreturns a collection made of the values that satisfy a predicate.\nTheo _.values seems trivial. Let me try to implement _.filter.\nThe implementation of _.filter takes a bit more time. Eventually, Theo manages to get\nit right, then he is able to test it.\nListing3.17 Custom implementation of filter\nfunction filter(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nif(f(coll[i])) {\nforEach instead\nres.push(coll[i]);\nof a for loop.\n}\n}\nreturn res;\n}\nListing3.18 Testing the custom implementation of filter\nfilter([\"Watchmen\", \"Batman\"], function (title) {\nreturn title.includes(\"Watch\");\n});\n// → [\"Watchmen\"]\nTheo To me, it’s a bit weird that to access the title of a book record, I need to write\n_.get(book, \"title\"). I’d expect it to be book.title in dot notation or\nbook[\"title\"] in bracket notation.\nJoe Remember that book is a record that’s not represented as an object. It’s a map.\nIndeed, in JavaScript, you can write _.get(book, \"title\"), book.title, or\nbook[\"title\"]. But I prefer to use Lodash’s _.get function. In some lan-\nguages, the dot and the bracket notations might not work on maps.\n--- Page 90 ---\n62 CHAPTER 3 Basic data manipulation\nTheo Being language-agnostic has a price!\nJoe Right, would you like to test searchBooksByTitle?\nTheo Absolutely! Let me call searchBooksByTitle to search the books whose title\ncontain the string Watch.\nListing3.19 Testing searchBooksByTitle\nsearchBooksByTitle(catalogData, \"Wat\");\n//[\n// {\n// \"authorNames\": [\n// \"Alan Moore\",\n// \"Dave Gibbons\"\n// ],\n// \"isbn\": \"978-1779501127\",\n// \"title\": \"Watchmen\"\n// }\n//]\nTheo It seems to work! Are we done with the search implementation?\nJoe Almost. The searchBooksByTitle function we wrote is going to be part of the\nCatalog module, and it returns a collection of records. We have to write a\nfunction that’s part of the Library module, and that returns a JSON string.\nTheo You told me earlier that JSON serialization was straightforward in DOP.\nJoe Correct. The code for searchBooksByTitleJSON retrieves the Catalog record,\npasses it to searchBooksByTitle, and converts the results to JSON with\nJSON.stringify. That’s part of JavaScript. Here, let me show you.\nListing3.20 Implementation of searching books in a library as JSON\nfunction searchBooksByTitleJSON(libraryData, query) {\nvar results = searchBooksByTitle(_.get(libraryData, \"catalog\"), query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\nJoe In order to test our code, we need to create a Library record that contains our\nCatalog record. Could you do that for me, please?\nTheo Should the Library record contain all the Library fields (name, address,\nand UserManagement)?\nJoe That’s not necessary. For now, we only need the catalog field, then the test\nfor searching books.\nListing3.21 A Library record\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n--- Page 91 ---\n3.4 Calculating search results 63\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nListing3.22 Test for searching books in a library as JSON\nsearchBooksByTitleJSON(libraryData, \"Wat\");\nTheo How are we going to combine the four functions that we’ve written so far?\nJoe The functions authorNames, bookInfo, and searchBooksByTitle go into\nthe Catalog module, and searchBooksByTitleJSON goes into the Library\nmodule.\nTheo looks at the resulting code of the two modules, Library and Catalog. He’s quite\namazed by its conciseness.\nListing3.23 Calculating search results for Library and Catalog\nclass Catalog {\nstatic authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\n--- Page 92 ---\n64 CHAPTER 3 Basic data manipulation\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nThere’s no need\nreturn bookInfo;\nto create a class\n}\nfor bookInfo.\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nWhen _.filter is\nvar matchingBooks = _.filter(allBooks,\npassed a map, it\nfunction(book) {\ngoes over the values\nreturn _.get(book, \"title\").includes(query);\nof the map.\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nConverts data\nreturn resultsJSON;\nto JSON (part\n}\nof JavaScript)\n}\nAfter testing the final code in listing 3.24, Theo looks again at the source code from list-\ning 3.23. After a few seconds, he feels like he’s having another Aha! moment.\nListing3.24 Search results in JSON\nLibrary.searchBooksByTitleJSON(libraryData, \"Watchmen\");\n// → \"[{\\\"title\\\":\\\"Watchmen\\\",\\\"isbn\\\":\\\"978-1779501127\\\",\n// → \\\"authorNames\\\":[\\\"Alan Moore\\\",\\\"Dave Gibbons\\\"]}]\"\nTheo The important thing is not that the code is concise, but that the code contains\nno abstractions. It’s just data manipulation!\nJoe responds with a smile that says, “You got it, my friend!”\nJoe It reminds me of what my first meditation teacher told me 10 years ago:\nmeditation guides the mind to grasp the reality as it is without the abstractions\ncreated by our thoughts.\nTIP In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\n--- Page 93 ---\n3.5 Handling records of different types 65\n3.5 Handling records of different types\nWe’ve seen how DOP enables us to treat records as first-class citizens that can be\nmanipulated in a flexible way using generic functions. But if a record is nothing more\nthan an aggregation of fields, how do we know what the type of the record is? DOP has\na surprising answer to this question.\nTheo I have a question. If a record is nothing more than a map, how do you know\nthe type of the record?\nJoe That’s a great question with a surprising answer.\nTheo I’m curious.\nJoe Most of the time, there’s no need to know the record type.\nTheo What! What do you mean?\nJoe I mean that what matters most are the values of the fields. For example, take a\nlook at the Catalog.authorNames source code. It operates on a Book record,\nbut the only thing that matters is the value of the authorIds field.\nDoubtful, Theo looks at the source code for Catalog.authorNames. This is what Theo sees.\nListing3.25 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nTheo What about differentiating between various user types like Member versus\nLibrarian? I mean, they both have email and encryptedPassword. How do\nyou know if a record represents a Member or a Librarian?\nJoe Simple. You check to see if the record is found in the librariansByEmail\nindex or in the membersByEmail index of the Catalog.\nTheo Could you be more specific?\nJoe Sure! Let me write what the user management data of our tiny library might\nlook like, assuming we have one librarian and one member. To keep things\nsimple, I’m encrypting passwords through naive base-64 encoding for the User-\nManagement record.\nListing3.26 A UserManagement record\nvar userManagementData = {\n\"librariansByEmail\": {\n\"franck@gmail.com\" : { The base-64\nencoding of\n\"email\": \"franck@gmail.com\",\n\"mypassword\"\n\"encryptedPassword\": \"bXlwYXNzd29yZA==\"\n}\n},\n--- Page 94 ---\n66 CHAPTER 3 Basic data manipulation\n\"membersByEmail\": {\n\"samantha@gmail.com\": {\n\"email\": \"samantha@gmail.com\",\n\"encryptedPassword\": \"c2VjcmV0\",\nThe base-64\n\"isBlocked\": false,\nencoding of\n\"bookLendings\": [\n\"secret\"\n{\n\"bookItemId\": \"book-item-1\",\n\"bookIsbn\": \"978-1779501127\",\n\"lendingDate\": \"2020-04-23\"\n}\n]\n}\n}\n}\nTIP Most of the time, there’s no need to know the record type.\nTheo This morning, you told me you’d show me the code for UserManagement\n.isLibrarian function this afternoon.\nJoe So, here we are. It’s afternoon, and I’m going to fulfill my promise.\nJoe implements isLibrarian. With a slight pause, he then issues the test for isLibrarian.\nListing3.27 Checking if a user is a librarian\nfunction isLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nListing3.28 Testing isLibrarian\nisLibrarian(userManagementData, \"franck@gmail.com\");\n// → true\nTheo I’m assuming that _.has is a function that checks whether a key exists in a\nmap. Right?\nJoe Correct.\nTheo OK. You simply check whether the librariansByEmail map contains the\nemail field.\nJoe Yep.\nTheo Would you use the same pattern to check whether a member is a Super mem-\nber or a VIP member?\nJoe Sure. We could have SuperMembersByEmail and VIPMembersByEmail indexes.\nBut there’s a better way.\nTheo How?\nJoe When a member is a VIP member, we add a field, isVIP, with the value true to\nits record. To check if a member is a VIP member, we check whether the\nisVIP field is set to true in the member record. Here’s how I would code\nisVIPMember.\n--- Page 95 ---\n3.5 Handling records of different types 67\nListing3.29 Checking whether a member is a VIP member\nfunction isVIPMember(userManagement, email) {\nreturn _.get(userManagement, [\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nTheo I see that you access the isVIP field via its information path, [\"membersBy-\nEmail\", email, \"isVIP\"].\nJoe Yes, I think it makes the code crystal clear.\nTheo I agree. I guess we can do the same for isSuperMember and set an isSuper\nfield to true when a member is a Super member?\nJoe Yes, just like this.\nJoe assembles all the pieces in a UserManagement class. He then shows the code to Theo.\nListing3.30 The code of UserManagement module\nclass UserManagement {\nisLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nisVIPMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nisSuperMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isSuper\"]) == true;\n}\n}\nTheo looks at the UserManagement module code for a couple of seconds. Suddenly, an\nidea comes to his mind.\nTheo Why not have a type field in member record whose value would be either VIP\nor Super?\nJoe I assume that, according to the product requirements, a member can be both a\nVIP and a Super member.\nTheo Hmm...then the types field could be a collection containing VIP or Super\nor both.\nJoe In some situations, having a types field is helpful, but I find it simpler to have\na Boolean field for each feature that the record supports.\nTheo Is there a name for fields like isVIP and isSuper?\nJoe I call them feature fields.\nTIP Instead of maintaining type information about a record, use a feature field (e.g.,\nisVIP).\n--- Page 96 ---\n68 CHAPTER 3 Basic data manipulation\nTheo Can we use feature fields to differentiate between librarians and members?\nJoe You mean having an isLibrarian and an isMember field?\nTheo Yes, and having a common User record type for both librarians and members.\nJoe We can, but I think it’s simpler to have different record types for librarians and\nmembers: Librarian for librarians and Member for members.\nTheo Why?\nJoe Because there’s a clear distinction between librarians and members in terms of\ndata. For example, members can have book lendings but librarians don’t.\nTheo I agree. Now, we need to mention the two Member feature fields in our entity\ndiagram.\nWith that, Theo adds these fields to his diagram on the whiteboard. When he’s finished, he\nshows Joe his additions (figure 3.6).\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: Catalog\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian *\nCC Book id: String email: String CC Member\nname: String\ntitle : String encryptedPassword: String email: String\nbookIsbns: [String]\npublicationYear: Number encryptedPassword: String\nisbn: String * isBlocked: Boolean\nauthorIds: [String] bookLendings: [BookLending]\nbookItems: [BookItem] * isVIP: Boolean\nisSuper: Boolean\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.6 A library management data model with the Member feature fields isVIP and isSuper\nJoe Do you like the data model that we have designed together?\nTheo I find it quite simple and clear.\n--- Page 97 ---\nSummary 69\nJoe That’s the main goal of DOP.\nTheo Also, I’m pleasantly surprised how easy it is to adapt to changing requirements,\nboth in terms of code and the data model.\nJoe I suppose you’re also happy to get rid of complex class hierarchy diagrams.\nTheo Absolutely! Also, I think I’ve found an interesting connection between DOP\nand meditation.\nJoe Really?\nTheo When we were eating at Simple, you told me that meditation helped you expe-\nrience reality as it is without the filter of your thoughts.\nJoe Right.\nTheo From what you taught me today, I understand that in DOP, we are encouraged\nto treat data as data without the filter of our classes.\nJoe Clever! I never noticed that connection between those two disciplines that are\nso important for me. I guess you’d like to continue your journey in the realm\nof DOP.\nTheo Definitely. Let’s meet again tomorrow.\nJoe Unfortunately, tomorrow I’m taking my family to the beach to celebrate the\ntwelfth birthday of my eldest daughter, Aurelia.\nTheo Happy birthday, Aurelia!\nJoe We could meet again next Monday, if that’s OK with you.\nTheo With pleasure!\nSummary\n DOP principle #2 is to represent data entities with generic data structures.\n We refer to maps that have strings as keys as string maps.\n Representing data as data means representing records with string maps.\n By positional collection, we mean a collection where the elements are in order\n(like a list or an array).\n A positional collection of Strings is noted as [String].\n By index, we mean a collection where the elements are accessible via a key (like\na hash map or a dictionary).\n An index of Books is noted as {Book}.\n In the context of a data model, the index keys are always strings.\n A record is a data structure that groups together related data items. It’s a collec-\ntion of fields, possibly of different data types.\n A homogeneous map is a map where all the values are of the same type.\n A heterogeneous map is a map where the values are of different types.\n In DOP, we represent a record as a heterogeneous string map.\n A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes.\n The relation between records in a data entity diagram is either composition or\nassociation.\n--- Page 98 ---\n70 CHAPTER 3 Basic data manipulation\n The data part of a DOP system is flexible, and each piece of information is\naccessible via its information path.\n There is a tradeoff between flexibility and safety in a data model.\n DOP compromises on data safety to gain flexibility and genericity.\n In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\n We manipulate data with generic functions.\n Generic functions are provided either by the language itself or by third-party\nlibraries like Lodash.\n JSON serialization is implemented in terms of a generic function.\n On the one hand, we’ve lost the safety of accessing record fields via members\ndefined at compile time. On the other hand, we’ve liberated data from the lim-\nitation of classes and objects. Data is represented as data!\n The weak dependency between code and data makes it is easier to adapt to\nchanging requirements.\n When data is represented as data, it is straightforward to visualize system data.\n Usually, we do not need to maintain type information about a record.\n We can visualize any part of the system data.\n In statically-typed languages, we sometimes need to statically cast the field values.\n Instead of maintaining type information about a record, we use a feature field.\n There is no significant performance hit for accessing a field in a map instead of\na class member.\n In DOP, you can retrieve every piece of information via an information path and\na generic function.\n In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\nLodash functions introduced in this chapter\nFunction Description\nget(map, path) Gets the value of map at path\nhas(map, path) Checks if map has a field at path\nmerge(mapA, mapB) Creates a map resulting from the recursive merges between mapA and mapB\nvalues(map) Creates an array of values of map\nfilter(coll, pred) Iterates over elements of coll, returning an array of all elements for which\npred returns true\nmap(coll, f) Creates an array of values by running each element in coll through f\n--- Page 99 ---\nState management\nTime travel\nThis chapter covers\n A multi-version approach to state management\n The calculation phase of a mutation\n The commit phase of a mutation\n Keeping a history of previous state versions\nSo far, we have seen how DOP handles queries via generic functions that access sys-\ntem data, which is represented as a hash map. In this chapter, we illustrate how\nDOP deals with mutations (requests that change the system state). Instead of updat-\ning the state in place, we maintain multiple versions of the system data. At a specific\npoint in time, the system state refers to a specific version of the system data. This\nchapter is a deep dive in the third principle of DOP.\nPRINCIPLE #3 Data is immutable.\nThe maintenance of multiple versions of the system data requires the data to be\nimmutable. This is made efficient both in terms of computation and memory via a\n71\n--- Page 100 ---\n72 CHAPTER 4 State management\ntechnique called structural sharing, where parts of the data that are common between\ntwo versions are shared instead of being copied. In DOP, a mutation is split into two\ndistinct phases:\n In the calculation phase, we compute the next version of the system data.\n In the commit phase, we move the system state forward so that it refers to the\nversion of the system data computed by the calculation phase.\nThis distinction between calculation and commit phases allows us to reduce the part\nof our system that is stateful to its bare minimum. Only the code of the commit phase\nis stateful, while the code in the calculation phase of a mutation is stateless and is\nmade of generic functions similar to the code of a query. The implementation of the\ncommit phase is common to all mutations. As a consequence, inside the commit\nphase, we have the ability to ensure that the state always refers to a valid version of the\nsystem data.\nAnother benefit of this state management approach is that we can keep track of\nthe history of previous versions of the system data. Restoring the system to a previous\nstate (if needed) becomes straightforward. Table 4.1 shows the two phases.\nTable 4.1 The two phases of a mutation\nPhase Responsibility State Implementation\nCalculation Computes the next version of system data Stateless Specific\nCommit Moves the system state forward Stateful Common\nIn this chapter, we assume that no mutations occur concurrently in our system. In the\nnext chapter, we will deal with concurrency control.\n4.1 Multiple versions of the system data\nWhen Joe comes in to the office on Monday, he tells Theo that he needs to exercise before\nstarting to work with his mind. Theo and Joe go for a walk around the block, and the dis-\ncussion turns toward version control systems. They discuss how Git keeps track of the\nwhole commit history and how easy and fast it is to restore the code to a previous state.\nWhen Theo tells Joe that Git’s ability to “time travel” reminds him one of his favorite mov-\nies, Back to the Future, Joe shares that a month ago he watched the Back to the Future trilogy\nwith Neriah, his 14-year-old son.\nTheir walk complete, they arrive back at Theo’s office. Theo and Joe partake of the\nespresso machine in the kitchen before they begin today’s lesson.\nJoe So far, we’ve seen how we manage queries that retrieve information from the\nsystem in DOP. Now I’m going to show you how we manage mutations. By a\nmutation, I mean an operation that changes the state of the system.\n NOTE A mutation is an operation that changes the state of the system.\n--- Page 101 ---\n4.1 Multiple versions of the system data 73\nTheo Is there a fundamental difference between queries and mutations in DOP?\nAfter all, the whole state of the system is represented as a hash map. I could\neasily write code that modifies part of the hash map, and it would be similar to\nthe code that retrieves information from the hash map.\nJoe You could mutate the data in place, but then it would be challenging to ensure\nthat the code of a mutation doesn’t put the system into an invalid date. You\nwould also lose the ability to track previous versions of the system state.\nTheo I see. So, how do you handle mutations in DOP?\nJoe We adopt a multi-version state approach, similar to what a version control sys-\ntem like Git does; we manage different versions of the system data. At a specific\npoint in time, the state of the system refers to a version of the system data. After\na mutation is executed, we move the reference forward.\nTheo I’m confused. Is the system state mutable or immutable?\nJoe The data is immutable, but the state reference is mutable.\nTIP The data is immutable, but the state reference is mutable.\nNoticing the look of confusion on Theo’s face, Joe draws a quick diagram on the white-\nboard. He then shows Theo figure 4.1, hoping that it will clear up Theo’s perplexity.\nAfter mutation B After mutation C\nData V10 Data V10\nMutationA MutationA\nData V11 Data V11\nMutation B Mutation B\nSystem State Data V12 Data V12\nMutation C\nSystem State Data V13\nFigure 4.1 After mutation B is executed, the system state refers to Data V12. After\nmutation C is executed, the system state refers to Data V13.\nTheo Does that mean that before the code of a mutation runs, we make a copy of the\nsystem data?\nJoe No, that would be inefficient, as we would have to do a deep copy of the data.",
        "sections_found": []
      },
      "accurate_page_range": "76-101"
    },
    {
      "text": "- 3.2 Representing records as maps",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "raw_line": "- 3.2 Representing records as maps (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 24,
      "chapter_info": {
        "page": 76,
        "title": "Basic data manipulation",
        "pattern_matched": "Chapter 3",
        "text_preview": "48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to"
      },
      "chapter_sections": {
        "start_page": 76,
        "end_page": 101,
        "content": "\n--- Page 76 ---\n48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to say that a data entity diagram consists only of records, positional\ncollections, and indexes?\nJoe That’s correct. Can you make a similar statement about the relations between\nentities?\nTheo The relations in a data entity diagram are either composition (solid line with a\nfull diamond) or association (dashed line with an empty diamond). Both types\nof relations can be either one-to-one, one-to-many, or many-to-many.\nJoe Excellent!\nTIP A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes. The relation between records is either composition or\nassociation.\n3.2 Representing records as maps\nSo far, we’ve illustrated the benefits we gain from the separation between code and\ndata at a high-system level. There’s a separation of concerns between code and data,\nand each part has clear constraints:\n Code consists of static functions that receive data as an explicit argument.\n Data entities are modeled as records, and the relations between records are\nrepresented by positional collections and indexes.\nNow comes the question of the representation of the data. DOP has nothing special\ntosay about collections and indexes. However, it’s strongly opinionated about the\nrepresentation of records: records should be represented by generic data structures\nsuch as maps.\nThis applies to both OOP and FP languages. In dynamically-typed languages like\nJavaScript, Python, and Ruby, data representation feels natural. While in statically-\ntyped languages like Java and C#, it is a bit more cumbersome.\nTheo I’m really curious to know how we represent positional collections, indexes,\nand records in DOP.\nJoe Let’s start with positional collections. DOP has nothing special to say about the\nrepresentation of collections. They can be linked lists, arrays, vectors, sets, or\nother collections best suited for the use case.\nTheo It’s like in OOP.\nJoe Right! For now, to keep things simple, we’ll use arrays to represent positional\ncollections.\nTheo What about indexes?\nJoe Indexes are represented as homogeneous string maps.\nTheo What do you mean by a homogeneous map?\n--- Page 77 ---\n3.2 Representing records as maps 49\nJoe I mean that all the values of the map are of the same kind. For example, in a\nBook index, all the values are Book, and in an author index, all the values are\nAuthor, and so forth.\nTheo Again, it’s like in OOP.\n NOTE A homogeneous map is a map where all the values are of the same type. A hetero-\ngeneous map is a map where the values are of different types.\nJoe Now, here’s the big surprise. In DOP, records are represented as maps, more\nprecisely, heterogeneous string maps.\nJoe goes to the whiteboard and begins to draw. When he’s finished, he shows Theo the dia-\ngram in figure 3.4.\nRecord Heterogeneous map\nLinked list\nArray\nData representation Collection\nSet\nVector\nFigure 3.4 The building blocks\nIndex Homogeneous map\nof data representation\nTheo stays silent for a while. He is shocked to hear that the data entities of a system can be\nrepresented as a generic data structure, where the field names and value types are not\nspecified in a class. Then, Theo asks Joe:\nTheo What are the benefits of this folly?\nJoe Flexibility and genericity.\nTheo Could you explain, please?\nJoe I’ll explain in a moment, but before that, I’d like to show you what an instance\nof a record in a DOP system looks like.\nTheo OK.\nJoe Let’s take as an example, Watchmen, by Alan Moore and Dave Gibbons, which is\nmy favorite graphic novel. This masterpiece was published in 1987. I’m going\nto assume that, in a physical library, there are two copies of this book, whose ID\nis nyc-central-lib, and that one of the two copies is currently out. Here’s\nhow I’d represent the Book record for Watchmen in DOP.\nJoe comes closer to Theo’s laptop. He opens a text editor (not an IDE!) and types the Book\nrecord for Theo.\n--- Page 78 ---\n50 CHAPTER 3 Basic data manipulation\nListing3.1 An instance of a Book record represented as a map\n{\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\nTheo looks at the laptop screen. He has a question.\nTheo How am I supposed to instantiate the Book record for Watchmen programmat-\nically?\nJoe It depends on the facilities that your programming language offers to instantiate\nmaps. With dynamic languages like JavaScript, Ruby, or Python, it’s straight-\nforward, because we can use literals for maps and arrays. Here, let me show\nyou how.\nJoe jots down the JavaScript code that creates an instance of a Book record, which rep-\nresents as a map in JavaScript. He shows the code to Theo.\nListing3.2 A Book record represented as a map in JavaScript\nvar watchmenBook = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n--- Page 79 ---\n3.2 Representing records as maps 51\nTheo And, if I’m in Java?\nJoe It’s a bit more tedious, but still doable with the immutable Map and List static\nfactory methods.\n NOTE See “Creating Immutable Lists, Sets, and Maps” at http://mng.bz/voGm for\nmore information on this Java core library.\nJoe types the Java code to create an instance of a Book record represented as a map. He\nshows Theo the Java code.\nListing3.3 A Book record represented as a map in Java\nMap watchmen = Map.of(\n\"isbn\", \"978-1779501127\",\n\"title\", \"Watchmen\",\n\"publicationYear\", 1987,\n\"authors\", List.of(\"alan-moore\", \"dave-gibbons\"),\n\"bookItems\", List.of(\nMap.of(\n\"id\", \"book-item-1\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", true\n),\nMap.of (\n\"id\", \"book-item-2\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", false\n)\n)\n);\nTIP In DOP, we represent a record as a heterogeneous string map.\nTheo I’d definitely prefer to create a Book record using a Book class and a BookItem\nclass.\nTheo opens his IDE. He types the JavaScript code to represent a Book record as an instance\nof a Book class.\nListing3.4 A Book record as an instance of a Book class in JavaScript\nclass Book {\nisbn;\ntitle;\npublicationYear;\nauthors;\nbookItems;\nconstructor(isbn, title, publicationYear, authors, bookItems) {\nthis.isbn = isbn;\nthis.title = title;\nthis.publicationYear = publicationYear;\nthis.authors = authors;\nthis.bookItems = bookItems;\n--- Page 80 ---\n52 CHAPTER 3 Basic data manipulation\n}\n}\nclass BookItem {\nid;\nlibId;\nisLent;\nconstructor(id, libId, isLent) {\nthis.id = id;\nthis.libId = libId;\nthis.isLent = isLent;\n}\n}\nvar watchmenBook = new Book(\"978-1779501127\",\n\"Watchmen\",\n1987,\n[\"alan-moore\", \"dave-gibbons\"],\n[new BookItem(\"book-item-1\", \"nyc-central-lib\", true),\nnew BookItem(\"book-item-2\", \"nyc-central-lib\", false)]);\nJoe Theo, why do you prefer classes over maps for representing records?\nTheo It makes the data shape of the record part of my program. As a result, the IDE\ncan auto-complete field names, and errors are caught at compile time.\nJoe Fair enough. Can I show you some drawbacks for this approach?\nTheo Sure.\nJoe Imagine that you want to display the information about a book in the context\nof search results. In that case, instead of author IDs, you want to display\nauthor names, and you don’t need the book item information. How would\nyou handle that?\nTheo I’d create a class BookInSearchResults without a bookItems member and\nwith an authorNames member instead of the authorIds member of the Book\nclass. Also, I would need to write a copy constructor that receives a Book object.\nJoe In classic OOP, the fact that data is instantiated only via classes brings safety.\nBut this safety comes at the cost of flexibility.\nTIP There’s a tradeoff between flexibility and safety in a data model.\nTheo So, how can it be different?\nJoe In the DOP approach, where records are represented as maps, we don’t need\nto create a class for each variation of the data. We’re free to add, remove, and\nrename record fields dynamically. Our data model is flexible.\nTheo Interesting!\nTIP In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\nJoe Now, let me talk about genericity. How would you serialize the content of a\nBook object to JSON?\n--- Page 81 ---\n3.2 Representing records as maps 53\nTIP In DOP, records are manipulated with generic functions.\nTheo Oh no! I remember that while working on the Klafim prototype, I had a night-\nmare about JSON serialization when I was developing the first version of the\nLibrary Management System.\nJoe Well, in DOP, serializing a record to JSON is super easy.\nTheo Does it require the usage of reflection in order to go over the fields of the\nrecord like the Gson Java library does?\n NOTE See https://github.com/google/gson for more information on Gson.\nJoe Not at all! Remember that in DOP, a record is nothing more than data. We can\nwrite a generic JSON serialization function that works with any record. It can\nbe a Book, an Author, a BookItem, or anything else.\nTheo Amazing!\nTIP In DOP, you get JSON serialization for free.\nJoe Actually, as I’ll show you in a moment, lots of data manipulation stuff can be\ndone using generic functions.\nTheo Are the generic functions part of the language?\nJoe It depends on the functions and on the language. For example, JavaScript pro-\nvides a JSON serialization function called JSON.stringify out of the box, but\nnone for omitting multiple keys or for renaming keys.\nTheo That’s annoying.\nJoe Not so much; there are third-party libraries that provide data-manipulation facil-\nities. A popular data manipulation library in the JavaScript ecosystem is Lodash.\n NOTE See https://lodash.com/ to find out more about Lodash.\nTheo What about other languages?\nJoe Lodash has been ported to Java, C#, Python, and Ruby. Let me bookmark some\nsites for you.\nJoe bookmarks these sites for Theo:\n https://javalibs.com/artifact/com.github.javadev/underscore-lodash for Java\n https://www.nuget.org/packages/lodash/ for C#\n https://github.com/dgilland/pydash for Python\n https://rudash-website.now.sh/ for Ruby\n NOTE Throughout the book, we use Lodash to show how to manipulate data with\ngeneric functions, but there is nothing special about Lodash. The exact same approach\ncould be implemented via other data manipulation libraries or custom code.\nTheo Cool!\nJoe Actually, Lodash and its rich set of data manipulation functions can be ported\nto any language. That’s why it’s so beneficial to represent records as maps.\n--- Page 82 ---\n54 CHAPTER 3 Basic data manipulation\nTIP DOP compromises on data safety to gain flexibility and genericity.\nAt the whiteboard, Joe quickly sketches the tradeoffs (see table 3.1).\nTable 3.1 The tradeoff among safety, flexibility, and genericity\nOOP DOP\nSafety High Low\nFlexibility Low High\nGenericity Low High\n3.3 Manipulating data with generic functions\nJoe Now let me show you how to manipulate data in DOP with generic functions.\nTheo Yes, I’m quite curious to see how you’ll implement the search functionality of\nthe Library Management System.\nJoe OK. First, let’s instantiate a Catalog record for the catalog data of a library,\nwhere we have a single book, Watchmen.\nJoe instantiates a Catalog record according to Theo’s data model in figure 3.3. Here’s\nwhat Joe shows to Theo.\nListing3.5 A Catalog record\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n--- Page 83 ---\n3.3 Manipulating data with generic functions 55\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\nTheo I see the two indexes we talked about, booksByIsbn and authorsById. How\ndo you differentiate a record from an index in DOP?\nJoe In an entity diagram, there’s a clear distinction between records and indexes.\nBut in our code, both are plain data.\nTheo I guess that’s why this approach is called data-oriented programming.\nJoe See how straightforward it is to visualize any part of the system data inside a\nprogram? The reason is that data is represented as data!\nTIP In DOP, data is represented as data.\nTheo That sounds like a lapalissade.1\nJoe Oh, does it? I’m not so sure! In OOP, data is usually represented by objects,\nwhich makes it more challenging to visualize data inside a program.\nTIP In DOP, we can visualize any part of the system data.\nTheo How would you retrieve the title of a specific book from the catalog data?\nJoe Great question! In fact, in a DOP system, every piece of information has an\ninformation path from which we can retrieve the information.\nTheo Information path?\nJoe For example, the information path to the title of the Watchmen book in the\ncatalog is [\"booksByIsbn\", \"978-1779501127\", \"title\"].\nTheo Ah, I see. So, is an information path sort of like a file path, but that names in\nan information path correspond to nested entities?\nJoe You’re exactly right. And once we have the path of a piece of information, we\ncan retrieve the information with Lodash’s _.get function.\nJoe types a few characters on Theo’s laptop. Theo is amazed at how little code is needed to\nget the book title.\nListing3.6 Retrieving the title of a book from its information path\n_.get(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"])\n// → \"Watchmen\"\nTheo Neat. I wonder how hard it would be to implement a function like _.get\nmyself.\n1 A lapalissade is an obvious truth—a truism or tautology—that produces a comical effect.\n--- Page 84 ---\n56 CHAPTER 3 Basic data manipulation\nAfter a few minutes of trial and error, Theo is able to produce his implementation. He\nshows Joe the code.\nListing3.7 Custom implementation of get\nfunction get(m, path) {\nvar res = m;\nfor(var i = 0; i < path.length; i++) {\nWe could use\nvar key = path[i];\nforEach instead\nres = res[key];\nof a for loop.\n}\nreturn res;\n}\nAfter testing Theo’s implementation of get, Joe compliments Theo. He’s grateful that\nTheo is catching on so quickly.\nListing3.8 Testing the custom implementation of get\nget(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"]);\n// → \"Watchmen\"\nJoe Well done!\nTheo I wonder if a function like _.get works smoothly in a statically-typed language\nlike Java?\nJoe It depends on whether you only need to pass the value around or to access the\nvalue concretely.\nTheo I don’t follow.\nJoe Imagine that once you get the title of a book, you want to convert the string\ninto an uppercase string. You need to do a static cast to String, right? Here,\nlet me show you an example that casts a field value to a string, then we can\nmanipulate it as a string.\nListing3.9 Casting a field value to a string\n((String)watchmen.get(\"title\")).toUpperCase()\nTheo That makes sense. The values of the map are of different types, so the compiler\ndeclares it as a Map<String,Object>. The information of the type of the field\nis lost.\nJoe It’s a bit annoying, but quite often our code just passes the data around. In that\ncase, we don’t have to deal with static casting. Moreover, in a language like C#,\nwhen using the dynamic data type, type casting can be avoided.2,3\n2 See http://mng.bz/4jo5 for the C# documentation on the built-in reference to dynamic types.\n3 See appendix A for details about dynamic fields and type casting in C#.\n--- Page 85 ---\n3.3 Manipulating data with generic functions 57\nTIP In statically-typed languages, we sometimes need to statically cast the field values.\nTheo What about performance?\nJoe In most programming languages, maps are quite efficient. Accessing a field\nin a map is slightly slower than accessing a class member. Usually, it’s not\nsignificant.\nTIP There’s no significant performance hit for accessing a field in a map instead of as\na class member.\nTheo Let’s get back to this idea of information path. It works in OOP too. I could\naccess the title of the Watchmen book with catalogData.booksByIsbn[\"978-\n1779501127\"].title. I’d use class members for record fields and strings for\nindex keys.\nJoe There’s a fundamental difference, though. When records are represented as\nmaps, the information can be retrieved via its information path using a generic\nfunction like _.get. But when records are represented as objects, you need to\nwrite specific code for each type of information path.\nTheo What do you mean by specific code? What’s specific in catalogData.books-\nByIsbn[\"978-1779501127\"].title?\nJoe In a statically-typed language like Java, you’d need to import the class defini-\ntions for Catalog and Book.\nTheo And, in a dynamically-typed language like JavaScript...?\nJoe Even in JavaScript, when you represent records with objects instantiated from\nclasses, you can’t easily write a function that receives a path as an argument\nand display the information that corresponds to this path. You would have to\nwrite specific code for each kind of path. You’d access class members with dot\nnotation and map fields with bracket notation.\nTheo Would you say that in DOP, the information path is a first-class citizen?\nJoe Absolutely! The information path can be stored in a variable and passed as an\nargument to a function.\nTIP In DOP, you can retrieve every piece of information via a path and a generic\nfunction.\nJoe goes to the whiteboard. He draws a diagram like that in figure 3.5, which shows the\ncatalog data as a tree.\nJoe You see, Theo, each piece of information is accessible via a path made of\nstrings and integers. For example, the path of Alan Moore’s first book is\n[\"catalog\", \"authorsById\", \"alan-moore\", \"bookIsbns\", 0].\n--- Page 86 ---\n58 CHAPTER 3 Basic data manipulation\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 3.5 The catalog data as a tree\n3.4 Calculating search results\nTheo Interesting. I’m starting to feel the power of expression of DOP!\nJoe Wait, that’s just the beginning. Let me show you how simple it is to write code\nthat retrieves book information and displays it in search results. Can you tell\nme exactly what information has to appear in the search results?\nTheo Searching for book information should return isbn, title, and author-\nNames.\nJoe And what would a BookInfo record look like for Watchmen?\nTheo quickly enters the code on his laptop. He then shows it to Joe.\nListing3.10 A BookInfo record for Watchmen in the context of search result\n{\n\"title\": \"Watchmen\",\n\"isbn\": \"978-1779501127\",\n\"authorNames\": [\n\"Alan Moore\",\n\"Dave Gibbons\",\n]\n}\n--- Page 87 ---\n3.4 Calculating search results 59\nJoe Now I’ll show you step by step how to write a function that returns search\nresults matching a title in JSON format. I’ll use generic data manipulation\nfunctions from Lodash.\nTheo I’m ready!\nJoe Let’s start with an authorNames function that calculates the author names of a\nBook record by looking at the authorsById index. Could you tell me what’s\nthe information path for the name of an author whose ID is authorId?\nTheo It’s [\"authorsById\", authorId, \"name\"].\nJoe Now, let me show you how to retrieve the name of several authors using _.map.\nJoe types the code to map the author IDs to the author names. Theo nonchalantly peeks\nover Joe’s shoulder.\nListing3.11 Mapping author IDs to author names\n_.map([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\nTheo What’s this _.map function? It smells like functional programming! You said I\nwouldn’t have to learn FP to implement DOP!\nJoe No need to learn functional programming in order to use _.map, which is a\nfunction that transforms the values of a collection. You can implement it with\na simple for loop.\nTheo spends a couple of minutes in front of his computer figuring out how to implement\n_.map. Now he’s got it!\nListing3.12 Custom implementation of map\nfunction map(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nres[i] = f(coll[i]);\nforEach instead\n}\nof a for loop.\nreturn res;\n}\nAfter testing Theo’s implementation of map, Joe shows Theo the test. Joe again compli-\nments Theo.\nListing3.13 Testing the custom implementation of map\nmap([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\n--- Page 88 ---\n60 CHAPTER 3 Basic data manipulation\nJoe Well done!\nTheo You were right! It wasn’t hard.\nJoe Now, let’s implement authorNames using _.map.\nIt takes a few minutes for Theo to come up with the implementation of authorNames.\nWhen he’s finished, he turns his laptop to Joe.\nListing3.14 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nJoe We also need a bookInfo function that converts a Book record into a Book-\nInfo record. Let me show you the code for that.\nListing3.15 Converting a Book record into a BookInfo record\nfunction bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": authorNames(catalogData, book)\n};\nThere’s no need to create\nreturn bookInfo;\na class for bookInfo.\n}\nTheo Looking at the code, I see that a BookInfo record has three fields: title,\nisbn, and authorNames. Is there a way to get this information without looking\nat the code?\nJoe You can either add it to the data entity diagram or write it in the documenta-\ntion of the bookInfo function, or both.\nTheo I have to get used to the idea that in DOP, the record field information is not\npart of the program.\nJoe Indeed, it’s not part of the program, but it gives us a lot of flexibility.\nTheo Is there any way for me to have my cake and eat it too?\nJoe Yes, and someday I’ll show you how to make record field information part of a\nDOP program (see chapters 7 and 12).\nTheo Sounds intriguing!\nJoe Now that we have all the pieces in place, we can write our searchBooksBy-\nTitle function, which returns the book information about the books that\nmatch the query. First, we find the Book records that match the query with\n_.filter and then we transform each Book record into a BookInfo record\nwith _.map and bookInfo.\n--- Page 89 ---\n3.4 Calculating search results 61\nListing3.16 Searching books that match a query\nfunction searchBooksByTitle(catalogData, query) {\nvar allBooks = _.values(_.get(catalogData, \"booksByIsbn\"));\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\nThe includes JavaScript\n});\nfunction checks whether\na string includes a string\nvar bookInfos = _.map(matchingBooks, function(book) { as a substring.\nreturn bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\nTheo You’re using Lodash functions without any explanation again!\nJoe Sorry about that. I am so used to basic data manipulation functions that I con-\nsider them as part of the language. What functions are new to you?\nTheo _.values and _.filter\nJoe Well, _.values returns a collection made of the values of a map, and _.filter\nreturns a collection made of the values that satisfy a predicate.\nTheo _.values seems trivial. Let me try to implement _.filter.\nThe implementation of _.filter takes a bit more time. Eventually, Theo manages to get\nit right, then he is able to test it.\nListing3.17 Custom implementation of filter\nfunction filter(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nif(f(coll[i])) {\nforEach instead\nres.push(coll[i]);\nof a for loop.\n}\n}\nreturn res;\n}\nListing3.18 Testing the custom implementation of filter\nfilter([\"Watchmen\", \"Batman\"], function (title) {\nreturn title.includes(\"Watch\");\n});\n// → [\"Watchmen\"]\nTheo To me, it’s a bit weird that to access the title of a book record, I need to write\n_.get(book, \"title\"). I’d expect it to be book.title in dot notation or\nbook[\"title\"] in bracket notation.\nJoe Remember that book is a record that’s not represented as an object. It’s a map.\nIndeed, in JavaScript, you can write _.get(book, \"title\"), book.title, or\nbook[\"title\"]. But I prefer to use Lodash’s _.get function. In some lan-\nguages, the dot and the bracket notations might not work on maps.\n--- Page 90 ---\n62 CHAPTER 3 Basic data manipulation\nTheo Being language-agnostic has a price!\nJoe Right, would you like to test searchBooksByTitle?\nTheo Absolutely! Let me call searchBooksByTitle to search the books whose title\ncontain the string Watch.\nListing3.19 Testing searchBooksByTitle\nsearchBooksByTitle(catalogData, \"Wat\");\n//[\n// {\n// \"authorNames\": [\n// \"Alan Moore\",\n// \"Dave Gibbons\"\n// ],\n// \"isbn\": \"978-1779501127\",\n// \"title\": \"Watchmen\"\n// }\n//]\nTheo It seems to work! Are we done with the search implementation?\nJoe Almost. The searchBooksByTitle function we wrote is going to be part of the\nCatalog module, and it returns a collection of records. We have to write a\nfunction that’s part of the Library module, and that returns a JSON string.\nTheo You told me earlier that JSON serialization was straightforward in DOP.\nJoe Correct. The code for searchBooksByTitleJSON retrieves the Catalog record,\npasses it to searchBooksByTitle, and converts the results to JSON with\nJSON.stringify. That’s part of JavaScript. Here, let me show you.\nListing3.20 Implementation of searching books in a library as JSON\nfunction searchBooksByTitleJSON(libraryData, query) {\nvar results = searchBooksByTitle(_.get(libraryData, \"catalog\"), query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\nJoe In order to test our code, we need to create a Library record that contains our\nCatalog record. Could you do that for me, please?\nTheo Should the Library record contain all the Library fields (name, address,\nand UserManagement)?\nJoe That’s not necessary. For now, we only need the catalog field, then the test\nfor searching books.\nListing3.21 A Library record\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n--- Page 91 ---\n3.4 Calculating search results 63\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nListing3.22 Test for searching books in a library as JSON\nsearchBooksByTitleJSON(libraryData, \"Wat\");\nTheo How are we going to combine the four functions that we’ve written so far?\nJoe The functions authorNames, bookInfo, and searchBooksByTitle go into\nthe Catalog module, and searchBooksByTitleJSON goes into the Library\nmodule.\nTheo looks at the resulting code of the two modules, Library and Catalog. He’s quite\namazed by its conciseness.\nListing3.23 Calculating search results for Library and Catalog\nclass Catalog {\nstatic authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\n--- Page 92 ---\n64 CHAPTER 3 Basic data manipulation\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nThere’s no need\nreturn bookInfo;\nto create a class\n}\nfor bookInfo.\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nWhen _.filter is\nvar matchingBooks = _.filter(allBooks,\npassed a map, it\nfunction(book) {\ngoes over the values\nreturn _.get(book, \"title\").includes(query);\nof the map.\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nConverts data\nreturn resultsJSON;\nto JSON (part\n}\nof JavaScript)\n}\nAfter testing the final code in listing 3.24, Theo looks again at the source code from list-\ning 3.23. After a few seconds, he feels like he’s having another Aha! moment.\nListing3.24 Search results in JSON\nLibrary.searchBooksByTitleJSON(libraryData, \"Watchmen\");\n// → \"[{\\\"title\\\":\\\"Watchmen\\\",\\\"isbn\\\":\\\"978-1779501127\\\",\n// → \\\"authorNames\\\":[\\\"Alan Moore\\\",\\\"Dave Gibbons\\\"]}]\"\nTheo The important thing is not that the code is concise, but that the code contains\nno abstractions. It’s just data manipulation!\nJoe responds with a smile that says, “You got it, my friend!”\nJoe It reminds me of what my first meditation teacher told me 10 years ago:\nmeditation guides the mind to grasp the reality as it is without the abstractions\ncreated by our thoughts.\nTIP In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\n--- Page 93 ---\n3.5 Handling records of different types 65\n3.5 Handling records of different types\nWe’ve seen how DOP enables us to treat records as first-class citizens that can be\nmanipulated in a flexible way using generic functions. But if a record is nothing more\nthan an aggregation of fields, how do we know what the type of the record is? DOP has\na surprising answer to this question.\nTheo I have a question. If a record is nothing more than a map, how do you know\nthe type of the record?\nJoe That’s a great question with a surprising answer.\nTheo I’m curious.\nJoe Most of the time, there’s no need to know the record type.\nTheo What! What do you mean?\nJoe I mean that what matters most are the values of the fields. For example, take a\nlook at the Catalog.authorNames source code. It operates on a Book record,\nbut the only thing that matters is the value of the authorIds field.\nDoubtful, Theo looks at the source code for Catalog.authorNames. This is what Theo sees.\nListing3.25 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nTheo What about differentiating between various user types like Member versus\nLibrarian? I mean, they both have email and encryptedPassword. How do\nyou know if a record represents a Member or a Librarian?\nJoe Simple. You check to see if the record is found in the librariansByEmail\nindex or in the membersByEmail index of the Catalog.\nTheo Could you be more specific?\nJoe Sure! Let me write what the user management data of our tiny library might\nlook like, assuming we have one librarian and one member. To keep things\nsimple, I’m encrypting passwords through naive base-64 encoding for the User-\nManagement record.\nListing3.26 A UserManagement record\nvar userManagementData = {\n\"librariansByEmail\": {\n\"franck@gmail.com\" : { The base-64\nencoding of\n\"email\": \"franck@gmail.com\",\n\"mypassword\"\n\"encryptedPassword\": \"bXlwYXNzd29yZA==\"\n}\n},\n--- Page 94 ---\n66 CHAPTER 3 Basic data manipulation\n\"membersByEmail\": {\n\"samantha@gmail.com\": {\n\"email\": \"samantha@gmail.com\",\n\"encryptedPassword\": \"c2VjcmV0\",\nThe base-64\n\"isBlocked\": false,\nencoding of\n\"bookLendings\": [\n\"secret\"\n{\n\"bookItemId\": \"book-item-1\",\n\"bookIsbn\": \"978-1779501127\",\n\"lendingDate\": \"2020-04-23\"\n}\n]\n}\n}\n}\nTIP Most of the time, there’s no need to know the record type.\nTheo This morning, you told me you’d show me the code for UserManagement\n.isLibrarian function this afternoon.\nJoe So, here we are. It’s afternoon, and I’m going to fulfill my promise.\nJoe implements isLibrarian. With a slight pause, he then issues the test for isLibrarian.\nListing3.27 Checking if a user is a librarian\nfunction isLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nListing3.28 Testing isLibrarian\nisLibrarian(userManagementData, \"franck@gmail.com\");\n// → true\nTheo I’m assuming that _.has is a function that checks whether a key exists in a\nmap. Right?\nJoe Correct.\nTheo OK. You simply check whether the librariansByEmail map contains the\nemail field.\nJoe Yep.\nTheo Would you use the same pattern to check whether a member is a Super mem-\nber or a VIP member?\nJoe Sure. We could have SuperMembersByEmail and VIPMembersByEmail indexes.\nBut there’s a better way.\nTheo How?\nJoe When a member is a VIP member, we add a field, isVIP, with the value true to\nits record. To check if a member is a VIP member, we check whether the\nisVIP field is set to true in the member record. Here’s how I would code\nisVIPMember.\n--- Page 95 ---\n3.5 Handling records of different types 67\nListing3.29 Checking whether a member is a VIP member\nfunction isVIPMember(userManagement, email) {\nreturn _.get(userManagement, [\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nTheo I see that you access the isVIP field via its information path, [\"membersBy-\nEmail\", email, \"isVIP\"].\nJoe Yes, I think it makes the code crystal clear.\nTheo I agree. I guess we can do the same for isSuperMember and set an isSuper\nfield to true when a member is a Super member?\nJoe Yes, just like this.\nJoe assembles all the pieces in a UserManagement class. He then shows the code to Theo.\nListing3.30 The code of UserManagement module\nclass UserManagement {\nisLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nisVIPMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nisSuperMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isSuper\"]) == true;\n}\n}\nTheo looks at the UserManagement module code for a couple of seconds. Suddenly, an\nidea comes to his mind.\nTheo Why not have a type field in member record whose value would be either VIP\nor Super?\nJoe I assume that, according to the product requirements, a member can be both a\nVIP and a Super member.\nTheo Hmm...then the types field could be a collection containing VIP or Super\nor both.\nJoe In some situations, having a types field is helpful, but I find it simpler to have\na Boolean field for each feature that the record supports.\nTheo Is there a name for fields like isVIP and isSuper?\nJoe I call them feature fields.\nTIP Instead of maintaining type information about a record, use a feature field (e.g.,\nisVIP).\n--- Page 96 ---\n68 CHAPTER 3 Basic data manipulation\nTheo Can we use feature fields to differentiate between librarians and members?\nJoe You mean having an isLibrarian and an isMember field?\nTheo Yes, and having a common User record type for both librarians and members.\nJoe We can, but I think it’s simpler to have different record types for librarians and\nmembers: Librarian for librarians and Member for members.\nTheo Why?\nJoe Because there’s a clear distinction between librarians and members in terms of\ndata. For example, members can have book lendings but librarians don’t.\nTheo I agree. Now, we need to mention the two Member feature fields in our entity\ndiagram.\nWith that, Theo adds these fields to his diagram on the whiteboard. When he’s finished, he\nshows Joe his additions (figure 3.6).\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: Catalog\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian *\nCC Book id: String email: String CC Member\nname: String\ntitle : String encryptedPassword: String email: String\nbookIsbns: [String]\npublicationYear: Number encryptedPassword: String\nisbn: String * isBlocked: Boolean\nauthorIds: [String] bookLendings: [BookLending]\nbookItems: [BookItem] * isVIP: Boolean\nisSuper: Boolean\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.6 A library management data model with the Member feature fields isVIP and isSuper\nJoe Do you like the data model that we have designed together?\nTheo I find it quite simple and clear.\n--- Page 97 ---\nSummary 69\nJoe That’s the main goal of DOP.\nTheo Also, I’m pleasantly surprised how easy it is to adapt to changing requirements,\nboth in terms of code and the data model.\nJoe I suppose you’re also happy to get rid of complex class hierarchy diagrams.\nTheo Absolutely! Also, I think I’ve found an interesting connection between DOP\nand meditation.\nJoe Really?\nTheo When we were eating at Simple, you told me that meditation helped you expe-\nrience reality as it is without the filter of your thoughts.\nJoe Right.\nTheo From what you taught me today, I understand that in DOP, we are encouraged\nto treat data as data without the filter of our classes.\nJoe Clever! I never noticed that connection between those two disciplines that are\nso important for me. I guess you’d like to continue your journey in the realm\nof DOP.\nTheo Definitely. Let’s meet again tomorrow.\nJoe Unfortunately, tomorrow I’m taking my family to the beach to celebrate the\ntwelfth birthday of my eldest daughter, Aurelia.\nTheo Happy birthday, Aurelia!\nJoe We could meet again next Monday, if that’s OK with you.\nTheo With pleasure!\nSummary\n DOP principle #2 is to represent data entities with generic data structures.\n We refer to maps that have strings as keys as string maps.\n Representing data as data means representing records with string maps.\n By positional collection, we mean a collection where the elements are in order\n(like a list or an array).\n A positional collection of Strings is noted as [String].\n By index, we mean a collection where the elements are accessible via a key (like\na hash map or a dictionary).\n An index of Books is noted as {Book}.\n In the context of a data model, the index keys are always strings.\n A record is a data structure that groups together related data items. It’s a collec-\ntion of fields, possibly of different data types.\n A homogeneous map is a map where all the values are of the same type.\n A heterogeneous map is a map where the values are of different types.\n In DOP, we represent a record as a heterogeneous string map.\n A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes.\n The relation between records in a data entity diagram is either composition or\nassociation.\n--- Page 98 ---\n70 CHAPTER 3 Basic data manipulation\n The data part of a DOP system is flexible, and each piece of information is\naccessible via its information path.\n There is a tradeoff between flexibility and safety in a data model.\n DOP compromises on data safety to gain flexibility and genericity.\n In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\n We manipulate data with generic functions.\n Generic functions are provided either by the language itself or by third-party\nlibraries like Lodash.\n JSON serialization is implemented in terms of a generic function.\n On the one hand, we’ve lost the safety of accessing record fields via members\ndefined at compile time. On the other hand, we’ve liberated data from the lim-\nitation of classes and objects. Data is represented as data!\n The weak dependency between code and data makes it is easier to adapt to\nchanging requirements.\n When data is represented as data, it is straightforward to visualize system data.\n Usually, we do not need to maintain type information about a record.\n We can visualize any part of the system data.\n In statically-typed languages, we sometimes need to statically cast the field values.\n Instead of maintaining type information about a record, we use a feature field.\n There is no significant performance hit for accessing a field in a map instead of\na class member.\n In DOP, you can retrieve every piece of information via an information path and\na generic function.\n In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\nLodash functions introduced in this chapter\nFunction Description\nget(map, path) Gets the value of map at path\nhas(map, path) Checks if map has a field at path\nmerge(mapA, mapB) Creates a map resulting from the recursive merges between mapA and mapB\nvalues(map) Creates an array of values of map\nfilter(coll, pred) Iterates over elements of coll, returning an array of all elements for which\npred returns true\nmap(coll, f) Creates an array of values by running each element in coll through f\n--- Page 99 ---\nState management\nTime travel\nThis chapter covers\n A multi-version approach to state management\n The calculation phase of a mutation\n The commit phase of a mutation\n Keeping a history of previous state versions\nSo far, we have seen how DOP handles queries via generic functions that access sys-\ntem data, which is represented as a hash map. In this chapter, we illustrate how\nDOP deals with mutations (requests that change the system state). Instead of updat-\ning the state in place, we maintain multiple versions of the system data. At a specific\npoint in time, the system state refers to a specific version of the system data. This\nchapter is a deep dive in the third principle of DOP.\nPRINCIPLE #3 Data is immutable.\nThe maintenance of multiple versions of the system data requires the data to be\nimmutable. This is made efficient both in terms of computation and memory via a\n71\n--- Page 100 ---\n72 CHAPTER 4 State management\ntechnique called structural sharing, where parts of the data that are common between\ntwo versions are shared instead of being copied. In DOP, a mutation is split into two\ndistinct phases:\n In the calculation phase, we compute the next version of the system data.\n In the commit phase, we move the system state forward so that it refers to the\nversion of the system data computed by the calculation phase.\nThis distinction between calculation and commit phases allows us to reduce the part\nof our system that is stateful to its bare minimum. Only the code of the commit phase\nis stateful, while the code in the calculation phase of a mutation is stateless and is\nmade of generic functions similar to the code of a query. The implementation of the\ncommit phase is common to all mutations. As a consequence, inside the commit\nphase, we have the ability to ensure that the state always refers to a valid version of the\nsystem data.\nAnother benefit of this state management approach is that we can keep track of\nthe history of previous versions of the system data. Restoring the system to a previous\nstate (if needed) becomes straightforward. Table 4.1 shows the two phases.\nTable 4.1 The two phases of a mutation\nPhase Responsibility State Implementation\nCalculation Computes the next version of system data Stateless Specific\nCommit Moves the system state forward Stateful Common\nIn this chapter, we assume that no mutations occur concurrently in our system. In the\nnext chapter, we will deal with concurrency control.\n4.1 Multiple versions of the system data\nWhen Joe comes in to the office on Monday, he tells Theo that he needs to exercise before\nstarting to work with his mind. Theo and Joe go for a walk around the block, and the dis-\ncussion turns toward version control systems. They discuss how Git keeps track of the\nwhole commit history and how easy and fast it is to restore the code to a previous state.\nWhen Theo tells Joe that Git’s ability to “time travel” reminds him one of his favorite mov-\nies, Back to the Future, Joe shares that a month ago he watched the Back to the Future trilogy\nwith Neriah, his 14-year-old son.\nTheir walk complete, they arrive back at Theo’s office. Theo and Joe partake of the\nespresso machine in the kitchen before they begin today’s lesson.\nJoe So far, we’ve seen how we manage queries that retrieve information from the\nsystem in DOP. Now I’m going to show you how we manage mutations. By a\nmutation, I mean an operation that changes the state of the system.\n NOTE A mutation is an operation that changes the state of the system.\n--- Page 101 ---\n4.1 Multiple versions of the system data 73\nTheo Is there a fundamental difference between queries and mutations in DOP?\nAfter all, the whole state of the system is represented as a hash map. I could\neasily write code that modifies part of the hash map, and it would be similar to\nthe code that retrieves information from the hash map.\nJoe You could mutate the data in place, but then it would be challenging to ensure\nthat the code of a mutation doesn’t put the system into an invalid date. You\nwould also lose the ability to track previous versions of the system state.\nTheo I see. So, how do you handle mutations in DOP?\nJoe We adopt a multi-version state approach, similar to what a version control sys-\ntem like Git does; we manage different versions of the system data. At a specific\npoint in time, the state of the system refers to a version of the system data. After\na mutation is executed, we move the reference forward.\nTheo I’m confused. Is the system state mutable or immutable?\nJoe The data is immutable, but the state reference is mutable.\nTIP The data is immutable, but the state reference is mutable.\nNoticing the look of confusion on Theo’s face, Joe draws a quick diagram on the white-\nboard. He then shows Theo figure 4.1, hoping that it will clear up Theo’s perplexity.\nAfter mutation B After mutation C\nData V10 Data V10\nMutationA MutationA\nData V11 Data V11\nMutation B Mutation B\nSystem State Data V12 Data V12\nMutation C\nSystem State Data V13\nFigure 4.1 After mutation B is executed, the system state refers to Data V12. After\nmutation C is executed, the system state refers to Data V13.\nTheo Does that mean that before the code of a mutation runs, we make a copy of the\nsystem data?\nJoe No, that would be inefficient, as we would have to do a deep copy of the data.",
        "sections_found": []
      },
      "accurate_page_range": "76-101"
    },
    {
      "text": "- 3.3 Manipulating data with generic functions",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "raw_line": "- 3.3 Manipulating data with generic functions (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 25,
      "chapter_info": {
        "page": 76,
        "title": "Basic data manipulation",
        "pattern_matched": "Chapter 3",
        "text_preview": "48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to"
      },
      "chapter_sections": {
        "start_page": 76,
        "end_page": 101,
        "content": "\n--- Page 76 ---\n48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to say that a data entity diagram consists only of records, positional\ncollections, and indexes?\nJoe That’s correct. Can you make a similar statement about the relations between\nentities?\nTheo The relations in a data entity diagram are either composition (solid line with a\nfull diamond) or association (dashed line with an empty diamond). Both types\nof relations can be either one-to-one, one-to-many, or many-to-many.\nJoe Excellent!\nTIP A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes. The relation between records is either composition or\nassociation.\n3.2 Representing records as maps\nSo far, we’ve illustrated the benefits we gain from the separation between code and\ndata at a high-system level. There’s a separation of concerns between code and data,\nand each part has clear constraints:\n Code consists of static functions that receive data as an explicit argument.\n Data entities are modeled as records, and the relations between records are\nrepresented by positional collections and indexes.\nNow comes the question of the representation of the data. DOP has nothing special\ntosay about collections and indexes. However, it’s strongly opinionated about the\nrepresentation of records: records should be represented by generic data structures\nsuch as maps.\nThis applies to both OOP and FP languages. In dynamically-typed languages like\nJavaScript, Python, and Ruby, data representation feels natural. While in statically-\ntyped languages like Java and C#, it is a bit more cumbersome.\nTheo I’m really curious to know how we represent positional collections, indexes,\nand records in DOP.\nJoe Let’s start with positional collections. DOP has nothing special to say about the\nrepresentation of collections. They can be linked lists, arrays, vectors, sets, or\nother collections best suited for the use case.\nTheo It’s like in OOP.\nJoe Right! For now, to keep things simple, we’ll use arrays to represent positional\ncollections.\nTheo What about indexes?\nJoe Indexes are represented as homogeneous string maps.\nTheo What do you mean by a homogeneous map?\n--- Page 77 ---\n3.2 Representing records as maps 49\nJoe I mean that all the values of the map are of the same kind. For example, in a\nBook index, all the values are Book, and in an author index, all the values are\nAuthor, and so forth.\nTheo Again, it’s like in OOP.\n NOTE A homogeneous map is a map where all the values are of the same type. A hetero-\ngeneous map is a map where the values are of different types.\nJoe Now, here’s the big surprise. In DOP, records are represented as maps, more\nprecisely, heterogeneous string maps.\nJoe goes to the whiteboard and begins to draw. When he’s finished, he shows Theo the dia-\ngram in figure 3.4.\nRecord Heterogeneous map\nLinked list\nArray\nData representation Collection\nSet\nVector\nFigure 3.4 The building blocks\nIndex Homogeneous map\nof data representation\nTheo stays silent for a while. He is shocked to hear that the data entities of a system can be\nrepresented as a generic data structure, where the field names and value types are not\nspecified in a class. Then, Theo asks Joe:\nTheo What are the benefits of this folly?\nJoe Flexibility and genericity.\nTheo Could you explain, please?\nJoe I’ll explain in a moment, but before that, I’d like to show you what an instance\nof a record in a DOP system looks like.\nTheo OK.\nJoe Let’s take as an example, Watchmen, by Alan Moore and Dave Gibbons, which is\nmy favorite graphic novel. This masterpiece was published in 1987. I’m going\nto assume that, in a physical library, there are two copies of this book, whose ID\nis nyc-central-lib, and that one of the two copies is currently out. Here’s\nhow I’d represent the Book record for Watchmen in DOP.\nJoe comes closer to Theo’s laptop. He opens a text editor (not an IDE!) and types the Book\nrecord for Theo.\n--- Page 78 ---\n50 CHAPTER 3 Basic data manipulation\nListing3.1 An instance of a Book record represented as a map\n{\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\nTheo looks at the laptop screen. He has a question.\nTheo How am I supposed to instantiate the Book record for Watchmen programmat-\nically?\nJoe It depends on the facilities that your programming language offers to instantiate\nmaps. With dynamic languages like JavaScript, Ruby, or Python, it’s straight-\nforward, because we can use literals for maps and arrays. Here, let me show\nyou how.\nJoe jots down the JavaScript code that creates an instance of a Book record, which rep-\nresents as a map in JavaScript. He shows the code to Theo.\nListing3.2 A Book record represented as a map in JavaScript\nvar watchmenBook = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n--- Page 79 ---\n3.2 Representing records as maps 51\nTheo And, if I’m in Java?\nJoe It’s a bit more tedious, but still doable with the immutable Map and List static\nfactory methods.\n NOTE See “Creating Immutable Lists, Sets, and Maps” at http://mng.bz/voGm for\nmore information on this Java core library.\nJoe types the Java code to create an instance of a Book record represented as a map. He\nshows Theo the Java code.\nListing3.3 A Book record represented as a map in Java\nMap watchmen = Map.of(\n\"isbn\", \"978-1779501127\",\n\"title\", \"Watchmen\",\n\"publicationYear\", 1987,\n\"authors\", List.of(\"alan-moore\", \"dave-gibbons\"),\n\"bookItems\", List.of(\nMap.of(\n\"id\", \"book-item-1\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", true\n),\nMap.of (\n\"id\", \"book-item-2\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", false\n)\n)\n);\nTIP In DOP, we represent a record as a heterogeneous string map.\nTheo I’d definitely prefer to create a Book record using a Book class and a BookItem\nclass.\nTheo opens his IDE. He types the JavaScript code to represent a Book record as an instance\nof a Book class.\nListing3.4 A Book record as an instance of a Book class in JavaScript\nclass Book {\nisbn;\ntitle;\npublicationYear;\nauthors;\nbookItems;\nconstructor(isbn, title, publicationYear, authors, bookItems) {\nthis.isbn = isbn;\nthis.title = title;\nthis.publicationYear = publicationYear;\nthis.authors = authors;\nthis.bookItems = bookItems;\n--- Page 80 ---\n52 CHAPTER 3 Basic data manipulation\n}\n}\nclass BookItem {\nid;\nlibId;\nisLent;\nconstructor(id, libId, isLent) {\nthis.id = id;\nthis.libId = libId;\nthis.isLent = isLent;\n}\n}\nvar watchmenBook = new Book(\"978-1779501127\",\n\"Watchmen\",\n1987,\n[\"alan-moore\", \"dave-gibbons\"],\n[new BookItem(\"book-item-1\", \"nyc-central-lib\", true),\nnew BookItem(\"book-item-2\", \"nyc-central-lib\", false)]);\nJoe Theo, why do you prefer classes over maps for representing records?\nTheo It makes the data shape of the record part of my program. As a result, the IDE\ncan auto-complete field names, and errors are caught at compile time.\nJoe Fair enough. Can I show you some drawbacks for this approach?\nTheo Sure.\nJoe Imagine that you want to display the information about a book in the context\nof search results. In that case, instead of author IDs, you want to display\nauthor names, and you don’t need the book item information. How would\nyou handle that?\nTheo I’d create a class BookInSearchResults without a bookItems member and\nwith an authorNames member instead of the authorIds member of the Book\nclass. Also, I would need to write a copy constructor that receives a Book object.\nJoe In classic OOP, the fact that data is instantiated only via classes brings safety.\nBut this safety comes at the cost of flexibility.\nTIP There’s a tradeoff between flexibility and safety in a data model.\nTheo So, how can it be different?\nJoe In the DOP approach, where records are represented as maps, we don’t need\nto create a class for each variation of the data. We’re free to add, remove, and\nrename record fields dynamically. Our data model is flexible.\nTheo Interesting!\nTIP In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\nJoe Now, let me talk about genericity. How would you serialize the content of a\nBook object to JSON?\n--- Page 81 ---\n3.2 Representing records as maps 53\nTIP In DOP, records are manipulated with generic functions.\nTheo Oh no! I remember that while working on the Klafim prototype, I had a night-\nmare about JSON serialization when I was developing the first version of the\nLibrary Management System.\nJoe Well, in DOP, serializing a record to JSON is super easy.\nTheo Does it require the usage of reflection in order to go over the fields of the\nrecord like the Gson Java library does?\n NOTE See https://github.com/google/gson for more information on Gson.\nJoe Not at all! Remember that in DOP, a record is nothing more than data. We can\nwrite a generic JSON serialization function that works with any record. It can\nbe a Book, an Author, a BookItem, or anything else.\nTheo Amazing!\nTIP In DOP, you get JSON serialization for free.\nJoe Actually, as I’ll show you in a moment, lots of data manipulation stuff can be\ndone using generic functions.\nTheo Are the generic functions part of the language?\nJoe It depends on the functions and on the language. For example, JavaScript pro-\nvides a JSON serialization function called JSON.stringify out of the box, but\nnone for omitting multiple keys or for renaming keys.\nTheo That’s annoying.\nJoe Not so much; there are third-party libraries that provide data-manipulation facil-\nities. A popular data manipulation library in the JavaScript ecosystem is Lodash.\n NOTE See https://lodash.com/ to find out more about Lodash.\nTheo What about other languages?\nJoe Lodash has been ported to Java, C#, Python, and Ruby. Let me bookmark some\nsites for you.\nJoe bookmarks these sites for Theo:\n https://javalibs.com/artifact/com.github.javadev/underscore-lodash for Java\n https://www.nuget.org/packages/lodash/ for C#\n https://github.com/dgilland/pydash for Python\n https://rudash-website.now.sh/ for Ruby\n NOTE Throughout the book, we use Lodash to show how to manipulate data with\ngeneric functions, but there is nothing special about Lodash. The exact same approach\ncould be implemented via other data manipulation libraries or custom code.\nTheo Cool!\nJoe Actually, Lodash and its rich set of data manipulation functions can be ported\nto any language. That’s why it’s so beneficial to represent records as maps.\n--- Page 82 ---\n54 CHAPTER 3 Basic data manipulation\nTIP DOP compromises on data safety to gain flexibility and genericity.\nAt the whiteboard, Joe quickly sketches the tradeoffs (see table 3.1).\nTable 3.1 The tradeoff among safety, flexibility, and genericity\nOOP DOP\nSafety High Low\nFlexibility Low High\nGenericity Low High\n3.3 Manipulating data with generic functions\nJoe Now let me show you how to manipulate data in DOP with generic functions.\nTheo Yes, I’m quite curious to see how you’ll implement the search functionality of\nthe Library Management System.\nJoe OK. First, let’s instantiate a Catalog record for the catalog data of a library,\nwhere we have a single book, Watchmen.\nJoe instantiates a Catalog record according to Theo’s data model in figure 3.3. Here’s\nwhat Joe shows to Theo.\nListing3.5 A Catalog record\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n--- Page 83 ---\n3.3 Manipulating data with generic functions 55\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\nTheo I see the two indexes we talked about, booksByIsbn and authorsById. How\ndo you differentiate a record from an index in DOP?\nJoe In an entity diagram, there’s a clear distinction between records and indexes.\nBut in our code, both are plain data.\nTheo I guess that’s why this approach is called data-oriented programming.\nJoe See how straightforward it is to visualize any part of the system data inside a\nprogram? The reason is that data is represented as data!\nTIP In DOP, data is represented as data.\nTheo That sounds like a lapalissade.1\nJoe Oh, does it? I’m not so sure! In OOP, data is usually represented by objects,\nwhich makes it more challenging to visualize data inside a program.\nTIP In DOP, we can visualize any part of the system data.\nTheo How would you retrieve the title of a specific book from the catalog data?\nJoe Great question! In fact, in a DOP system, every piece of information has an\ninformation path from which we can retrieve the information.\nTheo Information path?\nJoe For example, the information path to the title of the Watchmen book in the\ncatalog is [\"booksByIsbn\", \"978-1779501127\", \"title\"].\nTheo Ah, I see. So, is an information path sort of like a file path, but that names in\nan information path correspond to nested entities?\nJoe You’re exactly right. And once we have the path of a piece of information, we\ncan retrieve the information with Lodash’s _.get function.\nJoe types a few characters on Theo’s laptop. Theo is amazed at how little code is needed to\nget the book title.\nListing3.6 Retrieving the title of a book from its information path\n_.get(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"])\n// → \"Watchmen\"\nTheo Neat. I wonder how hard it would be to implement a function like _.get\nmyself.\n1 A lapalissade is an obvious truth—a truism or tautology—that produces a comical effect.\n--- Page 84 ---\n56 CHAPTER 3 Basic data manipulation\nAfter a few minutes of trial and error, Theo is able to produce his implementation. He\nshows Joe the code.\nListing3.7 Custom implementation of get\nfunction get(m, path) {\nvar res = m;\nfor(var i = 0; i < path.length; i++) {\nWe could use\nvar key = path[i];\nforEach instead\nres = res[key];\nof a for loop.\n}\nreturn res;\n}\nAfter testing Theo’s implementation of get, Joe compliments Theo. He’s grateful that\nTheo is catching on so quickly.\nListing3.8 Testing the custom implementation of get\nget(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"]);\n// → \"Watchmen\"\nJoe Well done!\nTheo I wonder if a function like _.get works smoothly in a statically-typed language\nlike Java?\nJoe It depends on whether you only need to pass the value around or to access the\nvalue concretely.\nTheo I don’t follow.\nJoe Imagine that once you get the title of a book, you want to convert the string\ninto an uppercase string. You need to do a static cast to String, right? Here,\nlet me show you an example that casts a field value to a string, then we can\nmanipulate it as a string.\nListing3.9 Casting a field value to a string\n((String)watchmen.get(\"title\")).toUpperCase()\nTheo That makes sense. The values of the map are of different types, so the compiler\ndeclares it as a Map<String,Object>. The information of the type of the field\nis lost.\nJoe It’s a bit annoying, but quite often our code just passes the data around. In that\ncase, we don’t have to deal with static casting. Moreover, in a language like C#,\nwhen using the dynamic data type, type casting can be avoided.2,3\n2 See http://mng.bz/4jo5 for the C# documentation on the built-in reference to dynamic types.\n3 See appendix A for details about dynamic fields and type casting in C#.\n--- Page 85 ---\n3.3 Manipulating data with generic functions 57\nTIP In statically-typed languages, we sometimes need to statically cast the field values.\nTheo What about performance?\nJoe In most programming languages, maps are quite efficient. Accessing a field\nin a map is slightly slower than accessing a class member. Usually, it’s not\nsignificant.\nTIP There’s no significant performance hit for accessing a field in a map instead of as\na class member.\nTheo Let’s get back to this idea of information path. It works in OOP too. I could\naccess the title of the Watchmen book with catalogData.booksByIsbn[\"978-\n1779501127\"].title. I’d use class members for record fields and strings for\nindex keys.\nJoe There’s a fundamental difference, though. When records are represented as\nmaps, the information can be retrieved via its information path using a generic\nfunction like _.get. But when records are represented as objects, you need to\nwrite specific code for each type of information path.\nTheo What do you mean by specific code? What’s specific in catalogData.books-\nByIsbn[\"978-1779501127\"].title?\nJoe In a statically-typed language like Java, you’d need to import the class defini-\ntions for Catalog and Book.\nTheo And, in a dynamically-typed language like JavaScript...?\nJoe Even in JavaScript, when you represent records with objects instantiated from\nclasses, you can’t easily write a function that receives a path as an argument\nand display the information that corresponds to this path. You would have to\nwrite specific code for each kind of path. You’d access class members with dot\nnotation and map fields with bracket notation.\nTheo Would you say that in DOP, the information path is a first-class citizen?\nJoe Absolutely! The information path can be stored in a variable and passed as an\nargument to a function.\nTIP In DOP, you can retrieve every piece of information via a path and a generic\nfunction.\nJoe goes to the whiteboard. He draws a diagram like that in figure 3.5, which shows the\ncatalog data as a tree.\nJoe You see, Theo, each piece of information is accessible via a path made of\nstrings and integers. For example, the path of Alan Moore’s first book is\n[\"catalog\", \"authorsById\", \"alan-moore\", \"bookIsbns\", 0].\n--- Page 86 ---\n58 CHAPTER 3 Basic data manipulation\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 3.5 The catalog data as a tree\n3.4 Calculating search results\nTheo Interesting. I’m starting to feel the power of expression of DOP!\nJoe Wait, that’s just the beginning. Let me show you how simple it is to write code\nthat retrieves book information and displays it in search results. Can you tell\nme exactly what information has to appear in the search results?\nTheo Searching for book information should return isbn, title, and author-\nNames.\nJoe And what would a BookInfo record look like for Watchmen?\nTheo quickly enters the code on his laptop. He then shows it to Joe.\nListing3.10 A BookInfo record for Watchmen in the context of search result\n{\n\"title\": \"Watchmen\",\n\"isbn\": \"978-1779501127\",\n\"authorNames\": [\n\"Alan Moore\",\n\"Dave Gibbons\",\n]\n}\n--- Page 87 ---\n3.4 Calculating search results 59\nJoe Now I’ll show you step by step how to write a function that returns search\nresults matching a title in JSON format. I’ll use generic data manipulation\nfunctions from Lodash.\nTheo I’m ready!\nJoe Let’s start with an authorNames function that calculates the author names of a\nBook record by looking at the authorsById index. Could you tell me what’s\nthe information path for the name of an author whose ID is authorId?\nTheo It’s [\"authorsById\", authorId, \"name\"].\nJoe Now, let me show you how to retrieve the name of several authors using _.map.\nJoe types the code to map the author IDs to the author names. Theo nonchalantly peeks\nover Joe’s shoulder.\nListing3.11 Mapping author IDs to author names\n_.map([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\nTheo What’s this _.map function? It smells like functional programming! You said I\nwouldn’t have to learn FP to implement DOP!\nJoe No need to learn functional programming in order to use _.map, which is a\nfunction that transforms the values of a collection. You can implement it with\na simple for loop.\nTheo spends a couple of minutes in front of his computer figuring out how to implement\n_.map. Now he’s got it!\nListing3.12 Custom implementation of map\nfunction map(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nres[i] = f(coll[i]);\nforEach instead\n}\nof a for loop.\nreturn res;\n}\nAfter testing Theo’s implementation of map, Joe shows Theo the test. Joe again compli-\nments Theo.\nListing3.13 Testing the custom implementation of map\nmap([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\n--- Page 88 ---\n60 CHAPTER 3 Basic data manipulation\nJoe Well done!\nTheo You were right! It wasn’t hard.\nJoe Now, let’s implement authorNames using _.map.\nIt takes a few minutes for Theo to come up with the implementation of authorNames.\nWhen he’s finished, he turns his laptop to Joe.\nListing3.14 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nJoe We also need a bookInfo function that converts a Book record into a Book-\nInfo record. Let me show you the code for that.\nListing3.15 Converting a Book record into a BookInfo record\nfunction bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": authorNames(catalogData, book)\n};\nThere’s no need to create\nreturn bookInfo;\na class for bookInfo.\n}\nTheo Looking at the code, I see that a BookInfo record has three fields: title,\nisbn, and authorNames. Is there a way to get this information without looking\nat the code?\nJoe You can either add it to the data entity diagram or write it in the documenta-\ntion of the bookInfo function, or both.\nTheo I have to get used to the idea that in DOP, the record field information is not\npart of the program.\nJoe Indeed, it’s not part of the program, but it gives us a lot of flexibility.\nTheo Is there any way for me to have my cake and eat it too?\nJoe Yes, and someday I’ll show you how to make record field information part of a\nDOP program (see chapters 7 and 12).\nTheo Sounds intriguing!\nJoe Now that we have all the pieces in place, we can write our searchBooksBy-\nTitle function, which returns the book information about the books that\nmatch the query. First, we find the Book records that match the query with\n_.filter and then we transform each Book record into a BookInfo record\nwith _.map and bookInfo.\n--- Page 89 ---\n3.4 Calculating search results 61\nListing3.16 Searching books that match a query\nfunction searchBooksByTitle(catalogData, query) {\nvar allBooks = _.values(_.get(catalogData, \"booksByIsbn\"));\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\nThe includes JavaScript\n});\nfunction checks whether\na string includes a string\nvar bookInfos = _.map(matchingBooks, function(book) { as a substring.\nreturn bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\nTheo You’re using Lodash functions without any explanation again!\nJoe Sorry about that. I am so used to basic data manipulation functions that I con-\nsider them as part of the language. What functions are new to you?\nTheo _.values and _.filter\nJoe Well, _.values returns a collection made of the values of a map, and _.filter\nreturns a collection made of the values that satisfy a predicate.\nTheo _.values seems trivial. Let me try to implement _.filter.\nThe implementation of _.filter takes a bit more time. Eventually, Theo manages to get\nit right, then he is able to test it.\nListing3.17 Custom implementation of filter\nfunction filter(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nif(f(coll[i])) {\nforEach instead\nres.push(coll[i]);\nof a for loop.\n}\n}\nreturn res;\n}\nListing3.18 Testing the custom implementation of filter\nfilter([\"Watchmen\", \"Batman\"], function (title) {\nreturn title.includes(\"Watch\");\n});\n// → [\"Watchmen\"]\nTheo To me, it’s a bit weird that to access the title of a book record, I need to write\n_.get(book, \"title\"). I’d expect it to be book.title in dot notation or\nbook[\"title\"] in bracket notation.\nJoe Remember that book is a record that’s not represented as an object. It’s a map.\nIndeed, in JavaScript, you can write _.get(book, \"title\"), book.title, or\nbook[\"title\"]. But I prefer to use Lodash’s _.get function. In some lan-\nguages, the dot and the bracket notations might not work on maps.\n--- Page 90 ---\n62 CHAPTER 3 Basic data manipulation\nTheo Being language-agnostic has a price!\nJoe Right, would you like to test searchBooksByTitle?\nTheo Absolutely! Let me call searchBooksByTitle to search the books whose title\ncontain the string Watch.\nListing3.19 Testing searchBooksByTitle\nsearchBooksByTitle(catalogData, \"Wat\");\n//[\n// {\n// \"authorNames\": [\n// \"Alan Moore\",\n// \"Dave Gibbons\"\n// ],\n// \"isbn\": \"978-1779501127\",\n// \"title\": \"Watchmen\"\n// }\n//]\nTheo It seems to work! Are we done with the search implementation?\nJoe Almost. The searchBooksByTitle function we wrote is going to be part of the\nCatalog module, and it returns a collection of records. We have to write a\nfunction that’s part of the Library module, and that returns a JSON string.\nTheo You told me earlier that JSON serialization was straightforward in DOP.\nJoe Correct. The code for searchBooksByTitleJSON retrieves the Catalog record,\npasses it to searchBooksByTitle, and converts the results to JSON with\nJSON.stringify. That’s part of JavaScript. Here, let me show you.\nListing3.20 Implementation of searching books in a library as JSON\nfunction searchBooksByTitleJSON(libraryData, query) {\nvar results = searchBooksByTitle(_.get(libraryData, \"catalog\"), query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\nJoe In order to test our code, we need to create a Library record that contains our\nCatalog record. Could you do that for me, please?\nTheo Should the Library record contain all the Library fields (name, address,\nand UserManagement)?\nJoe That’s not necessary. For now, we only need the catalog field, then the test\nfor searching books.\nListing3.21 A Library record\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n--- Page 91 ---\n3.4 Calculating search results 63\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nListing3.22 Test for searching books in a library as JSON\nsearchBooksByTitleJSON(libraryData, \"Wat\");\nTheo How are we going to combine the four functions that we’ve written so far?\nJoe The functions authorNames, bookInfo, and searchBooksByTitle go into\nthe Catalog module, and searchBooksByTitleJSON goes into the Library\nmodule.\nTheo looks at the resulting code of the two modules, Library and Catalog. He’s quite\namazed by its conciseness.\nListing3.23 Calculating search results for Library and Catalog\nclass Catalog {\nstatic authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\n--- Page 92 ---\n64 CHAPTER 3 Basic data manipulation\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nThere’s no need\nreturn bookInfo;\nto create a class\n}\nfor bookInfo.\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nWhen _.filter is\nvar matchingBooks = _.filter(allBooks,\npassed a map, it\nfunction(book) {\ngoes over the values\nreturn _.get(book, \"title\").includes(query);\nof the map.\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nConverts data\nreturn resultsJSON;\nto JSON (part\n}\nof JavaScript)\n}\nAfter testing the final code in listing 3.24, Theo looks again at the source code from list-\ning 3.23. After a few seconds, he feels like he’s having another Aha! moment.\nListing3.24 Search results in JSON\nLibrary.searchBooksByTitleJSON(libraryData, \"Watchmen\");\n// → \"[{\\\"title\\\":\\\"Watchmen\\\",\\\"isbn\\\":\\\"978-1779501127\\\",\n// → \\\"authorNames\\\":[\\\"Alan Moore\\\",\\\"Dave Gibbons\\\"]}]\"\nTheo The important thing is not that the code is concise, but that the code contains\nno abstractions. It’s just data manipulation!\nJoe responds with a smile that says, “You got it, my friend!”\nJoe It reminds me of what my first meditation teacher told me 10 years ago:\nmeditation guides the mind to grasp the reality as it is without the abstractions\ncreated by our thoughts.\nTIP In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\n--- Page 93 ---\n3.5 Handling records of different types 65\n3.5 Handling records of different types\nWe’ve seen how DOP enables us to treat records as first-class citizens that can be\nmanipulated in a flexible way using generic functions. But if a record is nothing more\nthan an aggregation of fields, how do we know what the type of the record is? DOP has\na surprising answer to this question.\nTheo I have a question. If a record is nothing more than a map, how do you know\nthe type of the record?\nJoe That’s a great question with a surprising answer.\nTheo I’m curious.\nJoe Most of the time, there’s no need to know the record type.\nTheo What! What do you mean?\nJoe I mean that what matters most are the values of the fields. For example, take a\nlook at the Catalog.authorNames source code. It operates on a Book record,\nbut the only thing that matters is the value of the authorIds field.\nDoubtful, Theo looks at the source code for Catalog.authorNames. This is what Theo sees.\nListing3.25 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nTheo What about differentiating between various user types like Member versus\nLibrarian? I mean, they both have email and encryptedPassword. How do\nyou know if a record represents a Member or a Librarian?\nJoe Simple. You check to see if the record is found in the librariansByEmail\nindex or in the membersByEmail index of the Catalog.\nTheo Could you be more specific?\nJoe Sure! Let me write what the user management data of our tiny library might\nlook like, assuming we have one librarian and one member. To keep things\nsimple, I’m encrypting passwords through naive base-64 encoding for the User-\nManagement record.\nListing3.26 A UserManagement record\nvar userManagementData = {\n\"librariansByEmail\": {\n\"franck@gmail.com\" : { The base-64\nencoding of\n\"email\": \"franck@gmail.com\",\n\"mypassword\"\n\"encryptedPassword\": \"bXlwYXNzd29yZA==\"\n}\n},\n--- Page 94 ---\n66 CHAPTER 3 Basic data manipulation\n\"membersByEmail\": {\n\"samantha@gmail.com\": {\n\"email\": \"samantha@gmail.com\",\n\"encryptedPassword\": \"c2VjcmV0\",\nThe base-64\n\"isBlocked\": false,\nencoding of\n\"bookLendings\": [\n\"secret\"\n{\n\"bookItemId\": \"book-item-1\",\n\"bookIsbn\": \"978-1779501127\",\n\"lendingDate\": \"2020-04-23\"\n}\n]\n}\n}\n}\nTIP Most of the time, there’s no need to know the record type.\nTheo This morning, you told me you’d show me the code for UserManagement\n.isLibrarian function this afternoon.\nJoe So, here we are. It’s afternoon, and I’m going to fulfill my promise.\nJoe implements isLibrarian. With a slight pause, he then issues the test for isLibrarian.\nListing3.27 Checking if a user is a librarian\nfunction isLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nListing3.28 Testing isLibrarian\nisLibrarian(userManagementData, \"franck@gmail.com\");\n// → true\nTheo I’m assuming that _.has is a function that checks whether a key exists in a\nmap. Right?\nJoe Correct.\nTheo OK. You simply check whether the librariansByEmail map contains the\nemail field.\nJoe Yep.\nTheo Would you use the same pattern to check whether a member is a Super mem-\nber or a VIP member?\nJoe Sure. We could have SuperMembersByEmail and VIPMembersByEmail indexes.\nBut there’s a better way.\nTheo How?\nJoe When a member is a VIP member, we add a field, isVIP, with the value true to\nits record. To check if a member is a VIP member, we check whether the\nisVIP field is set to true in the member record. Here’s how I would code\nisVIPMember.\n--- Page 95 ---\n3.5 Handling records of different types 67\nListing3.29 Checking whether a member is a VIP member\nfunction isVIPMember(userManagement, email) {\nreturn _.get(userManagement, [\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nTheo I see that you access the isVIP field via its information path, [\"membersBy-\nEmail\", email, \"isVIP\"].\nJoe Yes, I think it makes the code crystal clear.\nTheo I agree. I guess we can do the same for isSuperMember and set an isSuper\nfield to true when a member is a Super member?\nJoe Yes, just like this.\nJoe assembles all the pieces in a UserManagement class. He then shows the code to Theo.\nListing3.30 The code of UserManagement module\nclass UserManagement {\nisLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nisVIPMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nisSuperMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isSuper\"]) == true;\n}\n}\nTheo looks at the UserManagement module code for a couple of seconds. Suddenly, an\nidea comes to his mind.\nTheo Why not have a type field in member record whose value would be either VIP\nor Super?\nJoe I assume that, according to the product requirements, a member can be both a\nVIP and a Super member.\nTheo Hmm...then the types field could be a collection containing VIP or Super\nor both.\nJoe In some situations, having a types field is helpful, but I find it simpler to have\na Boolean field for each feature that the record supports.\nTheo Is there a name for fields like isVIP and isSuper?\nJoe I call them feature fields.\nTIP Instead of maintaining type information about a record, use a feature field (e.g.,\nisVIP).\n--- Page 96 ---\n68 CHAPTER 3 Basic data manipulation\nTheo Can we use feature fields to differentiate between librarians and members?\nJoe You mean having an isLibrarian and an isMember field?\nTheo Yes, and having a common User record type for both librarians and members.\nJoe We can, but I think it’s simpler to have different record types for librarians and\nmembers: Librarian for librarians and Member for members.\nTheo Why?\nJoe Because there’s a clear distinction between librarians and members in terms of\ndata. For example, members can have book lendings but librarians don’t.\nTheo I agree. Now, we need to mention the two Member feature fields in our entity\ndiagram.\nWith that, Theo adds these fields to his diagram on the whiteboard. When he’s finished, he\nshows Joe his additions (figure 3.6).\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: Catalog\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian *\nCC Book id: String email: String CC Member\nname: String\ntitle : String encryptedPassword: String email: String\nbookIsbns: [String]\npublicationYear: Number encryptedPassword: String\nisbn: String * isBlocked: Boolean\nauthorIds: [String] bookLendings: [BookLending]\nbookItems: [BookItem] * isVIP: Boolean\nisSuper: Boolean\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.6 A library management data model with the Member feature fields isVIP and isSuper\nJoe Do you like the data model that we have designed together?\nTheo I find it quite simple and clear.\n--- Page 97 ---\nSummary 69\nJoe That’s the main goal of DOP.\nTheo Also, I’m pleasantly surprised how easy it is to adapt to changing requirements,\nboth in terms of code and the data model.\nJoe I suppose you’re also happy to get rid of complex class hierarchy diagrams.\nTheo Absolutely! Also, I think I’ve found an interesting connection between DOP\nand meditation.\nJoe Really?\nTheo When we were eating at Simple, you told me that meditation helped you expe-\nrience reality as it is without the filter of your thoughts.\nJoe Right.\nTheo From what you taught me today, I understand that in DOP, we are encouraged\nto treat data as data without the filter of our classes.\nJoe Clever! I never noticed that connection between those two disciplines that are\nso important for me. I guess you’d like to continue your journey in the realm\nof DOP.\nTheo Definitely. Let’s meet again tomorrow.\nJoe Unfortunately, tomorrow I’m taking my family to the beach to celebrate the\ntwelfth birthday of my eldest daughter, Aurelia.\nTheo Happy birthday, Aurelia!\nJoe We could meet again next Monday, if that’s OK with you.\nTheo With pleasure!\nSummary\n DOP principle #2 is to represent data entities with generic data structures.\n We refer to maps that have strings as keys as string maps.\n Representing data as data means representing records with string maps.\n By positional collection, we mean a collection where the elements are in order\n(like a list or an array).\n A positional collection of Strings is noted as [String].\n By index, we mean a collection where the elements are accessible via a key (like\na hash map or a dictionary).\n An index of Books is noted as {Book}.\n In the context of a data model, the index keys are always strings.\n A record is a data structure that groups together related data items. It’s a collec-\ntion of fields, possibly of different data types.\n A homogeneous map is a map where all the values are of the same type.\n A heterogeneous map is a map where the values are of different types.\n In DOP, we represent a record as a heterogeneous string map.\n A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes.\n The relation between records in a data entity diagram is either composition or\nassociation.\n--- Page 98 ---\n70 CHAPTER 3 Basic data manipulation\n The data part of a DOP system is flexible, and each piece of information is\naccessible via its information path.\n There is a tradeoff between flexibility and safety in a data model.\n DOP compromises on data safety to gain flexibility and genericity.\n In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\n We manipulate data with generic functions.\n Generic functions are provided either by the language itself or by third-party\nlibraries like Lodash.\n JSON serialization is implemented in terms of a generic function.\n On the one hand, we’ve lost the safety of accessing record fields via members\ndefined at compile time. On the other hand, we’ve liberated data from the lim-\nitation of classes and objects. Data is represented as data!\n The weak dependency between code and data makes it is easier to adapt to\nchanging requirements.\n When data is represented as data, it is straightforward to visualize system data.\n Usually, we do not need to maintain type information about a record.\n We can visualize any part of the system data.\n In statically-typed languages, we sometimes need to statically cast the field values.\n Instead of maintaining type information about a record, we use a feature field.\n There is no significant performance hit for accessing a field in a map instead of\na class member.\n In DOP, you can retrieve every piece of information via an information path and\na generic function.\n In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\nLodash functions introduced in this chapter\nFunction Description\nget(map, path) Gets the value of map at path\nhas(map, path) Checks if map has a field at path\nmerge(mapA, mapB) Creates a map resulting from the recursive merges between mapA and mapB\nvalues(map) Creates an array of values of map\nfilter(coll, pred) Iterates over elements of coll, returning an array of all elements for which\npred returns true\nmap(coll, f) Creates an array of values by running each element in coll through f\n--- Page 99 ---\nState management\nTime travel\nThis chapter covers\n A multi-version approach to state management\n The calculation phase of a mutation\n The commit phase of a mutation\n Keeping a history of previous state versions\nSo far, we have seen how DOP handles queries via generic functions that access sys-\ntem data, which is represented as a hash map. In this chapter, we illustrate how\nDOP deals with mutations (requests that change the system state). Instead of updat-\ning the state in place, we maintain multiple versions of the system data. At a specific\npoint in time, the system state refers to a specific version of the system data. This\nchapter is a deep dive in the third principle of DOP.\nPRINCIPLE #3 Data is immutable.\nThe maintenance of multiple versions of the system data requires the data to be\nimmutable. This is made efficient both in terms of computation and memory via a\n71\n--- Page 100 ---\n72 CHAPTER 4 State management\ntechnique called structural sharing, where parts of the data that are common between\ntwo versions are shared instead of being copied. In DOP, a mutation is split into two\ndistinct phases:\n In the calculation phase, we compute the next version of the system data.\n In the commit phase, we move the system state forward so that it refers to the\nversion of the system data computed by the calculation phase.\nThis distinction between calculation and commit phases allows us to reduce the part\nof our system that is stateful to its bare minimum. Only the code of the commit phase\nis stateful, while the code in the calculation phase of a mutation is stateless and is\nmade of generic functions similar to the code of a query. The implementation of the\ncommit phase is common to all mutations. As a consequence, inside the commit\nphase, we have the ability to ensure that the state always refers to a valid version of the\nsystem data.\nAnother benefit of this state management approach is that we can keep track of\nthe history of previous versions of the system data. Restoring the system to a previous\nstate (if needed) becomes straightforward. Table 4.1 shows the two phases.\nTable 4.1 The two phases of a mutation\nPhase Responsibility State Implementation\nCalculation Computes the next version of system data Stateless Specific\nCommit Moves the system state forward Stateful Common\nIn this chapter, we assume that no mutations occur concurrently in our system. In the\nnext chapter, we will deal with concurrency control.\n4.1 Multiple versions of the system data\nWhen Joe comes in to the office on Monday, he tells Theo that he needs to exercise before\nstarting to work with his mind. Theo and Joe go for a walk around the block, and the dis-\ncussion turns toward version control systems. They discuss how Git keeps track of the\nwhole commit history and how easy and fast it is to restore the code to a previous state.\nWhen Theo tells Joe that Git’s ability to “time travel” reminds him one of his favorite mov-\nies, Back to the Future, Joe shares that a month ago he watched the Back to the Future trilogy\nwith Neriah, his 14-year-old son.\nTheir walk complete, they arrive back at Theo’s office. Theo and Joe partake of the\nespresso machine in the kitchen before they begin today’s lesson.\nJoe So far, we’ve seen how we manage queries that retrieve information from the\nsystem in DOP. Now I’m going to show you how we manage mutations. By a\nmutation, I mean an operation that changes the state of the system.\n NOTE A mutation is an operation that changes the state of the system.\n--- Page 101 ---\n4.1 Multiple versions of the system data 73\nTheo Is there a fundamental difference between queries and mutations in DOP?\nAfter all, the whole state of the system is represented as a hash map. I could\neasily write code that modifies part of the hash map, and it would be similar to\nthe code that retrieves information from the hash map.\nJoe You could mutate the data in place, but then it would be challenging to ensure\nthat the code of a mutation doesn’t put the system into an invalid date. You\nwould also lose the ability to track previous versions of the system state.\nTheo I see. So, how do you handle mutations in DOP?\nJoe We adopt a multi-version state approach, similar to what a version control sys-\ntem like Git does; we manage different versions of the system data. At a specific\npoint in time, the state of the system refers to a version of the system data. After\na mutation is executed, we move the reference forward.\nTheo I’m confused. Is the system state mutable or immutable?\nJoe The data is immutable, but the state reference is mutable.\nTIP The data is immutable, but the state reference is mutable.\nNoticing the look of confusion on Theo’s face, Joe draws a quick diagram on the white-\nboard. He then shows Theo figure 4.1, hoping that it will clear up Theo’s perplexity.\nAfter mutation B After mutation C\nData V10 Data V10\nMutationA MutationA\nData V11 Data V11\nMutation B Mutation B\nSystem State Data V12 Data V12\nMutation C\nSystem State Data V13\nFigure 4.1 After mutation B is executed, the system state refers to Data V12. After\nmutation C is executed, the system state refers to Data V13.\nTheo Does that mean that before the code of a mutation runs, we make a copy of the\nsystem data?\nJoe No, that would be inefficient, as we would have to do a deep copy of the data.",
        "sections_found": []
      },
      "accurate_page_range": "76-101"
    },
    {
      "text": "- 3.4 Calculating search results",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "raw_line": "- 3.4 Calculating search results (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 26,
      "chapter_info": {
        "page": 76,
        "title": "Basic data manipulation",
        "pattern_matched": "Chapter 3",
        "text_preview": "48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to"
      },
      "chapter_sections": {
        "start_page": 76,
        "end_page": 101,
        "content": "\n--- Page 76 ---\n48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to say that a data entity diagram consists only of records, positional\ncollections, and indexes?\nJoe That’s correct. Can you make a similar statement about the relations between\nentities?\nTheo The relations in a data entity diagram are either composition (solid line with a\nfull diamond) or association (dashed line with an empty diamond). Both types\nof relations can be either one-to-one, one-to-many, or many-to-many.\nJoe Excellent!\nTIP A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes. The relation between records is either composition or\nassociation.\n3.2 Representing records as maps\nSo far, we’ve illustrated the benefits we gain from the separation between code and\ndata at a high-system level. There’s a separation of concerns between code and data,\nand each part has clear constraints:\n Code consists of static functions that receive data as an explicit argument.\n Data entities are modeled as records, and the relations between records are\nrepresented by positional collections and indexes.\nNow comes the question of the representation of the data. DOP has nothing special\ntosay about collections and indexes. However, it’s strongly opinionated about the\nrepresentation of records: records should be represented by generic data structures\nsuch as maps.\nThis applies to both OOP and FP languages. In dynamically-typed languages like\nJavaScript, Python, and Ruby, data representation feels natural. While in statically-\ntyped languages like Java and C#, it is a bit more cumbersome.\nTheo I’m really curious to know how we represent positional collections, indexes,\nand records in DOP.\nJoe Let’s start with positional collections. DOP has nothing special to say about the\nrepresentation of collections. They can be linked lists, arrays, vectors, sets, or\nother collections best suited for the use case.\nTheo It’s like in OOP.\nJoe Right! For now, to keep things simple, we’ll use arrays to represent positional\ncollections.\nTheo What about indexes?\nJoe Indexes are represented as homogeneous string maps.\nTheo What do you mean by a homogeneous map?\n--- Page 77 ---\n3.2 Representing records as maps 49\nJoe I mean that all the values of the map are of the same kind. For example, in a\nBook index, all the values are Book, and in an author index, all the values are\nAuthor, and so forth.\nTheo Again, it’s like in OOP.\n NOTE A homogeneous map is a map where all the values are of the same type. A hetero-\ngeneous map is a map where the values are of different types.\nJoe Now, here’s the big surprise. In DOP, records are represented as maps, more\nprecisely, heterogeneous string maps.\nJoe goes to the whiteboard and begins to draw. When he’s finished, he shows Theo the dia-\ngram in figure 3.4.\nRecord Heterogeneous map\nLinked list\nArray\nData representation Collection\nSet\nVector\nFigure 3.4 The building blocks\nIndex Homogeneous map\nof data representation\nTheo stays silent for a while. He is shocked to hear that the data entities of a system can be\nrepresented as a generic data structure, where the field names and value types are not\nspecified in a class. Then, Theo asks Joe:\nTheo What are the benefits of this folly?\nJoe Flexibility and genericity.\nTheo Could you explain, please?\nJoe I’ll explain in a moment, but before that, I’d like to show you what an instance\nof a record in a DOP system looks like.\nTheo OK.\nJoe Let’s take as an example, Watchmen, by Alan Moore and Dave Gibbons, which is\nmy favorite graphic novel. This masterpiece was published in 1987. I’m going\nto assume that, in a physical library, there are two copies of this book, whose ID\nis nyc-central-lib, and that one of the two copies is currently out. Here’s\nhow I’d represent the Book record for Watchmen in DOP.\nJoe comes closer to Theo’s laptop. He opens a text editor (not an IDE!) and types the Book\nrecord for Theo.\n--- Page 78 ---\n50 CHAPTER 3 Basic data manipulation\nListing3.1 An instance of a Book record represented as a map\n{\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\nTheo looks at the laptop screen. He has a question.\nTheo How am I supposed to instantiate the Book record for Watchmen programmat-\nically?\nJoe It depends on the facilities that your programming language offers to instantiate\nmaps. With dynamic languages like JavaScript, Ruby, or Python, it’s straight-\nforward, because we can use literals for maps and arrays. Here, let me show\nyou how.\nJoe jots down the JavaScript code that creates an instance of a Book record, which rep-\nresents as a map in JavaScript. He shows the code to Theo.\nListing3.2 A Book record represented as a map in JavaScript\nvar watchmenBook = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n--- Page 79 ---\n3.2 Representing records as maps 51\nTheo And, if I’m in Java?\nJoe It’s a bit more tedious, but still doable with the immutable Map and List static\nfactory methods.\n NOTE See “Creating Immutable Lists, Sets, and Maps” at http://mng.bz/voGm for\nmore information on this Java core library.\nJoe types the Java code to create an instance of a Book record represented as a map. He\nshows Theo the Java code.\nListing3.3 A Book record represented as a map in Java\nMap watchmen = Map.of(\n\"isbn\", \"978-1779501127\",\n\"title\", \"Watchmen\",\n\"publicationYear\", 1987,\n\"authors\", List.of(\"alan-moore\", \"dave-gibbons\"),\n\"bookItems\", List.of(\nMap.of(\n\"id\", \"book-item-1\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", true\n),\nMap.of (\n\"id\", \"book-item-2\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", false\n)\n)\n);\nTIP In DOP, we represent a record as a heterogeneous string map.\nTheo I’d definitely prefer to create a Book record using a Book class and a BookItem\nclass.\nTheo opens his IDE. He types the JavaScript code to represent a Book record as an instance\nof a Book class.\nListing3.4 A Book record as an instance of a Book class in JavaScript\nclass Book {\nisbn;\ntitle;\npublicationYear;\nauthors;\nbookItems;\nconstructor(isbn, title, publicationYear, authors, bookItems) {\nthis.isbn = isbn;\nthis.title = title;\nthis.publicationYear = publicationYear;\nthis.authors = authors;\nthis.bookItems = bookItems;\n--- Page 80 ---\n52 CHAPTER 3 Basic data manipulation\n}\n}\nclass BookItem {\nid;\nlibId;\nisLent;\nconstructor(id, libId, isLent) {\nthis.id = id;\nthis.libId = libId;\nthis.isLent = isLent;\n}\n}\nvar watchmenBook = new Book(\"978-1779501127\",\n\"Watchmen\",\n1987,\n[\"alan-moore\", \"dave-gibbons\"],\n[new BookItem(\"book-item-1\", \"nyc-central-lib\", true),\nnew BookItem(\"book-item-2\", \"nyc-central-lib\", false)]);\nJoe Theo, why do you prefer classes over maps for representing records?\nTheo It makes the data shape of the record part of my program. As a result, the IDE\ncan auto-complete field names, and errors are caught at compile time.\nJoe Fair enough. Can I show you some drawbacks for this approach?\nTheo Sure.\nJoe Imagine that you want to display the information about a book in the context\nof search results. In that case, instead of author IDs, you want to display\nauthor names, and you don’t need the book item information. How would\nyou handle that?\nTheo I’d create a class BookInSearchResults without a bookItems member and\nwith an authorNames member instead of the authorIds member of the Book\nclass. Also, I would need to write a copy constructor that receives a Book object.\nJoe In classic OOP, the fact that data is instantiated only via classes brings safety.\nBut this safety comes at the cost of flexibility.\nTIP There’s a tradeoff between flexibility and safety in a data model.\nTheo So, how can it be different?\nJoe In the DOP approach, where records are represented as maps, we don’t need\nto create a class for each variation of the data. We’re free to add, remove, and\nrename record fields dynamically. Our data model is flexible.\nTheo Interesting!\nTIP In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\nJoe Now, let me talk about genericity. How would you serialize the content of a\nBook object to JSON?\n--- Page 81 ---\n3.2 Representing records as maps 53\nTIP In DOP, records are manipulated with generic functions.\nTheo Oh no! I remember that while working on the Klafim prototype, I had a night-\nmare about JSON serialization when I was developing the first version of the\nLibrary Management System.\nJoe Well, in DOP, serializing a record to JSON is super easy.\nTheo Does it require the usage of reflection in order to go over the fields of the\nrecord like the Gson Java library does?\n NOTE See https://github.com/google/gson for more information on Gson.\nJoe Not at all! Remember that in DOP, a record is nothing more than data. We can\nwrite a generic JSON serialization function that works with any record. It can\nbe a Book, an Author, a BookItem, or anything else.\nTheo Amazing!\nTIP In DOP, you get JSON serialization for free.\nJoe Actually, as I’ll show you in a moment, lots of data manipulation stuff can be\ndone using generic functions.\nTheo Are the generic functions part of the language?\nJoe It depends on the functions and on the language. For example, JavaScript pro-\nvides a JSON serialization function called JSON.stringify out of the box, but\nnone for omitting multiple keys or for renaming keys.\nTheo That’s annoying.\nJoe Not so much; there are third-party libraries that provide data-manipulation facil-\nities. A popular data manipulation library in the JavaScript ecosystem is Lodash.\n NOTE See https://lodash.com/ to find out more about Lodash.\nTheo What about other languages?\nJoe Lodash has been ported to Java, C#, Python, and Ruby. Let me bookmark some\nsites for you.\nJoe bookmarks these sites for Theo:\n https://javalibs.com/artifact/com.github.javadev/underscore-lodash for Java\n https://www.nuget.org/packages/lodash/ for C#\n https://github.com/dgilland/pydash for Python\n https://rudash-website.now.sh/ for Ruby\n NOTE Throughout the book, we use Lodash to show how to manipulate data with\ngeneric functions, but there is nothing special about Lodash. The exact same approach\ncould be implemented via other data manipulation libraries or custom code.\nTheo Cool!\nJoe Actually, Lodash and its rich set of data manipulation functions can be ported\nto any language. That’s why it’s so beneficial to represent records as maps.\n--- Page 82 ---\n54 CHAPTER 3 Basic data manipulation\nTIP DOP compromises on data safety to gain flexibility and genericity.\nAt the whiteboard, Joe quickly sketches the tradeoffs (see table 3.1).\nTable 3.1 The tradeoff among safety, flexibility, and genericity\nOOP DOP\nSafety High Low\nFlexibility Low High\nGenericity Low High\n3.3 Manipulating data with generic functions\nJoe Now let me show you how to manipulate data in DOP with generic functions.\nTheo Yes, I’m quite curious to see how you’ll implement the search functionality of\nthe Library Management System.\nJoe OK. First, let’s instantiate a Catalog record for the catalog data of a library,\nwhere we have a single book, Watchmen.\nJoe instantiates a Catalog record according to Theo’s data model in figure 3.3. Here’s\nwhat Joe shows to Theo.\nListing3.5 A Catalog record\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n--- Page 83 ---\n3.3 Manipulating data with generic functions 55\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\nTheo I see the two indexes we talked about, booksByIsbn and authorsById. How\ndo you differentiate a record from an index in DOP?\nJoe In an entity diagram, there’s a clear distinction between records and indexes.\nBut in our code, both are plain data.\nTheo I guess that’s why this approach is called data-oriented programming.\nJoe See how straightforward it is to visualize any part of the system data inside a\nprogram? The reason is that data is represented as data!\nTIP In DOP, data is represented as data.\nTheo That sounds like a lapalissade.1\nJoe Oh, does it? I’m not so sure! In OOP, data is usually represented by objects,\nwhich makes it more challenging to visualize data inside a program.\nTIP In DOP, we can visualize any part of the system data.\nTheo How would you retrieve the title of a specific book from the catalog data?\nJoe Great question! In fact, in a DOP system, every piece of information has an\ninformation path from which we can retrieve the information.\nTheo Information path?\nJoe For example, the information path to the title of the Watchmen book in the\ncatalog is [\"booksByIsbn\", \"978-1779501127\", \"title\"].\nTheo Ah, I see. So, is an information path sort of like a file path, but that names in\nan information path correspond to nested entities?\nJoe You’re exactly right. And once we have the path of a piece of information, we\ncan retrieve the information with Lodash’s _.get function.\nJoe types a few characters on Theo’s laptop. Theo is amazed at how little code is needed to\nget the book title.\nListing3.6 Retrieving the title of a book from its information path\n_.get(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"])\n// → \"Watchmen\"\nTheo Neat. I wonder how hard it would be to implement a function like _.get\nmyself.\n1 A lapalissade is an obvious truth—a truism or tautology—that produces a comical effect.\n--- Page 84 ---\n56 CHAPTER 3 Basic data manipulation\nAfter a few minutes of trial and error, Theo is able to produce his implementation. He\nshows Joe the code.\nListing3.7 Custom implementation of get\nfunction get(m, path) {\nvar res = m;\nfor(var i = 0; i < path.length; i++) {\nWe could use\nvar key = path[i];\nforEach instead\nres = res[key];\nof a for loop.\n}\nreturn res;\n}\nAfter testing Theo’s implementation of get, Joe compliments Theo. He’s grateful that\nTheo is catching on so quickly.\nListing3.8 Testing the custom implementation of get\nget(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"]);\n// → \"Watchmen\"\nJoe Well done!\nTheo I wonder if a function like _.get works smoothly in a statically-typed language\nlike Java?\nJoe It depends on whether you only need to pass the value around or to access the\nvalue concretely.\nTheo I don’t follow.\nJoe Imagine that once you get the title of a book, you want to convert the string\ninto an uppercase string. You need to do a static cast to String, right? Here,\nlet me show you an example that casts a field value to a string, then we can\nmanipulate it as a string.\nListing3.9 Casting a field value to a string\n((String)watchmen.get(\"title\")).toUpperCase()\nTheo That makes sense. The values of the map are of different types, so the compiler\ndeclares it as a Map<String,Object>. The information of the type of the field\nis lost.\nJoe It’s a bit annoying, but quite often our code just passes the data around. In that\ncase, we don’t have to deal with static casting. Moreover, in a language like C#,\nwhen using the dynamic data type, type casting can be avoided.2,3\n2 See http://mng.bz/4jo5 for the C# documentation on the built-in reference to dynamic types.\n3 See appendix A for details about dynamic fields and type casting in C#.\n--- Page 85 ---\n3.3 Manipulating data with generic functions 57\nTIP In statically-typed languages, we sometimes need to statically cast the field values.\nTheo What about performance?\nJoe In most programming languages, maps are quite efficient. Accessing a field\nin a map is slightly slower than accessing a class member. Usually, it’s not\nsignificant.\nTIP There’s no significant performance hit for accessing a field in a map instead of as\na class member.\nTheo Let’s get back to this idea of information path. It works in OOP too. I could\naccess the title of the Watchmen book with catalogData.booksByIsbn[\"978-\n1779501127\"].title. I’d use class members for record fields and strings for\nindex keys.\nJoe There’s a fundamental difference, though. When records are represented as\nmaps, the information can be retrieved via its information path using a generic\nfunction like _.get. But when records are represented as objects, you need to\nwrite specific code for each type of information path.\nTheo What do you mean by specific code? What’s specific in catalogData.books-\nByIsbn[\"978-1779501127\"].title?\nJoe In a statically-typed language like Java, you’d need to import the class defini-\ntions for Catalog and Book.\nTheo And, in a dynamically-typed language like JavaScript...?\nJoe Even in JavaScript, when you represent records with objects instantiated from\nclasses, you can’t easily write a function that receives a path as an argument\nand display the information that corresponds to this path. You would have to\nwrite specific code for each kind of path. You’d access class members with dot\nnotation and map fields with bracket notation.\nTheo Would you say that in DOP, the information path is a first-class citizen?\nJoe Absolutely! The information path can be stored in a variable and passed as an\nargument to a function.\nTIP In DOP, you can retrieve every piece of information via a path and a generic\nfunction.\nJoe goes to the whiteboard. He draws a diagram like that in figure 3.5, which shows the\ncatalog data as a tree.\nJoe You see, Theo, each piece of information is accessible via a path made of\nstrings and integers. For example, the path of Alan Moore’s first book is\n[\"catalog\", \"authorsById\", \"alan-moore\", \"bookIsbns\", 0].\n--- Page 86 ---\n58 CHAPTER 3 Basic data manipulation\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 3.5 The catalog data as a tree\n3.4 Calculating search results\nTheo Interesting. I’m starting to feel the power of expression of DOP!\nJoe Wait, that’s just the beginning. Let me show you how simple it is to write code\nthat retrieves book information and displays it in search results. Can you tell\nme exactly what information has to appear in the search results?\nTheo Searching for book information should return isbn, title, and author-\nNames.\nJoe And what would a BookInfo record look like for Watchmen?\nTheo quickly enters the code on his laptop. He then shows it to Joe.\nListing3.10 A BookInfo record for Watchmen in the context of search result\n{\n\"title\": \"Watchmen\",\n\"isbn\": \"978-1779501127\",\n\"authorNames\": [\n\"Alan Moore\",\n\"Dave Gibbons\",\n]\n}\n--- Page 87 ---\n3.4 Calculating search results 59\nJoe Now I’ll show you step by step how to write a function that returns search\nresults matching a title in JSON format. I’ll use generic data manipulation\nfunctions from Lodash.\nTheo I’m ready!\nJoe Let’s start with an authorNames function that calculates the author names of a\nBook record by looking at the authorsById index. Could you tell me what’s\nthe information path for the name of an author whose ID is authorId?\nTheo It’s [\"authorsById\", authorId, \"name\"].\nJoe Now, let me show you how to retrieve the name of several authors using _.map.\nJoe types the code to map the author IDs to the author names. Theo nonchalantly peeks\nover Joe’s shoulder.\nListing3.11 Mapping author IDs to author names\n_.map([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\nTheo What’s this _.map function? It smells like functional programming! You said I\nwouldn’t have to learn FP to implement DOP!\nJoe No need to learn functional programming in order to use _.map, which is a\nfunction that transforms the values of a collection. You can implement it with\na simple for loop.\nTheo spends a couple of minutes in front of his computer figuring out how to implement\n_.map. Now he’s got it!\nListing3.12 Custom implementation of map\nfunction map(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nres[i] = f(coll[i]);\nforEach instead\n}\nof a for loop.\nreturn res;\n}\nAfter testing Theo’s implementation of map, Joe shows Theo the test. Joe again compli-\nments Theo.\nListing3.13 Testing the custom implementation of map\nmap([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\n--- Page 88 ---\n60 CHAPTER 3 Basic data manipulation\nJoe Well done!\nTheo You were right! It wasn’t hard.\nJoe Now, let’s implement authorNames using _.map.\nIt takes a few minutes for Theo to come up with the implementation of authorNames.\nWhen he’s finished, he turns his laptop to Joe.\nListing3.14 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nJoe We also need a bookInfo function that converts a Book record into a Book-\nInfo record. Let me show you the code for that.\nListing3.15 Converting a Book record into a BookInfo record\nfunction bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": authorNames(catalogData, book)\n};\nThere’s no need to create\nreturn bookInfo;\na class for bookInfo.\n}\nTheo Looking at the code, I see that a BookInfo record has three fields: title,\nisbn, and authorNames. Is there a way to get this information without looking\nat the code?\nJoe You can either add it to the data entity diagram or write it in the documenta-\ntion of the bookInfo function, or both.\nTheo I have to get used to the idea that in DOP, the record field information is not\npart of the program.\nJoe Indeed, it’s not part of the program, but it gives us a lot of flexibility.\nTheo Is there any way for me to have my cake and eat it too?\nJoe Yes, and someday I’ll show you how to make record field information part of a\nDOP program (see chapters 7 and 12).\nTheo Sounds intriguing!\nJoe Now that we have all the pieces in place, we can write our searchBooksBy-\nTitle function, which returns the book information about the books that\nmatch the query. First, we find the Book records that match the query with\n_.filter and then we transform each Book record into a BookInfo record\nwith _.map and bookInfo.\n--- Page 89 ---\n3.4 Calculating search results 61\nListing3.16 Searching books that match a query\nfunction searchBooksByTitle(catalogData, query) {\nvar allBooks = _.values(_.get(catalogData, \"booksByIsbn\"));\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\nThe includes JavaScript\n});\nfunction checks whether\na string includes a string\nvar bookInfos = _.map(matchingBooks, function(book) { as a substring.\nreturn bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\nTheo You’re using Lodash functions without any explanation again!\nJoe Sorry about that. I am so used to basic data manipulation functions that I con-\nsider them as part of the language. What functions are new to you?\nTheo _.values and _.filter\nJoe Well, _.values returns a collection made of the values of a map, and _.filter\nreturns a collection made of the values that satisfy a predicate.\nTheo _.values seems trivial. Let me try to implement _.filter.\nThe implementation of _.filter takes a bit more time. Eventually, Theo manages to get\nit right, then he is able to test it.\nListing3.17 Custom implementation of filter\nfunction filter(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nif(f(coll[i])) {\nforEach instead\nres.push(coll[i]);\nof a for loop.\n}\n}\nreturn res;\n}\nListing3.18 Testing the custom implementation of filter\nfilter([\"Watchmen\", \"Batman\"], function (title) {\nreturn title.includes(\"Watch\");\n});\n// → [\"Watchmen\"]\nTheo To me, it’s a bit weird that to access the title of a book record, I need to write\n_.get(book, \"title\"). I’d expect it to be book.title in dot notation or\nbook[\"title\"] in bracket notation.\nJoe Remember that book is a record that’s not represented as an object. It’s a map.\nIndeed, in JavaScript, you can write _.get(book, \"title\"), book.title, or\nbook[\"title\"]. But I prefer to use Lodash’s _.get function. In some lan-\nguages, the dot and the bracket notations might not work on maps.\n--- Page 90 ---\n62 CHAPTER 3 Basic data manipulation\nTheo Being language-agnostic has a price!\nJoe Right, would you like to test searchBooksByTitle?\nTheo Absolutely! Let me call searchBooksByTitle to search the books whose title\ncontain the string Watch.\nListing3.19 Testing searchBooksByTitle\nsearchBooksByTitle(catalogData, \"Wat\");\n//[\n// {\n// \"authorNames\": [\n// \"Alan Moore\",\n// \"Dave Gibbons\"\n// ],\n// \"isbn\": \"978-1779501127\",\n// \"title\": \"Watchmen\"\n// }\n//]\nTheo It seems to work! Are we done with the search implementation?\nJoe Almost. The searchBooksByTitle function we wrote is going to be part of the\nCatalog module, and it returns a collection of records. We have to write a\nfunction that’s part of the Library module, and that returns a JSON string.\nTheo You told me earlier that JSON serialization was straightforward in DOP.\nJoe Correct. The code for searchBooksByTitleJSON retrieves the Catalog record,\npasses it to searchBooksByTitle, and converts the results to JSON with\nJSON.stringify. That’s part of JavaScript. Here, let me show you.\nListing3.20 Implementation of searching books in a library as JSON\nfunction searchBooksByTitleJSON(libraryData, query) {\nvar results = searchBooksByTitle(_.get(libraryData, \"catalog\"), query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\nJoe In order to test our code, we need to create a Library record that contains our\nCatalog record. Could you do that for me, please?\nTheo Should the Library record contain all the Library fields (name, address,\nand UserManagement)?\nJoe That’s not necessary. For now, we only need the catalog field, then the test\nfor searching books.\nListing3.21 A Library record\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n--- Page 91 ---\n3.4 Calculating search results 63\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nListing3.22 Test for searching books in a library as JSON\nsearchBooksByTitleJSON(libraryData, \"Wat\");\nTheo How are we going to combine the four functions that we’ve written so far?\nJoe The functions authorNames, bookInfo, and searchBooksByTitle go into\nthe Catalog module, and searchBooksByTitleJSON goes into the Library\nmodule.\nTheo looks at the resulting code of the two modules, Library and Catalog. He’s quite\namazed by its conciseness.\nListing3.23 Calculating search results for Library and Catalog\nclass Catalog {\nstatic authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\n--- Page 92 ---\n64 CHAPTER 3 Basic data manipulation\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nThere’s no need\nreturn bookInfo;\nto create a class\n}\nfor bookInfo.\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nWhen _.filter is\nvar matchingBooks = _.filter(allBooks,\npassed a map, it\nfunction(book) {\ngoes over the values\nreturn _.get(book, \"title\").includes(query);\nof the map.\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nConverts data\nreturn resultsJSON;\nto JSON (part\n}\nof JavaScript)\n}\nAfter testing the final code in listing 3.24, Theo looks again at the source code from list-\ning 3.23. After a few seconds, he feels like he’s having another Aha! moment.\nListing3.24 Search results in JSON\nLibrary.searchBooksByTitleJSON(libraryData, \"Watchmen\");\n// → \"[{\\\"title\\\":\\\"Watchmen\\\",\\\"isbn\\\":\\\"978-1779501127\\\",\n// → \\\"authorNames\\\":[\\\"Alan Moore\\\",\\\"Dave Gibbons\\\"]}]\"\nTheo The important thing is not that the code is concise, but that the code contains\nno abstractions. It’s just data manipulation!\nJoe responds with a smile that says, “You got it, my friend!”\nJoe It reminds me of what my first meditation teacher told me 10 years ago:\nmeditation guides the mind to grasp the reality as it is without the abstractions\ncreated by our thoughts.\nTIP In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\n--- Page 93 ---\n3.5 Handling records of different types 65\n3.5 Handling records of different types\nWe’ve seen how DOP enables us to treat records as first-class citizens that can be\nmanipulated in a flexible way using generic functions. But if a record is nothing more\nthan an aggregation of fields, how do we know what the type of the record is? DOP has\na surprising answer to this question.\nTheo I have a question. If a record is nothing more than a map, how do you know\nthe type of the record?\nJoe That’s a great question with a surprising answer.\nTheo I’m curious.\nJoe Most of the time, there’s no need to know the record type.\nTheo What! What do you mean?\nJoe I mean that what matters most are the values of the fields. For example, take a\nlook at the Catalog.authorNames source code. It operates on a Book record,\nbut the only thing that matters is the value of the authorIds field.\nDoubtful, Theo looks at the source code for Catalog.authorNames. This is what Theo sees.\nListing3.25 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nTheo What about differentiating between various user types like Member versus\nLibrarian? I mean, they both have email and encryptedPassword. How do\nyou know if a record represents a Member or a Librarian?\nJoe Simple. You check to see if the record is found in the librariansByEmail\nindex or in the membersByEmail index of the Catalog.\nTheo Could you be more specific?\nJoe Sure! Let me write what the user management data of our tiny library might\nlook like, assuming we have one librarian and one member. To keep things\nsimple, I’m encrypting passwords through naive base-64 encoding for the User-\nManagement record.\nListing3.26 A UserManagement record\nvar userManagementData = {\n\"librariansByEmail\": {\n\"franck@gmail.com\" : { The base-64\nencoding of\n\"email\": \"franck@gmail.com\",\n\"mypassword\"\n\"encryptedPassword\": \"bXlwYXNzd29yZA==\"\n}\n},\n--- Page 94 ---\n66 CHAPTER 3 Basic data manipulation\n\"membersByEmail\": {\n\"samantha@gmail.com\": {\n\"email\": \"samantha@gmail.com\",\n\"encryptedPassword\": \"c2VjcmV0\",\nThe base-64\n\"isBlocked\": false,\nencoding of\n\"bookLendings\": [\n\"secret\"\n{\n\"bookItemId\": \"book-item-1\",\n\"bookIsbn\": \"978-1779501127\",\n\"lendingDate\": \"2020-04-23\"\n}\n]\n}\n}\n}\nTIP Most of the time, there’s no need to know the record type.\nTheo This morning, you told me you’d show me the code for UserManagement\n.isLibrarian function this afternoon.\nJoe So, here we are. It’s afternoon, and I’m going to fulfill my promise.\nJoe implements isLibrarian. With a slight pause, he then issues the test for isLibrarian.\nListing3.27 Checking if a user is a librarian\nfunction isLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nListing3.28 Testing isLibrarian\nisLibrarian(userManagementData, \"franck@gmail.com\");\n// → true\nTheo I’m assuming that _.has is a function that checks whether a key exists in a\nmap. Right?\nJoe Correct.\nTheo OK. You simply check whether the librariansByEmail map contains the\nemail field.\nJoe Yep.\nTheo Would you use the same pattern to check whether a member is a Super mem-\nber or a VIP member?\nJoe Sure. We could have SuperMembersByEmail and VIPMembersByEmail indexes.\nBut there’s a better way.\nTheo How?\nJoe When a member is a VIP member, we add a field, isVIP, with the value true to\nits record. To check if a member is a VIP member, we check whether the\nisVIP field is set to true in the member record. Here’s how I would code\nisVIPMember.\n--- Page 95 ---\n3.5 Handling records of different types 67\nListing3.29 Checking whether a member is a VIP member\nfunction isVIPMember(userManagement, email) {\nreturn _.get(userManagement, [\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nTheo I see that you access the isVIP field via its information path, [\"membersBy-\nEmail\", email, \"isVIP\"].\nJoe Yes, I think it makes the code crystal clear.\nTheo I agree. I guess we can do the same for isSuperMember and set an isSuper\nfield to true when a member is a Super member?\nJoe Yes, just like this.\nJoe assembles all the pieces in a UserManagement class. He then shows the code to Theo.\nListing3.30 The code of UserManagement module\nclass UserManagement {\nisLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nisVIPMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nisSuperMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isSuper\"]) == true;\n}\n}\nTheo looks at the UserManagement module code for a couple of seconds. Suddenly, an\nidea comes to his mind.\nTheo Why not have a type field in member record whose value would be either VIP\nor Super?\nJoe I assume that, according to the product requirements, a member can be both a\nVIP and a Super member.\nTheo Hmm...then the types field could be a collection containing VIP or Super\nor both.\nJoe In some situations, having a types field is helpful, but I find it simpler to have\na Boolean field for each feature that the record supports.\nTheo Is there a name for fields like isVIP and isSuper?\nJoe I call them feature fields.\nTIP Instead of maintaining type information about a record, use a feature field (e.g.,\nisVIP).\n--- Page 96 ---\n68 CHAPTER 3 Basic data manipulation\nTheo Can we use feature fields to differentiate between librarians and members?\nJoe You mean having an isLibrarian and an isMember field?\nTheo Yes, and having a common User record type for both librarians and members.\nJoe We can, but I think it’s simpler to have different record types for librarians and\nmembers: Librarian for librarians and Member for members.\nTheo Why?\nJoe Because there’s a clear distinction between librarians and members in terms of\ndata. For example, members can have book lendings but librarians don’t.\nTheo I agree. Now, we need to mention the two Member feature fields in our entity\ndiagram.\nWith that, Theo adds these fields to his diagram on the whiteboard. When he’s finished, he\nshows Joe his additions (figure 3.6).\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: Catalog\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian *\nCC Book id: String email: String CC Member\nname: String\ntitle : String encryptedPassword: String email: String\nbookIsbns: [String]\npublicationYear: Number encryptedPassword: String\nisbn: String * isBlocked: Boolean\nauthorIds: [String] bookLendings: [BookLending]\nbookItems: [BookItem] * isVIP: Boolean\nisSuper: Boolean\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.6 A library management data model with the Member feature fields isVIP and isSuper\nJoe Do you like the data model that we have designed together?\nTheo I find it quite simple and clear.\n--- Page 97 ---\nSummary 69\nJoe That’s the main goal of DOP.\nTheo Also, I’m pleasantly surprised how easy it is to adapt to changing requirements,\nboth in terms of code and the data model.\nJoe I suppose you’re also happy to get rid of complex class hierarchy diagrams.\nTheo Absolutely! Also, I think I’ve found an interesting connection between DOP\nand meditation.\nJoe Really?\nTheo When we were eating at Simple, you told me that meditation helped you expe-\nrience reality as it is without the filter of your thoughts.\nJoe Right.\nTheo From what you taught me today, I understand that in DOP, we are encouraged\nto treat data as data without the filter of our classes.\nJoe Clever! I never noticed that connection between those two disciplines that are\nso important for me. I guess you’d like to continue your journey in the realm\nof DOP.\nTheo Definitely. Let’s meet again tomorrow.\nJoe Unfortunately, tomorrow I’m taking my family to the beach to celebrate the\ntwelfth birthday of my eldest daughter, Aurelia.\nTheo Happy birthday, Aurelia!\nJoe We could meet again next Monday, if that’s OK with you.\nTheo With pleasure!\nSummary\n DOP principle #2 is to represent data entities with generic data structures.\n We refer to maps that have strings as keys as string maps.\n Representing data as data means representing records with string maps.\n By positional collection, we mean a collection where the elements are in order\n(like a list or an array).\n A positional collection of Strings is noted as [String].\n By index, we mean a collection where the elements are accessible via a key (like\na hash map or a dictionary).\n An index of Books is noted as {Book}.\n In the context of a data model, the index keys are always strings.\n A record is a data structure that groups together related data items. It’s a collec-\ntion of fields, possibly of different data types.\n A homogeneous map is a map where all the values are of the same type.\n A heterogeneous map is a map where the values are of different types.\n In DOP, we represent a record as a heterogeneous string map.\n A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes.\n The relation between records in a data entity diagram is either composition or\nassociation.\n--- Page 98 ---\n70 CHAPTER 3 Basic data manipulation\n The data part of a DOP system is flexible, and each piece of information is\naccessible via its information path.\n There is a tradeoff between flexibility and safety in a data model.\n DOP compromises on data safety to gain flexibility and genericity.\n In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\n We manipulate data with generic functions.\n Generic functions are provided either by the language itself or by third-party\nlibraries like Lodash.\n JSON serialization is implemented in terms of a generic function.\n On the one hand, we’ve lost the safety of accessing record fields via members\ndefined at compile time. On the other hand, we’ve liberated data from the lim-\nitation of classes and objects. Data is represented as data!\n The weak dependency between code and data makes it is easier to adapt to\nchanging requirements.\n When data is represented as data, it is straightforward to visualize system data.\n Usually, we do not need to maintain type information about a record.\n We can visualize any part of the system data.\n In statically-typed languages, we sometimes need to statically cast the field values.\n Instead of maintaining type information about a record, we use a feature field.\n There is no significant performance hit for accessing a field in a map instead of\na class member.\n In DOP, you can retrieve every piece of information via an information path and\na generic function.\n In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\nLodash functions introduced in this chapter\nFunction Description\nget(map, path) Gets the value of map at path\nhas(map, path) Checks if map has a field at path\nmerge(mapA, mapB) Creates a map resulting from the recursive merges between mapA and mapB\nvalues(map) Creates an array of values of map\nfilter(coll, pred) Iterates over elements of coll, returning an array of all elements for which\npred returns true\nmap(coll, f) Creates an array of values by running each element in coll through f\n--- Page 99 ---\nState management\nTime travel\nThis chapter covers\n A multi-version approach to state management\n The calculation phase of a mutation\n The commit phase of a mutation\n Keeping a history of previous state versions\nSo far, we have seen how DOP handles queries via generic functions that access sys-\ntem data, which is represented as a hash map. In this chapter, we illustrate how\nDOP deals with mutations (requests that change the system state). Instead of updat-\ning the state in place, we maintain multiple versions of the system data. At a specific\npoint in time, the system state refers to a specific version of the system data. This\nchapter is a deep dive in the third principle of DOP.\nPRINCIPLE #3 Data is immutable.\nThe maintenance of multiple versions of the system data requires the data to be\nimmutable. This is made efficient both in terms of computation and memory via a\n71\n--- Page 100 ---\n72 CHAPTER 4 State management\ntechnique called structural sharing, where parts of the data that are common between\ntwo versions are shared instead of being copied. In DOP, a mutation is split into two\ndistinct phases:\n In the calculation phase, we compute the next version of the system data.\n In the commit phase, we move the system state forward so that it refers to the\nversion of the system data computed by the calculation phase.\nThis distinction between calculation and commit phases allows us to reduce the part\nof our system that is stateful to its bare minimum. Only the code of the commit phase\nis stateful, while the code in the calculation phase of a mutation is stateless and is\nmade of generic functions similar to the code of a query. The implementation of the\ncommit phase is common to all mutations. As a consequence, inside the commit\nphase, we have the ability to ensure that the state always refers to a valid version of the\nsystem data.\nAnother benefit of this state management approach is that we can keep track of\nthe history of previous versions of the system data. Restoring the system to a previous\nstate (if needed) becomes straightforward. Table 4.1 shows the two phases.\nTable 4.1 The two phases of a mutation\nPhase Responsibility State Implementation\nCalculation Computes the next version of system data Stateless Specific\nCommit Moves the system state forward Stateful Common\nIn this chapter, we assume that no mutations occur concurrently in our system. In the\nnext chapter, we will deal with concurrency control.\n4.1 Multiple versions of the system data\nWhen Joe comes in to the office on Monday, he tells Theo that he needs to exercise before\nstarting to work with his mind. Theo and Joe go for a walk around the block, and the dis-\ncussion turns toward version control systems. They discuss how Git keeps track of the\nwhole commit history and how easy and fast it is to restore the code to a previous state.\nWhen Theo tells Joe that Git’s ability to “time travel” reminds him one of his favorite mov-\nies, Back to the Future, Joe shares that a month ago he watched the Back to the Future trilogy\nwith Neriah, his 14-year-old son.\nTheir walk complete, they arrive back at Theo’s office. Theo and Joe partake of the\nespresso machine in the kitchen before they begin today’s lesson.\nJoe So far, we’ve seen how we manage queries that retrieve information from the\nsystem in DOP. Now I’m going to show you how we manage mutations. By a\nmutation, I mean an operation that changes the state of the system.\n NOTE A mutation is an operation that changes the state of the system.\n--- Page 101 ---\n4.1 Multiple versions of the system data 73\nTheo Is there a fundamental difference between queries and mutations in DOP?\nAfter all, the whole state of the system is represented as a hash map. I could\neasily write code that modifies part of the hash map, and it would be similar to\nthe code that retrieves information from the hash map.\nJoe You could mutate the data in place, but then it would be challenging to ensure\nthat the code of a mutation doesn’t put the system into an invalid date. You\nwould also lose the ability to track previous versions of the system state.\nTheo I see. So, how do you handle mutations in DOP?\nJoe We adopt a multi-version state approach, similar to what a version control sys-\ntem like Git does; we manage different versions of the system data. At a specific\npoint in time, the state of the system refers to a version of the system data. After\na mutation is executed, we move the reference forward.\nTheo I’m confused. Is the system state mutable or immutable?\nJoe The data is immutable, but the state reference is mutable.\nTIP The data is immutable, but the state reference is mutable.\nNoticing the look of confusion on Theo’s face, Joe draws a quick diagram on the white-\nboard. He then shows Theo figure 4.1, hoping that it will clear up Theo’s perplexity.\nAfter mutation B After mutation C\nData V10 Data V10\nMutationA MutationA\nData V11 Data V11\nMutation B Mutation B\nSystem State Data V12 Data V12\nMutation C\nSystem State Data V13\nFigure 4.1 After mutation B is executed, the system state refers to Data V12. After\nmutation C is executed, the system state refers to Data V13.\nTheo Does that mean that before the code of a mutation runs, we make a copy of the\nsystem data?\nJoe No, that would be inefficient, as we would have to do a deep copy of the data.",
        "sections_found": []
      },
      "accurate_page_range": "76-101"
    },
    {
      "text": "- 3.5 Handling records of different types",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "raw_line": "- 3.5 Handling records of different types (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 27,
      "chapter_info": {
        "page": 76,
        "title": "Basic data manipulation",
        "pattern_matched": "Chapter 3",
        "text_preview": "48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to"
      },
      "chapter_sections": {
        "start_page": 76,
        "end_page": 101,
        "content": "\n--- Page 76 ---\n48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to say that a data entity diagram consists only of records, positional\ncollections, and indexes?\nJoe That’s correct. Can you make a similar statement about the relations between\nentities?\nTheo The relations in a data entity diagram are either composition (solid line with a\nfull diamond) or association (dashed line with an empty diamond). Both types\nof relations can be either one-to-one, one-to-many, or many-to-many.\nJoe Excellent!\nTIP A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes. The relation between records is either composition or\nassociation.\n3.2 Representing records as maps\nSo far, we’ve illustrated the benefits we gain from the separation between code and\ndata at a high-system level. There’s a separation of concerns between code and data,\nand each part has clear constraints:\n Code consists of static functions that receive data as an explicit argument.\n Data entities are modeled as records, and the relations between records are\nrepresented by positional collections and indexes.\nNow comes the question of the representation of the data. DOP has nothing special\ntosay about collections and indexes. However, it’s strongly opinionated about the\nrepresentation of records: records should be represented by generic data structures\nsuch as maps.\nThis applies to both OOP and FP languages. In dynamically-typed languages like\nJavaScript, Python, and Ruby, data representation feels natural. While in statically-\ntyped languages like Java and C#, it is a bit more cumbersome.\nTheo I’m really curious to know how we represent positional collections, indexes,\nand records in DOP.\nJoe Let’s start with positional collections. DOP has nothing special to say about the\nrepresentation of collections. They can be linked lists, arrays, vectors, sets, or\nother collections best suited for the use case.\nTheo It’s like in OOP.\nJoe Right! For now, to keep things simple, we’ll use arrays to represent positional\ncollections.\nTheo What about indexes?\nJoe Indexes are represented as homogeneous string maps.\nTheo What do you mean by a homogeneous map?\n--- Page 77 ---\n3.2 Representing records as maps 49\nJoe I mean that all the values of the map are of the same kind. For example, in a\nBook index, all the values are Book, and in an author index, all the values are\nAuthor, and so forth.\nTheo Again, it’s like in OOP.\n NOTE A homogeneous map is a map where all the values are of the same type. A hetero-\ngeneous map is a map where the values are of different types.\nJoe Now, here’s the big surprise. In DOP, records are represented as maps, more\nprecisely, heterogeneous string maps.\nJoe goes to the whiteboard and begins to draw. When he’s finished, he shows Theo the dia-\ngram in figure 3.4.\nRecord Heterogeneous map\nLinked list\nArray\nData representation Collection\nSet\nVector\nFigure 3.4 The building blocks\nIndex Homogeneous map\nof data representation\nTheo stays silent for a while. He is shocked to hear that the data entities of a system can be\nrepresented as a generic data structure, where the field names and value types are not\nspecified in a class. Then, Theo asks Joe:\nTheo What are the benefits of this folly?\nJoe Flexibility and genericity.\nTheo Could you explain, please?\nJoe I’ll explain in a moment, but before that, I’d like to show you what an instance\nof a record in a DOP system looks like.\nTheo OK.\nJoe Let’s take as an example, Watchmen, by Alan Moore and Dave Gibbons, which is\nmy favorite graphic novel. This masterpiece was published in 1987. I’m going\nto assume that, in a physical library, there are two copies of this book, whose ID\nis nyc-central-lib, and that one of the two copies is currently out. Here’s\nhow I’d represent the Book record for Watchmen in DOP.\nJoe comes closer to Theo’s laptop. He opens a text editor (not an IDE!) and types the Book\nrecord for Theo.\n--- Page 78 ---\n50 CHAPTER 3 Basic data manipulation\nListing3.1 An instance of a Book record represented as a map\n{\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\nTheo looks at the laptop screen. He has a question.\nTheo How am I supposed to instantiate the Book record for Watchmen programmat-\nically?\nJoe It depends on the facilities that your programming language offers to instantiate\nmaps. With dynamic languages like JavaScript, Ruby, or Python, it’s straight-\nforward, because we can use literals for maps and arrays. Here, let me show\nyou how.\nJoe jots down the JavaScript code that creates an instance of a Book record, which rep-\nresents as a map in JavaScript. He shows the code to Theo.\nListing3.2 A Book record represented as a map in JavaScript\nvar watchmenBook = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n--- Page 79 ---\n3.2 Representing records as maps 51\nTheo And, if I’m in Java?\nJoe It’s a bit more tedious, but still doable with the immutable Map and List static\nfactory methods.\n NOTE See “Creating Immutable Lists, Sets, and Maps” at http://mng.bz/voGm for\nmore information on this Java core library.\nJoe types the Java code to create an instance of a Book record represented as a map. He\nshows Theo the Java code.\nListing3.3 A Book record represented as a map in Java\nMap watchmen = Map.of(\n\"isbn\", \"978-1779501127\",\n\"title\", \"Watchmen\",\n\"publicationYear\", 1987,\n\"authors\", List.of(\"alan-moore\", \"dave-gibbons\"),\n\"bookItems\", List.of(\nMap.of(\n\"id\", \"book-item-1\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", true\n),\nMap.of (\n\"id\", \"book-item-2\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", false\n)\n)\n);\nTIP In DOP, we represent a record as a heterogeneous string map.\nTheo I’d definitely prefer to create a Book record using a Book class and a BookItem\nclass.\nTheo opens his IDE. He types the JavaScript code to represent a Book record as an instance\nof a Book class.\nListing3.4 A Book record as an instance of a Book class in JavaScript\nclass Book {\nisbn;\ntitle;\npublicationYear;\nauthors;\nbookItems;\nconstructor(isbn, title, publicationYear, authors, bookItems) {\nthis.isbn = isbn;\nthis.title = title;\nthis.publicationYear = publicationYear;\nthis.authors = authors;\nthis.bookItems = bookItems;\n--- Page 80 ---\n52 CHAPTER 3 Basic data manipulation\n}\n}\nclass BookItem {\nid;\nlibId;\nisLent;\nconstructor(id, libId, isLent) {\nthis.id = id;\nthis.libId = libId;\nthis.isLent = isLent;\n}\n}\nvar watchmenBook = new Book(\"978-1779501127\",\n\"Watchmen\",\n1987,\n[\"alan-moore\", \"dave-gibbons\"],\n[new BookItem(\"book-item-1\", \"nyc-central-lib\", true),\nnew BookItem(\"book-item-2\", \"nyc-central-lib\", false)]);\nJoe Theo, why do you prefer classes over maps for representing records?\nTheo It makes the data shape of the record part of my program. As a result, the IDE\ncan auto-complete field names, and errors are caught at compile time.\nJoe Fair enough. Can I show you some drawbacks for this approach?\nTheo Sure.\nJoe Imagine that you want to display the information about a book in the context\nof search results. In that case, instead of author IDs, you want to display\nauthor names, and you don’t need the book item information. How would\nyou handle that?\nTheo I’d create a class BookInSearchResults without a bookItems member and\nwith an authorNames member instead of the authorIds member of the Book\nclass. Also, I would need to write a copy constructor that receives a Book object.\nJoe In classic OOP, the fact that data is instantiated only via classes brings safety.\nBut this safety comes at the cost of flexibility.\nTIP There’s a tradeoff between flexibility and safety in a data model.\nTheo So, how can it be different?\nJoe In the DOP approach, where records are represented as maps, we don’t need\nto create a class for each variation of the data. We’re free to add, remove, and\nrename record fields dynamically. Our data model is flexible.\nTheo Interesting!\nTIP In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\nJoe Now, let me talk about genericity. How would you serialize the content of a\nBook object to JSON?\n--- Page 81 ---\n3.2 Representing records as maps 53\nTIP In DOP, records are manipulated with generic functions.\nTheo Oh no! I remember that while working on the Klafim prototype, I had a night-\nmare about JSON serialization when I was developing the first version of the\nLibrary Management System.\nJoe Well, in DOP, serializing a record to JSON is super easy.\nTheo Does it require the usage of reflection in order to go over the fields of the\nrecord like the Gson Java library does?\n NOTE See https://github.com/google/gson for more information on Gson.\nJoe Not at all! Remember that in DOP, a record is nothing more than data. We can\nwrite a generic JSON serialization function that works with any record. It can\nbe a Book, an Author, a BookItem, or anything else.\nTheo Amazing!\nTIP In DOP, you get JSON serialization for free.\nJoe Actually, as I’ll show you in a moment, lots of data manipulation stuff can be\ndone using generic functions.\nTheo Are the generic functions part of the language?\nJoe It depends on the functions and on the language. For example, JavaScript pro-\nvides a JSON serialization function called JSON.stringify out of the box, but\nnone for omitting multiple keys or for renaming keys.\nTheo That’s annoying.\nJoe Not so much; there are third-party libraries that provide data-manipulation facil-\nities. A popular data manipulation library in the JavaScript ecosystem is Lodash.\n NOTE See https://lodash.com/ to find out more about Lodash.\nTheo What about other languages?\nJoe Lodash has been ported to Java, C#, Python, and Ruby. Let me bookmark some\nsites for you.\nJoe bookmarks these sites for Theo:\n https://javalibs.com/artifact/com.github.javadev/underscore-lodash for Java\n https://www.nuget.org/packages/lodash/ for C#\n https://github.com/dgilland/pydash for Python\n https://rudash-website.now.sh/ for Ruby\n NOTE Throughout the book, we use Lodash to show how to manipulate data with\ngeneric functions, but there is nothing special about Lodash. The exact same approach\ncould be implemented via other data manipulation libraries or custom code.\nTheo Cool!\nJoe Actually, Lodash and its rich set of data manipulation functions can be ported\nto any language. That’s why it’s so beneficial to represent records as maps.\n--- Page 82 ---\n54 CHAPTER 3 Basic data manipulation\nTIP DOP compromises on data safety to gain flexibility and genericity.\nAt the whiteboard, Joe quickly sketches the tradeoffs (see table 3.1).\nTable 3.1 The tradeoff among safety, flexibility, and genericity\nOOP DOP\nSafety High Low\nFlexibility Low High\nGenericity Low High\n3.3 Manipulating data with generic functions\nJoe Now let me show you how to manipulate data in DOP with generic functions.\nTheo Yes, I’m quite curious to see how you’ll implement the search functionality of\nthe Library Management System.\nJoe OK. First, let’s instantiate a Catalog record for the catalog data of a library,\nwhere we have a single book, Watchmen.\nJoe instantiates a Catalog record according to Theo’s data model in figure 3.3. Here’s\nwhat Joe shows to Theo.\nListing3.5 A Catalog record\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n--- Page 83 ---\n3.3 Manipulating data with generic functions 55\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\nTheo I see the two indexes we talked about, booksByIsbn and authorsById. How\ndo you differentiate a record from an index in DOP?\nJoe In an entity diagram, there’s a clear distinction between records and indexes.\nBut in our code, both are plain data.\nTheo I guess that’s why this approach is called data-oriented programming.\nJoe See how straightforward it is to visualize any part of the system data inside a\nprogram? The reason is that data is represented as data!\nTIP In DOP, data is represented as data.\nTheo That sounds like a lapalissade.1\nJoe Oh, does it? I’m not so sure! In OOP, data is usually represented by objects,\nwhich makes it more challenging to visualize data inside a program.\nTIP In DOP, we can visualize any part of the system data.\nTheo How would you retrieve the title of a specific book from the catalog data?\nJoe Great question! In fact, in a DOP system, every piece of information has an\ninformation path from which we can retrieve the information.\nTheo Information path?\nJoe For example, the information path to the title of the Watchmen book in the\ncatalog is [\"booksByIsbn\", \"978-1779501127\", \"title\"].\nTheo Ah, I see. So, is an information path sort of like a file path, but that names in\nan information path correspond to nested entities?\nJoe You’re exactly right. And once we have the path of a piece of information, we\ncan retrieve the information with Lodash’s _.get function.\nJoe types a few characters on Theo’s laptop. Theo is amazed at how little code is needed to\nget the book title.\nListing3.6 Retrieving the title of a book from its information path\n_.get(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"])\n// → \"Watchmen\"\nTheo Neat. I wonder how hard it would be to implement a function like _.get\nmyself.\n1 A lapalissade is an obvious truth—a truism or tautology—that produces a comical effect.\n--- Page 84 ---\n56 CHAPTER 3 Basic data manipulation\nAfter a few minutes of trial and error, Theo is able to produce his implementation. He\nshows Joe the code.\nListing3.7 Custom implementation of get\nfunction get(m, path) {\nvar res = m;\nfor(var i = 0; i < path.length; i++) {\nWe could use\nvar key = path[i];\nforEach instead\nres = res[key];\nof a for loop.\n}\nreturn res;\n}\nAfter testing Theo’s implementation of get, Joe compliments Theo. He’s grateful that\nTheo is catching on so quickly.\nListing3.8 Testing the custom implementation of get\nget(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"]);\n// → \"Watchmen\"\nJoe Well done!\nTheo I wonder if a function like _.get works smoothly in a statically-typed language\nlike Java?\nJoe It depends on whether you only need to pass the value around or to access the\nvalue concretely.\nTheo I don’t follow.\nJoe Imagine that once you get the title of a book, you want to convert the string\ninto an uppercase string. You need to do a static cast to String, right? Here,\nlet me show you an example that casts a field value to a string, then we can\nmanipulate it as a string.\nListing3.9 Casting a field value to a string\n((String)watchmen.get(\"title\")).toUpperCase()\nTheo That makes sense. The values of the map are of different types, so the compiler\ndeclares it as a Map<String,Object>. The information of the type of the field\nis lost.\nJoe It’s a bit annoying, but quite often our code just passes the data around. In that\ncase, we don’t have to deal with static casting. Moreover, in a language like C#,\nwhen using the dynamic data type, type casting can be avoided.2,3\n2 See http://mng.bz/4jo5 for the C# documentation on the built-in reference to dynamic types.\n3 See appendix A for details about dynamic fields and type casting in C#.\n--- Page 85 ---\n3.3 Manipulating data with generic functions 57\nTIP In statically-typed languages, we sometimes need to statically cast the field values.\nTheo What about performance?\nJoe In most programming languages, maps are quite efficient. Accessing a field\nin a map is slightly slower than accessing a class member. Usually, it’s not\nsignificant.\nTIP There’s no significant performance hit for accessing a field in a map instead of as\na class member.\nTheo Let’s get back to this idea of information path. It works in OOP too. I could\naccess the title of the Watchmen book with catalogData.booksByIsbn[\"978-\n1779501127\"].title. I’d use class members for record fields and strings for\nindex keys.\nJoe There’s a fundamental difference, though. When records are represented as\nmaps, the information can be retrieved via its information path using a generic\nfunction like _.get. But when records are represented as objects, you need to\nwrite specific code for each type of information path.\nTheo What do you mean by specific code? What’s specific in catalogData.books-\nByIsbn[\"978-1779501127\"].title?\nJoe In a statically-typed language like Java, you’d need to import the class defini-\ntions for Catalog and Book.\nTheo And, in a dynamically-typed language like JavaScript...?\nJoe Even in JavaScript, when you represent records with objects instantiated from\nclasses, you can’t easily write a function that receives a path as an argument\nand display the information that corresponds to this path. You would have to\nwrite specific code for each kind of path. You’d access class members with dot\nnotation and map fields with bracket notation.\nTheo Would you say that in DOP, the information path is a first-class citizen?\nJoe Absolutely! The information path can be stored in a variable and passed as an\nargument to a function.\nTIP In DOP, you can retrieve every piece of information via a path and a generic\nfunction.\nJoe goes to the whiteboard. He draws a diagram like that in figure 3.5, which shows the\ncatalog data as a tree.\nJoe You see, Theo, each piece of information is accessible via a path made of\nstrings and integers. For example, the path of Alan Moore’s first book is\n[\"catalog\", \"authorsById\", \"alan-moore\", \"bookIsbns\", 0].\n--- Page 86 ---\n58 CHAPTER 3 Basic data manipulation\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 3.5 The catalog data as a tree\n3.4 Calculating search results\nTheo Interesting. I’m starting to feel the power of expression of DOP!\nJoe Wait, that’s just the beginning. Let me show you how simple it is to write code\nthat retrieves book information and displays it in search results. Can you tell\nme exactly what information has to appear in the search results?\nTheo Searching for book information should return isbn, title, and author-\nNames.\nJoe And what would a BookInfo record look like for Watchmen?\nTheo quickly enters the code on his laptop. He then shows it to Joe.\nListing3.10 A BookInfo record for Watchmen in the context of search result\n{\n\"title\": \"Watchmen\",\n\"isbn\": \"978-1779501127\",\n\"authorNames\": [\n\"Alan Moore\",\n\"Dave Gibbons\",\n]\n}\n--- Page 87 ---\n3.4 Calculating search results 59\nJoe Now I’ll show you step by step how to write a function that returns search\nresults matching a title in JSON format. I’ll use generic data manipulation\nfunctions from Lodash.\nTheo I’m ready!\nJoe Let’s start with an authorNames function that calculates the author names of a\nBook record by looking at the authorsById index. Could you tell me what’s\nthe information path for the name of an author whose ID is authorId?\nTheo It’s [\"authorsById\", authorId, \"name\"].\nJoe Now, let me show you how to retrieve the name of several authors using _.map.\nJoe types the code to map the author IDs to the author names. Theo nonchalantly peeks\nover Joe’s shoulder.\nListing3.11 Mapping author IDs to author names\n_.map([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\nTheo What’s this _.map function? It smells like functional programming! You said I\nwouldn’t have to learn FP to implement DOP!\nJoe No need to learn functional programming in order to use _.map, which is a\nfunction that transforms the values of a collection. You can implement it with\na simple for loop.\nTheo spends a couple of minutes in front of his computer figuring out how to implement\n_.map. Now he’s got it!\nListing3.12 Custom implementation of map\nfunction map(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nres[i] = f(coll[i]);\nforEach instead\n}\nof a for loop.\nreturn res;\n}\nAfter testing Theo’s implementation of map, Joe shows Theo the test. Joe again compli-\nments Theo.\nListing3.13 Testing the custom implementation of map\nmap([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\n--- Page 88 ---\n60 CHAPTER 3 Basic data manipulation\nJoe Well done!\nTheo You were right! It wasn’t hard.\nJoe Now, let’s implement authorNames using _.map.\nIt takes a few minutes for Theo to come up with the implementation of authorNames.\nWhen he’s finished, he turns his laptop to Joe.\nListing3.14 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nJoe We also need a bookInfo function that converts a Book record into a Book-\nInfo record. Let me show you the code for that.\nListing3.15 Converting a Book record into a BookInfo record\nfunction bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": authorNames(catalogData, book)\n};\nThere’s no need to create\nreturn bookInfo;\na class for bookInfo.\n}\nTheo Looking at the code, I see that a BookInfo record has three fields: title,\nisbn, and authorNames. Is there a way to get this information without looking\nat the code?\nJoe You can either add it to the data entity diagram or write it in the documenta-\ntion of the bookInfo function, or both.\nTheo I have to get used to the idea that in DOP, the record field information is not\npart of the program.\nJoe Indeed, it’s not part of the program, but it gives us a lot of flexibility.\nTheo Is there any way for me to have my cake and eat it too?\nJoe Yes, and someday I’ll show you how to make record field information part of a\nDOP program (see chapters 7 and 12).\nTheo Sounds intriguing!\nJoe Now that we have all the pieces in place, we can write our searchBooksBy-\nTitle function, which returns the book information about the books that\nmatch the query. First, we find the Book records that match the query with\n_.filter and then we transform each Book record into a BookInfo record\nwith _.map and bookInfo.\n--- Page 89 ---\n3.4 Calculating search results 61\nListing3.16 Searching books that match a query\nfunction searchBooksByTitle(catalogData, query) {\nvar allBooks = _.values(_.get(catalogData, \"booksByIsbn\"));\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\nThe includes JavaScript\n});\nfunction checks whether\na string includes a string\nvar bookInfos = _.map(matchingBooks, function(book) { as a substring.\nreturn bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\nTheo You’re using Lodash functions without any explanation again!\nJoe Sorry about that. I am so used to basic data manipulation functions that I con-\nsider them as part of the language. What functions are new to you?\nTheo _.values and _.filter\nJoe Well, _.values returns a collection made of the values of a map, and _.filter\nreturns a collection made of the values that satisfy a predicate.\nTheo _.values seems trivial. Let me try to implement _.filter.\nThe implementation of _.filter takes a bit more time. Eventually, Theo manages to get\nit right, then he is able to test it.\nListing3.17 Custom implementation of filter\nfunction filter(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nif(f(coll[i])) {\nforEach instead\nres.push(coll[i]);\nof a for loop.\n}\n}\nreturn res;\n}\nListing3.18 Testing the custom implementation of filter\nfilter([\"Watchmen\", \"Batman\"], function (title) {\nreturn title.includes(\"Watch\");\n});\n// → [\"Watchmen\"]\nTheo To me, it’s a bit weird that to access the title of a book record, I need to write\n_.get(book, \"title\"). I’d expect it to be book.title in dot notation or\nbook[\"title\"] in bracket notation.\nJoe Remember that book is a record that’s not represented as an object. It’s a map.\nIndeed, in JavaScript, you can write _.get(book, \"title\"), book.title, or\nbook[\"title\"]. But I prefer to use Lodash’s _.get function. In some lan-\nguages, the dot and the bracket notations might not work on maps.\n--- Page 90 ---\n62 CHAPTER 3 Basic data manipulation\nTheo Being language-agnostic has a price!\nJoe Right, would you like to test searchBooksByTitle?\nTheo Absolutely! Let me call searchBooksByTitle to search the books whose title\ncontain the string Watch.\nListing3.19 Testing searchBooksByTitle\nsearchBooksByTitle(catalogData, \"Wat\");\n//[\n// {\n// \"authorNames\": [\n// \"Alan Moore\",\n// \"Dave Gibbons\"\n// ],\n// \"isbn\": \"978-1779501127\",\n// \"title\": \"Watchmen\"\n// }\n//]\nTheo It seems to work! Are we done with the search implementation?\nJoe Almost. The searchBooksByTitle function we wrote is going to be part of the\nCatalog module, and it returns a collection of records. We have to write a\nfunction that’s part of the Library module, and that returns a JSON string.\nTheo You told me earlier that JSON serialization was straightforward in DOP.\nJoe Correct. The code for searchBooksByTitleJSON retrieves the Catalog record,\npasses it to searchBooksByTitle, and converts the results to JSON with\nJSON.stringify. That’s part of JavaScript. Here, let me show you.\nListing3.20 Implementation of searching books in a library as JSON\nfunction searchBooksByTitleJSON(libraryData, query) {\nvar results = searchBooksByTitle(_.get(libraryData, \"catalog\"), query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\nJoe In order to test our code, we need to create a Library record that contains our\nCatalog record. Could you do that for me, please?\nTheo Should the Library record contain all the Library fields (name, address,\nand UserManagement)?\nJoe That’s not necessary. For now, we only need the catalog field, then the test\nfor searching books.\nListing3.21 A Library record\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n--- Page 91 ---\n3.4 Calculating search results 63\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nListing3.22 Test for searching books in a library as JSON\nsearchBooksByTitleJSON(libraryData, \"Wat\");\nTheo How are we going to combine the four functions that we’ve written so far?\nJoe The functions authorNames, bookInfo, and searchBooksByTitle go into\nthe Catalog module, and searchBooksByTitleJSON goes into the Library\nmodule.\nTheo looks at the resulting code of the two modules, Library and Catalog. He’s quite\namazed by its conciseness.\nListing3.23 Calculating search results for Library and Catalog\nclass Catalog {\nstatic authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\n--- Page 92 ---\n64 CHAPTER 3 Basic data manipulation\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nThere’s no need\nreturn bookInfo;\nto create a class\n}\nfor bookInfo.\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nWhen _.filter is\nvar matchingBooks = _.filter(allBooks,\npassed a map, it\nfunction(book) {\ngoes over the values\nreturn _.get(book, \"title\").includes(query);\nof the map.\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nConverts data\nreturn resultsJSON;\nto JSON (part\n}\nof JavaScript)\n}\nAfter testing the final code in listing 3.24, Theo looks again at the source code from list-\ning 3.23. After a few seconds, he feels like he’s having another Aha! moment.\nListing3.24 Search results in JSON\nLibrary.searchBooksByTitleJSON(libraryData, \"Watchmen\");\n// → \"[{\\\"title\\\":\\\"Watchmen\\\",\\\"isbn\\\":\\\"978-1779501127\\\",\n// → \\\"authorNames\\\":[\\\"Alan Moore\\\",\\\"Dave Gibbons\\\"]}]\"\nTheo The important thing is not that the code is concise, but that the code contains\nno abstractions. It’s just data manipulation!\nJoe responds with a smile that says, “You got it, my friend!”\nJoe It reminds me of what my first meditation teacher told me 10 years ago:\nmeditation guides the mind to grasp the reality as it is without the abstractions\ncreated by our thoughts.\nTIP In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\n--- Page 93 ---\n3.5 Handling records of different types 65\n3.5 Handling records of different types\nWe’ve seen how DOP enables us to treat records as first-class citizens that can be\nmanipulated in a flexible way using generic functions. But if a record is nothing more\nthan an aggregation of fields, how do we know what the type of the record is? DOP has\na surprising answer to this question.\nTheo I have a question. If a record is nothing more than a map, how do you know\nthe type of the record?\nJoe That’s a great question with a surprising answer.\nTheo I’m curious.\nJoe Most of the time, there’s no need to know the record type.\nTheo What! What do you mean?\nJoe I mean that what matters most are the values of the fields. For example, take a\nlook at the Catalog.authorNames source code. It operates on a Book record,\nbut the only thing that matters is the value of the authorIds field.\nDoubtful, Theo looks at the source code for Catalog.authorNames. This is what Theo sees.\nListing3.25 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nTheo What about differentiating between various user types like Member versus\nLibrarian? I mean, they both have email and encryptedPassword. How do\nyou know if a record represents a Member or a Librarian?\nJoe Simple. You check to see if the record is found in the librariansByEmail\nindex or in the membersByEmail index of the Catalog.\nTheo Could you be more specific?\nJoe Sure! Let me write what the user management data of our tiny library might\nlook like, assuming we have one librarian and one member. To keep things\nsimple, I’m encrypting passwords through naive base-64 encoding for the User-\nManagement record.\nListing3.26 A UserManagement record\nvar userManagementData = {\n\"librariansByEmail\": {\n\"franck@gmail.com\" : { The base-64\nencoding of\n\"email\": \"franck@gmail.com\",\n\"mypassword\"\n\"encryptedPassword\": \"bXlwYXNzd29yZA==\"\n}\n},\n--- Page 94 ---\n66 CHAPTER 3 Basic data manipulation\n\"membersByEmail\": {\n\"samantha@gmail.com\": {\n\"email\": \"samantha@gmail.com\",\n\"encryptedPassword\": \"c2VjcmV0\",\nThe base-64\n\"isBlocked\": false,\nencoding of\n\"bookLendings\": [\n\"secret\"\n{\n\"bookItemId\": \"book-item-1\",\n\"bookIsbn\": \"978-1779501127\",\n\"lendingDate\": \"2020-04-23\"\n}\n]\n}\n}\n}\nTIP Most of the time, there’s no need to know the record type.\nTheo This morning, you told me you’d show me the code for UserManagement\n.isLibrarian function this afternoon.\nJoe So, here we are. It’s afternoon, and I’m going to fulfill my promise.\nJoe implements isLibrarian. With a slight pause, he then issues the test for isLibrarian.\nListing3.27 Checking if a user is a librarian\nfunction isLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nListing3.28 Testing isLibrarian\nisLibrarian(userManagementData, \"franck@gmail.com\");\n// → true\nTheo I’m assuming that _.has is a function that checks whether a key exists in a\nmap. Right?\nJoe Correct.\nTheo OK. You simply check whether the librariansByEmail map contains the\nemail field.\nJoe Yep.\nTheo Would you use the same pattern to check whether a member is a Super mem-\nber or a VIP member?\nJoe Sure. We could have SuperMembersByEmail and VIPMembersByEmail indexes.\nBut there’s a better way.\nTheo How?\nJoe When a member is a VIP member, we add a field, isVIP, with the value true to\nits record. To check if a member is a VIP member, we check whether the\nisVIP field is set to true in the member record. Here’s how I would code\nisVIPMember.\n--- Page 95 ---\n3.5 Handling records of different types 67\nListing3.29 Checking whether a member is a VIP member\nfunction isVIPMember(userManagement, email) {\nreturn _.get(userManagement, [\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nTheo I see that you access the isVIP field via its information path, [\"membersBy-\nEmail\", email, \"isVIP\"].\nJoe Yes, I think it makes the code crystal clear.\nTheo I agree. I guess we can do the same for isSuperMember and set an isSuper\nfield to true when a member is a Super member?\nJoe Yes, just like this.\nJoe assembles all the pieces in a UserManagement class. He then shows the code to Theo.\nListing3.30 The code of UserManagement module\nclass UserManagement {\nisLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nisVIPMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nisSuperMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isSuper\"]) == true;\n}\n}\nTheo looks at the UserManagement module code for a couple of seconds. Suddenly, an\nidea comes to his mind.\nTheo Why not have a type field in member record whose value would be either VIP\nor Super?\nJoe I assume that, according to the product requirements, a member can be both a\nVIP and a Super member.\nTheo Hmm...then the types field could be a collection containing VIP or Super\nor both.\nJoe In some situations, having a types field is helpful, but I find it simpler to have\na Boolean field for each feature that the record supports.\nTheo Is there a name for fields like isVIP and isSuper?\nJoe I call them feature fields.\nTIP Instead of maintaining type information about a record, use a feature field (e.g.,\nisVIP).\n--- Page 96 ---\n68 CHAPTER 3 Basic data manipulation\nTheo Can we use feature fields to differentiate between librarians and members?\nJoe You mean having an isLibrarian and an isMember field?\nTheo Yes, and having a common User record type for both librarians and members.\nJoe We can, but I think it’s simpler to have different record types for librarians and\nmembers: Librarian for librarians and Member for members.\nTheo Why?\nJoe Because there’s a clear distinction between librarians and members in terms of\ndata. For example, members can have book lendings but librarians don’t.\nTheo I agree. Now, we need to mention the two Member feature fields in our entity\ndiagram.\nWith that, Theo adds these fields to his diagram on the whiteboard. When he’s finished, he\nshows Joe his additions (figure 3.6).\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: Catalog\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian *\nCC Book id: String email: String CC Member\nname: String\ntitle : String encryptedPassword: String email: String\nbookIsbns: [String]\npublicationYear: Number encryptedPassword: String\nisbn: String * isBlocked: Boolean\nauthorIds: [String] bookLendings: [BookLending]\nbookItems: [BookItem] * isVIP: Boolean\nisSuper: Boolean\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.6 A library management data model with the Member feature fields isVIP and isSuper\nJoe Do you like the data model that we have designed together?\nTheo I find it quite simple and clear.\n--- Page 97 ---\nSummary 69\nJoe That’s the main goal of DOP.\nTheo Also, I’m pleasantly surprised how easy it is to adapt to changing requirements,\nboth in terms of code and the data model.\nJoe I suppose you’re also happy to get rid of complex class hierarchy diagrams.\nTheo Absolutely! Also, I think I’ve found an interesting connection between DOP\nand meditation.\nJoe Really?\nTheo When we were eating at Simple, you told me that meditation helped you expe-\nrience reality as it is without the filter of your thoughts.\nJoe Right.\nTheo From what you taught me today, I understand that in DOP, we are encouraged\nto treat data as data without the filter of our classes.\nJoe Clever! I never noticed that connection between those two disciplines that are\nso important for me. I guess you’d like to continue your journey in the realm\nof DOP.\nTheo Definitely. Let’s meet again tomorrow.\nJoe Unfortunately, tomorrow I’m taking my family to the beach to celebrate the\ntwelfth birthday of my eldest daughter, Aurelia.\nTheo Happy birthday, Aurelia!\nJoe We could meet again next Monday, if that’s OK with you.\nTheo With pleasure!\nSummary\n DOP principle #2 is to represent data entities with generic data structures.\n We refer to maps that have strings as keys as string maps.\n Representing data as data means representing records with string maps.\n By positional collection, we mean a collection where the elements are in order\n(like a list or an array).\n A positional collection of Strings is noted as [String].\n By index, we mean a collection where the elements are accessible via a key (like\na hash map or a dictionary).\n An index of Books is noted as {Book}.\n In the context of a data model, the index keys are always strings.\n A record is a data structure that groups together related data items. It’s a collec-\ntion of fields, possibly of different data types.\n A homogeneous map is a map where all the values are of the same type.\n A heterogeneous map is a map where the values are of different types.\n In DOP, we represent a record as a heterogeneous string map.\n A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes.\n The relation between records in a data entity diagram is either composition or\nassociation.\n--- Page 98 ---\n70 CHAPTER 3 Basic data manipulation\n The data part of a DOP system is flexible, and each piece of information is\naccessible via its information path.\n There is a tradeoff between flexibility and safety in a data model.\n DOP compromises on data safety to gain flexibility and genericity.\n In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\n We manipulate data with generic functions.\n Generic functions are provided either by the language itself or by third-party\nlibraries like Lodash.\n JSON serialization is implemented in terms of a generic function.\n On the one hand, we’ve lost the safety of accessing record fields via members\ndefined at compile time. On the other hand, we’ve liberated data from the lim-\nitation of classes and objects. Data is represented as data!\n The weak dependency between code and data makes it is easier to adapt to\nchanging requirements.\n When data is represented as data, it is straightforward to visualize system data.\n Usually, we do not need to maintain type information about a record.\n We can visualize any part of the system data.\n In statically-typed languages, we sometimes need to statically cast the field values.\n Instead of maintaining type information about a record, we use a feature field.\n There is no significant performance hit for accessing a field in a map instead of\na class member.\n In DOP, you can retrieve every piece of information via an information path and\na generic function.\n In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\nLodash functions introduced in this chapter\nFunction Description\nget(map, path) Gets the value of map at path\nhas(map, path) Checks if map has a field at path\nmerge(mapA, mapB) Creates a map resulting from the recursive merges between mapA and mapB\nvalues(map) Creates an array of values of map\nfilter(coll, pred) Iterates over elements of coll, returning an array of all elements for which\npred returns true\nmap(coll, f) Creates an array of values by running each element in coll through f\n--- Page 99 ---\nState management\nTime travel\nThis chapter covers\n A multi-version approach to state management\n The calculation phase of a mutation\n The commit phase of a mutation\n Keeping a history of previous state versions\nSo far, we have seen how DOP handles queries via generic functions that access sys-\ntem data, which is represented as a hash map. In this chapter, we illustrate how\nDOP deals with mutations (requests that change the system state). Instead of updat-\ning the state in place, we maintain multiple versions of the system data. At a specific\npoint in time, the system state refers to a specific version of the system data. This\nchapter is a deep dive in the third principle of DOP.\nPRINCIPLE #3 Data is immutable.\nThe maintenance of multiple versions of the system data requires the data to be\nimmutable. This is made efficient both in terms of computation and memory via a\n71\n--- Page 100 ---\n72 CHAPTER 4 State management\ntechnique called structural sharing, where parts of the data that are common between\ntwo versions are shared instead of being copied. In DOP, a mutation is split into two\ndistinct phases:\n In the calculation phase, we compute the next version of the system data.\n In the commit phase, we move the system state forward so that it refers to the\nversion of the system data computed by the calculation phase.\nThis distinction between calculation and commit phases allows us to reduce the part\nof our system that is stateful to its bare minimum. Only the code of the commit phase\nis stateful, while the code in the calculation phase of a mutation is stateless and is\nmade of generic functions similar to the code of a query. The implementation of the\ncommit phase is common to all mutations. As a consequence, inside the commit\nphase, we have the ability to ensure that the state always refers to a valid version of the\nsystem data.\nAnother benefit of this state management approach is that we can keep track of\nthe history of previous versions of the system data. Restoring the system to a previous\nstate (if needed) becomes straightforward. Table 4.1 shows the two phases.\nTable 4.1 The two phases of a mutation\nPhase Responsibility State Implementation\nCalculation Computes the next version of system data Stateless Specific\nCommit Moves the system state forward Stateful Common\nIn this chapter, we assume that no mutations occur concurrently in our system. In the\nnext chapter, we will deal with concurrency control.\n4.1 Multiple versions of the system data\nWhen Joe comes in to the office on Monday, he tells Theo that he needs to exercise before\nstarting to work with his mind. Theo and Joe go for a walk around the block, and the dis-\ncussion turns toward version control systems. They discuss how Git keeps track of the\nwhole commit history and how easy and fast it is to restore the code to a previous state.\nWhen Theo tells Joe that Git’s ability to “time travel” reminds him one of his favorite mov-\nies, Back to the Future, Joe shares that a month ago he watched the Back to the Future trilogy\nwith Neriah, his 14-year-old son.\nTheir walk complete, they arrive back at Theo’s office. Theo and Joe partake of the\nespresso machine in the kitchen before they begin today’s lesson.\nJoe So far, we’ve seen how we manage queries that retrieve information from the\nsystem in DOP. Now I’m going to show you how we manage mutations. By a\nmutation, I mean an operation that changes the state of the system.\n NOTE A mutation is an operation that changes the state of the system.\n--- Page 101 ---\n4.1 Multiple versions of the system data 73\nTheo Is there a fundamental difference between queries and mutations in DOP?\nAfter all, the whole state of the system is represented as a hash map. I could\neasily write code that modifies part of the hash map, and it would be similar to\nthe code that retrieves information from the hash map.\nJoe You could mutate the data in place, but then it would be challenging to ensure\nthat the code of a mutation doesn’t put the system into an invalid date. You\nwould also lose the ability to track previous versions of the system state.\nTheo I see. So, how do you handle mutations in DOP?\nJoe We adopt a multi-version state approach, similar to what a version control sys-\ntem like Git does; we manage different versions of the system data. At a specific\npoint in time, the state of the system refers to a version of the system data. After\na mutation is executed, we move the reference forward.\nTheo I’m confused. Is the system state mutable or immutable?\nJoe The data is immutable, but the state reference is mutable.\nTIP The data is immutable, but the state reference is mutable.\nNoticing the look of confusion on Theo’s face, Joe draws a quick diagram on the white-\nboard. He then shows Theo figure 4.1, hoping that it will clear up Theo’s perplexity.\nAfter mutation B After mutation C\nData V10 Data V10\nMutationA MutationA\nData V11 Data V11\nMutation B Mutation B\nSystem State Data V12 Data V12\nMutation C\nSystem State Data V13\nFigure 4.1 After mutation B is executed, the system state refers to Data V12. After\nmutation C is executed, the system state refers to Data V13.\nTheo Does that mean that before the code of a mutation runs, we make a copy of the\nsystem data?\nJoe No, that would be inefficient, as we would have to do a deep copy of the data.",
        "sections_found": []
      },
      "accurate_page_range": "76-101"
    },
    {
      "text": "- Summary",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "3 Basic data manipulation",
      "raw_line": "- Summary (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 28,
      "chapter_info": {
        "page": 76,
        "title": "Basic data manipulation",
        "pattern_matched": "Chapter 3",
        "text_preview": "48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to"
      },
      "chapter_sections": {
        "start_page": 76,
        "end_page": 101,
        "content": "\n--- Page 76 ---\n48 CHAPTER 3 Basic data manipulation\n NOTE A record is a data structure that groups together related data items. It’s a col-\nlection of fields, possibly of different data types.\nTheo Is it correct to say that a data entity diagram consists only of records, positional\ncollections, and indexes?\nJoe That’s correct. Can you make a similar statement about the relations between\nentities?\nTheo The relations in a data entity diagram are either composition (solid line with a\nfull diamond) or association (dashed line with an empty diamond). Both types\nof relations can be either one-to-one, one-to-many, or many-to-many.\nJoe Excellent!\nTIP A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes. The relation between records is either composition or\nassociation.\n3.2 Representing records as maps\nSo far, we’ve illustrated the benefits we gain from the separation between code and\ndata at a high-system level. There’s a separation of concerns between code and data,\nand each part has clear constraints:\n Code consists of static functions that receive data as an explicit argument.\n Data entities are modeled as records, and the relations between records are\nrepresented by positional collections and indexes.\nNow comes the question of the representation of the data. DOP has nothing special\ntosay about collections and indexes. However, it’s strongly opinionated about the\nrepresentation of records: records should be represented by generic data structures\nsuch as maps.\nThis applies to both OOP and FP languages. In dynamically-typed languages like\nJavaScript, Python, and Ruby, data representation feels natural. While in statically-\ntyped languages like Java and C#, it is a bit more cumbersome.\nTheo I’m really curious to know how we represent positional collections, indexes,\nand records in DOP.\nJoe Let’s start with positional collections. DOP has nothing special to say about the\nrepresentation of collections. They can be linked lists, arrays, vectors, sets, or\nother collections best suited for the use case.\nTheo It’s like in OOP.\nJoe Right! For now, to keep things simple, we’ll use arrays to represent positional\ncollections.\nTheo What about indexes?\nJoe Indexes are represented as homogeneous string maps.\nTheo What do you mean by a homogeneous map?\n--- Page 77 ---\n3.2 Representing records as maps 49\nJoe I mean that all the values of the map are of the same kind. For example, in a\nBook index, all the values are Book, and in an author index, all the values are\nAuthor, and so forth.\nTheo Again, it’s like in OOP.\n NOTE A homogeneous map is a map where all the values are of the same type. A hetero-\ngeneous map is a map where the values are of different types.\nJoe Now, here’s the big surprise. In DOP, records are represented as maps, more\nprecisely, heterogeneous string maps.\nJoe goes to the whiteboard and begins to draw. When he’s finished, he shows Theo the dia-\ngram in figure 3.4.\nRecord Heterogeneous map\nLinked list\nArray\nData representation Collection\nSet\nVector\nFigure 3.4 The building blocks\nIndex Homogeneous map\nof data representation\nTheo stays silent for a while. He is shocked to hear that the data entities of a system can be\nrepresented as a generic data structure, where the field names and value types are not\nspecified in a class. Then, Theo asks Joe:\nTheo What are the benefits of this folly?\nJoe Flexibility and genericity.\nTheo Could you explain, please?\nJoe I’ll explain in a moment, but before that, I’d like to show you what an instance\nof a record in a DOP system looks like.\nTheo OK.\nJoe Let’s take as an example, Watchmen, by Alan Moore and Dave Gibbons, which is\nmy favorite graphic novel. This masterpiece was published in 1987. I’m going\nto assume that, in a physical library, there are two copies of this book, whose ID\nis nyc-central-lib, and that one of the two copies is currently out. Here’s\nhow I’d represent the Book record for Watchmen in DOP.\nJoe comes closer to Theo’s laptop. He opens a text editor (not an IDE!) and types the Book\nrecord for Theo.\n--- Page 78 ---\n50 CHAPTER 3 Basic data manipulation\nListing3.1 An instance of a Book record represented as a map\n{\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\nTheo looks at the laptop screen. He has a question.\nTheo How am I supposed to instantiate the Book record for Watchmen programmat-\nically?\nJoe It depends on the facilities that your programming language offers to instantiate\nmaps. With dynamic languages like JavaScript, Ruby, or Python, it’s straight-\nforward, because we can use literals for maps and arrays. Here, let me show\nyou how.\nJoe jots down the JavaScript code that creates an instance of a Book record, which rep-\nresents as a map in JavaScript. He shows the code to Theo.\nListing3.2 A Book record represented as a map in JavaScript\nvar watchmenBook = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authors\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n--- Page 79 ---\n3.2 Representing records as maps 51\nTheo And, if I’m in Java?\nJoe It’s a bit more tedious, but still doable with the immutable Map and List static\nfactory methods.\n NOTE See “Creating Immutable Lists, Sets, and Maps” at http://mng.bz/voGm for\nmore information on this Java core library.\nJoe types the Java code to create an instance of a Book record represented as a map. He\nshows Theo the Java code.\nListing3.3 A Book record represented as a map in Java\nMap watchmen = Map.of(\n\"isbn\", \"978-1779501127\",\n\"title\", \"Watchmen\",\n\"publicationYear\", 1987,\n\"authors\", List.of(\"alan-moore\", \"dave-gibbons\"),\n\"bookItems\", List.of(\nMap.of(\n\"id\", \"book-item-1\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", true\n),\nMap.of (\n\"id\", \"book-item-2\",\n\"libId\", \"nyc-central-lib\",\n\"isLent\", false\n)\n)\n);\nTIP In DOP, we represent a record as a heterogeneous string map.\nTheo I’d definitely prefer to create a Book record using a Book class and a BookItem\nclass.\nTheo opens his IDE. He types the JavaScript code to represent a Book record as an instance\nof a Book class.\nListing3.4 A Book record as an instance of a Book class in JavaScript\nclass Book {\nisbn;\ntitle;\npublicationYear;\nauthors;\nbookItems;\nconstructor(isbn, title, publicationYear, authors, bookItems) {\nthis.isbn = isbn;\nthis.title = title;\nthis.publicationYear = publicationYear;\nthis.authors = authors;\nthis.bookItems = bookItems;\n--- Page 80 ---\n52 CHAPTER 3 Basic data manipulation\n}\n}\nclass BookItem {\nid;\nlibId;\nisLent;\nconstructor(id, libId, isLent) {\nthis.id = id;\nthis.libId = libId;\nthis.isLent = isLent;\n}\n}\nvar watchmenBook = new Book(\"978-1779501127\",\n\"Watchmen\",\n1987,\n[\"alan-moore\", \"dave-gibbons\"],\n[new BookItem(\"book-item-1\", \"nyc-central-lib\", true),\nnew BookItem(\"book-item-2\", \"nyc-central-lib\", false)]);\nJoe Theo, why do you prefer classes over maps for representing records?\nTheo It makes the data shape of the record part of my program. As a result, the IDE\ncan auto-complete field names, and errors are caught at compile time.\nJoe Fair enough. Can I show you some drawbacks for this approach?\nTheo Sure.\nJoe Imagine that you want to display the information about a book in the context\nof search results. In that case, instead of author IDs, you want to display\nauthor names, and you don’t need the book item information. How would\nyou handle that?\nTheo I’d create a class BookInSearchResults without a bookItems member and\nwith an authorNames member instead of the authorIds member of the Book\nclass. Also, I would need to write a copy constructor that receives a Book object.\nJoe In classic OOP, the fact that data is instantiated only via classes brings safety.\nBut this safety comes at the cost of flexibility.\nTIP There’s a tradeoff between flexibility and safety in a data model.\nTheo So, how can it be different?\nJoe In the DOP approach, where records are represented as maps, we don’t need\nto create a class for each variation of the data. We’re free to add, remove, and\nrename record fields dynamically. Our data model is flexible.\nTheo Interesting!\nTIP In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\nJoe Now, let me talk about genericity. How would you serialize the content of a\nBook object to JSON?\n--- Page 81 ---\n3.2 Representing records as maps 53\nTIP In DOP, records are manipulated with generic functions.\nTheo Oh no! I remember that while working on the Klafim prototype, I had a night-\nmare about JSON serialization when I was developing the first version of the\nLibrary Management System.\nJoe Well, in DOP, serializing a record to JSON is super easy.\nTheo Does it require the usage of reflection in order to go over the fields of the\nrecord like the Gson Java library does?\n NOTE See https://github.com/google/gson for more information on Gson.\nJoe Not at all! Remember that in DOP, a record is nothing more than data. We can\nwrite a generic JSON serialization function that works with any record. It can\nbe a Book, an Author, a BookItem, or anything else.\nTheo Amazing!\nTIP In DOP, you get JSON serialization for free.\nJoe Actually, as I’ll show you in a moment, lots of data manipulation stuff can be\ndone using generic functions.\nTheo Are the generic functions part of the language?\nJoe It depends on the functions and on the language. For example, JavaScript pro-\nvides a JSON serialization function called JSON.stringify out of the box, but\nnone for omitting multiple keys or for renaming keys.\nTheo That’s annoying.\nJoe Not so much; there are third-party libraries that provide data-manipulation facil-\nities. A popular data manipulation library in the JavaScript ecosystem is Lodash.\n NOTE See https://lodash.com/ to find out more about Lodash.\nTheo What about other languages?\nJoe Lodash has been ported to Java, C#, Python, and Ruby. Let me bookmark some\nsites for you.\nJoe bookmarks these sites for Theo:\n https://javalibs.com/artifact/com.github.javadev/underscore-lodash for Java\n https://www.nuget.org/packages/lodash/ for C#\n https://github.com/dgilland/pydash for Python\n https://rudash-website.now.sh/ for Ruby\n NOTE Throughout the book, we use Lodash to show how to manipulate data with\ngeneric functions, but there is nothing special about Lodash. The exact same approach\ncould be implemented via other data manipulation libraries or custom code.\nTheo Cool!\nJoe Actually, Lodash and its rich set of data manipulation functions can be ported\nto any language. That’s why it’s so beneficial to represent records as maps.\n--- Page 82 ---\n54 CHAPTER 3 Basic data manipulation\nTIP DOP compromises on data safety to gain flexibility and genericity.\nAt the whiteboard, Joe quickly sketches the tradeoffs (see table 3.1).\nTable 3.1 The tradeoff among safety, flexibility, and genericity\nOOP DOP\nSafety High Low\nFlexibility Low High\nGenericity Low High\n3.3 Manipulating data with generic functions\nJoe Now let me show you how to manipulate data in DOP with generic functions.\nTheo Yes, I’m quite curious to see how you’ll implement the search functionality of\nthe Library Management System.\nJoe OK. First, let’s instantiate a Catalog record for the catalog data of a library,\nwhere we have a single book, Watchmen.\nJoe instantiates a Catalog record according to Theo’s data model in figure 3.3. Here’s\nwhat Joe shows to Theo.\nListing3.5 A Catalog record\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n--- Page 83 ---\n3.3 Manipulating data with generic functions 55\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\nTheo I see the two indexes we talked about, booksByIsbn and authorsById. How\ndo you differentiate a record from an index in DOP?\nJoe In an entity diagram, there’s a clear distinction between records and indexes.\nBut in our code, both are plain data.\nTheo I guess that’s why this approach is called data-oriented programming.\nJoe See how straightforward it is to visualize any part of the system data inside a\nprogram? The reason is that data is represented as data!\nTIP In DOP, data is represented as data.\nTheo That sounds like a lapalissade.1\nJoe Oh, does it? I’m not so sure! In OOP, data is usually represented by objects,\nwhich makes it more challenging to visualize data inside a program.\nTIP In DOP, we can visualize any part of the system data.\nTheo How would you retrieve the title of a specific book from the catalog data?\nJoe Great question! In fact, in a DOP system, every piece of information has an\ninformation path from which we can retrieve the information.\nTheo Information path?\nJoe For example, the information path to the title of the Watchmen book in the\ncatalog is [\"booksByIsbn\", \"978-1779501127\", \"title\"].\nTheo Ah, I see. So, is an information path sort of like a file path, but that names in\nan information path correspond to nested entities?\nJoe You’re exactly right. And once we have the path of a piece of information, we\ncan retrieve the information with Lodash’s _.get function.\nJoe types a few characters on Theo’s laptop. Theo is amazed at how little code is needed to\nget the book title.\nListing3.6 Retrieving the title of a book from its information path\n_.get(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"])\n// → \"Watchmen\"\nTheo Neat. I wonder how hard it would be to implement a function like _.get\nmyself.\n1 A lapalissade is an obvious truth—a truism or tautology—that produces a comical effect.\n--- Page 84 ---\n56 CHAPTER 3 Basic data manipulation\nAfter a few minutes of trial and error, Theo is able to produce his implementation. He\nshows Joe the code.\nListing3.7 Custom implementation of get\nfunction get(m, path) {\nvar res = m;\nfor(var i = 0; i < path.length; i++) {\nWe could use\nvar key = path[i];\nforEach instead\nres = res[key];\nof a for loop.\n}\nreturn res;\n}\nAfter testing Theo’s implementation of get, Joe compliments Theo. He’s grateful that\nTheo is catching on so quickly.\nListing3.8 Testing the custom implementation of get\nget(catalogData, [\"booksByIsbn\", \"978-1779501127\", \"title\"]);\n// → \"Watchmen\"\nJoe Well done!\nTheo I wonder if a function like _.get works smoothly in a statically-typed language\nlike Java?\nJoe It depends on whether you only need to pass the value around or to access the\nvalue concretely.\nTheo I don’t follow.\nJoe Imagine that once you get the title of a book, you want to convert the string\ninto an uppercase string. You need to do a static cast to String, right? Here,\nlet me show you an example that casts a field value to a string, then we can\nmanipulate it as a string.\nListing3.9 Casting a field value to a string\n((String)watchmen.get(\"title\")).toUpperCase()\nTheo That makes sense. The values of the map are of different types, so the compiler\ndeclares it as a Map<String,Object>. The information of the type of the field\nis lost.\nJoe It’s a bit annoying, but quite often our code just passes the data around. In that\ncase, we don’t have to deal with static casting. Moreover, in a language like C#,\nwhen using the dynamic data type, type casting can be avoided.2,3\n2 See http://mng.bz/4jo5 for the C# documentation on the built-in reference to dynamic types.\n3 See appendix A for details about dynamic fields and type casting in C#.\n--- Page 85 ---\n3.3 Manipulating data with generic functions 57\nTIP In statically-typed languages, we sometimes need to statically cast the field values.\nTheo What about performance?\nJoe In most programming languages, maps are quite efficient. Accessing a field\nin a map is slightly slower than accessing a class member. Usually, it’s not\nsignificant.\nTIP There’s no significant performance hit for accessing a field in a map instead of as\na class member.\nTheo Let’s get back to this idea of information path. It works in OOP too. I could\naccess the title of the Watchmen book with catalogData.booksByIsbn[\"978-\n1779501127\"].title. I’d use class members for record fields and strings for\nindex keys.\nJoe There’s a fundamental difference, though. When records are represented as\nmaps, the information can be retrieved via its information path using a generic\nfunction like _.get. But when records are represented as objects, you need to\nwrite specific code for each type of information path.\nTheo What do you mean by specific code? What’s specific in catalogData.books-\nByIsbn[\"978-1779501127\"].title?\nJoe In a statically-typed language like Java, you’d need to import the class defini-\ntions for Catalog and Book.\nTheo And, in a dynamically-typed language like JavaScript...?\nJoe Even in JavaScript, when you represent records with objects instantiated from\nclasses, you can’t easily write a function that receives a path as an argument\nand display the information that corresponds to this path. You would have to\nwrite specific code for each kind of path. You’d access class members with dot\nnotation and map fields with bracket notation.\nTheo Would you say that in DOP, the information path is a first-class citizen?\nJoe Absolutely! The information path can be stored in a variable and passed as an\nargument to a function.\nTIP In DOP, you can retrieve every piece of information via a path and a generic\nfunction.\nJoe goes to the whiteboard. He draws a diagram like that in figure 3.5, which shows the\ncatalog data as a tree.\nJoe You see, Theo, each piece of information is accessible via a path made of\nstrings and integers. For example, the path of Alan Moore’s first book is\n[\"catalog\", \"authorsById\", \"alan-moore\", \"bookIsbns\", 0].\n--- Page 86 ---\n58 CHAPTER 3 Basic data manipulation\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 3.5 The catalog data as a tree\n3.4 Calculating search results\nTheo Interesting. I’m starting to feel the power of expression of DOP!\nJoe Wait, that’s just the beginning. Let me show you how simple it is to write code\nthat retrieves book information and displays it in search results. Can you tell\nme exactly what information has to appear in the search results?\nTheo Searching for book information should return isbn, title, and author-\nNames.\nJoe And what would a BookInfo record look like for Watchmen?\nTheo quickly enters the code on his laptop. He then shows it to Joe.\nListing3.10 A BookInfo record for Watchmen in the context of search result\n{\n\"title\": \"Watchmen\",\n\"isbn\": \"978-1779501127\",\n\"authorNames\": [\n\"Alan Moore\",\n\"Dave Gibbons\",\n]\n}\n--- Page 87 ---\n3.4 Calculating search results 59\nJoe Now I’ll show you step by step how to write a function that returns search\nresults matching a title in JSON format. I’ll use generic data manipulation\nfunctions from Lodash.\nTheo I’m ready!\nJoe Let’s start with an authorNames function that calculates the author names of a\nBook record by looking at the authorsById index. Could you tell me what’s\nthe information path for the name of an author whose ID is authorId?\nTheo It’s [\"authorsById\", authorId, \"name\"].\nJoe Now, let me show you how to retrieve the name of several authors using _.map.\nJoe types the code to map the author IDs to the author names. Theo nonchalantly peeks\nover Joe’s shoulder.\nListing3.11 Mapping author IDs to author names\n_.map([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\nTheo What’s this _.map function? It smells like functional programming! You said I\nwouldn’t have to learn FP to implement DOP!\nJoe No need to learn functional programming in order to use _.map, which is a\nfunction that transforms the values of a collection. You can implement it with\na simple for loop.\nTheo spends a couple of minutes in front of his computer figuring out how to implement\n_.map. Now he’s got it!\nListing3.12 Custom implementation of map\nfunction map(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nres[i] = f(coll[i]);\nforEach instead\n}\nof a for loop.\nreturn res;\n}\nAfter testing Theo’s implementation of map, Joe shows Theo the test. Joe again compli-\nments Theo.\nListing3.13 Testing the custom implementation of map\nmap([\"alan-moore\", \"dave-gibbons\"],\nfunction(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n// → [ \"Alan Moore\", \"Dave Gibbons\"]\n--- Page 88 ---\n60 CHAPTER 3 Basic data manipulation\nJoe Well done!\nTheo You were right! It wasn’t hard.\nJoe Now, let’s implement authorNames using _.map.\nIt takes a few minutes for Theo to come up with the implementation of authorNames.\nWhen he’s finished, he turns his laptop to Joe.\nListing3.14 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nJoe We also need a bookInfo function that converts a Book record into a Book-\nInfo record. Let me show you the code for that.\nListing3.15 Converting a Book record into a BookInfo record\nfunction bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": authorNames(catalogData, book)\n};\nThere’s no need to create\nreturn bookInfo;\na class for bookInfo.\n}\nTheo Looking at the code, I see that a BookInfo record has three fields: title,\nisbn, and authorNames. Is there a way to get this information without looking\nat the code?\nJoe You can either add it to the data entity diagram or write it in the documenta-\ntion of the bookInfo function, or both.\nTheo I have to get used to the idea that in DOP, the record field information is not\npart of the program.\nJoe Indeed, it’s not part of the program, but it gives us a lot of flexibility.\nTheo Is there any way for me to have my cake and eat it too?\nJoe Yes, and someday I’ll show you how to make record field information part of a\nDOP program (see chapters 7 and 12).\nTheo Sounds intriguing!\nJoe Now that we have all the pieces in place, we can write our searchBooksBy-\nTitle function, which returns the book information about the books that\nmatch the query. First, we find the Book records that match the query with\n_.filter and then we transform each Book record into a BookInfo record\nwith _.map and bookInfo.\n--- Page 89 ---\n3.4 Calculating search results 61\nListing3.16 Searching books that match a query\nfunction searchBooksByTitle(catalogData, query) {\nvar allBooks = _.values(_.get(catalogData, \"booksByIsbn\"));\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\nThe includes JavaScript\n});\nfunction checks whether\na string includes a string\nvar bookInfos = _.map(matchingBooks, function(book) { as a substring.\nreturn bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\nTheo You’re using Lodash functions without any explanation again!\nJoe Sorry about that. I am so used to basic data manipulation functions that I con-\nsider them as part of the language. What functions are new to you?\nTheo _.values and _.filter\nJoe Well, _.values returns a collection made of the values of a map, and _.filter\nreturns a collection made of the values that satisfy a predicate.\nTheo _.values seems trivial. Let me try to implement _.filter.\nThe implementation of _.filter takes a bit more time. Eventually, Theo manages to get\nit right, then he is able to test it.\nListing3.17 Custom implementation of filter\nfunction filter(coll, f) {\nvar res = [];\nfor(var i = 0; i < coll.length; i++) {\nWe could use\nif(f(coll[i])) {\nforEach instead\nres.push(coll[i]);\nof a for loop.\n}\n}\nreturn res;\n}\nListing3.18 Testing the custom implementation of filter\nfilter([\"Watchmen\", \"Batman\"], function (title) {\nreturn title.includes(\"Watch\");\n});\n// → [\"Watchmen\"]\nTheo To me, it’s a bit weird that to access the title of a book record, I need to write\n_.get(book, \"title\"). I’d expect it to be book.title in dot notation or\nbook[\"title\"] in bracket notation.\nJoe Remember that book is a record that’s not represented as an object. It’s a map.\nIndeed, in JavaScript, you can write _.get(book, \"title\"), book.title, or\nbook[\"title\"]. But I prefer to use Lodash’s _.get function. In some lan-\nguages, the dot and the bracket notations might not work on maps.\n--- Page 90 ---\n62 CHAPTER 3 Basic data manipulation\nTheo Being language-agnostic has a price!\nJoe Right, would you like to test searchBooksByTitle?\nTheo Absolutely! Let me call searchBooksByTitle to search the books whose title\ncontain the string Watch.\nListing3.19 Testing searchBooksByTitle\nsearchBooksByTitle(catalogData, \"Wat\");\n//[\n// {\n// \"authorNames\": [\n// \"Alan Moore\",\n// \"Dave Gibbons\"\n// ],\n// \"isbn\": \"978-1779501127\",\n// \"title\": \"Watchmen\"\n// }\n//]\nTheo It seems to work! Are we done with the search implementation?\nJoe Almost. The searchBooksByTitle function we wrote is going to be part of the\nCatalog module, and it returns a collection of records. We have to write a\nfunction that’s part of the Library module, and that returns a JSON string.\nTheo You told me earlier that JSON serialization was straightforward in DOP.\nJoe Correct. The code for searchBooksByTitleJSON retrieves the Catalog record,\npasses it to searchBooksByTitle, and converts the results to JSON with\nJSON.stringify. That’s part of JavaScript. Here, let me show you.\nListing3.20 Implementation of searching books in a library as JSON\nfunction searchBooksByTitleJSON(libraryData, query) {\nvar results = searchBooksByTitle(_.get(libraryData, \"catalog\"), query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\nJoe In order to test our code, we need to create a Library record that contains our\nCatalog record. Could you do that for me, please?\nTheo Should the Library record contain all the Library fields (name, address,\nand UserManagement)?\nJoe That’s not necessary. For now, we only need the catalog field, then the test\nfor searching books.\nListing3.21 A Library record\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n--- Page 91 ---\n3.4 Calculating search results 63\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nListing3.22 Test for searching books in a library as JSON\nsearchBooksByTitleJSON(libraryData, \"Wat\");\nTheo How are we going to combine the four functions that we’ve written so far?\nJoe The functions authorNames, bookInfo, and searchBooksByTitle go into\nthe Catalog module, and searchBooksByTitleJSON goes into the Library\nmodule.\nTheo looks at the resulting code of the two modules, Library and Catalog. He’s quite\namazed by its conciseness.\nListing3.23 Calculating search results for Library and Catalog\nclass Catalog {\nstatic authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\n--- Page 92 ---\n64 CHAPTER 3 Basic data manipulation\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData, book)\n};\nThere’s no need\nreturn bookInfo;\nto create a class\n}\nfor bookInfo.\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nWhen _.filter is\nvar matchingBooks = _.filter(allBooks,\npassed a map, it\nfunction(book) {\ngoes over the values\nreturn _.get(book, \"title\").includes(query);\nof the map.\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nConverts data\nreturn resultsJSON;\nto JSON (part\n}\nof JavaScript)\n}\nAfter testing the final code in listing 3.24, Theo looks again at the source code from list-\ning 3.23. After a few seconds, he feels like he’s having another Aha! moment.\nListing3.24 Search results in JSON\nLibrary.searchBooksByTitleJSON(libraryData, \"Watchmen\");\n// → \"[{\\\"title\\\":\\\"Watchmen\\\",\\\"isbn\\\":\\\"978-1779501127\\\",\n// → \\\"authorNames\\\":[\\\"Alan Moore\\\",\\\"Dave Gibbons\\\"]}]\"\nTheo The important thing is not that the code is concise, but that the code contains\nno abstractions. It’s just data manipulation!\nJoe responds with a smile that says, “You got it, my friend!”\nJoe It reminds me of what my first meditation teacher told me 10 years ago:\nmeditation guides the mind to grasp the reality as it is without the abstractions\ncreated by our thoughts.\nTIP In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\n--- Page 93 ---\n3.5 Handling records of different types 65\n3.5 Handling records of different types\nWe’ve seen how DOP enables us to treat records as first-class citizens that can be\nmanipulated in a flexible way using generic functions. But if a record is nothing more\nthan an aggregation of fields, how do we know what the type of the record is? DOP has\na surprising answer to this question.\nTheo I have a question. If a record is nothing more than a map, how do you know\nthe type of the record?\nJoe That’s a great question with a surprising answer.\nTheo I’m curious.\nJoe Most of the time, there’s no need to know the record type.\nTheo What! What do you mean?\nJoe I mean that what matters most are the values of the fields. For example, take a\nlook at the Catalog.authorNames source code. It operates on a Book record,\nbut the only thing that matters is the value of the authorIds field.\nDoubtful, Theo looks at the source code for Catalog.authorNames. This is what Theo sees.\nListing3.25 Calculating the author names of a book\nfunction authorNames(catalogData, book) {\nvar authorIds = _.get(book, \"authorIds\");\nvar names = _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\nreturn names;\n}\nTheo What about differentiating between various user types like Member versus\nLibrarian? I mean, they both have email and encryptedPassword. How do\nyou know if a record represents a Member or a Librarian?\nJoe Simple. You check to see if the record is found in the librariansByEmail\nindex or in the membersByEmail index of the Catalog.\nTheo Could you be more specific?\nJoe Sure! Let me write what the user management data of our tiny library might\nlook like, assuming we have one librarian and one member. To keep things\nsimple, I’m encrypting passwords through naive base-64 encoding for the User-\nManagement record.\nListing3.26 A UserManagement record\nvar userManagementData = {\n\"librariansByEmail\": {\n\"franck@gmail.com\" : { The base-64\nencoding of\n\"email\": \"franck@gmail.com\",\n\"mypassword\"\n\"encryptedPassword\": \"bXlwYXNzd29yZA==\"\n}\n},\n--- Page 94 ---\n66 CHAPTER 3 Basic data manipulation\n\"membersByEmail\": {\n\"samantha@gmail.com\": {\n\"email\": \"samantha@gmail.com\",\n\"encryptedPassword\": \"c2VjcmV0\",\nThe base-64\n\"isBlocked\": false,\nencoding of\n\"bookLendings\": [\n\"secret\"\n{\n\"bookItemId\": \"book-item-1\",\n\"bookIsbn\": \"978-1779501127\",\n\"lendingDate\": \"2020-04-23\"\n}\n]\n}\n}\n}\nTIP Most of the time, there’s no need to know the record type.\nTheo This morning, you told me you’d show me the code for UserManagement\n.isLibrarian function this afternoon.\nJoe So, here we are. It’s afternoon, and I’m going to fulfill my promise.\nJoe implements isLibrarian. With a slight pause, he then issues the test for isLibrarian.\nListing3.27 Checking if a user is a librarian\nfunction isLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nListing3.28 Testing isLibrarian\nisLibrarian(userManagementData, \"franck@gmail.com\");\n// → true\nTheo I’m assuming that _.has is a function that checks whether a key exists in a\nmap. Right?\nJoe Correct.\nTheo OK. You simply check whether the librariansByEmail map contains the\nemail field.\nJoe Yep.\nTheo Would you use the same pattern to check whether a member is a Super mem-\nber or a VIP member?\nJoe Sure. We could have SuperMembersByEmail and VIPMembersByEmail indexes.\nBut there’s a better way.\nTheo How?\nJoe When a member is a VIP member, we add a field, isVIP, with the value true to\nits record. To check if a member is a VIP member, we check whether the\nisVIP field is set to true in the member record. Here’s how I would code\nisVIPMember.\n--- Page 95 ---\n3.5 Handling records of different types 67\nListing3.29 Checking whether a member is a VIP member\nfunction isVIPMember(userManagement, email) {\nreturn _.get(userManagement, [\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nTheo I see that you access the isVIP field via its information path, [\"membersBy-\nEmail\", email, \"isVIP\"].\nJoe Yes, I think it makes the code crystal clear.\nTheo I agree. I guess we can do the same for isSuperMember and set an isSuper\nfield to true when a member is a Super member?\nJoe Yes, just like this.\nJoe assembles all the pieces in a UserManagement class. He then shows the code to Theo.\nListing3.30 The code of UserManagement module\nclass UserManagement {\nisLibrarian(userManagement, email) {\nreturn _.has(_.get(userManagement, \"librariansByEmail\"), email);\n}\nisVIPMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isVIP\"]) == true;\n}\nisSuperMember(userManagement, email) {\nreturn _.get(userManagement,\n[\"membersByEmail\", email, \"isSuper\"]) == true;\n}\n}\nTheo looks at the UserManagement module code for a couple of seconds. Suddenly, an\nidea comes to his mind.\nTheo Why not have a type field in member record whose value would be either VIP\nor Super?\nJoe I assume that, according to the product requirements, a member can be both a\nVIP and a Super member.\nTheo Hmm...then the types field could be a collection containing VIP or Super\nor both.\nJoe In some situations, having a types field is helpful, but I find it simpler to have\na Boolean field for each feature that the record supports.\nTheo Is there a name for fields like isVIP and isSuper?\nJoe I call them feature fields.\nTIP Instead of maintaining type information about a record, use a feature field (e.g.,\nisVIP).\n--- Page 96 ---\n68 CHAPTER 3 Basic data manipulation\nTheo Can we use feature fields to differentiate between librarians and members?\nJoe You mean having an isLibrarian and an isMember field?\nTheo Yes, and having a common User record type for both librarians and members.\nJoe We can, but I think it’s simpler to have different record types for librarians and\nmembers: Librarian for librarians and Member for members.\nTheo Why?\nJoe Because there’s a clear distinction between librarians and members in terms of\ndata. For example, members can have book lendings but librarians don’t.\nTheo I agree. Now, we need to mention the two Member feature fields in our entity\ndiagram.\nWith that, Theo adds these fields to his diagram on the whiteboard. When he’s finished, he\nshows Joe his additions (figure 3.6).\nCC Library\nname: String\naddress: String\ncatalog: Catalog\nuserManagement: Catalog\nCC Catalog CC UserManagement\nbooksByIsbn: {Book} librariansByEmail: {Librarian}\nauthorsById: {Author} membersByEmail: {Member}\n*\n*\n* CC Author CC Librarian *\nCC Book id: String email: String CC Member\nname: String\ntitle : String encryptedPassword: String email: String\nbookIsbns: [String]\npublicationYear: Number encryptedPassword: String\nisbn: String * isBlocked: Boolean\nauthorIds: [String] bookLendings: [BookLending]\nbookItems: [BookItem] * isVIP: Boolean\nisSuper: Boolean\nCC BookLending\nlendingDate: String\nbookItemId: String *\nCC BookItem\nbookIsbn: String\nid: String\nlibId: String\n*\npurchaseDate: String\nisLent: Boolean\nFigure 3.6 A library management data model with the Member feature fields isVIP and isSuper\nJoe Do you like the data model that we have designed together?\nTheo I find it quite simple and clear.\n--- Page 97 ---\nSummary 69\nJoe That’s the main goal of DOP.\nTheo Also, I’m pleasantly surprised how easy it is to adapt to changing requirements,\nboth in terms of code and the data model.\nJoe I suppose you’re also happy to get rid of complex class hierarchy diagrams.\nTheo Absolutely! Also, I think I’ve found an interesting connection between DOP\nand meditation.\nJoe Really?\nTheo When we were eating at Simple, you told me that meditation helped you expe-\nrience reality as it is without the filter of your thoughts.\nJoe Right.\nTheo From what you taught me today, I understand that in DOP, we are encouraged\nto treat data as data without the filter of our classes.\nJoe Clever! I never noticed that connection between those two disciplines that are\nso important for me. I guess you’d like to continue your journey in the realm\nof DOP.\nTheo Definitely. Let’s meet again tomorrow.\nJoe Unfortunately, tomorrow I’m taking my family to the beach to celebrate the\ntwelfth birthday of my eldest daughter, Aurelia.\nTheo Happy birthday, Aurelia!\nJoe We could meet again next Monday, if that’s OK with you.\nTheo With pleasure!\nSummary\n DOP principle #2 is to represent data entities with generic data structures.\n We refer to maps that have strings as keys as string maps.\n Representing data as data means representing records with string maps.\n By positional collection, we mean a collection where the elements are in order\n(like a list or an array).\n A positional collection of Strings is noted as [String].\n By index, we mean a collection where the elements are accessible via a key (like\na hash map or a dictionary).\n An index of Books is noted as {Book}.\n In the context of a data model, the index keys are always strings.\n A record is a data structure that groups together related data items. It’s a collec-\ntion of fields, possibly of different data types.\n A homogeneous map is a map where all the values are of the same type.\n A heterogeneous map is a map where the values are of different types.\n In DOP, we represent a record as a heterogeneous string map.\n A data entity diagram consists of records whose values are either primitives, posi-\ntional collections, or indexes.\n The relation between records in a data entity diagram is either composition or\nassociation.\n--- Page 98 ---\n70 CHAPTER 3 Basic data manipulation\n The data part of a DOP system is flexible, and each piece of information is\naccessible via its information path.\n There is a tradeoff between flexibility and safety in a data model.\n DOP compromises on data safety to gain flexibility and genericity.\n In DOP, the data model is flexible. We’re free to add, remove, and rename\nrecord fields dynamically at run time.\n We manipulate data with generic functions.\n Generic functions are provided either by the language itself or by third-party\nlibraries like Lodash.\n JSON serialization is implemented in terms of a generic function.\n On the one hand, we’ve lost the safety of accessing record fields via members\ndefined at compile time. On the other hand, we’ve liberated data from the lim-\nitation of classes and objects. Data is represented as data!\n The weak dependency between code and data makes it is easier to adapt to\nchanging requirements.\n When data is represented as data, it is straightforward to visualize system data.\n Usually, we do not need to maintain type information about a record.\n We can visualize any part of the system data.\n In statically-typed languages, we sometimes need to statically cast the field values.\n Instead of maintaining type information about a record, we use a feature field.\n There is no significant performance hit for accessing a field in a map instead of\na class member.\n In DOP, you can retrieve every piece of information via an information path and\na generic function.\n In DOP, many parts of our code base tend to be just about data manipulation\nwith no abstractions.\nLodash functions introduced in this chapter\nFunction Description\nget(map, path) Gets the value of map at path\nhas(map, path) Checks if map has a field at path\nmerge(mapA, mapB) Creates a map resulting from the recursive merges between mapA and mapB\nvalues(map) Creates an array of values of map\nfilter(coll, pred) Iterates over elements of coll, returning an array of all elements for which\npred returns true\nmap(coll, f) Creates an array of values by running each element in coll through f\n--- Page 99 ---\nState management\nTime travel\nThis chapter covers\n A multi-version approach to state management\n The calculation phase of a mutation\n The commit phase of a mutation\n Keeping a history of previous state versions\nSo far, we have seen how DOP handles queries via generic functions that access sys-\ntem data, which is represented as a hash map. In this chapter, we illustrate how\nDOP deals with mutations (requests that change the system state). Instead of updat-\ning the state in place, we maintain multiple versions of the system data. At a specific\npoint in time, the system state refers to a specific version of the system data. This\nchapter is a deep dive in the third principle of DOP.\nPRINCIPLE #3 Data is immutable.\nThe maintenance of multiple versions of the system data requires the data to be\nimmutable. This is made efficient both in terms of computation and memory via a\n71\n--- Page 100 ---\n72 CHAPTER 4 State management\ntechnique called structural sharing, where parts of the data that are common between\ntwo versions are shared instead of being copied. In DOP, a mutation is split into two\ndistinct phases:\n In the calculation phase, we compute the next version of the system data.\n In the commit phase, we move the system state forward so that it refers to the\nversion of the system data computed by the calculation phase.\nThis distinction between calculation and commit phases allows us to reduce the part\nof our system that is stateful to its bare minimum. Only the code of the commit phase\nis stateful, while the code in the calculation phase of a mutation is stateless and is\nmade of generic functions similar to the code of a query. The implementation of the\ncommit phase is common to all mutations. As a consequence, inside the commit\nphase, we have the ability to ensure that the state always refers to a valid version of the\nsystem data.\nAnother benefit of this state management approach is that we can keep track of\nthe history of previous versions of the system data. Restoring the system to a previous\nstate (if needed) becomes straightforward. Table 4.1 shows the two phases.\nTable 4.1 The two phases of a mutation\nPhase Responsibility State Implementation\nCalculation Computes the next version of system data Stateless Specific\nCommit Moves the system state forward Stateful Common\nIn this chapter, we assume that no mutations occur concurrently in our system. In the\nnext chapter, we will deal with concurrency control.\n4.1 Multiple versions of the system data\nWhen Joe comes in to the office on Monday, he tells Theo that he needs to exercise before\nstarting to work with his mind. Theo and Joe go for a walk around the block, and the dis-\ncussion turns toward version control systems. They discuss how Git keeps track of the\nwhole commit history and how easy and fast it is to restore the code to a previous state.\nWhen Theo tells Joe that Git’s ability to “time travel” reminds him one of his favorite mov-\nies, Back to the Future, Joe shares that a month ago he watched the Back to the Future trilogy\nwith Neriah, his 14-year-old son.\nTheir walk complete, they arrive back at Theo’s office. Theo and Joe partake of the\nespresso machine in the kitchen before they begin today’s lesson.\nJoe So far, we’ve seen how we manage queries that retrieve information from the\nsystem in DOP. Now I’m going to show you how we manage mutations. By a\nmutation, I mean an operation that changes the state of the system.\n NOTE A mutation is an operation that changes the state of the system.\n--- Page 101 ---\n4.1 Multiple versions of the system data 73\nTheo Is there a fundamental difference between queries and mutations in DOP?\nAfter all, the whole state of the system is represented as a hash map. I could\neasily write code that modifies part of the hash map, and it would be similar to\nthe code that retrieves information from the hash map.\nJoe You could mutate the data in place, but then it would be challenging to ensure\nthat the code of a mutation doesn’t put the system into an invalid date. You\nwould also lose the ability to track previous versions of the system state.\nTheo I see. So, how do you handle mutations in DOP?\nJoe We adopt a multi-version state approach, similar to what a version control sys-\ntem like Git does; we manage different versions of the system data. At a specific\npoint in time, the state of the system refers to a version of the system data. After\na mutation is executed, we move the reference forward.\nTheo I’m confused. Is the system state mutable or immutable?\nJoe The data is immutable, but the state reference is mutable.\nTIP The data is immutable, but the state reference is mutable.\nNoticing the look of confusion on Theo’s face, Joe draws a quick diagram on the white-\nboard. He then shows Theo figure 4.1, hoping that it will clear up Theo’s perplexity.\nAfter mutation B After mutation C\nData V10 Data V10\nMutationA MutationA\nData V11 Data V11\nMutation B Mutation B\nSystem State Data V12 Data V12\nMutation C\nSystem State Data V13\nFigure 4.1 After mutation B is executed, the system state refers to Data V12. After\nmutation C is executed, the system state refers to Data V13.\nTheo Does that mean that before the code of a mutation runs, we make a copy of the\nsystem data?\nJoe No, that would be inefficient, as we would have to do a deep copy of the data.",
        "sections_found": []
      },
      "accurate_page_range": "76-101"
    }
  ]
}