{
  "chapter": "6",
  "title": "Unit tests",
  "page_info": {
    "page": 152,
    "title": "Unit tests",
    "pattern_matched": "Chapter 6",
    "text_preview": "124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again "
  },
  "leaf_nodes": [
    {
      "text": "- 6.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "raw_line": "- 6.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 45,
      "chapter_info": {
        "page": 152,
        "title": "Unit tests",
        "pattern_matched": "Chapter 6",
        "text_preview": "124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again "
      },
      "chapter_sections": {
        "start_page": 152,
        "end_page": 175,
        "content": "\n--- Page 152 ---\n124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again at the\ncode for Catalog.searchBooksByTitle.\nListing6.16 The code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nWriting the unit test for Catalog.searchBooksByTitle is a more pleasant experience for\nTheo than writing the unit test for Library.searchBooksByTitleJSON. He appreciates\nthis for two reasons:\n It’s not necessary to deserialize the output because the function returns data.\n It’s not necessary to wrap the catalog data in a library data map.\nListing6.17 Unit test for Catalog.searchBooksByTitle\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n--- Page 153 ---\n6.3 Unit tests for queries 125\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Watchmen\"), [bookInfo]);\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Batman\"), []);\nJoe That’s a good start!\nTheo I thought I was done. What did I miss?\nJoe You forgot to test cases where the query string is all lowercase.\nTheo You’re right! Let me quickly add one more test case.\nIn less than a minute, Theo creates an additional test case and shows it to Joe. What a dis-\nappointment when Theo discovers that the test case with \"watchmen\" in lowercase fails!\nListing6.18 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe Don’t be too upset, my friend. After all, the purpose of unit tests is to find bugs\nin the code so that you can fix them. Can you fix the code of Catalog-\nData.searchBooksByTitle?\nTheo Sure. All I need to do is to lowercase both the query string and the book title\nbefore comparing them. I’d probably do something like this.\nListing6.19 Fixed code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar queryLowerCased = query.toLowerCase();\nConverts the query\nvar matchingBooks = _.filter(allBooks, function(book) {\nto lowercase\nreturn _.get(book, \"title\")\n.toLowerCase()\nConverts the book\n.includes(queryLowerCased);\ntitle to lowercase\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nAfter fixing the code of Catalog.searchBooksByTitle, Theo runs all the test cases\nagain. This time, all of them pass—what a relief!\nListing6.20 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe It’s such good feeling when all the test cases pass.\nTheo Sure is.\nJoe I think we’ve written unit tests for all the search query code, so now we’re ready\nto write unit tests for mutations. Thank goodness the waiter just brought our\ncoffee orders.\n--- Page 154 ---\n126 CHAPTER 6 Unit tests\n6.4 Unit tests for mutations\nJoe Before writing unit tests for the add member mutation, let’s draw the tree of\nfunction calls for System.addMember.\nTheo I can do that.\nTheo takes a look at the code for the functions involved in the add member mutation. He\nnotices the code is spread over three classes: System, Library, and UserManagement.\nListing6.21 The functions involved in the add member mutation\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement, member);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nthrow \"Member already exists.\";\n}\nvar nextUserManagement = _.set(userManagement,\ninfoPath,\nmember);\nreturn nextUserManagement;\n};\nTheo grabs another napkin. Drawing the tree of function calls for System.addMember is\nnow quite easy (see figure 6.5).\nSystem.addMember\nSystemState.get SystemState.commit Library.addMember\n_.get _.set UserManagement.addMember\n_.has _.set\nFigure 6.5 The tree of function calls for System.addMember\n--- Page 155 ---\n6.4 Unit tests for mutations 127\nJoe Excellent! So which functions of the tree should be unit tested for the add\nmember mutation?\nTheo I think the functions we need to test are System.addMember, SystemState\n.get, SystemState.commit, Library.addMember, and UserManagement\n.addMember. That right?\nJoe You’re totally right. Let’s defer writing unit tests for functions that belong to\nSystemState until later. Those are generic functions that should be tested\noutside the context of a specific mutation. Let’s assume for now that we’ve\nalready written unit tests for the SystemState class. We’re left with three func-\ntions: System.addMember, Library.addMember, and UserManagement.add-\nMember.\nTheo In what order should we write the unit tests, bottom up or top down?\nJoe Let’s start where the real meat is—in UserManagement.addMember. The two\nother functions are just wrappers.\nTheo OK.\nJoe Writing a unit test for the main function of a mutation requires more effort\nthan writing the test for a query. The reason is that a query returns a response\nbased on the system data, whereas a mutation computes a new state of the system\nbased on the current state of the system and some arguments (see figure 6.6).\nSystemData Argument Argument SystemData\nMutation Query\nNextSystemData ResponseData\nFigure 6.6 The output of a mutation is more complex than\nthe output of a query.\nTIP Writing a unit test for the main function of a mutation requires more effort than\nfor a query.\nTheo It means that in the test cases of UserManagement.addMember, both the input\nand the expected output are maps that describe the state of the system.\nJoe Exactly. Let’s start with the simplest case, where the initial state of the system\nis empty.\nTheo You mean that userManagementData passed to UserManagement.addMember\nis an empty map?\nJoe Yes.\nOnce again, Theo places his hands over his laptop keyboard, thinks for a moment, and\nbegins typing. He reminds himself that the code needs to add a member to an empty user\n--- Page 156 ---\n128 CHAPTER 6 Unit tests\nmanagement map and to check that the resulting map is as expected. When he’s finished,\nhe shows his code to Joe.\nListing6.22 Test case for Catalog.addMember without members\nvar member = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, member);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Very nice! Keep going and write a test case when the initial state is not empty.\nTheo knows this requires a few more lines of code but nothing complicated. When he fin-\nishes, he once again shows the code to Joe.\nListing6.23 Test case for Catalog.addMember with existing members\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n--- Page 157 ---\n6.4 Unit tests for mutations 129\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, jessie);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Awesome! Can you think of other test cases for UserManagement.addMember?\nTheo No.\nJoe What about cases where the mutation fails?\nTheo Right! I always forget to think about negative test cases. I assume that relates to\nthe fact that I’m an optimistic person.\nTIP Don’t forget to include negative test cases in your unit tests.\nJoe Me too. The more I meditate, the more I’m able to focus on the positive side of\nlife. Anyway, how would you write a test case where the mutation fails?\nTheo I would pass to UserManagement.addMember a member that already exists in\nuserManagementStateBefore.\nJoe And how would you check that the code behaves as expected in case of a failure?\nTheo Let me see. When a member already exists, UserManagement.addMember\nthrows an exception. Therefore, what I need to do in my test case is to wrap the\ncode in a try/catch block.\nJoe Sounds good to me.\nOnce again, it doesn’t require too much of an effort for Theo to create a new test case.\nWhen he’s finished, he eagerly turns his laptop to Joe.\nListing6.24 Test case for UserManagement.addMember if it’s expected to fail\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\n--- Page 158 ---\n130 CHAPTER 6 Unit tests\nvar expectedException = \"Member already exists.\";\nvar exceptionInMutation;\ntry {\nUserManagement.addMember(userManagementStateBefore, jessie);\n} catch (e) {\nexceptionInMutation = e;\n}\n_.isEqual(exceptionInMutation, expectedException);\nTheo Now, I think I’m ready to move forward and write unit tests for Library.add-\nMember and System.addMember.\nJoe I agree with you. Please start with Library.addMember.\nTheo Library.addMember is quite similar to UserManagement.addMember. So I\nguess I’ll write similar test cases.\nJoe In fact, that won’t be required. As I told you when we wrote unit tests for a\nquery, when you write a unit test for a function, you can assume that the func-\ntions down the tree work as expected.\nTheo Right. So I’ll just write the test case for existing members.\nJoe Go for it!\nTheo starts with a copy-and-paste of the code from the UserManagement.addMember test\ncase with the existing members in listing 6.23. After a few modifications, the unit test for\nLibrary.addMember is ready.\nListing6.25 Unit test for Library.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 159 ---\n6.4 Unit tests for mutations 131\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar result = Library.addMember(libraryStateBefore, jessie);\n_.isEqual(result, expectedLibraryStateAfter);\nJoe Beautiful! Now, we’re ready for the last piece. Write a unit test for System\n.addMember. Before you start, could you please describe the input and the out-\nput of System.addMember?\nTheo takes another look at the code for System.addMember and hesitates; he’s a bit con-\nfused. The function doesn’t seem to return anything!\nListing6.26 The code of System.addMember\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nTheo The input of System.addMember is a system state instance and a member. But,\nI’m not sure what the output of System.addMember is.\nJoe In fact, System.addMember doesn’t have any output. It belongs to this stateful\npart of our code that doesn’t deal with data manipulation. Although DOP\nallows us to reduce the size of the stateful part of our code, it still exists. Here is\nhow I visualize it.\nJoe calls the waiter to see if he can get more napkins. With that problem resolved, he draws\nthe diagram in figure 6.7.\nSystemData Member\nMutation Change system state\nFigure 6.7 System.addMember\ndoesn’t return data—it changes the\nNothing system state!\n--- Page 160 ---\n132 CHAPTER 6 Unit tests\nTheo Then how do we validate that the code works as expected?\nJoe We’ll retrieve the system state after the code is executed and compare it to the\nexpected value of the state.\nTheo OK. I’ll try to write the unit test.\nJoe Writing unit tests for stateful code is more complicated than for data manipula-\ntion code. It requires the calm of the office.\nTheo Then let’s go back to the office. Waiter! Check, please.\nTheo picks up the tab, and he and Joe take the cable car back to Albatross. When they’re\nback at the office, Theo starts coding the unit test for Library.addMember.\nTheo Can we use _.isEqual with system state?\nJoe Definitely. The system state is a map like any other map.\nTIP The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state using\n_.isEqual\nTheo copies and pastes the code for Library.addMember (listing 6.21), which initializes\nthe data for the test. Then, he passes a SystemState object that is initialized with\nlibraryStateBefore to System.addMember. Finally, to complete the test, he compares\nthe system state after the mutation is executed with the expected value of the state.\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nwindow.SystemState = SystemState;\nListing6.27 Unit test for System.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 161 ---\n6.4 Unit tests for mutations 133\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\nCreates an empty\n}\nSystemState object\n}\n(see chapter 4)\n}\n};\nInitializes the system\nstate with the library\ndata before the\nvar systemState = new SystemState();\nmutation\nsystemState.commit(null, libraryStateBefore);\nSystem.addMember(systemState, jessie);\nExecutes the\nmutation on the\n_.isEqual(systemState.get(),\nSystemState object\nexpectedLibraryStateAfter);\nValidates the state after the\nmutation is executed\nJoe Wow, I’m impressed; you did it! Congratulations!\nTheo Thank you. I’m so glad that in DOP most of our code deals with data manipu-\nlation. It’s definitely more pleasant to write unit tests for stateless code that\nonly deals with data manipulation.\nJoe Now that you know the basics of DOP, would you like to refactor the code of\nyour Klafim prototype according to DOP principles?\nTheo Definitely. Nancy told me yesterday that Klafim is getting nice market traction.\nI’m supposed to have a meeting with her in a week or so about the next steps.\nHopefully, she’ll be willing to work with Albatross for the long term.\nJoe Exciting! Do you know what might influence Nancy’s decision?\nTheo Our cost estimate, certainly, but I know she’s in touch with other software com-\npanies. If we come up with a competitive proposal, I think we’ll get the deal.\nJoe I’m quite sure that after refactoring to DOP, features will take much less time\nto implement. That means you should be able to quote Nancy a lower total cost\nthan the competition, right?\nTheo I’ll keep my fingers crossed!\n--- Page 162 ---\n134 CHAPTER 6 Unit tests\nMoving forward\nThe meeting with Nancy went well. Albatross got the deal, Monica (Theo’s boss) is\npleased, and it’s going to be a long-term project with a nice budget. They’ll need to hire a\nteam of developers in order to meet the tough deadlines. While driving back to the office,\nTheo gets a phone call from Joe.\nJoe How was your meeting with Nancy?\nTheo We got the deal!\nJoe Awesome! I told you that with DOP the cost estimation would be lower.\nTheo In fact, we are not going to use DOP for this project.\nJoe Why?\nTheo After refactoring the Library Management System prototype to DOP, I did a\ndeep analysis with my engineers. We came to the conclusion that DOP might\nbe a good fit for the prototype phase, but it won’t work well at scale.\nJoe Could you share the details of your analysis?\nTheo I can’t right now. I’m driving.\nJoe Could we meet in your office later today?\nTheo I’m quite busy with the new project and the tough deadlines.\nJoe Let’s meet at least in order to have a proper farewell.\nTheo OK. Let’s meet at 4 PM, then.\n NOTE The story continues in the opener of part 2.\nSummary\n Most of the code in a data-oriented system deals with data manipulation.\n It’s straightforward to write unit tests for code that deals with data manipulation.\n Test cases follow the same simple general pattern:\na Generate data input\nb Generate expected data output\nc Compare the output of the function with the expected data output\n In order to compare the output of a function with the expected data output, we\nneed to recursively compare the two pieces of data.\n The recursive comparison of two pieces of data is implemented via a generic\nfunction.\n When a function returns a JSON string, we parse the string back to data so that\nwe deal with data comparison instead of string comparison.\n A tree of function calls for a function f is a tree where the root is f, and the chil-\ndren of a node g in the tree are the functions called by g.\n The leaves of the tree are functions that are not part of the code base of the\napplication and are functions that don’t call any other functions.\n The tree of function calls visualization guides us regarding the quality and\nquantity of the test cases in a unit test.\n--- Page 163 ---\nSummary 135\n Functions that appear in a lower level in the tree of function calls tend to involve\nless complex data than functions that appear in a higher level in the tree.\n Functions that appear in a lower level in the tree of function calls usually need\nto be covered with more test cases than functions that appear in a higher level\nin the tree.\n Unit tests for mutations focus on the calculation phase of the mutation.\n The validity of the data depends on the context.\n The smaller the data, the easier it is to manipulate.\n We compare the output and the expected output of our functions with a generic\nfunction that recursively compares two pieces of data (e.g., _.isEqual).\n When we write a unit test for a function, we assume that the functions called by\nthis function are covered by the unit tests and work as expected. This signifi-\ncantly reduces the quantity of test cases in our unit tests.\n We avoid using string comparison in unit tests for functions that deal with data.\n Writing a unit test for the main function of a mutation requires more effort\nthan for a query.\n Remember to include negative test cases in your unit tests.\n The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state\nusing a generic function like _.isEqual.\n--- Page 164 ---\n\n--- Page 165 ---\nPart 2\nScalability\nT\nheo feels a bit uncomfortable about the meeting with Joe. He was so enthusias-\ntic about DOP, and he was very good at teaching it. Every meeting with him was an\nopportunity to learn new things. Theo feels lot of gratitude for the time Joe spent\nwith him. He doesn’t want to hurt him in any fashion. Surprisingly, Joe enters the\noffice with the same relaxed attitude as usual, and he is even smiling.\nJoe I’m really glad that you got the deal with Nancy.\nTheo Yeah. There’s lot of excitement about it here in the office, and a bit of\nstress too.\nJoe What kind of stress?\nTheo You know.... We need to hire a team of developers, and the deadlines\nare quite tight.\nJoe But you told me that you won’t use DOP. I assume that you gave regular\ndeadlines?\nTheo No, my boss Monica really wanted to close the deal. She feels that success\nwith this project is strategically important for Albatross, so it’s worthwhile\nto accept some risk by giving what she calls an “optimistic” time estima-\ntion. I told her that it was really an unrealistic time estimation, but Mon-\nica insists that if we make smart decisions and bring in more developers,\nwe can do it.\nJoe I see. Now I understand why you told me over the phone that you were\nvery busy. Anyway, would you please share the reasons that made you\nthink DOP wouldn’t be a good fit at scale?\n--- Page 166 ---\n138 PART 2 Scalability\nTheo First of all, let me tell you that I feel lot of gratitude for all the teaching you\nshared with me. Reimplementing the Klafim prototype with DOP was really\nfun and productive due to the flexibility this paradigm offers.\nJoe I’m happy that you found it valuable.\nTheo But, as I told you over the phone, now we’re scaling up into a long-term project\nwith several developers working on a large code base. We came to the conclu-\nsion that DOP will not be a good fit at scale.\nJoe Could you share the reasons behind your conclusion?\nTheo There are many of them. First of all, as DOP deals only with generic data struc-\ntures, it’s hard to know what kind of data we have in hand, while in OOP, we\nknow the type of every piece of data. For the prototype, it was kind of OK. But\nas the code base grows and more developers are involved in the project, it\nwould be too painful.\nJoe I hear you. What else, my friend?\nTheo Our system is going to run on a multi-threaded environment. I reviewed the\nconcurrency control strategy that you presented, and it’s not thread-safe.\nJoe I hear you. What else, my friend?\nTheo I have been doing a bit of research about implementing immutable data struc-\ntures with structural sharing. I discovered that when the size of the data\nstructures grows, there is a significant performance hit.\nJoe I hear you. What else?\nTheo As our system grows, we will use a database to store the application data and\nexternal services to enrich book information, and in what you have showed me\nso far, data lives in memory.\nJoe I hear you. What else, my friend?\nTheo Don’t you think I have shared enough reasons to abandon DOP?\nJoe I think that your concerns about DOP at scale totally make sense. However, it\ndoesn’t mean that you should abandon DOP.\nTheo What do you mean?\nJoe With the help of meditation, I learned not be attached to the objections that\nflow in my mind while I’m practicing. Sometimes all that is needed to quiet our\nminds is to keep breathing; sometimes, a deeper level of practice is needed.\nTheo I don’t see how breathing would convince me to give DOP a second chance.\nJoe Breathing might not be enough in this case, but a deeper knowledge of DOP\ncould be helpful. Until now, I have shared with you only the material that was\nneeded in order to refactor your prototype. In order to use DOP in a big proj-\nect, a few more lessons are necessary.\nTheo But I don’t have time for more lessons. I need to work.\nJoe Have you heard the story about the young woodcutter and the old man?\nTheo No.\nJoe It goes like this.\n--- Page 167 ---\nPART 2 Scalability 139\nThe young woodcutter and the old man\nA young woodcutter strained to saw down a tree. An old man who was watching near-\nby asked, “What are you doing?”\n“Are you blind?” the woodcutter replied. “I’m cutting down this tree.”\nThe old man replied, “You look exhausted! Take a break. Sharpen your saw.”\nThe young woodcutter explained to the old man that he had been sawing for hours\nand did not have time to take a break.\nThe old man pushed back, “If you sharpen the saw, you would cut down the tree much\nfaster.”\nThe woodcutter said, “I don’t have time to sharpen the saw. Don’t you see, I’m too\nbusy!”\nTheo takes a moment to meditate on the story. He wonders if he needs to take the time to\nsharpen his saw and commit to a deeper level of practice.\nTheo Do you really think that with DOP, it will take much less time to deliver the\nproject?\nJoe I know so!\nTheo But if we miss the deadline, I will probably get fired. I’m the one that needs to\ntake the risk, not you.\nJoe Let’s make a deal. If you miss the deadline and get fired, I will hire you at my\ncompany for double the salary you make at Albatross.\nTheo And what if we meet the deadline?\nJoe If you meet the deadline, you will probably get promoted. In that case, I will\nask you to buy a gift for my son Neriah and my daughter Aurelia.\nTheo Deal! When will I get my first lesson about going deeper into DOP?\nJoe Why not start right now?\nTheo Let me reschedule my meetings.\n--- Page 168 ---\n\n--- Page 169 ---\nBasic data validation\nA solemn gift\nThis chapter covers\n The importance of validating data at system\nboundaries\n Validating data using the JSON Schema language\n Integrating data validation into an existing code\nbase\n Getting detailed information about data validation\nfailures\nAt first glance, it may seem that embracing DOP means accessing data without validat-\ning it and engaging in wishful thinking, where data is always valid. In fact, data valida-\ntion is not only possible but recommended when we follow data-oriented principles.\nThis chapter illustrates how to validate data when data is represented with\ngeneric data structures. It focuses on data validation occurring at the boundaries of\nthe system, while in part 3, we will deal with validating data as it flows through the\nsystem. This chapter is a deep dive into the fourth principle of DOP.\nPRINCIPLE #4 Separate data schema from data representation.\n141\n--- Page 170 ---\n142 CHAPTER 7 Basic data validation\n7.1 Data validation in DOP\nTheo has rescheduled his meetings. With such an imposing deadline, he’s still not sure if\nhe’s made a big mistake giving DOP a second chance.\n NOTE The reason why Theo rescheduled his meetings is explained in the opener\nfor part 2. Take a moment to read the opener if you missed it.\nJoe What aspect of OOP do you think you will miss the most in your big project?\nTheo Data validation.\nJoe Can you elaborate a bit?\nTheo In OOP, I have this strong guarantee that when a class is instantiated, its mem-\nber fields have the proper names and proper types. But with DOP, it’s so easy\nto have small mistakes in field names and field types.\nJoe Well, I have good news for you! There is a way to validate data in DOP.\nTheo How does it work? I thought DOP and data validation were two contradictory\nconcepts!\nJoe Not at all. It’s true that DOP doesn’t force you to validate data, but it doesn’t\nprevent you from doing so. In DOP, the data schema is separate from the data\nrepresentation.\nTheo I don’t get how that would eliminate data consistency issues.\nJoe According to DOP, the most important data to validate is data that crosses the\nboundaries of the system.\nTheo Which boundaries are you referring to?\nJoe In the case of a web server, it would be the areas where the web server commu-\nnicates with its clients and with its data sources.\nTheo A diagram might help me see it better.\nJoe goes to the whiteboard and picks up the pen. He then draws a diagram like the one in\nfigure 7.1.\nClient (e.g., web browser)\nData\nWeb server\nData Data\nWeb service Database Figure 7.1 High-level architecture of\na modern web server\n--- Page 171 ---\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n--- Page 172 ---\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n--- Page 173 ---\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n--- Page 174 ---\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n--- Page 175 ---\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer",
        "sections_found": []
      },
      "accurate_page_range": "152-175"
    },
    {
      "text": "- 6.1 The simplicity of data-oriented test cases",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "raw_line": "- 6.1 The simplicity of data-oriented test cases (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 46,
      "chapter_info": {
        "page": 152,
        "title": "Unit tests",
        "pattern_matched": "Chapter 6",
        "text_preview": "124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again "
      },
      "chapter_sections": {
        "start_page": 152,
        "end_page": 175,
        "content": "\n--- Page 152 ---\n124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again at the\ncode for Catalog.searchBooksByTitle.\nListing6.16 The code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nWriting the unit test for Catalog.searchBooksByTitle is a more pleasant experience for\nTheo than writing the unit test for Library.searchBooksByTitleJSON. He appreciates\nthis for two reasons:\n It’s not necessary to deserialize the output because the function returns data.\n It’s not necessary to wrap the catalog data in a library data map.\nListing6.17 Unit test for Catalog.searchBooksByTitle\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n--- Page 153 ---\n6.3 Unit tests for queries 125\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Watchmen\"), [bookInfo]);\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Batman\"), []);\nJoe That’s a good start!\nTheo I thought I was done. What did I miss?\nJoe You forgot to test cases where the query string is all lowercase.\nTheo You’re right! Let me quickly add one more test case.\nIn less than a minute, Theo creates an additional test case and shows it to Joe. What a dis-\nappointment when Theo discovers that the test case with \"watchmen\" in lowercase fails!\nListing6.18 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe Don’t be too upset, my friend. After all, the purpose of unit tests is to find bugs\nin the code so that you can fix them. Can you fix the code of Catalog-\nData.searchBooksByTitle?\nTheo Sure. All I need to do is to lowercase both the query string and the book title\nbefore comparing them. I’d probably do something like this.\nListing6.19 Fixed code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar queryLowerCased = query.toLowerCase();\nConverts the query\nvar matchingBooks = _.filter(allBooks, function(book) {\nto lowercase\nreturn _.get(book, \"title\")\n.toLowerCase()\nConverts the book\n.includes(queryLowerCased);\ntitle to lowercase\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nAfter fixing the code of Catalog.searchBooksByTitle, Theo runs all the test cases\nagain. This time, all of them pass—what a relief!\nListing6.20 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe It’s such good feeling when all the test cases pass.\nTheo Sure is.\nJoe I think we’ve written unit tests for all the search query code, so now we’re ready\nto write unit tests for mutations. Thank goodness the waiter just brought our\ncoffee orders.\n--- Page 154 ---\n126 CHAPTER 6 Unit tests\n6.4 Unit tests for mutations\nJoe Before writing unit tests for the add member mutation, let’s draw the tree of\nfunction calls for System.addMember.\nTheo I can do that.\nTheo takes a look at the code for the functions involved in the add member mutation. He\nnotices the code is spread over three classes: System, Library, and UserManagement.\nListing6.21 The functions involved in the add member mutation\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement, member);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nthrow \"Member already exists.\";\n}\nvar nextUserManagement = _.set(userManagement,\ninfoPath,\nmember);\nreturn nextUserManagement;\n};\nTheo grabs another napkin. Drawing the tree of function calls for System.addMember is\nnow quite easy (see figure 6.5).\nSystem.addMember\nSystemState.get SystemState.commit Library.addMember\n_.get _.set UserManagement.addMember\n_.has _.set\nFigure 6.5 The tree of function calls for System.addMember\n--- Page 155 ---\n6.4 Unit tests for mutations 127\nJoe Excellent! So which functions of the tree should be unit tested for the add\nmember mutation?\nTheo I think the functions we need to test are System.addMember, SystemState\n.get, SystemState.commit, Library.addMember, and UserManagement\n.addMember. That right?\nJoe You’re totally right. Let’s defer writing unit tests for functions that belong to\nSystemState until later. Those are generic functions that should be tested\noutside the context of a specific mutation. Let’s assume for now that we’ve\nalready written unit tests for the SystemState class. We’re left with three func-\ntions: System.addMember, Library.addMember, and UserManagement.add-\nMember.\nTheo In what order should we write the unit tests, bottom up or top down?\nJoe Let’s start where the real meat is—in UserManagement.addMember. The two\nother functions are just wrappers.\nTheo OK.\nJoe Writing a unit test for the main function of a mutation requires more effort\nthan writing the test for a query. The reason is that a query returns a response\nbased on the system data, whereas a mutation computes a new state of the system\nbased on the current state of the system and some arguments (see figure 6.6).\nSystemData Argument Argument SystemData\nMutation Query\nNextSystemData ResponseData\nFigure 6.6 The output of a mutation is more complex than\nthe output of a query.\nTIP Writing a unit test for the main function of a mutation requires more effort than\nfor a query.\nTheo It means that in the test cases of UserManagement.addMember, both the input\nand the expected output are maps that describe the state of the system.\nJoe Exactly. Let’s start with the simplest case, where the initial state of the system\nis empty.\nTheo You mean that userManagementData passed to UserManagement.addMember\nis an empty map?\nJoe Yes.\nOnce again, Theo places his hands over his laptop keyboard, thinks for a moment, and\nbegins typing. He reminds himself that the code needs to add a member to an empty user\n--- Page 156 ---\n128 CHAPTER 6 Unit tests\nmanagement map and to check that the resulting map is as expected. When he’s finished,\nhe shows his code to Joe.\nListing6.22 Test case for Catalog.addMember without members\nvar member = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, member);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Very nice! Keep going and write a test case when the initial state is not empty.\nTheo knows this requires a few more lines of code but nothing complicated. When he fin-\nishes, he once again shows the code to Joe.\nListing6.23 Test case for Catalog.addMember with existing members\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n--- Page 157 ---\n6.4 Unit tests for mutations 129\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, jessie);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Awesome! Can you think of other test cases for UserManagement.addMember?\nTheo No.\nJoe What about cases where the mutation fails?\nTheo Right! I always forget to think about negative test cases. I assume that relates to\nthe fact that I’m an optimistic person.\nTIP Don’t forget to include negative test cases in your unit tests.\nJoe Me too. The more I meditate, the more I’m able to focus on the positive side of\nlife. Anyway, how would you write a test case where the mutation fails?\nTheo I would pass to UserManagement.addMember a member that already exists in\nuserManagementStateBefore.\nJoe And how would you check that the code behaves as expected in case of a failure?\nTheo Let me see. When a member already exists, UserManagement.addMember\nthrows an exception. Therefore, what I need to do in my test case is to wrap the\ncode in a try/catch block.\nJoe Sounds good to me.\nOnce again, it doesn’t require too much of an effort for Theo to create a new test case.\nWhen he’s finished, he eagerly turns his laptop to Joe.\nListing6.24 Test case for UserManagement.addMember if it’s expected to fail\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\n--- Page 158 ---\n130 CHAPTER 6 Unit tests\nvar expectedException = \"Member already exists.\";\nvar exceptionInMutation;\ntry {\nUserManagement.addMember(userManagementStateBefore, jessie);\n} catch (e) {\nexceptionInMutation = e;\n}\n_.isEqual(exceptionInMutation, expectedException);\nTheo Now, I think I’m ready to move forward and write unit tests for Library.add-\nMember and System.addMember.\nJoe I agree with you. Please start with Library.addMember.\nTheo Library.addMember is quite similar to UserManagement.addMember. So I\nguess I’ll write similar test cases.\nJoe In fact, that won’t be required. As I told you when we wrote unit tests for a\nquery, when you write a unit test for a function, you can assume that the func-\ntions down the tree work as expected.\nTheo Right. So I’ll just write the test case for existing members.\nJoe Go for it!\nTheo starts with a copy-and-paste of the code from the UserManagement.addMember test\ncase with the existing members in listing 6.23. After a few modifications, the unit test for\nLibrary.addMember is ready.\nListing6.25 Unit test for Library.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 159 ---\n6.4 Unit tests for mutations 131\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar result = Library.addMember(libraryStateBefore, jessie);\n_.isEqual(result, expectedLibraryStateAfter);\nJoe Beautiful! Now, we’re ready for the last piece. Write a unit test for System\n.addMember. Before you start, could you please describe the input and the out-\nput of System.addMember?\nTheo takes another look at the code for System.addMember and hesitates; he’s a bit con-\nfused. The function doesn’t seem to return anything!\nListing6.26 The code of System.addMember\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nTheo The input of System.addMember is a system state instance and a member. But,\nI’m not sure what the output of System.addMember is.\nJoe In fact, System.addMember doesn’t have any output. It belongs to this stateful\npart of our code that doesn’t deal with data manipulation. Although DOP\nallows us to reduce the size of the stateful part of our code, it still exists. Here is\nhow I visualize it.\nJoe calls the waiter to see if he can get more napkins. With that problem resolved, he draws\nthe diagram in figure 6.7.\nSystemData Member\nMutation Change system state\nFigure 6.7 System.addMember\ndoesn’t return data—it changes the\nNothing system state!\n--- Page 160 ---\n132 CHAPTER 6 Unit tests\nTheo Then how do we validate that the code works as expected?\nJoe We’ll retrieve the system state after the code is executed and compare it to the\nexpected value of the state.\nTheo OK. I’ll try to write the unit test.\nJoe Writing unit tests for stateful code is more complicated than for data manipula-\ntion code. It requires the calm of the office.\nTheo Then let’s go back to the office. Waiter! Check, please.\nTheo picks up the tab, and he and Joe take the cable car back to Albatross. When they’re\nback at the office, Theo starts coding the unit test for Library.addMember.\nTheo Can we use _.isEqual with system state?\nJoe Definitely. The system state is a map like any other map.\nTIP The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state using\n_.isEqual\nTheo copies and pastes the code for Library.addMember (listing 6.21), which initializes\nthe data for the test. Then, he passes a SystemState object that is initialized with\nlibraryStateBefore to System.addMember. Finally, to complete the test, he compares\nthe system state after the mutation is executed with the expected value of the state.\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nwindow.SystemState = SystemState;\nListing6.27 Unit test for System.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 161 ---\n6.4 Unit tests for mutations 133\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\nCreates an empty\n}\nSystemState object\n}\n(see chapter 4)\n}\n};\nInitializes the system\nstate with the library\ndata before the\nvar systemState = new SystemState();\nmutation\nsystemState.commit(null, libraryStateBefore);\nSystem.addMember(systemState, jessie);\nExecutes the\nmutation on the\n_.isEqual(systemState.get(),\nSystemState object\nexpectedLibraryStateAfter);\nValidates the state after the\nmutation is executed\nJoe Wow, I’m impressed; you did it! Congratulations!\nTheo Thank you. I’m so glad that in DOP most of our code deals with data manipu-\nlation. It’s definitely more pleasant to write unit tests for stateless code that\nonly deals with data manipulation.\nJoe Now that you know the basics of DOP, would you like to refactor the code of\nyour Klafim prototype according to DOP principles?\nTheo Definitely. Nancy told me yesterday that Klafim is getting nice market traction.\nI’m supposed to have a meeting with her in a week or so about the next steps.\nHopefully, she’ll be willing to work with Albatross for the long term.\nJoe Exciting! Do you know what might influence Nancy’s decision?\nTheo Our cost estimate, certainly, but I know she’s in touch with other software com-\npanies. If we come up with a competitive proposal, I think we’ll get the deal.\nJoe I’m quite sure that after refactoring to DOP, features will take much less time\nto implement. That means you should be able to quote Nancy a lower total cost\nthan the competition, right?\nTheo I’ll keep my fingers crossed!\n--- Page 162 ---\n134 CHAPTER 6 Unit tests\nMoving forward\nThe meeting with Nancy went well. Albatross got the deal, Monica (Theo’s boss) is\npleased, and it’s going to be a long-term project with a nice budget. They’ll need to hire a\nteam of developers in order to meet the tough deadlines. While driving back to the office,\nTheo gets a phone call from Joe.\nJoe How was your meeting with Nancy?\nTheo We got the deal!\nJoe Awesome! I told you that with DOP the cost estimation would be lower.\nTheo In fact, we are not going to use DOP for this project.\nJoe Why?\nTheo After refactoring the Library Management System prototype to DOP, I did a\ndeep analysis with my engineers. We came to the conclusion that DOP might\nbe a good fit for the prototype phase, but it won’t work well at scale.\nJoe Could you share the details of your analysis?\nTheo I can’t right now. I’m driving.\nJoe Could we meet in your office later today?\nTheo I’m quite busy with the new project and the tough deadlines.\nJoe Let’s meet at least in order to have a proper farewell.\nTheo OK. Let’s meet at 4 PM, then.\n NOTE The story continues in the opener of part 2.\nSummary\n Most of the code in a data-oriented system deals with data manipulation.\n It’s straightforward to write unit tests for code that deals with data manipulation.\n Test cases follow the same simple general pattern:\na Generate data input\nb Generate expected data output\nc Compare the output of the function with the expected data output\n In order to compare the output of a function with the expected data output, we\nneed to recursively compare the two pieces of data.\n The recursive comparison of two pieces of data is implemented via a generic\nfunction.\n When a function returns a JSON string, we parse the string back to data so that\nwe deal with data comparison instead of string comparison.\n A tree of function calls for a function f is a tree where the root is f, and the chil-\ndren of a node g in the tree are the functions called by g.\n The leaves of the tree are functions that are not part of the code base of the\napplication and are functions that don’t call any other functions.\n The tree of function calls visualization guides us regarding the quality and\nquantity of the test cases in a unit test.\n--- Page 163 ---\nSummary 135\n Functions that appear in a lower level in the tree of function calls tend to involve\nless complex data than functions that appear in a higher level in the tree.\n Functions that appear in a lower level in the tree of function calls usually need\nto be covered with more test cases than functions that appear in a higher level\nin the tree.\n Unit tests for mutations focus on the calculation phase of the mutation.\n The validity of the data depends on the context.\n The smaller the data, the easier it is to manipulate.\n We compare the output and the expected output of our functions with a generic\nfunction that recursively compares two pieces of data (e.g., _.isEqual).\n When we write a unit test for a function, we assume that the functions called by\nthis function are covered by the unit tests and work as expected. This signifi-\ncantly reduces the quantity of test cases in our unit tests.\n We avoid using string comparison in unit tests for functions that deal with data.\n Writing a unit test for the main function of a mutation requires more effort\nthan for a query.\n Remember to include negative test cases in your unit tests.\n The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state\nusing a generic function like _.isEqual.\n--- Page 164 ---\n\n--- Page 165 ---\nPart 2\nScalability\nT\nheo feels a bit uncomfortable about the meeting with Joe. He was so enthusias-\ntic about DOP, and he was very good at teaching it. Every meeting with him was an\nopportunity to learn new things. Theo feels lot of gratitude for the time Joe spent\nwith him. He doesn’t want to hurt him in any fashion. Surprisingly, Joe enters the\noffice with the same relaxed attitude as usual, and he is even smiling.\nJoe I’m really glad that you got the deal with Nancy.\nTheo Yeah. There’s lot of excitement about it here in the office, and a bit of\nstress too.\nJoe What kind of stress?\nTheo You know.... We need to hire a team of developers, and the deadlines\nare quite tight.\nJoe But you told me that you won’t use DOP. I assume that you gave regular\ndeadlines?\nTheo No, my boss Monica really wanted to close the deal. She feels that success\nwith this project is strategically important for Albatross, so it’s worthwhile\nto accept some risk by giving what she calls an “optimistic” time estima-\ntion. I told her that it was really an unrealistic time estimation, but Mon-\nica insists that if we make smart decisions and bring in more developers,\nwe can do it.\nJoe I see. Now I understand why you told me over the phone that you were\nvery busy. Anyway, would you please share the reasons that made you\nthink DOP wouldn’t be a good fit at scale?\n--- Page 166 ---\n138 PART 2 Scalability\nTheo First of all, let me tell you that I feel lot of gratitude for all the teaching you\nshared with me. Reimplementing the Klafim prototype with DOP was really\nfun and productive due to the flexibility this paradigm offers.\nJoe I’m happy that you found it valuable.\nTheo But, as I told you over the phone, now we’re scaling up into a long-term project\nwith several developers working on a large code base. We came to the conclu-\nsion that DOP will not be a good fit at scale.\nJoe Could you share the reasons behind your conclusion?\nTheo There are many of them. First of all, as DOP deals only with generic data struc-\ntures, it’s hard to know what kind of data we have in hand, while in OOP, we\nknow the type of every piece of data. For the prototype, it was kind of OK. But\nas the code base grows and more developers are involved in the project, it\nwould be too painful.\nJoe I hear you. What else, my friend?\nTheo Our system is going to run on a multi-threaded environment. I reviewed the\nconcurrency control strategy that you presented, and it’s not thread-safe.\nJoe I hear you. What else, my friend?\nTheo I have been doing a bit of research about implementing immutable data struc-\ntures with structural sharing. I discovered that when the size of the data\nstructures grows, there is a significant performance hit.\nJoe I hear you. What else?\nTheo As our system grows, we will use a database to store the application data and\nexternal services to enrich book information, and in what you have showed me\nso far, data lives in memory.\nJoe I hear you. What else, my friend?\nTheo Don’t you think I have shared enough reasons to abandon DOP?\nJoe I think that your concerns about DOP at scale totally make sense. However, it\ndoesn’t mean that you should abandon DOP.\nTheo What do you mean?\nJoe With the help of meditation, I learned not be attached to the objections that\nflow in my mind while I’m practicing. Sometimes all that is needed to quiet our\nminds is to keep breathing; sometimes, a deeper level of practice is needed.\nTheo I don’t see how breathing would convince me to give DOP a second chance.\nJoe Breathing might not be enough in this case, but a deeper knowledge of DOP\ncould be helpful. Until now, I have shared with you only the material that was\nneeded in order to refactor your prototype. In order to use DOP in a big proj-\nect, a few more lessons are necessary.\nTheo But I don’t have time for more lessons. I need to work.\nJoe Have you heard the story about the young woodcutter and the old man?\nTheo No.\nJoe It goes like this.\n--- Page 167 ---\nPART 2 Scalability 139\nThe young woodcutter and the old man\nA young woodcutter strained to saw down a tree. An old man who was watching near-\nby asked, “What are you doing?”\n“Are you blind?” the woodcutter replied. “I’m cutting down this tree.”\nThe old man replied, “You look exhausted! Take a break. Sharpen your saw.”\nThe young woodcutter explained to the old man that he had been sawing for hours\nand did not have time to take a break.\nThe old man pushed back, “If you sharpen the saw, you would cut down the tree much\nfaster.”\nThe woodcutter said, “I don’t have time to sharpen the saw. Don’t you see, I’m too\nbusy!”\nTheo takes a moment to meditate on the story. He wonders if he needs to take the time to\nsharpen his saw and commit to a deeper level of practice.\nTheo Do you really think that with DOP, it will take much less time to deliver the\nproject?\nJoe I know so!\nTheo But if we miss the deadline, I will probably get fired. I’m the one that needs to\ntake the risk, not you.\nJoe Let’s make a deal. If you miss the deadline and get fired, I will hire you at my\ncompany for double the salary you make at Albatross.\nTheo And what if we meet the deadline?\nJoe If you meet the deadline, you will probably get promoted. In that case, I will\nask you to buy a gift for my son Neriah and my daughter Aurelia.\nTheo Deal! When will I get my first lesson about going deeper into DOP?\nJoe Why not start right now?\nTheo Let me reschedule my meetings.\n--- Page 168 ---\n\n--- Page 169 ---\nBasic data validation\nA solemn gift\nThis chapter covers\n The importance of validating data at system\nboundaries\n Validating data using the JSON Schema language\n Integrating data validation into an existing code\nbase\n Getting detailed information about data validation\nfailures\nAt first glance, it may seem that embracing DOP means accessing data without validat-\ning it and engaging in wishful thinking, where data is always valid. In fact, data valida-\ntion is not only possible but recommended when we follow data-oriented principles.\nThis chapter illustrates how to validate data when data is represented with\ngeneric data structures. It focuses on data validation occurring at the boundaries of\nthe system, while in part 3, we will deal with validating data as it flows through the\nsystem. This chapter is a deep dive into the fourth principle of DOP.\nPRINCIPLE #4 Separate data schema from data representation.\n141\n--- Page 170 ---\n142 CHAPTER 7 Basic data validation\n7.1 Data validation in DOP\nTheo has rescheduled his meetings. With such an imposing deadline, he’s still not sure if\nhe’s made a big mistake giving DOP a second chance.\n NOTE The reason why Theo rescheduled his meetings is explained in the opener\nfor part 2. Take a moment to read the opener if you missed it.\nJoe What aspect of OOP do you think you will miss the most in your big project?\nTheo Data validation.\nJoe Can you elaborate a bit?\nTheo In OOP, I have this strong guarantee that when a class is instantiated, its mem-\nber fields have the proper names and proper types. But with DOP, it’s so easy\nto have small mistakes in field names and field types.\nJoe Well, I have good news for you! There is a way to validate data in DOP.\nTheo How does it work? I thought DOP and data validation were two contradictory\nconcepts!\nJoe Not at all. It’s true that DOP doesn’t force you to validate data, but it doesn’t\nprevent you from doing so. In DOP, the data schema is separate from the data\nrepresentation.\nTheo I don’t get how that would eliminate data consistency issues.\nJoe According to DOP, the most important data to validate is data that crosses the\nboundaries of the system.\nTheo Which boundaries are you referring to?\nJoe In the case of a web server, it would be the areas where the web server commu-\nnicates with its clients and with its data sources.\nTheo A diagram might help me see it better.\nJoe goes to the whiteboard and picks up the pen. He then draws a diagram like the one in\nfigure 7.1.\nClient (e.g., web browser)\nData\nWeb server\nData Data\nWeb service Database Figure 7.1 High-level architecture of\na modern web server\n--- Page 171 ---\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n--- Page 172 ---\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n--- Page 173 ---\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n--- Page 174 ---\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n--- Page 175 ---\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer",
        "sections_found": []
      },
      "accurate_page_range": "152-175"
    },
    {
      "text": "- 6.2.0 Introduction (사용자 추가)",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "raw_line": "- 6.2.0 Introduction (사용자 추가) (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 47,
      "chapter_info": {
        "page": 152,
        "title": "Unit tests",
        "pattern_matched": "Chapter 6",
        "text_preview": "124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again "
      },
      "chapter_sections": {
        "start_page": 152,
        "end_page": 175,
        "content": "\n--- Page 152 ---\n124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again at the\ncode for Catalog.searchBooksByTitle.\nListing6.16 The code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nWriting the unit test for Catalog.searchBooksByTitle is a more pleasant experience for\nTheo than writing the unit test for Library.searchBooksByTitleJSON. He appreciates\nthis for two reasons:\n It’s not necessary to deserialize the output because the function returns data.\n It’s not necessary to wrap the catalog data in a library data map.\nListing6.17 Unit test for Catalog.searchBooksByTitle\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n--- Page 153 ---\n6.3 Unit tests for queries 125\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Watchmen\"), [bookInfo]);\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Batman\"), []);\nJoe That’s a good start!\nTheo I thought I was done. What did I miss?\nJoe You forgot to test cases where the query string is all lowercase.\nTheo You’re right! Let me quickly add one more test case.\nIn less than a minute, Theo creates an additional test case and shows it to Joe. What a dis-\nappointment when Theo discovers that the test case with \"watchmen\" in lowercase fails!\nListing6.18 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe Don’t be too upset, my friend. After all, the purpose of unit tests is to find bugs\nin the code so that you can fix them. Can you fix the code of Catalog-\nData.searchBooksByTitle?\nTheo Sure. All I need to do is to lowercase both the query string and the book title\nbefore comparing them. I’d probably do something like this.\nListing6.19 Fixed code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar queryLowerCased = query.toLowerCase();\nConverts the query\nvar matchingBooks = _.filter(allBooks, function(book) {\nto lowercase\nreturn _.get(book, \"title\")\n.toLowerCase()\nConverts the book\n.includes(queryLowerCased);\ntitle to lowercase\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nAfter fixing the code of Catalog.searchBooksByTitle, Theo runs all the test cases\nagain. This time, all of them pass—what a relief!\nListing6.20 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe It’s such good feeling when all the test cases pass.\nTheo Sure is.\nJoe I think we’ve written unit tests for all the search query code, so now we’re ready\nto write unit tests for mutations. Thank goodness the waiter just brought our\ncoffee orders.\n--- Page 154 ---\n126 CHAPTER 6 Unit tests\n6.4 Unit tests for mutations\nJoe Before writing unit tests for the add member mutation, let’s draw the tree of\nfunction calls for System.addMember.\nTheo I can do that.\nTheo takes a look at the code for the functions involved in the add member mutation. He\nnotices the code is spread over three classes: System, Library, and UserManagement.\nListing6.21 The functions involved in the add member mutation\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement, member);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nthrow \"Member already exists.\";\n}\nvar nextUserManagement = _.set(userManagement,\ninfoPath,\nmember);\nreturn nextUserManagement;\n};\nTheo grabs another napkin. Drawing the tree of function calls for System.addMember is\nnow quite easy (see figure 6.5).\nSystem.addMember\nSystemState.get SystemState.commit Library.addMember\n_.get _.set UserManagement.addMember\n_.has _.set\nFigure 6.5 The tree of function calls for System.addMember\n--- Page 155 ---\n6.4 Unit tests for mutations 127\nJoe Excellent! So which functions of the tree should be unit tested for the add\nmember mutation?\nTheo I think the functions we need to test are System.addMember, SystemState\n.get, SystemState.commit, Library.addMember, and UserManagement\n.addMember. That right?\nJoe You’re totally right. Let’s defer writing unit tests for functions that belong to\nSystemState until later. Those are generic functions that should be tested\noutside the context of a specific mutation. Let’s assume for now that we’ve\nalready written unit tests for the SystemState class. We’re left with three func-\ntions: System.addMember, Library.addMember, and UserManagement.add-\nMember.\nTheo In what order should we write the unit tests, bottom up or top down?\nJoe Let’s start where the real meat is—in UserManagement.addMember. The two\nother functions are just wrappers.\nTheo OK.\nJoe Writing a unit test for the main function of a mutation requires more effort\nthan writing the test for a query. The reason is that a query returns a response\nbased on the system data, whereas a mutation computes a new state of the system\nbased on the current state of the system and some arguments (see figure 6.6).\nSystemData Argument Argument SystemData\nMutation Query\nNextSystemData ResponseData\nFigure 6.6 The output of a mutation is more complex than\nthe output of a query.\nTIP Writing a unit test for the main function of a mutation requires more effort than\nfor a query.\nTheo It means that in the test cases of UserManagement.addMember, both the input\nand the expected output are maps that describe the state of the system.\nJoe Exactly. Let’s start with the simplest case, where the initial state of the system\nis empty.\nTheo You mean that userManagementData passed to UserManagement.addMember\nis an empty map?\nJoe Yes.\nOnce again, Theo places his hands over his laptop keyboard, thinks for a moment, and\nbegins typing. He reminds himself that the code needs to add a member to an empty user\n--- Page 156 ---\n128 CHAPTER 6 Unit tests\nmanagement map and to check that the resulting map is as expected. When he’s finished,\nhe shows his code to Joe.\nListing6.22 Test case for Catalog.addMember without members\nvar member = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, member);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Very nice! Keep going and write a test case when the initial state is not empty.\nTheo knows this requires a few more lines of code but nothing complicated. When he fin-\nishes, he once again shows the code to Joe.\nListing6.23 Test case for Catalog.addMember with existing members\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n--- Page 157 ---\n6.4 Unit tests for mutations 129\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, jessie);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Awesome! Can you think of other test cases for UserManagement.addMember?\nTheo No.\nJoe What about cases where the mutation fails?\nTheo Right! I always forget to think about negative test cases. I assume that relates to\nthe fact that I’m an optimistic person.\nTIP Don’t forget to include negative test cases in your unit tests.\nJoe Me too. The more I meditate, the more I’m able to focus on the positive side of\nlife. Anyway, how would you write a test case where the mutation fails?\nTheo I would pass to UserManagement.addMember a member that already exists in\nuserManagementStateBefore.\nJoe And how would you check that the code behaves as expected in case of a failure?\nTheo Let me see. When a member already exists, UserManagement.addMember\nthrows an exception. Therefore, what I need to do in my test case is to wrap the\ncode in a try/catch block.\nJoe Sounds good to me.\nOnce again, it doesn’t require too much of an effort for Theo to create a new test case.\nWhen he’s finished, he eagerly turns his laptop to Joe.\nListing6.24 Test case for UserManagement.addMember if it’s expected to fail\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\n--- Page 158 ---\n130 CHAPTER 6 Unit tests\nvar expectedException = \"Member already exists.\";\nvar exceptionInMutation;\ntry {\nUserManagement.addMember(userManagementStateBefore, jessie);\n} catch (e) {\nexceptionInMutation = e;\n}\n_.isEqual(exceptionInMutation, expectedException);\nTheo Now, I think I’m ready to move forward and write unit tests for Library.add-\nMember and System.addMember.\nJoe I agree with you. Please start with Library.addMember.\nTheo Library.addMember is quite similar to UserManagement.addMember. So I\nguess I’ll write similar test cases.\nJoe In fact, that won’t be required. As I told you when we wrote unit tests for a\nquery, when you write a unit test for a function, you can assume that the func-\ntions down the tree work as expected.\nTheo Right. So I’ll just write the test case for existing members.\nJoe Go for it!\nTheo starts with a copy-and-paste of the code from the UserManagement.addMember test\ncase with the existing members in listing 6.23. After a few modifications, the unit test for\nLibrary.addMember is ready.\nListing6.25 Unit test for Library.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 159 ---\n6.4 Unit tests for mutations 131\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar result = Library.addMember(libraryStateBefore, jessie);\n_.isEqual(result, expectedLibraryStateAfter);\nJoe Beautiful! Now, we’re ready for the last piece. Write a unit test for System\n.addMember. Before you start, could you please describe the input and the out-\nput of System.addMember?\nTheo takes another look at the code for System.addMember and hesitates; he’s a bit con-\nfused. The function doesn’t seem to return anything!\nListing6.26 The code of System.addMember\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nTheo The input of System.addMember is a system state instance and a member. But,\nI’m not sure what the output of System.addMember is.\nJoe In fact, System.addMember doesn’t have any output. It belongs to this stateful\npart of our code that doesn’t deal with data manipulation. Although DOP\nallows us to reduce the size of the stateful part of our code, it still exists. Here is\nhow I visualize it.\nJoe calls the waiter to see if he can get more napkins. With that problem resolved, he draws\nthe diagram in figure 6.7.\nSystemData Member\nMutation Change system state\nFigure 6.7 System.addMember\ndoesn’t return data—it changes the\nNothing system state!\n--- Page 160 ---\n132 CHAPTER 6 Unit tests\nTheo Then how do we validate that the code works as expected?\nJoe We’ll retrieve the system state after the code is executed and compare it to the\nexpected value of the state.\nTheo OK. I’ll try to write the unit test.\nJoe Writing unit tests for stateful code is more complicated than for data manipula-\ntion code. It requires the calm of the office.\nTheo Then let’s go back to the office. Waiter! Check, please.\nTheo picks up the tab, and he and Joe take the cable car back to Albatross. When they’re\nback at the office, Theo starts coding the unit test for Library.addMember.\nTheo Can we use _.isEqual with system state?\nJoe Definitely. The system state is a map like any other map.\nTIP The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state using\n_.isEqual\nTheo copies and pastes the code for Library.addMember (listing 6.21), which initializes\nthe data for the test. Then, he passes a SystemState object that is initialized with\nlibraryStateBefore to System.addMember. Finally, to complete the test, he compares\nthe system state after the mutation is executed with the expected value of the state.\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nwindow.SystemState = SystemState;\nListing6.27 Unit test for System.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 161 ---\n6.4 Unit tests for mutations 133\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\nCreates an empty\n}\nSystemState object\n}\n(see chapter 4)\n}\n};\nInitializes the system\nstate with the library\ndata before the\nvar systemState = new SystemState();\nmutation\nsystemState.commit(null, libraryStateBefore);\nSystem.addMember(systemState, jessie);\nExecutes the\nmutation on the\n_.isEqual(systemState.get(),\nSystemState object\nexpectedLibraryStateAfter);\nValidates the state after the\nmutation is executed\nJoe Wow, I’m impressed; you did it! Congratulations!\nTheo Thank you. I’m so glad that in DOP most of our code deals with data manipu-\nlation. It’s definitely more pleasant to write unit tests for stateless code that\nonly deals with data manipulation.\nJoe Now that you know the basics of DOP, would you like to refactor the code of\nyour Klafim prototype according to DOP principles?\nTheo Definitely. Nancy told me yesterday that Klafim is getting nice market traction.\nI’m supposed to have a meeting with her in a week or so about the next steps.\nHopefully, she’ll be willing to work with Albatross for the long term.\nJoe Exciting! Do you know what might influence Nancy’s decision?\nTheo Our cost estimate, certainly, but I know she’s in touch with other software com-\npanies. If we come up with a competitive proposal, I think we’ll get the deal.\nJoe I’m quite sure that after refactoring to DOP, features will take much less time\nto implement. That means you should be able to quote Nancy a lower total cost\nthan the competition, right?\nTheo I’ll keep my fingers crossed!\n--- Page 162 ---\n134 CHAPTER 6 Unit tests\nMoving forward\nThe meeting with Nancy went well. Albatross got the deal, Monica (Theo’s boss) is\npleased, and it’s going to be a long-term project with a nice budget. They’ll need to hire a\nteam of developers in order to meet the tough deadlines. While driving back to the office,\nTheo gets a phone call from Joe.\nJoe How was your meeting with Nancy?\nTheo We got the deal!\nJoe Awesome! I told you that with DOP the cost estimation would be lower.\nTheo In fact, we are not going to use DOP for this project.\nJoe Why?\nTheo After refactoring the Library Management System prototype to DOP, I did a\ndeep analysis with my engineers. We came to the conclusion that DOP might\nbe a good fit for the prototype phase, but it won’t work well at scale.\nJoe Could you share the details of your analysis?\nTheo I can’t right now. I’m driving.\nJoe Could we meet in your office later today?\nTheo I’m quite busy with the new project and the tough deadlines.\nJoe Let’s meet at least in order to have a proper farewell.\nTheo OK. Let’s meet at 4 PM, then.\n NOTE The story continues in the opener of part 2.\nSummary\n Most of the code in a data-oriented system deals with data manipulation.\n It’s straightforward to write unit tests for code that deals with data manipulation.\n Test cases follow the same simple general pattern:\na Generate data input\nb Generate expected data output\nc Compare the output of the function with the expected data output\n In order to compare the output of a function with the expected data output, we\nneed to recursively compare the two pieces of data.\n The recursive comparison of two pieces of data is implemented via a generic\nfunction.\n When a function returns a JSON string, we parse the string back to data so that\nwe deal with data comparison instead of string comparison.\n A tree of function calls for a function f is a tree where the root is f, and the chil-\ndren of a node g in the tree are the functions called by g.\n The leaves of the tree are functions that are not part of the code base of the\napplication and are functions that don’t call any other functions.\n The tree of function calls visualization guides us regarding the quality and\nquantity of the test cases in a unit test.\n--- Page 163 ---\nSummary 135\n Functions that appear in a lower level in the tree of function calls tend to involve\nless complex data than functions that appear in a higher level in the tree.\n Functions that appear in a lower level in the tree of function calls usually need\nto be covered with more test cases than functions that appear in a higher level\nin the tree.\n Unit tests for mutations focus on the calculation phase of the mutation.\n The validity of the data depends on the context.\n The smaller the data, the easier it is to manipulate.\n We compare the output and the expected output of our functions with a generic\nfunction that recursively compares two pieces of data (e.g., _.isEqual).\n When we write a unit test for a function, we assume that the functions called by\nthis function are covered by the unit tests and work as expected. This signifi-\ncantly reduces the quantity of test cases in our unit tests.\n We avoid using string comparison in unit tests for functions that deal with data.\n Writing a unit test for the main function of a mutation requires more effort\nthan for a query.\n Remember to include negative test cases in your unit tests.\n The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state\nusing a generic function like _.isEqual.\n--- Page 164 ---\n\n--- Page 165 ---\nPart 2\nScalability\nT\nheo feels a bit uncomfortable about the meeting with Joe. He was so enthusias-\ntic about DOP, and he was very good at teaching it. Every meeting with him was an\nopportunity to learn new things. Theo feels lot of gratitude for the time Joe spent\nwith him. He doesn’t want to hurt him in any fashion. Surprisingly, Joe enters the\noffice with the same relaxed attitude as usual, and he is even smiling.\nJoe I’m really glad that you got the deal with Nancy.\nTheo Yeah. There’s lot of excitement about it here in the office, and a bit of\nstress too.\nJoe What kind of stress?\nTheo You know.... We need to hire a team of developers, and the deadlines\nare quite tight.\nJoe But you told me that you won’t use DOP. I assume that you gave regular\ndeadlines?\nTheo No, my boss Monica really wanted to close the deal. She feels that success\nwith this project is strategically important for Albatross, so it’s worthwhile\nto accept some risk by giving what she calls an “optimistic” time estima-\ntion. I told her that it was really an unrealistic time estimation, but Mon-\nica insists that if we make smart decisions and bring in more developers,\nwe can do it.\nJoe I see. Now I understand why you told me over the phone that you were\nvery busy. Anyway, would you please share the reasons that made you\nthink DOP wouldn’t be a good fit at scale?\n--- Page 166 ---\n138 PART 2 Scalability\nTheo First of all, let me tell you that I feel lot of gratitude for all the teaching you\nshared with me. Reimplementing the Klafim prototype with DOP was really\nfun and productive due to the flexibility this paradigm offers.\nJoe I’m happy that you found it valuable.\nTheo But, as I told you over the phone, now we’re scaling up into a long-term project\nwith several developers working on a large code base. We came to the conclu-\nsion that DOP will not be a good fit at scale.\nJoe Could you share the reasons behind your conclusion?\nTheo There are many of them. First of all, as DOP deals only with generic data struc-\ntures, it’s hard to know what kind of data we have in hand, while in OOP, we\nknow the type of every piece of data. For the prototype, it was kind of OK. But\nas the code base grows and more developers are involved in the project, it\nwould be too painful.\nJoe I hear you. What else, my friend?\nTheo Our system is going to run on a multi-threaded environment. I reviewed the\nconcurrency control strategy that you presented, and it’s not thread-safe.\nJoe I hear you. What else, my friend?\nTheo I have been doing a bit of research about implementing immutable data struc-\ntures with structural sharing. I discovered that when the size of the data\nstructures grows, there is a significant performance hit.\nJoe I hear you. What else?\nTheo As our system grows, we will use a database to store the application data and\nexternal services to enrich book information, and in what you have showed me\nso far, data lives in memory.\nJoe I hear you. What else, my friend?\nTheo Don’t you think I have shared enough reasons to abandon DOP?\nJoe I think that your concerns about DOP at scale totally make sense. However, it\ndoesn’t mean that you should abandon DOP.\nTheo What do you mean?\nJoe With the help of meditation, I learned not be attached to the objections that\nflow in my mind while I’m practicing. Sometimes all that is needed to quiet our\nminds is to keep breathing; sometimes, a deeper level of practice is needed.\nTheo I don’t see how breathing would convince me to give DOP a second chance.\nJoe Breathing might not be enough in this case, but a deeper knowledge of DOP\ncould be helpful. Until now, I have shared with you only the material that was\nneeded in order to refactor your prototype. In order to use DOP in a big proj-\nect, a few more lessons are necessary.\nTheo But I don’t have time for more lessons. I need to work.\nJoe Have you heard the story about the young woodcutter and the old man?\nTheo No.\nJoe It goes like this.\n--- Page 167 ---\nPART 2 Scalability 139\nThe young woodcutter and the old man\nA young woodcutter strained to saw down a tree. An old man who was watching near-\nby asked, “What are you doing?”\n“Are you blind?” the woodcutter replied. “I’m cutting down this tree.”\nThe old man replied, “You look exhausted! Take a break. Sharpen your saw.”\nThe young woodcutter explained to the old man that he had been sawing for hours\nand did not have time to take a break.\nThe old man pushed back, “If you sharpen the saw, you would cut down the tree much\nfaster.”\nThe woodcutter said, “I don’t have time to sharpen the saw. Don’t you see, I’m too\nbusy!”\nTheo takes a moment to meditate on the story. He wonders if he needs to take the time to\nsharpen his saw and commit to a deeper level of practice.\nTheo Do you really think that with DOP, it will take much less time to deliver the\nproject?\nJoe I know so!\nTheo But if we miss the deadline, I will probably get fired. I’m the one that needs to\ntake the risk, not you.\nJoe Let’s make a deal. If you miss the deadline and get fired, I will hire you at my\ncompany for double the salary you make at Albatross.\nTheo And what if we meet the deadline?\nJoe If you meet the deadline, you will probably get promoted. In that case, I will\nask you to buy a gift for my son Neriah and my daughter Aurelia.\nTheo Deal! When will I get my first lesson about going deeper into DOP?\nJoe Why not start right now?\nTheo Let me reschedule my meetings.\n--- Page 168 ---\n\n--- Page 169 ---\nBasic data validation\nA solemn gift\nThis chapter covers\n The importance of validating data at system\nboundaries\n Validating data using the JSON Schema language\n Integrating data validation into an existing code\nbase\n Getting detailed information about data validation\nfailures\nAt first glance, it may seem that embracing DOP means accessing data without validat-\ning it and engaging in wishful thinking, where data is always valid. In fact, data valida-\ntion is not only possible but recommended when we follow data-oriented principles.\nThis chapter illustrates how to validate data when data is represented with\ngeneric data structures. It focuses on data validation occurring at the boundaries of\nthe system, while in part 3, we will deal with validating data as it flows through the\nsystem. This chapter is a deep dive into the fourth principle of DOP.\nPRINCIPLE #4 Separate data schema from data representation.\n141\n--- Page 170 ---\n142 CHAPTER 7 Basic data validation\n7.1 Data validation in DOP\nTheo has rescheduled his meetings. With such an imposing deadline, he’s still not sure if\nhe’s made a big mistake giving DOP a second chance.\n NOTE The reason why Theo rescheduled his meetings is explained in the opener\nfor part 2. Take a moment to read the opener if you missed it.\nJoe What aspect of OOP do you think you will miss the most in your big project?\nTheo Data validation.\nJoe Can you elaborate a bit?\nTheo In OOP, I have this strong guarantee that when a class is instantiated, its mem-\nber fields have the proper names and proper types. But with DOP, it’s so easy\nto have small mistakes in field names and field types.\nJoe Well, I have good news for you! There is a way to validate data in DOP.\nTheo How does it work? I thought DOP and data validation were two contradictory\nconcepts!\nJoe Not at all. It’s true that DOP doesn’t force you to validate data, but it doesn’t\nprevent you from doing so. In DOP, the data schema is separate from the data\nrepresentation.\nTheo I don’t get how that would eliminate data consistency issues.\nJoe According to DOP, the most important data to validate is data that crosses the\nboundaries of the system.\nTheo Which boundaries are you referring to?\nJoe In the case of a web server, it would be the areas where the web server commu-\nnicates with its clients and with its data sources.\nTheo A diagram might help me see it better.\nJoe goes to the whiteboard and picks up the pen. He then draws a diagram like the one in\nfigure 7.1.\nClient (e.g., web browser)\nData\nWeb server\nData Data\nWeb service Database Figure 7.1 High-level architecture of\na modern web server\n--- Page 171 ---\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n--- Page 172 ---\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n--- Page 173 ---\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n--- Page 174 ---\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n--- Page 175 ---\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer",
        "sections_found": []
      },
      "accurate_page_range": "152-175"
    },
    {
      "text": "- 6.2.1 The tree of function calls",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "raw_line": "- 6.2.1 The tree of function calls (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 48,
      "chapter_info": {
        "page": 152,
        "title": "Unit tests",
        "pattern_matched": "Chapter 6",
        "text_preview": "124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again "
      },
      "chapter_sections": {
        "start_page": 152,
        "end_page": 175,
        "content": "\n--- Page 152 ---\n124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again at the\ncode for Catalog.searchBooksByTitle.\nListing6.16 The code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nWriting the unit test for Catalog.searchBooksByTitle is a more pleasant experience for\nTheo than writing the unit test for Library.searchBooksByTitleJSON. He appreciates\nthis for two reasons:\n It’s not necessary to deserialize the output because the function returns data.\n It’s not necessary to wrap the catalog data in a library data map.\nListing6.17 Unit test for Catalog.searchBooksByTitle\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n--- Page 153 ---\n6.3 Unit tests for queries 125\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Watchmen\"), [bookInfo]);\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Batman\"), []);\nJoe That’s a good start!\nTheo I thought I was done. What did I miss?\nJoe You forgot to test cases where the query string is all lowercase.\nTheo You’re right! Let me quickly add one more test case.\nIn less than a minute, Theo creates an additional test case and shows it to Joe. What a dis-\nappointment when Theo discovers that the test case with \"watchmen\" in lowercase fails!\nListing6.18 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe Don’t be too upset, my friend. After all, the purpose of unit tests is to find bugs\nin the code so that you can fix them. Can you fix the code of Catalog-\nData.searchBooksByTitle?\nTheo Sure. All I need to do is to lowercase both the query string and the book title\nbefore comparing them. I’d probably do something like this.\nListing6.19 Fixed code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar queryLowerCased = query.toLowerCase();\nConverts the query\nvar matchingBooks = _.filter(allBooks, function(book) {\nto lowercase\nreturn _.get(book, \"title\")\n.toLowerCase()\nConverts the book\n.includes(queryLowerCased);\ntitle to lowercase\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nAfter fixing the code of Catalog.searchBooksByTitle, Theo runs all the test cases\nagain. This time, all of them pass—what a relief!\nListing6.20 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe It’s such good feeling when all the test cases pass.\nTheo Sure is.\nJoe I think we’ve written unit tests for all the search query code, so now we’re ready\nto write unit tests for mutations. Thank goodness the waiter just brought our\ncoffee orders.\n--- Page 154 ---\n126 CHAPTER 6 Unit tests\n6.4 Unit tests for mutations\nJoe Before writing unit tests for the add member mutation, let’s draw the tree of\nfunction calls for System.addMember.\nTheo I can do that.\nTheo takes a look at the code for the functions involved in the add member mutation. He\nnotices the code is spread over three classes: System, Library, and UserManagement.\nListing6.21 The functions involved in the add member mutation\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement, member);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nthrow \"Member already exists.\";\n}\nvar nextUserManagement = _.set(userManagement,\ninfoPath,\nmember);\nreturn nextUserManagement;\n};\nTheo grabs another napkin. Drawing the tree of function calls for System.addMember is\nnow quite easy (see figure 6.5).\nSystem.addMember\nSystemState.get SystemState.commit Library.addMember\n_.get _.set UserManagement.addMember\n_.has _.set\nFigure 6.5 The tree of function calls for System.addMember\n--- Page 155 ---\n6.4 Unit tests for mutations 127\nJoe Excellent! So which functions of the tree should be unit tested for the add\nmember mutation?\nTheo I think the functions we need to test are System.addMember, SystemState\n.get, SystemState.commit, Library.addMember, and UserManagement\n.addMember. That right?\nJoe You’re totally right. Let’s defer writing unit tests for functions that belong to\nSystemState until later. Those are generic functions that should be tested\noutside the context of a specific mutation. Let’s assume for now that we’ve\nalready written unit tests for the SystemState class. We’re left with three func-\ntions: System.addMember, Library.addMember, and UserManagement.add-\nMember.\nTheo In what order should we write the unit tests, bottom up or top down?\nJoe Let’s start where the real meat is—in UserManagement.addMember. The two\nother functions are just wrappers.\nTheo OK.\nJoe Writing a unit test for the main function of a mutation requires more effort\nthan writing the test for a query. The reason is that a query returns a response\nbased on the system data, whereas a mutation computes a new state of the system\nbased on the current state of the system and some arguments (see figure 6.6).\nSystemData Argument Argument SystemData\nMutation Query\nNextSystemData ResponseData\nFigure 6.6 The output of a mutation is more complex than\nthe output of a query.\nTIP Writing a unit test for the main function of a mutation requires more effort than\nfor a query.\nTheo It means that in the test cases of UserManagement.addMember, both the input\nand the expected output are maps that describe the state of the system.\nJoe Exactly. Let’s start with the simplest case, where the initial state of the system\nis empty.\nTheo You mean that userManagementData passed to UserManagement.addMember\nis an empty map?\nJoe Yes.\nOnce again, Theo places his hands over his laptop keyboard, thinks for a moment, and\nbegins typing. He reminds himself that the code needs to add a member to an empty user\n--- Page 156 ---\n128 CHAPTER 6 Unit tests\nmanagement map and to check that the resulting map is as expected. When he’s finished,\nhe shows his code to Joe.\nListing6.22 Test case for Catalog.addMember without members\nvar member = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, member);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Very nice! Keep going and write a test case when the initial state is not empty.\nTheo knows this requires a few more lines of code but nothing complicated. When he fin-\nishes, he once again shows the code to Joe.\nListing6.23 Test case for Catalog.addMember with existing members\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n--- Page 157 ---\n6.4 Unit tests for mutations 129\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, jessie);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Awesome! Can you think of other test cases for UserManagement.addMember?\nTheo No.\nJoe What about cases where the mutation fails?\nTheo Right! I always forget to think about negative test cases. I assume that relates to\nthe fact that I’m an optimistic person.\nTIP Don’t forget to include negative test cases in your unit tests.\nJoe Me too. The more I meditate, the more I’m able to focus on the positive side of\nlife. Anyway, how would you write a test case where the mutation fails?\nTheo I would pass to UserManagement.addMember a member that already exists in\nuserManagementStateBefore.\nJoe And how would you check that the code behaves as expected in case of a failure?\nTheo Let me see. When a member already exists, UserManagement.addMember\nthrows an exception. Therefore, what I need to do in my test case is to wrap the\ncode in a try/catch block.\nJoe Sounds good to me.\nOnce again, it doesn’t require too much of an effort for Theo to create a new test case.\nWhen he’s finished, he eagerly turns his laptop to Joe.\nListing6.24 Test case for UserManagement.addMember if it’s expected to fail\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\n--- Page 158 ---\n130 CHAPTER 6 Unit tests\nvar expectedException = \"Member already exists.\";\nvar exceptionInMutation;\ntry {\nUserManagement.addMember(userManagementStateBefore, jessie);\n} catch (e) {\nexceptionInMutation = e;\n}\n_.isEqual(exceptionInMutation, expectedException);\nTheo Now, I think I’m ready to move forward and write unit tests for Library.add-\nMember and System.addMember.\nJoe I agree with you. Please start with Library.addMember.\nTheo Library.addMember is quite similar to UserManagement.addMember. So I\nguess I’ll write similar test cases.\nJoe In fact, that won’t be required. As I told you when we wrote unit tests for a\nquery, when you write a unit test for a function, you can assume that the func-\ntions down the tree work as expected.\nTheo Right. So I’ll just write the test case for existing members.\nJoe Go for it!\nTheo starts with a copy-and-paste of the code from the UserManagement.addMember test\ncase with the existing members in listing 6.23. After a few modifications, the unit test for\nLibrary.addMember is ready.\nListing6.25 Unit test for Library.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 159 ---\n6.4 Unit tests for mutations 131\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar result = Library.addMember(libraryStateBefore, jessie);\n_.isEqual(result, expectedLibraryStateAfter);\nJoe Beautiful! Now, we’re ready for the last piece. Write a unit test for System\n.addMember. Before you start, could you please describe the input and the out-\nput of System.addMember?\nTheo takes another look at the code for System.addMember and hesitates; he’s a bit con-\nfused. The function doesn’t seem to return anything!\nListing6.26 The code of System.addMember\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nTheo The input of System.addMember is a system state instance and a member. But,\nI’m not sure what the output of System.addMember is.\nJoe In fact, System.addMember doesn’t have any output. It belongs to this stateful\npart of our code that doesn’t deal with data manipulation. Although DOP\nallows us to reduce the size of the stateful part of our code, it still exists. Here is\nhow I visualize it.\nJoe calls the waiter to see if he can get more napkins. With that problem resolved, he draws\nthe diagram in figure 6.7.\nSystemData Member\nMutation Change system state\nFigure 6.7 System.addMember\ndoesn’t return data—it changes the\nNothing system state!\n--- Page 160 ---\n132 CHAPTER 6 Unit tests\nTheo Then how do we validate that the code works as expected?\nJoe We’ll retrieve the system state after the code is executed and compare it to the\nexpected value of the state.\nTheo OK. I’ll try to write the unit test.\nJoe Writing unit tests for stateful code is more complicated than for data manipula-\ntion code. It requires the calm of the office.\nTheo Then let’s go back to the office. Waiter! Check, please.\nTheo picks up the tab, and he and Joe take the cable car back to Albatross. When they’re\nback at the office, Theo starts coding the unit test for Library.addMember.\nTheo Can we use _.isEqual with system state?\nJoe Definitely. The system state is a map like any other map.\nTIP The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state using\n_.isEqual\nTheo copies and pastes the code for Library.addMember (listing 6.21), which initializes\nthe data for the test. Then, he passes a SystemState object that is initialized with\nlibraryStateBefore to System.addMember. Finally, to complete the test, he compares\nthe system state after the mutation is executed with the expected value of the state.\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nwindow.SystemState = SystemState;\nListing6.27 Unit test for System.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 161 ---\n6.4 Unit tests for mutations 133\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\nCreates an empty\n}\nSystemState object\n}\n(see chapter 4)\n}\n};\nInitializes the system\nstate with the library\ndata before the\nvar systemState = new SystemState();\nmutation\nsystemState.commit(null, libraryStateBefore);\nSystem.addMember(systemState, jessie);\nExecutes the\nmutation on the\n_.isEqual(systemState.get(),\nSystemState object\nexpectedLibraryStateAfter);\nValidates the state after the\nmutation is executed\nJoe Wow, I’m impressed; you did it! Congratulations!\nTheo Thank you. I’m so glad that in DOP most of our code deals with data manipu-\nlation. It’s definitely more pleasant to write unit tests for stateless code that\nonly deals with data manipulation.\nJoe Now that you know the basics of DOP, would you like to refactor the code of\nyour Klafim prototype according to DOP principles?\nTheo Definitely. Nancy told me yesterday that Klafim is getting nice market traction.\nI’m supposed to have a meeting with her in a week or so about the next steps.\nHopefully, she’ll be willing to work with Albatross for the long term.\nJoe Exciting! Do you know what might influence Nancy’s decision?\nTheo Our cost estimate, certainly, but I know she’s in touch with other software com-\npanies. If we come up with a competitive proposal, I think we’ll get the deal.\nJoe I’m quite sure that after refactoring to DOP, features will take much less time\nto implement. That means you should be able to quote Nancy a lower total cost\nthan the competition, right?\nTheo I’ll keep my fingers crossed!\n--- Page 162 ---\n134 CHAPTER 6 Unit tests\nMoving forward\nThe meeting with Nancy went well. Albatross got the deal, Monica (Theo’s boss) is\npleased, and it’s going to be a long-term project with a nice budget. They’ll need to hire a\nteam of developers in order to meet the tough deadlines. While driving back to the office,\nTheo gets a phone call from Joe.\nJoe How was your meeting with Nancy?\nTheo We got the deal!\nJoe Awesome! I told you that with DOP the cost estimation would be lower.\nTheo In fact, we are not going to use DOP for this project.\nJoe Why?\nTheo After refactoring the Library Management System prototype to DOP, I did a\ndeep analysis with my engineers. We came to the conclusion that DOP might\nbe a good fit for the prototype phase, but it won’t work well at scale.\nJoe Could you share the details of your analysis?\nTheo I can’t right now. I’m driving.\nJoe Could we meet in your office later today?\nTheo I’m quite busy with the new project and the tough deadlines.\nJoe Let’s meet at least in order to have a proper farewell.\nTheo OK. Let’s meet at 4 PM, then.\n NOTE The story continues in the opener of part 2.\nSummary\n Most of the code in a data-oriented system deals with data manipulation.\n It’s straightforward to write unit tests for code that deals with data manipulation.\n Test cases follow the same simple general pattern:\na Generate data input\nb Generate expected data output\nc Compare the output of the function with the expected data output\n In order to compare the output of a function with the expected data output, we\nneed to recursively compare the two pieces of data.\n The recursive comparison of two pieces of data is implemented via a generic\nfunction.\n When a function returns a JSON string, we parse the string back to data so that\nwe deal with data comparison instead of string comparison.\n A tree of function calls for a function f is a tree where the root is f, and the chil-\ndren of a node g in the tree are the functions called by g.\n The leaves of the tree are functions that are not part of the code base of the\napplication and are functions that don’t call any other functions.\n The tree of function calls visualization guides us regarding the quality and\nquantity of the test cases in a unit test.\n--- Page 163 ---\nSummary 135\n Functions that appear in a lower level in the tree of function calls tend to involve\nless complex data than functions that appear in a higher level in the tree.\n Functions that appear in a lower level in the tree of function calls usually need\nto be covered with more test cases than functions that appear in a higher level\nin the tree.\n Unit tests for mutations focus on the calculation phase of the mutation.\n The validity of the data depends on the context.\n The smaller the data, the easier it is to manipulate.\n We compare the output and the expected output of our functions with a generic\nfunction that recursively compares two pieces of data (e.g., _.isEqual).\n When we write a unit test for a function, we assume that the functions called by\nthis function are covered by the unit tests and work as expected. This signifi-\ncantly reduces the quantity of test cases in our unit tests.\n We avoid using string comparison in unit tests for functions that deal with data.\n Writing a unit test for the main function of a mutation requires more effort\nthan for a query.\n Remember to include negative test cases in your unit tests.\n The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state\nusing a generic function like _.isEqual.\n--- Page 164 ---\n\n--- Page 165 ---\nPart 2\nScalability\nT\nheo feels a bit uncomfortable about the meeting with Joe. He was so enthusias-\ntic about DOP, and he was very good at teaching it. Every meeting with him was an\nopportunity to learn new things. Theo feels lot of gratitude for the time Joe spent\nwith him. He doesn’t want to hurt him in any fashion. Surprisingly, Joe enters the\noffice with the same relaxed attitude as usual, and he is even smiling.\nJoe I’m really glad that you got the deal with Nancy.\nTheo Yeah. There’s lot of excitement about it here in the office, and a bit of\nstress too.\nJoe What kind of stress?\nTheo You know.... We need to hire a team of developers, and the deadlines\nare quite tight.\nJoe But you told me that you won’t use DOP. I assume that you gave regular\ndeadlines?\nTheo No, my boss Monica really wanted to close the deal. She feels that success\nwith this project is strategically important for Albatross, so it’s worthwhile\nto accept some risk by giving what she calls an “optimistic” time estima-\ntion. I told her that it was really an unrealistic time estimation, but Mon-\nica insists that if we make smart decisions and bring in more developers,\nwe can do it.\nJoe I see. Now I understand why you told me over the phone that you were\nvery busy. Anyway, would you please share the reasons that made you\nthink DOP wouldn’t be a good fit at scale?\n--- Page 166 ---\n138 PART 2 Scalability\nTheo First of all, let me tell you that I feel lot of gratitude for all the teaching you\nshared with me. Reimplementing the Klafim prototype with DOP was really\nfun and productive due to the flexibility this paradigm offers.\nJoe I’m happy that you found it valuable.\nTheo But, as I told you over the phone, now we’re scaling up into a long-term project\nwith several developers working on a large code base. We came to the conclu-\nsion that DOP will not be a good fit at scale.\nJoe Could you share the reasons behind your conclusion?\nTheo There are many of them. First of all, as DOP deals only with generic data struc-\ntures, it’s hard to know what kind of data we have in hand, while in OOP, we\nknow the type of every piece of data. For the prototype, it was kind of OK. But\nas the code base grows and more developers are involved in the project, it\nwould be too painful.\nJoe I hear you. What else, my friend?\nTheo Our system is going to run on a multi-threaded environment. I reviewed the\nconcurrency control strategy that you presented, and it’s not thread-safe.\nJoe I hear you. What else, my friend?\nTheo I have been doing a bit of research about implementing immutable data struc-\ntures with structural sharing. I discovered that when the size of the data\nstructures grows, there is a significant performance hit.\nJoe I hear you. What else?\nTheo As our system grows, we will use a database to store the application data and\nexternal services to enrich book information, and in what you have showed me\nso far, data lives in memory.\nJoe I hear you. What else, my friend?\nTheo Don’t you think I have shared enough reasons to abandon DOP?\nJoe I think that your concerns about DOP at scale totally make sense. However, it\ndoesn’t mean that you should abandon DOP.\nTheo What do you mean?\nJoe With the help of meditation, I learned not be attached to the objections that\nflow in my mind while I’m practicing. Sometimes all that is needed to quiet our\nminds is to keep breathing; sometimes, a deeper level of practice is needed.\nTheo I don’t see how breathing would convince me to give DOP a second chance.\nJoe Breathing might not be enough in this case, but a deeper knowledge of DOP\ncould be helpful. Until now, I have shared with you only the material that was\nneeded in order to refactor your prototype. In order to use DOP in a big proj-\nect, a few more lessons are necessary.\nTheo But I don’t have time for more lessons. I need to work.\nJoe Have you heard the story about the young woodcutter and the old man?\nTheo No.\nJoe It goes like this.\n--- Page 167 ---\nPART 2 Scalability 139\nThe young woodcutter and the old man\nA young woodcutter strained to saw down a tree. An old man who was watching near-\nby asked, “What are you doing?”\n“Are you blind?” the woodcutter replied. “I’m cutting down this tree.”\nThe old man replied, “You look exhausted! Take a break. Sharpen your saw.”\nThe young woodcutter explained to the old man that he had been sawing for hours\nand did not have time to take a break.\nThe old man pushed back, “If you sharpen the saw, you would cut down the tree much\nfaster.”\nThe woodcutter said, “I don’t have time to sharpen the saw. Don’t you see, I’m too\nbusy!”\nTheo takes a moment to meditate on the story. He wonders if he needs to take the time to\nsharpen his saw and commit to a deeper level of practice.\nTheo Do you really think that with DOP, it will take much less time to deliver the\nproject?\nJoe I know so!\nTheo But if we miss the deadline, I will probably get fired. I’m the one that needs to\ntake the risk, not you.\nJoe Let’s make a deal. If you miss the deadline and get fired, I will hire you at my\ncompany for double the salary you make at Albatross.\nTheo And what if we meet the deadline?\nJoe If you meet the deadline, you will probably get promoted. In that case, I will\nask you to buy a gift for my son Neriah and my daughter Aurelia.\nTheo Deal! When will I get my first lesson about going deeper into DOP?\nJoe Why not start right now?\nTheo Let me reschedule my meetings.\n--- Page 168 ---\n\n--- Page 169 ---\nBasic data validation\nA solemn gift\nThis chapter covers\n The importance of validating data at system\nboundaries\n Validating data using the JSON Schema language\n Integrating data validation into an existing code\nbase\n Getting detailed information about data validation\nfailures\nAt first glance, it may seem that embracing DOP means accessing data without validat-\ning it and engaging in wishful thinking, where data is always valid. In fact, data valida-\ntion is not only possible but recommended when we follow data-oriented principles.\nThis chapter illustrates how to validate data when data is represented with\ngeneric data structures. It focuses on data validation occurring at the boundaries of\nthe system, while in part 3, we will deal with validating data as it flows through the\nsystem. This chapter is a deep dive into the fourth principle of DOP.\nPRINCIPLE #4 Separate data schema from data representation.\n141\n--- Page 170 ---\n142 CHAPTER 7 Basic data validation\n7.1 Data validation in DOP\nTheo has rescheduled his meetings. With such an imposing deadline, he’s still not sure if\nhe’s made a big mistake giving DOP a second chance.\n NOTE The reason why Theo rescheduled his meetings is explained in the opener\nfor part 2. Take a moment to read the opener if you missed it.\nJoe What aspect of OOP do you think you will miss the most in your big project?\nTheo Data validation.\nJoe Can you elaborate a bit?\nTheo In OOP, I have this strong guarantee that when a class is instantiated, its mem-\nber fields have the proper names and proper types. But with DOP, it’s so easy\nto have small mistakes in field names and field types.\nJoe Well, I have good news for you! There is a way to validate data in DOP.\nTheo How does it work? I thought DOP and data validation were two contradictory\nconcepts!\nJoe Not at all. It’s true that DOP doesn’t force you to validate data, but it doesn’t\nprevent you from doing so. In DOP, the data schema is separate from the data\nrepresentation.\nTheo I don’t get how that would eliminate data consistency issues.\nJoe According to DOP, the most important data to validate is data that crosses the\nboundaries of the system.\nTheo Which boundaries are you referring to?\nJoe In the case of a web server, it would be the areas where the web server commu-\nnicates with its clients and with its data sources.\nTheo A diagram might help me see it better.\nJoe goes to the whiteboard and picks up the pen. He then draws a diagram like the one in\nfigure 7.1.\nClient (e.g., web browser)\nData\nWeb server\nData Data\nWeb service Database Figure 7.1 High-level architecture of\na modern web server\n--- Page 171 ---\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n--- Page 172 ---\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n--- Page 173 ---\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n--- Page 174 ---\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n--- Page 175 ---\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer",
        "sections_found": []
      },
      "accurate_page_range": "152-175"
    },
    {
      "text": "- 6.2.2 Unit tests for functions down the tree",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "raw_line": "- 6.2.2 Unit tests for functions down the tree (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 49,
      "chapter_info": {
        "page": 152,
        "title": "Unit tests",
        "pattern_matched": "Chapter 6",
        "text_preview": "124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again "
      },
      "chapter_sections": {
        "start_page": 152,
        "end_page": 175,
        "content": "\n--- Page 152 ---\n124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again at the\ncode for Catalog.searchBooksByTitle.\nListing6.16 The code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nWriting the unit test for Catalog.searchBooksByTitle is a more pleasant experience for\nTheo than writing the unit test for Library.searchBooksByTitleJSON. He appreciates\nthis for two reasons:\n It’s not necessary to deserialize the output because the function returns data.\n It’s not necessary to wrap the catalog data in a library data map.\nListing6.17 Unit test for Catalog.searchBooksByTitle\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n--- Page 153 ---\n6.3 Unit tests for queries 125\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Watchmen\"), [bookInfo]);\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Batman\"), []);\nJoe That’s a good start!\nTheo I thought I was done. What did I miss?\nJoe You forgot to test cases where the query string is all lowercase.\nTheo You’re right! Let me quickly add one more test case.\nIn less than a minute, Theo creates an additional test case and shows it to Joe. What a dis-\nappointment when Theo discovers that the test case with \"watchmen\" in lowercase fails!\nListing6.18 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe Don’t be too upset, my friend. After all, the purpose of unit tests is to find bugs\nin the code so that you can fix them. Can you fix the code of Catalog-\nData.searchBooksByTitle?\nTheo Sure. All I need to do is to lowercase both the query string and the book title\nbefore comparing them. I’d probably do something like this.\nListing6.19 Fixed code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar queryLowerCased = query.toLowerCase();\nConverts the query\nvar matchingBooks = _.filter(allBooks, function(book) {\nto lowercase\nreturn _.get(book, \"title\")\n.toLowerCase()\nConverts the book\n.includes(queryLowerCased);\ntitle to lowercase\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nAfter fixing the code of Catalog.searchBooksByTitle, Theo runs all the test cases\nagain. This time, all of them pass—what a relief!\nListing6.20 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe It’s such good feeling when all the test cases pass.\nTheo Sure is.\nJoe I think we’ve written unit tests for all the search query code, so now we’re ready\nto write unit tests for mutations. Thank goodness the waiter just brought our\ncoffee orders.\n--- Page 154 ---\n126 CHAPTER 6 Unit tests\n6.4 Unit tests for mutations\nJoe Before writing unit tests for the add member mutation, let’s draw the tree of\nfunction calls for System.addMember.\nTheo I can do that.\nTheo takes a look at the code for the functions involved in the add member mutation. He\nnotices the code is spread over three classes: System, Library, and UserManagement.\nListing6.21 The functions involved in the add member mutation\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement, member);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nthrow \"Member already exists.\";\n}\nvar nextUserManagement = _.set(userManagement,\ninfoPath,\nmember);\nreturn nextUserManagement;\n};\nTheo grabs another napkin. Drawing the tree of function calls for System.addMember is\nnow quite easy (see figure 6.5).\nSystem.addMember\nSystemState.get SystemState.commit Library.addMember\n_.get _.set UserManagement.addMember\n_.has _.set\nFigure 6.5 The tree of function calls for System.addMember\n--- Page 155 ---\n6.4 Unit tests for mutations 127\nJoe Excellent! So which functions of the tree should be unit tested for the add\nmember mutation?\nTheo I think the functions we need to test are System.addMember, SystemState\n.get, SystemState.commit, Library.addMember, and UserManagement\n.addMember. That right?\nJoe You’re totally right. Let’s defer writing unit tests for functions that belong to\nSystemState until later. Those are generic functions that should be tested\noutside the context of a specific mutation. Let’s assume for now that we’ve\nalready written unit tests for the SystemState class. We’re left with three func-\ntions: System.addMember, Library.addMember, and UserManagement.add-\nMember.\nTheo In what order should we write the unit tests, bottom up or top down?\nJoe Let’s start where the real meat is—in UserManagement.addMember. The two\nother functions are just wrappers.\nTheo OK.\nJoe Writing a unit test for the main function of a mutation requires more effort\nthan writing the test for a query. The reason is that a query returns a response\nbased on the system data, whereas a mutation computes a new state of the system\nbased on the current state of the system and some arguments (see figure 6.6).\nSystemData Argument Argument SystemData\nMutation Query\nNextSystemData ResponseData\nFigure 6.6 The output of a mutation is more complex than\nthe output of a query.\nTIP Writing a unit test for the main function of a mutation requires more effort than\nfor a query.\nTheo It means that in the test cases of UserManagement.addMember, both the input\nand the expected output are maps that describe the state of the system.\nJoe Exactly. Let’s start with the simplest case, where the initial state of the system\nis empty.\nTheo You mean that userManagementData passed to UserManagement.addMember\nis an empty map?\nJoe Yes.\nOnce again, Theo places his hands over his laptop keyboard, thinks for a moment, and\nbegins typing. He reminds himself that the code needs to add a member to an empty user\n--- Page 156 ---\n128 CHAPTER 6 Unit tests\nmanagement map and to check that the resulting map is as expected. When he’s finished,\nhe shows his code to Joe.\nListing6.22 Test case for Catalog.addMember without members\nvar member = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, member);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Very nice! Keep going and write a test case when the initial state is not empty.\nTheo knows this requires a few more lines of code but nothing complicated. When he fin-\nishes, he once again shows the code to Joe.\nListing6.23 Test case for Catalog.addMember with existing members\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n--- Page 157 ---\n6.4 Unit tests for mutations 129\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, jessie);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Awesome! Can you think of other test cases for UserManagement.addMember?\nTheo No.\nJoe What about cases where the mutation fails?\nTheo Right! I always forget to think about negative test cases. I assume that relates to\nthe fact that I’m an optimistic person.\nTIP Don’t forget to include negative test cases in your unit tests.\nJoe Me too. The more I meditate, the more I’m able to focus on the positive side of\nlife. Anyway, how would you write a test case where the mutation fails?\nTheo I would pass to UserManagement.addMember a member that already exists in\nuserManagementStateBefore.\nJoe And how would you check that the code behaves as expected in case of a failure?\nTheo Let me see. When a member already exists, UserManagement.addMember\nthrows an exception. Therefore, what I need to do in my test case is to wrap the\ncode in a try/catch block.\nJoe Sounds good to me.\nOnce again, it doesn’t require too much of an effort for Theo to create a new test case.\nWhen he’s finished, he eagerly turns his laptop to Joe.\nListing6.24 Test case for UserManagement.addMember if it’s expected to fail\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\n--- Page 158 ---\n130 CHAPTER 6 Unit tests\nvar expectedException = \"Member already exists.\";\nvar exceptionInMutation;\ntry {\nUserManagement.addMember(userManagementStateBefore, jessie);\n} catch (e) {\nexceptionInMutation = e;\n}\n_.isEqual(exceptionInMutation, expectedException);\nTheo Now, I think I’m ready to move forward and write unit tests for Library.add-\nMember and System.addMember.\nJoe I agree with you. Please start with Library.addMember.\nTheo Library.addMember is quite similar to UserManagement.addMember. So I\nguess I’ll write similar test cases.\nJoe In fact, that won’t be required. As I told you when we wrote unit tests for a\nquery, when you write a unit test for a function, you can assume that the func-\ntions down the tree work as expected.\nTheo Right. So I’ll just write the test case for existing members.\nJoe Go for it!\nTheo starts with a copy-and-paste of the code from the UserManagement.addMember test\ncase with the existing members in listing 6.23. After a few modifications, the unit test for\nLibrary.addMember is ready.\nListing6.25 Unit test for Library.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 159 ---\n6.4 Unit tests for mutations 131\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar result = Library.addMember(libraryStateBefore, jessie);\n_.isEqual(result, expectedLibraryStateAfter);\nJoe Beautiful! Now, we’re ready for the last piece. Write a unit test for System\n.addMember. Before you start, could you please describe the input and the out-\nput of System.addMember?\nTheo takes another look at the code for System.addMember and hesitates; he’s a bit con-\nfused. The function doesn’t seem to return anything!\nListing6.26 The code of System.addMember\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nTheo The input of System.addMember is a system state instance and a member. But,\nI’m not sure what the output of System.addMember is.\nJoe In fact, System.addMember doesn’t have any output. It belongs to this stateful\npart of our code that doesn’t deal with data manipulation. Although DOP\nallows us to reduce the size of the stateful part of our code, it still exists. Here is\nhow I visualize it.\nJoe calls the waiter to see if he can get more napkins. With that problem resolved, he draws\nthe diagram in figure 6.7.\nSystemData Member\nMutation Change system state\nFigure 6.7 System.addMember\ndoesn’t return data—it changes the\nNothing system state!\n--- Page 160 ---\n132 CHAPTER 6 Unit tests\nTheo Then how do we validate that the code works as expected?\nJoe We’ll retrieve the system state after the code is executed and compare it to the\nexpected value of the state.\nTheo OK. I’ll try to write the unit test.\nJoe Writing unit tests for stateful code is more complicated than for data manipula-\ntion code. It requires the calm of the office.\nTheo Then let’s go back to the office. Waiter! Check, please.\nTheo picks up the tab, and he and Joe take the cable car back to Albatross. When they’re\nback at the office, Theo starts coding the unit test for Library.addMember.\nTheo Can we use _.isEqual with system state?\nJoe Definitely. The system state is a map like any other map.\nTIP The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state using\n_.isEqual\nTheo copies and pastes the code for Library.addMember (listing 6.21), which initializes\nthe data for the test. Then, he passes a SystemState object that is initialized with\nlibraryStateBefore to System.addMember. Finally, to complete the test, he compares\nthe system state after the mutation is executed with the expected value of the state.\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nwindow.SystemState = SystemState;\nListing6.27 Unit test for System.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 161 ---\n6.4 Unit tests for mutations 133\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\nCreates an empty\n}\nSystemState object\n}\n(see chapter 4)\n}\n};\nInitializes the system\nstate with the library\ndata before the\nvar systemState = new SystemState();\nmutation\nsystemState.commit(null, libraryStateBefore);\nSystem.addMember(systemState, jessie);\nExecutes the\nmutation on the\n_.isEqual(systemState.get(),\nSystemState object\nexpectedLibraryStateAfter);\nValidates the state after the\nmutation is executed\nJoe Wow, I’m impressed; you did it! Congratulations!\nTheo Thank you. I’m so glad that in DOP most of our code deals with data manipu-\nlation. It’s definitely more pleasant to write unit tests for stateless code that\nonly deals with data manipulation.\nJoe Now that you know the basics of DOP, would you like to refactor the code of\nyour Klafim prototype according to DOP principles?\nTheo Definitely. Nancy told me yesterday that Klafim is getting nice market traction.\nI’m supposed to have a meeting with her in a week or so about the next steps.\nHopefully, she’ll be willing to work with Albatross for the long term.\nJoe Exciting! Do you know what might influence Nancy’s decision?\nTheo Our cost estimate, certainly, but I know she’s in touch with other software com-\npanies. If we come up with a competitive proposal, I think we’ll get the deal.\nJoe I’m quite sure that after refactoring to DOP, features will take much less time\nto implement. That means you should be able to quote Nancy a lower total cost\nthan the competition, right?\nTheo I’ll keep my fingers crossed!\n--- Page 162 ---\n134 CHAPTER 6 Unit tests\nMoving forward\nThe meeting with Nancy went well. Albatross got the deal, Monica (Theo’s boss) is\npleased, and it’s going to be a long-term project with a nice budget. They’ll need to hire a\nteam of developers in order to meet the tough deadlines. While driving back to the office,\nTheo gets a phone call from Joe.\nJoe How was your meeting with Nancy?\nTheo We got the deal!\nJoe Awesome! I told you that with DOP the cost estimation would be lower.\nTheo In fact, we are not going to use DOP for this project.\nJoe Why?\nTheo After refactoring the Library Management System prototype to DOP, I did a\ndeep analysis with my engineers. We came to the conclusion that DOP might\nbe a good fit for the prototype phase, but it won’t work well at scale.\nJoe Could you share the details of your analysis?\nTheo I can’t right now. I’m driving.\nJoe Could we meet in your office later today?\nTheo I’m quite busy with the new project and the tough deadlines.\nJoe Let’s meet at least in order to have a proper farewell.\nTheo OK. Let’s meet at 4 PM, then.\n NOTE The story continues in the opener of part 2.\nSummary\n Most of the code in a data-oriented system deals with data manipulation.\n It’s straightforward to write unit tests for code that deals with data manipulation.\n Test cases follow the same simple general pattern:\na Generate data input\nb Generate expected data output\nc Compare the output of the function with the expected data output\n In order to compare the output of a function with the expected data output, we\nneed to recursively compare the two pieces of data.\n The recursive comparison of two pieces of data is implemented via a generic\nfunction.\n When a function returns a JSON string, we parse the string back to data so that\nwe deal with data comparison instead of string comparison.\n A tree of function calls for a function f is a tree where the root is f, and the chil-\ndren of a node g in the tree are the functions called by g.\n The leaves of the tree are functions that are not part of the code base of the\napplication and are functions that don’t call any other functions.\n The tree of function calls visualization guides us regarding the quality and\nquantity of the test cases in a unit test.\n--- Page 163 ---\nSummary 135\n Functions that appear in a lower level in the tree of function calls tend to involve\nless complex data than functions that appear in a higher level in the tree.\n Functions that appear in a lower level in the tree of function calls usually need\nto be covered with more test cases than functions that appear in a higher level\nin the tree.\n Unit tests for mutations focus on the calculation phase of the mutation.\n The validity of the data depends on the context.\n The smaller the data, the easier it is to manipulate.\n We compare the output and the expected output of our functions with a generic\nfunction that recursively compares two pieces of data (e.g., _.isEqual).\n When we write a unit test for a function, we assume that the functions called by\nthis function are covered by the unit tests and work as expected. This signifi-\ncantly reduces the quantity of test cases in our unit tests.\n We avoid using string comparison in unit tests for functions that deal with data.\n Writing a unit test for the main function of a mutation requires more effort\nthan for a query.\n Remember to include negative test cases in your unit tests.\n The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state\nusing a generic function like _.isEqual.\n--- Page 164 ---\n\n--- Page 165 ---\nPart 2\nScalability\nT\nheo feels a bit uncomfortable about the meeting with Joe. He was so enthusias-\ntic about DOP, and he was very good at teaching it. Every meeting with him was an\nopportunity to learn new things. Theo feels lot of gratitude for the time Joe spent\nwith him. He doesn’t want to hurt him in any fashion. Surprisingly, Joe enters the\noffice with the same relaxed attitude as usual, and he is even smiling.\nJoe I’m really glad that you got the deal with Nancy.\nTheo Yeah. There’s lot of excitement about it here in the office, and a bit of\nstress too.\nJoe What kind of stress?\nTheo You know.... We need to hire a team of developers, and the deadlines\nare quite tight.\nJoe But you told me that you won’t use DOP. I assume that you gave regular\ndeadlines?\nTheo No, my boss Monica really wanted to close the deal. She feels that success\nwith this project is strategically important for Albatross, so it’s worthwhile\nto accept some risk by giving what she calls an “optimistic” time estima-\ntion. I told her that it was really an unrealistic time estimation, but Mon-\nica insists that if we make smart decisions and bring in more developers,\nwe can do it.\nJoe I see. Now I understand why you told me over the phone that you were\nvery busy. Anyway, would you please share the reasons that made you\nthink DOP wouldn’t be a good fit at scale?\n--- Page 166 ---\n138 PART 2 Scalability\nTheo First of all, let me tell you that I feel lot of gratitude for all the teaching you\nshared with me. Reimplementing the Klafim prototype with DOP was really\nfun and productive due to the flexibility this paradigm offers.\nJoe I’m happy that you found it valuable.\nTheo But, as I told you over the phone, now we’re scaling up into a long-term project\nwith several developers working on a large code base. We came to the conclu-\nsion that DOP will not be a good fit at scale.\nJoe Could you share the reasons behind your conclusion?\nTheo There are many of them. First of all, as DOP deals only with generic data struc-\ntures, it’s hard to know what kind of data we have in hand, while in OOP, we\nknow the type of every piece of data. For the prototype, it was kind of OK. But\nas the code base grows and more developers are involved in the project, it\nwould be too painful.\nJoe I hear you. What else, my friend?\nTheo Our system is going to run on a multi-threaded environment. I reviewed the\nconcurrency control strategy that you presented, and it’s not thread-safe.\nJoe I hear you. What else, my friend?\nTheo I have been doing a bit of research about implementing immutable data struc-\ntures with structural sharing. I discovered that when the size of the data\nstructures grows, there is a significant performance hit.\nJoe I hear you. What else?\nTheo As our system grows, we will use a database to store the application data and\nexternal services to enrich book information, and in what you have showed me\nso far, data lives in memory.\nJoe I hear you. What else, my friend?\nTheo Don’t you think I have shared enough reasons to abandon DOP?\nJoe I think that your concerns about DOP at scale totally make sense. However, it\ndoesn’t mean that you should abandon DOP.\nTheo What do you mean?\nJoe With the help of meditation, I learned not be attached to the objections that\nflow in my mind while I’m practicing. Sometimes all that is needed to quiet our\nminds is to keep breathing; sometimes, a deeper level of practice is needed.\nTheo I don’t see how breathing would convince me to give DOP a second chance.\nJoe Breathing might not be enough in this case, but a deeper knowledge of DOP\ncould be helpful. Until now, I have shared with you only the material that was\nneeded in order to refactor your prototype. In order to use DOP in a big proj-\nect, a few more lessons are necessary.\nTheo But I don’t have time for more lessons. I need to work.\nJoe Have you heard the story about the young woodcutter and the old man?\nTheo No.\nJoe It goes like this.\n--- Page 167 ---\nPART 2 Scalability 139\nThe young woodcutter and the old man\nA young woodcutter strained to saw down a tree. An old man who was watching near-\nby asked, “What are you doing?”\n“Are you blind?” the woodcutter replied. “I’m cutting down this tree.”\nThe old man replied, “You look exhausted! Take a break. Sharpen your saw.”\nThe young woodcutter explained to the old man that he had been sawing for hours\nand did not have time to take a break.\nThe old man pushed back, “If you sharpen the saw, you would cut down the tree much\nfaster.”\nThe woodcutter said, “I don’t have time to sharpen the saw. Don’t you see, I’m too\nbusy!”\nTheo takes a moment to meditate on the story. He wonders if he needs to take the time to\nsharpen his saw and commit to a deeper level of practice.\nTheo Do you really think that with DOP, it will take much less time to deliver the\nproject?\nJoe I know so!\nTheo But if we miss the deadline, I will probably get fired. I’m the one that needs to\ntake the risk, not you.\nJoe Let’s make a deal. If you miss the deadline and get fired, I will hire you at my\ncompany for double the salary you make at Albatross.\nTheo And what if we meet the deadline?\nJoe If you meet the deadline, you will probably get promoted. In that case, I will\nask you to buy a gift for my son Neriah and my daughter Aurelia.\nTheo Deal! When will I get my first lesson about going deeper into DOP?\nJoe Why not start right now?\nTheo Let me reschedule my meetings.\n--- Page 168 ---\n\n--- Page 169 ---\nBasic data validation\nA solemn gift\nThis chapter covers\n The importance of validating data at system\nboundaries\n Validating data using the JSON Schema language\n Integrating data validation into an existing code\nbase\n Getting detailed information about data validation\nfailures\nAt first glance, it may seem that embracing DOP means accessing data without validat-\ning it and engaging in wishful thinking, where data is always valid. In fact, data valida-\ntion is not only possible but recommended when we follow data-oriented principles.\nThis chapter illustrates how to validate data when data is represented with\ngeneric data structures. It focuses on data validation occurring at the boundaries of\nthe system, while in part 3, we will deal with validating data as it flows through the\nsystem. This chapter is a deep dive into the fourth principle of DOP.\nPRINCIPLE #4 Separate data schema from data representation.\n141\n--- Page 170 ---\n142 CHAPTER 7 Basic data validation\n7.1 Data validation in DOP\nTheo has rescheduled his meetings. With such an imposing deadline, he’s still not sure if\nhe’s made a big mistake giving DOP a second chance.\n NOTE The reason why Theo rescheduled his meetings is explained in the opener\nfor part 2. Take a moment to read the opener if you missed it.\nJoe What aspect of OOP do you think you will miss the most in your big project?\nTheo Data validation.\nJoe Can you elaborate a bit?\nTheo In OOP, I have this strong guarantee that when a class is instantiated, its mem-\nber fields have the proper names and proper types. But with DOP, it’s so easy\nto have small mistakes in field names and field types.\nJoe Well, I have good news for you! There is a way to validate data in DOP.\nTheo How does it work? I thought DOP and data validation were two contradictory\nconcepts!\nJoe Not at all. It’s true that DOP doesn’t force you to validate data, but it doesn’t\nprevent you from doing so. In DOP, the data schema is separate from the data\nrepresentation.\nTheo I don’t get how that would eliminate data consistency issues.\nJoe According to DOP, the most important data to validate is data that crosses the\nboundaries of the system.\nTheo Which boundaries are you referring to?\nJoe In the case of a web server, it would be the areas where the web server commu-\nnicates with its clients and with its data sources.\nTheo A diagram might help me see it better.\nJoe goes to the whiteboard and picks up the pen. He then draws a diagram like the one in\nfigure 7.1.\nClient (e.g., web browser)\nData\nWeb server\nData Data\nWeb service Database Figure 7.1 High-level architecture of\na modern web server\n--- Page 171 ---\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n--- Page 172 ---\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n--- Page 173 ---\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n--- Page 174 ---\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n--- Page 175 ---\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer",
        "sections_found": []
      },
      "accurate_page_range": "152-175"
    },
    {
      "text": "- 6.2.3 Unit tests for nodes in the tree",
      "node_level": 4,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "raw_line": "- 6.2.3 Unit tests for nodes in the tree (node4) **[LEAF]**",
      "is_part_intro": false,
      "id": 50,
      "chapter_info": {
        "page": 152,
        "title": "Unit tests",
        "pattern_matched": "Chapter 6",
        "text_preview": "124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again "
      },
      "chapter_sections": {
        "start_page": 152,
        "end_page": 175,
        "content": "\n--- Page 152 ---\n124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again at the\ncode for Catalog.searchBooksByTitle.\nListing6.16 The code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nWriting the unit test for Catalog.searchBooksByTitle is a more pleasant experience for\nTheo than writing the unit test for Library.searchBooksByTitleJSON. He appreciates\nthis for two reasons:\n It’s not necessary to deserialize the output because the function returns data.\n It’s not necessary to wrap the catalog data in a library data map.\nListing6.17 Unit test for Catalog.searchBooksByTitle\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n--- Page 153 ---\n6.3 Unit tests for queries 125\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Watchmen\"), [bookInfo]);\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Batman\"), []);\nJoe That’s a good start!\nTheo I thought I was done. What did I miss?\nJoe You forgot to test cases where the query string is all lowercase.\nTheo You’re right! Let me quickly add one more test case.\nIn less than a minute, Theo creates an additional test case and shows it to Joe. What a dis-\nappointment when Theo discovers that the test case with \"watchmen\" in lowercase fails!\nListing6.18 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe Don’t be too upset, my friend. After all, the purpose of unit tests is to find bugs\nin the code so that you can fix them. Can you fix the code of Catalog-\nData.searchBooksByTitle?\nTheo Sure. All I need to do is to lowercase both the query string and the book title\nbefore comparing them. I’d probably do something like this.\nListing6.19 Fixed code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar queryLowerCased = query.toLowerCase();\nConverts the query\nvar matchingBooks = _.filter(allBooks, function(book) {\nto lowercase\nreturn _.get(book, \"title\")\n.toLowerCase()\nConverts the book\n.includes(queryLowerCased);\ntitle to lowercase\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nAfter fixing the code of Catalog.searchBooksByTitle, Theo runs all the test cases\nagain. This time, all of them pass—what a relief!\nListing6.20 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe It’s such good feeling when all the test cases pass.\nTheo Sure is.\nJoe I think we’ve written unit tests for all the search query code, so now we’re ready\nto write unit tests for mutations. Thank goodness the waiter just brought our\ncoffee orders.\n--- Page 154 ---\n126 CHAPTER 6 Unit tests\n6.4 Unit tests for mutations\nJoe Before writing unit tests for the add member mutation, let’s draw the tree of\nfunction calls for System.addMember.\nTheo I can do that.\nTheo takes a look at the code for the functions involved in the add member mutation. He\nnotices the code is spread over three classes: System, Library, and UserManagement.\nListing6.21 The functions involved in the add member mutation\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement, member);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nthrow \"Member already exists.\";\n}\nvar nextUserManagement = _.set(userManagement,\ninfoPath,\nmember);\nreturn nextUserManagement;\n};\nTheo grabs another napkin. Drawing the tree of function calls for System.addMember is\nnow quite easy (see figure 6.5).\nSystem.addMember\nSystemState.get SystemState.commit Library.addMember\n_.get _.set UserManagement.addMember\n_.has _.set\nFigure 6.5 The tree of function calls for System.addMember\n--- Page 155 ---\n6.4 Unit tests for mutations 127\nJoe Excellent! So which functions of the tree should be unit tested for the add\nmember mutation?\nTheo I think the functions we need to test are System.addMember, SystemState\n.get, SystemState.commit, Library.addMember, and UserManagement\n.addMember. That right?\nJoe You’re totally right. Let’s defer writing unit tests for functions that belong to\nSystemState until later. Those are generic functions that should be tested\noutside the context of a specific mutation. Let’s assume for now that we’ve\nalready written unit tests for the SystemState class. We’re left with three func-\ntions: System.addMember, Library.addMember, and UserManagement.add-\nMember.\nTheo In what order should we write the unit tests, bottom up or top down?\nJoe Let’s start where the real meat is—in UserManagement.addMember. The two\nother functions are just wrappers.\nTheo OK.\nJoe Writing a unit test for the main function of a mutation requires more effort\nthan writing the test for a query. The reason is that a query returns a response\nbased on the system data, whereas a mutation computes a new state of the system\nbased on the current state of the system and some arguments (see figure 6.6).\nSystemData Argument Argument SystemData\nMutation Query\nNextSystemData ResponseData\nFigure 6.6 The output of a mutation is more complex than\nthe output of a query.\nTIP Writing a unit test for the main function of a mutation requires more effort than\nfor a query.\nTheo It means that in the test cases of UserManagement.addMember, both the input\nand the expected output are maps that describe the state of the system.\nJoe Exactly. Let’s start with the simplest case, where the initial state of the system\nis empty.\nTheo You mean that userManagementData passed to UserManagement.addMember\nis an empty map?\nJoe Yes.\nOnce again, Theo places his hands over his laptop keyboard, thinks for a moment, and\nbegins typing. He reminds himself that the code needs to add a member to an empty user\n--- Page 156 ---\n128 CHAPTER 6 Unit tests\nmanagement map and to check that the resulting map is as expected. When he’s finished,\nhe shows his code to Joe.\nListing6.22 Test case for Catalog.addMember without members\nvar member = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, member);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Very nice! Keep going and write a test case when the initial state is not empty.\nTheo knows this requires a few more lines of code but nothing complicated. When he fin-\nishes, he once again shows the code to Joe.\nListing6.23 Test case for Catalog.addMember with existing members\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n--- Page 157 ---\n6.4 Unit tests for mutations 129\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, jessie);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Awesome! Can you think of other test cases for UserManagement.addMember?\nTheo No.\nJoe What about cases where the mutation fails?\nTheo Right! I always forget to think about negative test cases. I assume that relates to\nthe fact that I’m an optimistic person.\nTIP Don’t forget to include negative test cases in your unit tests.\nJoe Me too. The more I meditate, the more I’m able to focus on the positive side of\nlife. Anyway, how would you write a test case where the mutation fails?\nTheo I would pass to UserManagement.addMember a member that already exists in\nuserManagementStateBefore.\nJoe And how would you check that the code behaves as expected in case of a failure?\nTheo Let me see. When a member already exists, UserManagement.addMember\nthrows an exception. Therefore, what I need to do in my test case is to wrap the\ncode in a try/catch block.\nJoe Sounds good to me.\nOnce again, it doesn’t require too much of an effort for Theo to create a new test case.\nWhen he’s finished, he eagerly turns his laptop to Joe.\nListing6.24 Test case for UserManagement.addMember if it’s expected to fail\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\n--- Page 158 ---\n130 CHAPTER 6 Unit tests\nvar expectedException = \"Member already exists.\";\nvar exceptionInMutation;\ntry {\nUserManagement.addMember(userManagementStateBefore, jessie);\n} catch (e) {\nexceptionInMutation = e;\n}\n_.isEqual(exceptionInMutation, expectedException);\nTheo Now, I think I’m ready to move forward and write unit tests for Library.add-\nMember and System.addMember.\nJoe I agree with you. Please start with Library.addMember.\nTheo Library.addMember is quite similar to UserManagement.addMember. So I\nguess I’ll write similar test cases.\nJoe In fact, that won’t be required. As I told you when we wrote unit tests for a\nquery, when you write a unit test for a function, you can assume that the func-\ntions down the tree work as expected.\nTheo Right. So I’ll just write the test case for existing members.\nJoe Go for it!\nTheo starts with a copy-and-paste of the code from the UserManagement.addMember test\ncase with the existing members in listing 6.23. After a few modifications, the unit test for\nLibrary.addMember is ready.\nListing6.25 Unit test for Library.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 159 ---\n6.4 Unit tests for mutations 131\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar result = Library.addMember(libraryStateBefore, jessie);\n_.isEqual(result, expectedLibraryStateAfter);\nJoe Beautiful! Now, we’re ready for the last piece. Write a unit test for System\n.addMember. Before you start, could you please describe the input and the out-\nput of System.addMember?\nTheo takes another look at the code for System.addMember and hesitates; he’s a bit con-\nfused. The function doesn’t seem to return anything!\nListing6.26 The code of System.addMember\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nTheo The input of System.addMember is a system state instance and a member. But,\nI’m not sure what the output of System.addMember is.\nJoe In fact, System.addMember doesn’t have any output. It belongs to this stateful\npart of our code that doesn’t deal with data manipulation. Although DOP\nallows us to reduce the size of the stateful part of our code, it still exists. Here is\nhow I visualize it.\nJoe calls the waiter to see if he can get more napkins. With that problem resolved, he draws\nthe diagram in figure 6.7.\nSystemData Member\nMutation Change system state\nFigure 6.7 System.addMember\ndoesn’t return data—it changes the\nNothing system state!\n--- Page 160 ---\n132 CHAPTER 6 Unit tests\nTheo Then how do we validate that the code works as expected?\nJoe We’ll retrieve the system state after the code is executed and compare it to the\nexpected value of the state.\nTheo OK. I’ll try to write the unit test.\nJoe Writing unit tests for stateful code is more complicated than for data manipula-\ntion code. It requires the calm of the office.\nTheo Then let’s go back to the office. Waiter! Check, please.\nTheo picks up the tab, and he and Joe take the cable car back to Albatross. When they’re\nback at the office, Theo starts coding the unit test for Library.addMember.\nTheo Can we use _.isEqual with system state?\nJoe Definitely. The system state is a map like any other map.\nTIP The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state using\n_.isEqual\nTheo copies and pastes the code for Library.addMember (listing 6.21), which initializes\nthe data for the test. Then, he passes a SystemState object that is initialized with\nlibraryStateBefore to System.addMember. Finally, to complete the test, he compares\nthe system state after the mutation is executed with the expected value of the state.\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nwindow.SystemState = SystemState;\nListing6.27 Unit test for System.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 161 ---\n6.4 Unit tests for mutations 133\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\nCreates an empty\n}\nSystemState object\n}\n(see chapter 4)\n}\n};\nInitializes the system\nstate with the library\ndata before the\nvar systemState = new SystemState();\nmutation\nsystemState.commit(null, libraryStateBefore);\nSystem.addMember(systemState, jessie);\nExecutes the\nmutation on the\n_.isEqual(systemState.get(),\nSystemState object\nexpectedLibraryStateAfter);\nValidates the state after the\nmutation is executed\nJoe Wow, I’m impressed; you did it! Congratulations!\nTheo Thank you. I’m so glad that in DOP most of our code deals with data manipu-\nlation. It’s definitely more pleasant to write unit tests for stateless code that\nonly deals with data manipulation.\nJoe Now that you know the basics of DOP, would you like to refactor the code of\nyour Klafim prototype according to DOP principles?\nTheo Definitely. Nancy told me yesterday that Klafim is getting nice market traction.\nI’m supposed to have a meeting with her in a week or so about the next steps.\nHopefully, she’ll be willing to work with Albatross for the long term.\nJoe Exciting! Do you know what might influence Nancy’s decision?\nTheo Our cost estimate, certainly, but I know she’s in touch with other software com-\npanies. If we come up with a competitive proposal, I think we’ll get the deal.\nJoe I’m quite sure that after refactoring to DOP, features will take much less time\nto implement. That means you should be able to quote Nancy a lower total cost\nthan the competition, right?\nTheo I’ll keep my fingers crossed!\n--- Page 162 ---\n134 CHAPTER 6 Unit tests\nMoving forward\nThe meeting with Nancy went well. Albatross got the deal, Monica (Theo’s boss) is\npleased, and it’s going to be a long-term project with a nice budget. They’ll need to hire a\nteam of developers in order to meet the tough deadlines. While driving back to the office,\nTheo gets a phone call from Joe.\nJoe How was your meeting with Nancy?\nTheo We got the deal!\nJoe Awesome! I told you that with DOP the cost estimation would be lower.\nTheo In fact, we are not going to use DOP for this project.\nJoe Why?\nTheo After refactoring the Library Management System prototype to DOP, I did a\ndeep analysis with my engineers. We came to the conclusion that DOP might\nbe a good fit for the prototype phase, but it won’t work well at scale.\nJoe Could you share the details of your analysis?\nTheo I can’t right now. I’m driving.\nJoe Could we meet in your office later today?\nTheo I’m quite busy with the new project and the tough deadlines.\nJoe Let’s meet at least in order to have a proper farewell.\nTheo OK. Let’s meet at 4 PM, then.\n NOTE The story continues in the opener of part 2.\nSummary\n Most of the code in a data-oriented system deals with data manipulation.\n It’s straightforward to write unit tests for code that deals with data manipulation.\n Test cases follow the same simple general pattern:\na Generate data input\nb Generate expected data output\nc Compare the output of the function with the expected data output\n In order to compare the output of a function with the expected data output, we\nneed to recursively compare the two pieces of data.\n The recursive comparison of two pieces of data is implemented via a generic\nfunction.\n When a function returns a JSON string, we parse the string back to data so that\nwe deal with data comparison instead of string comparison.\n A tree of function calls for a function f is a tree where the root is f, and the chil-\ndren of a node g in the tree are the functions called by g.\n The leaves of the tree are functions that are not part of the code base of the\napplication and are functions that don’t call any other functions.\n The tree of function calls visualization guides us regarding the quality and\nquantity of the test cases in a unit test.\n--- Page 163 ---\nSummary 135\n Functions that appear in a lower level in the tree of function calls tend to involve\nless complex data than functions that appear in a higher level in the tree.\n Functions that appear in a lower level in the tree of function calls usually need\nto be covered with more test cases than functions that appear in a higher level\nin the tree.\n Unit tests for mutations focus on the calculation phase of the mutation.\n The validity of the data depends on the context.\n The smaller the data, the easier it is to manipulate.\n We compare the output and the expected output of our functions with a generic\nfunction that recursively compares two pieces of data (e.g., _.isEqual).\n When we write a unit test for a function, we assume that the functions called by\nthis function are covered by the unit tests and work as expected. This signifi-\ncantly reduces the quantity of test cases in our unit tests.\n We avoid using string comparison in unit tests for functions that deal with data.\n Writing a unit test for the main function of a mutation requires more effort\nthan for a query.\n Remember to include negative test cases in your unit tests.\n The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state\nusing a generic function like _.isEqual.\n--- Page 164 ---\n\n--- Page 165 ---\nPart 2\nScalability\nT\nheo feels a bit uncomfortable about the meeting with Joe. He was so enthusias-\ntic about DOP, and he was very good at teaching it. Every meeting with him was an\nopportunity to learn new things. Theo feels lot of gratitude for the time Joe spent\nwith him. He doesn’t want to hurt him in any fashion. Surprisingly, Joe enters the\noffice with the same relaxed attitude as usual, and he is even smiling.\nJoe I’m really glad that you got the deal with Nancy.\nTheo Yeah. There’s lot of excitement about it here in the office, and a bit of\nstress too.\nJoe What kind of stress?\nTheo You know.... We need to hire a team of developers, and the deadlines\nare quite tight.\nJoe But you told me that you won’t use DOP. I assume that you gave regular\ndeadlines?\nTheo No, my boss Monica really wanted to close the deal. She feels that success\nwith this project is strategically important for Albatross, so it’s worthwhile\nto accept some risk by giving what she calls an “optimistic” time estima-\ntion. I told her that it was really an unrealistic time estimation, but Mon-\nica insists that if we make smart decisions and bring in more developers,\nwe can do it.\nJoe I see. Now I understand why you told me over the phone that you were\nvery busy. Anyway, would you please share the reasons that made you\nthink DOP wouldn’t be a good fit at scale?\n--- Page 166 ---\n138 PART 2 Scalability\nTheo First of all, let me tell you that I feel lot of gratitude for all the teaching you\nshared with me. Reimplementing the Klafim prototype with DOP was really\nfun and productive due to the flexibility this paradigm offers.\nJoe I’m happy that you found it valuable.\nTheo But, as I told you over the phone, now we’re scaling up into a long-term project\nwith several developers working on a large code base. We came to the conclu-\nsion that DOP will not be a good fit at scale.\nJoe Could you share the reasons behind your conclusion?\nTheo There are many of them. First of all, as DOP deals only with generic data struc-\ntures, it’s hard to know what kind of data we have in hand, while in OOP, we\nknow the type of every piece of data. For the prototype, it was kind of OK. But\nas the code base grows and more developers are involved in the project, it\nwould be too painful.\nJoe I hear you. What else, my friend?\nTheo Our system is going to run on a multi-threaded environment. I reviewed the\nconcurrency control strategy that you presented, and it’s not thread-safe.\nJoe I hear you. What else, my friend?\nTheo I have been doing a bit of research about implementing immutable data struc-\ntures with structural sharing. I discovered that when the size of the data\nstructures grows, there is a significant performance hit.\nJoe I hear you. What else?\nTheo As our system grows, we will use a database to store the application data and\nexternal services to enrich book information, and in what you have showed me\nso far, data lives in memory.\nJoe I hear you. What else, my friend?\nTheo Don’t you think I have shared enough reasons to abandon DOP?\nJoe I think that your concerns about DOP at scale totally make sense. However, it\ndoesn’t mean that you should abandon DOP.\nTheo What do you mean?\nJoe With the help of meditation, I learned not be attached to the objections that\nflow in my mind while I’m practicing. Sometimes all that is needed to quiet our\nminds is to keep breathing; sometimes, a deeper level of practice is needed.\nTheo I don’t see how breathing would convince me to give DOP a second chance.\nJoe Breathing might not be enough in this case, but a deeper knowledge of DOP\ncould be helpful. Until now, I have shared with you only the material that was\nneeded in order to refactor your prototype. In order to use DOP in a big proj-\nect, a few more lessons are necessary.\nTheo But I don’t have time for more lessons. I need to work.\nJoe Have you heard the story about the young woodcutter and the old man?\nTheo No.\nJoe It goes like this.\n--- Page 167 ---\nPART 2 Scalability 139\nThe young woodcutter and the old man\nA young woodcutter strained to saw down a tree. An old man who was watching near-\nby asked, “What are you doing?”\n“Are you blind?” the woodcutter replied. “I’m cutting down this tree.”\nThe old man replied, “You look exhausted! Take a break. Sharpen your saw.”\nThe young woodcutter explained to the old man that he had been sawing for hours\nand did not have time to take a break.\nThe old man pushed back, “If you sharpen the saw, you would cut down the tree much\nfaster.”\nThe woodcutter said, “I don’t have time to sharpen the saw. Don’t you see, I’m too\nbusy!”\nTheo takes a moment to meditate on the story. He wonders if he needs to take the time to\nsharpen his saw and commit to a deeper level of practice.\nTheo Do you really think that with DOP, it will take much less time to deliver the\nproject?\nJoe I know so!\nTheo But if we miss the deadline, I will probably get fired. I’m the one that needs to\ntake the risk, not you.\nJoe Let’s make a deal. If you miss the deadline and get fired, I will hire you at my\ncompany for double the salary you make at Albatross.\nTheo And what if we meet the deadline?\nJoe If you meet the deadline, you will probably get promoted. In that case, I will\nask you to buy a gift for my son Neriah and my daughter Aurelia.\nTheo Deal! When will I get my first lesson about going deeper into DOP?\nJoe Why not start right now?\nTheo Let me reschedule my meetings.\n--- Page 168 ---\n\n--- Page 169 ---\nBasic data validation\nA solemn gift\nThis chapter covers\n The importance of validating data at system\nboundaries\n Validating data using the JSON Schema language\n Integrating data validation into an existing code\nbase\n Getting detailed information about data validation\nfailures\nAt first glance, it may seem that embracing DOP means accessing data without validat-\ning it and engaging in wishful thinking, where data is always valid. In fact, data valida-\ntion is not only possible but recommended when we follow data-oriented principles.\nThis chapter illustrates how to validate data when data is represented with\ngeneric data structures. It focuses on data validation occurring at the boundaries of\nthe system, while in part 3, we will deal with validating data as it flows through the\nsystem. This chapter is a deep dive into the fourth principle of DOP.\nPRINCIPLE #4 Separate data schema from data representation.\n141\n--- Page 170 ---\n142 CHAPTER 7 Basic data validation\n7.1 Data validation in DOP\nTheo has rescheduled his meetings. With such an imposing deadline, he’s still not sure if\nhe’s made a big mistake giving DOP a second chance.\n NOTE The reason why Theo rescheduled his meetings is explained in the opener\nfor part 2. Take a moment to read the opener if you missed it.\nJoe What aspect of OOP do you think you will miss the most in your big project?\nTheo Data validation.\nJoe Can you elaborate a bit?\nTheo In OOP, I have this strong guarantee that when a class is instantiated, its mem-\nber fields have the proper names and proper types. But with DOP, it’s so easy\nto have small mistakes in field names and field types.\nJoe Well, I have good news for you! There is a way to validate data in DOP.\nTheo How does it work? I thought DOP and data validation were two contradictory\nconcepts!\nJoe Not at all. It’s true that DOP doesn’t force you to validate data, but it doesn’t\nprevent you from doing so. In DOP, the data schema is separate from the data\nrepresentation.\nTheo I don’t get how that would eliminate data consistency issues.\nJoe According to DOP, the most important data to validate is data that crosses the\nboundaries of the system.\nTheo Which boundaries are you referring to?\nJoe In the case of a web server, it would be the areas where the web server commu-\nnicates with its clients and with its data sources.\nTheo A diagram might help me see it better.\nJoe goes to the whiteboard and picks up the pen. He then draws a diagram like the one in\nfigure 7.1.\nClient (e.g., web browser)\nData\nWeb server\nData Data\nWeb service Database Figure 7.1 High-level architecture of\na modern web server\n--- Page 171 ---\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n--- Page 172 ---\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n--- Page 173 ---\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n--- Page 174 ---\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n--- Page 175 ---\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer",
        "sections_found": []
      },
      "accurate_page_range": "152-175"
    },
    {
      "text": "- 6.3 Unit tests for queries",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "raw_line": "- 6.3 Unit tests for queries (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 51,
      "chapter_info": {
        "page": 152,
        "title": "Unit tests",
        "pattern_matched": "Chapter 6",
        "text_preview": "124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again "
      },
      "chapter_sections": {
        "start_page": 152,
        "end_page": 175,
        "content": "\n--- Page 152 ---\n124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again at the\ncode for Catalog.searchBooksByTitle.\nListing6.16 The code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nWriting the unit test for Catalog.searchBooksByTitle is a more pleasant experience for\nTheo than writing the unit test for Library.searchBooksByTitleJSON. He appreciates\nthis for two reasons:\n It’s not necessary to deserialize the output because the function returns data.\n It’s not necessary to wrap the catalog data in a library data map.\nListing6.17 Unit test for Catalog.searchBooksByTitle\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n--- Page 153 ---\n6.3 Unit tests for queries 125\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Watchmen\"), [bookInfo]);\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Batman\"), []);\nJoe That’s a good start!\nTheo I thought I was done. What did I miss?\nJoe You forgot to test cases where the query string is all lowercase.\nTheo You’re right! Let me quickly add one more test case.\nIn less than a minute, Theo creates an additional test case and shows it to Joe. What a dis-\nappointment when Theo discovers that the test case with \"watchmen\" in lowercase fails!\nListing6.18 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe Don’t be too upset, my friend. After all, the purpose of unit tests is to find bugs\nin the code so that you can fix them. Can you fix the code of Catalog-\nData.searchBooksByTitle?\nTheo Sure. All I need to do is to lowercase both the query string and the book title\nbefore comparing them. I’d probably do something like this.\nListing6.19 Fixed code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar queryLowerCased = query.toLowerCase();\nConverts the query\nvar matchingBooks = _.filter(allBooks, function(book) {\nto lowercase\nreturn _.get(book, \"title\")\n.toLowerCase()\nConverts the book\n.includes(queryLowerCased);\ntitle to lowercase\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nAfter fixing the code of Catalog.searchBooksByTitle, Theo runs all the test cases\nagain. This time, all of them pass—what a relief!\nListing6.20 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe It’s such good feeling when all the test cases pass.\nTheo Sure is.\nJoe I think we’ve written unit tests for all the search query code, so now we’re ready\nto write unit tests for mutations. Thank goodness the waiter just brought our\ncoffee orders.\n--- Page 154 ---\n126 CHAPTER 6 Unit tests\n6.4 Unit tests for mutations\nJoe Before writing unit tests for the add member mutation, let’s draw the tree of\nfunction calls for System.addMember.\nTheo I can do that.\nTheo takes a look at the code for the functions involved in the add member mutation. He\nnotices the code is spread over three classes: System, Library, and UserManagement.\nListing6.21 The functions involved in the add member mutation\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement, member);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nthrow \"Member already exists.\";\n}\nvar nextUserManagement = _.set(userManagement,\ninfoPath,\nmember);\nreturn nextUserManagement;\n};\nTheo grabs another napkin. Drawing the tree of function calls for System.addMember is\nnow quite easy (see figure 6.5).\nSystem.addMember\nSystemState.get SystemState.commit Library.addMember\n_.get _.set UserManagement.addMember\n_.has _.set\nFigure 6.5 The tree of function calls for System.addMember\n--- Page 155 ---\n6.4 Unit tests for mutations 127\nJoe Excellent! So which functions of the tree should be unit tested for the add\nmember mutation?\nTheo I think the functions we need to test are System.addMember, SystemState\n.get, SystemState.commit, Library.addMember, and UserManagement\n.addMember. That right?\nJoe You’re totally right. Let’s defer writing unit tests for functions that belong to\nSystemState until later. Those are generic functions that should be tested\noutside the context of a specific mutation. Let’s assume for now that we’ve\nalready written unit tests for the SystemState class. We’re left with three func-\ntions: System.addMember, Library.addMember, and UserManagement.add-\nMember.\nTheo In what order should we write the unit tests, bottom up or top down?\nJoe Let’s start where the real meat is—in UserManagement.addMember. The two\nother functions are just wrappers.\nTheo OK.\nJoe Writing a unit test for the main function of a mutation requires more effort\nthan writing the test for a query. The reason is that a query returns a response\nbased on the system data, whereas a mutation computes a new state of the system\nbased on the current state of the system and some arguments (see figure 6.6).\nSystemData Argument Argument SystemData\nMutation Query\nNextSystemData ResponseData\nFigure 6.6 The output of a mutation is more complex than\nthe output of a query.\nTIP Writing a unit test for the main function of a mutation requires more effort than\nfor a query.\nTheo It means that in the test cases of UserManagement.addMember, both the input\nand the expected output are maps that describe the state of the system.\nJoe Exactly. Let’s start with the simplest case, where the initial state of the system\nis empty.\nTheo You mean that userManagementData passed to UserManagement.addMember\nis an empty map?\nJoe Yes.\nOnce again, Theo places his hands over his laptop keyboard, thinks for a moment, and\nbegins typing. He reminds himself that the code needs to add a member to an empty user\n--- Page 156 ---\n128 CHAPTER 6 Unit tests\nmanagement map and to check that the resulting map is as expected. When he’s finished,\nhe shows his code to Joe.\nListing6.22 Test case for Catalog.addMember without members\nvar member = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, member);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Very nice! Keep going and write a test case when the initial state is not empty.\nTheo knows this requires a few more lines of code but nothing complicated. When he fin-\nishes, he once again shows the code to Joe.\nListing6.23 Test case for Catalog.addMember with existing members\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n--- Page 157 ---\n6.4 Unit tests for mutations 129\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, jessie);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Awesome! Can you think of other test cases for UserManagement.addMember?\nTheo No.\nJoe What about cases where the mutation fails?\nTheo Right! I always forget to think about negative test cases. I assume that relates to\nthe fact that I’m an optimistic person.\nTIP Don’t forget to include negative test cases in your unit tests.\nJoe Me too. The more I meditate, the more I’m able to focus on the positive side of\nlife. Anyway, how would you write a test case where the mutation fails?\nTheo I would pass to UserManagement.addMember a member that already exists in\nuserManagementStateBefore.\nJoe And how would you check that the code behaves as expected in case of a failure?\nTheo Let me see. When a member already exists, UserManagement.addMember\nthrows an exception. Therefore, what I need to do in my test case is to wrap the\ncode in a try/catch block.\nJoe Sounds good to me.\nOnce again, it doesn’t require too much of an effort for Theo to create a new test case.\nWhen he’s finished, he eagerly turns his laptop to Joe.\nListing6.24 Test case for UserManagement.addMember if it’s expected to fail\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\n--- Page 158 ---\n130 CHAPTER 6 Unit tests\nvar expectedException = \"Member already exists.\";\nvar exceptionInMutation;\ntry {\nUserManagement.addMember(userManagementStateBefore, jessie);\n} catch (e) {\nexceptionInMutation = e;\n}\n_.isEqual(exceptionInMutation, expectedException);\nTheo Now, I think I’m ready to move forward and write unit tests for Library.add-\nMember and System.addMember.\nJoe I agree with you. Please start with Library.addMember.\nTheo Library.addMember is quite similar to UserManagement.addMember. So I\nguess I’ll write similar test cases.\nJoe In fact, that won’t be required. As I told you when we wrote unit tests for a\nquery, when you write a unit test for a function, you can assume that the func-\ntions down the tree work as expected.\nTheo Right. So I’ll just write the test case for existing members.\nJoe Go for it!\nTheo starts with a copy-and-paste of the code from the UserManagement.addMember test\ncase with the existing members in listing 6.23. After a few modifications, the unit test for\nLibrary.addMember is ready.\nListing6.25 Unit test for Library.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 159 ---\n6.4 Unit tests for mutations 131\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar result = Library.addMember(libraryStateBefore, jessie);\n_.isEqual(result, expectedLibraryStateAfter);\nJoe Beautiful! Now, we’re ready for the last piece. Write a unit test for System\n.addMember. Before you start, could you please describe the input and the out-\nput of System.addMember?\nTheo takes another look at the code for System.addMember and hesitates; he’s a bit con-\nfused. The function doesn’t seem to return anything!\nListing6.26 The code of System.addMember\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nTheo The input of System.addMember is a system state instance and a member. But,\nI’m not sure what the output of System.addMember is.\nJoe In fact, System.addMember doesn’t have any output. It belongs to this stateful\npart of our code that doesn’t deal with data manipulation. Although DOP\nallows us to reduce the size of the stateful part of our code, it still exists. Here is\nhow I visualize it.\nJoe calls the waiter to see if he can get more napkins. With that problem resolved, he draws\nthe diagram in figure 6.7.\nSystemData Member\nMutation Change system state\nFigure 6.7 System.addMember\ndoesn’t return data—it changes the\nNothing system state!\n--- Page 160 ---\n132 CHAPTER 6 Unit tests\nTheo Then how do we validate that the code works as expected?\nJoe We’ll retrieve the system state after the code is executed and compare it to the\nexpected value of the state.\nTheo OK. I’ll try to write the unit test.\nJoe Writing unit tests for stateful code is more complicated than for data manipula-\ntion code. It requires the calm of the office.\nTheo Then let’s go back to the office. Waiter! Check, please.\nTheo picks up the tab, and he and Joe take the cable car back to Albatross. When they’re\nback at the office, Theo starts coding the unit test for Library.addMember.\nTheo Can we use _.isEqual with system state?\nJoe Definitely. The system state is a map like any other map.\nTIP The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state using\n_.isEqual\nTheo copies and pastes the code for Library.addMember (listing 6.21), which initializes\nthe data for the test. Then, he passes a SystemState object that is initialized with\nlibraryStateBefore to System.addMember. Finally, to complete the test, he compares\nthe system state after the mutation is executed with the expected value of the state.\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nwindow.SystemState = SystemState;\nListing6.27 Unit test for System.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 161 ---\n6.4 Unit tests for mutations 133\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\nCreates an empty\n}\nSystemState object\n}\n(see chapter 4)\n}\n};\nInitializes the system\nstate with the library\ndata before the\nvar systemState = new SystemState();\nmutation\nsystemState.commit(null, libraryStateBefore);\nSystem.addMember(systemState, jessie);\nExecutes the\nmutation on the\n_.isEqual(systemState.get(),\nSystemState object\nexpectedLibraryStateAfter);\nValidates the state after the\nmutation is executed\nJoe Wow, I’m impressed; you did it! Congratulations!\nTheo Thank you. I’m so glad that in DOP most of our code deals with data manipu-\nlation. It’s definitely more pleasant to write unit tests for stateless code that\nonly deals with data manipulation.\nJoe Now that you know the basics of DOP, would you like to refactor the code of\nyour Klafim prototype according to DOP principles?\nTheo Definitely. Nancy told me yesterday that Klafim is getting nice market traction.\nI’m supposed to have a meeting with her in a week or so about the next steps.\nHopefully, she’ll be willing to work with Albatross for the long term.\nJoe Exciting! Do you know what might influence Nancy’s decision?\nTheo Our cost estimate, certainly, but I know she’s in touch with other software com-\npanies. If we come up with a competitive proposal, I think we’ll get the deal.\nJoe I’m quite sure that after refactoring to DOP, features will take much less time\nto implement. That means you should be able to quote Nancy a lower total cost\nthan the competition, right?\nTheo I’ll keep my fingers crossed!\n--- Page 162 ---\n134 CHAPTER 6 Unit tests\nMoving forward\nThe meeting with Nancy went well. Albatross got the deal, Monica (Theo’s boss) is\npleased, and it’s going to be a long-term project with a nice budget. They’ll need to hire a\nteam of developers in order to meet the tough deadlines. While driving back to the office,\nTheo gets a phone call from Joe.\nJoe How was your meeting with Nancy?\nTheo We got the deal!\nJoe Awesome! I told you that with DOP the cost estimation would be lower.\nTheo In fact, we are not going to use DOP for this project.\nJoe Why?\nTheo After refactoring the Library Management System prototype to DOP, I did a\ndeep analysis with my engineers. We came to the conclusion that DOP might\nbe a good fit for the prototype phase, but it won’t work well at scale.\nJoe Could you share the details of your analysis?\nTheo I can’t right now. I’m driving.\nJoe Could we meet in your office later today?\nTheo I’m quite busy with the new project and the tough deadlines.\nJoe Let’s meet at least in order to have a proper farewell.\nTheo OK. Let’s meet at 4 PM, then.\n NOTE The story continues in the opener of part 2.\nSummary\n Most of the code in a data-oriented system deals with data manipulation.\n It’s straightforward to write unit tests for code that deals with data manipulation.\n Test cases follow the same simple general pattern:\na Generate data input\nb Generate expected data output\nc Compare the output of the function with the expected data output\n In order to compare the output of a function with the expected data output, we\nneed to recursively compare the two pieces of data.\n The recursive comparison of two pieces of data is implemented via a generic\nfunction.\n When a function returns a JSON string, we parse the string back to data so that\nwe deal with data comparison instead of string comparison.\n A tree of function calls for a function f is a tree where the root is f, and the chil-\ndren of a node g in the tree are the functions called by g.\n The leaves of the tree are functions that are not part of the code base of the\napplication and are functions that don’t call any other functions.\n The tree of function calls visualization guides us regarding the quality and\nquantity of the test cases in a unit test.\n--- Page 163 ---\nSummary 135\n Functions that appear in a lower level in the tree of function calls tend to involve\nless complex data than functions that appear in a higher level in the tree.\n Functions that appear in a lower level in the tree of function calls usually need\nto be covered with more test cases than functions that appear in a higher level\nin the tree.\n Unit tests for mutations focus on the calculation phase of the mutation.\n The validity of the data depends on the context.\n The smaller the data, the easier it is to manipulate.\n We compare the output and the expected output of our functions with a generic\nfunction that recursively compares two pieces of data (e.g., _.isEqual).\n When we write a unit test for a function, we assume that the functions called by\nthis function are covered by the unit tests and work as expected. This signifi-\ncantly reduces the quantity of test cases in our unit tests.\n We avoid using string comparison in unit tests for functions that deal with data.\n Writing a unit test for the main function of a mutation requires more effort\nthan for a query.\n Remember to include negative test cases in your unit tests.\n The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state\nusing a generic function like _.isEqual.\n--- Page 164 ---\n\n--- Page 165 ---\nPart 2\nScalability\nT\nheo feels a bit uncomfortable about the meeting with Joe. He was so enthusias-\ntic about DOP, and he was very good at teaching it. Every meeting with him was an\nopportunity to learn new things. Theo feels lot of gratitude for the time Joe spent\nwith him. He doesn’t want to hurt him in any fashion. Surprisingly, Joe enters the\noffice with the same relaxed attitude as usual, and he is even smiling.\nJoe I’m really glad that you got the deal with Nancy.\nTheo Yeah. There’s lot of excitement about it here in the office, and a bit of\nstress too.\nJoe What kind of stress?\nTheo You know.... We need to hire a team of developers, and the deadlines\nare quite tight.\nJoe But you told me that you won’t use DOP. I assume that you gave regular\ndeadlines?\nTheo No, my boss Monica really wanted to close the deal. She feels that success\nwith this project is strategically important for Albatross, so it’s worthwhile\nto accept some risk by giving what she calls an “optimistic” time estima-\ntion. I told her that it was really an unrealistic time estimation, but Mon-\nica insists that if we make smart decisions and bring in more developers,\nwe can do it.\nJoe I see. Now I understand why you told me over the phone that you were\nvery busy. Anyway, would you please share the reasons that made you\nthink DOP wouldn’t be a good fit at scale?\n--- Page 166 ---\n138 PART 2 Scalability\nTheo First of all, let me tell you that I feel lot of gratitude for all the teaching you\nshared with me. Reimplementing the Klafim prototype with DOP was really\nfun and productive due to the flexibility this paradigm offers.\nJoe I’m happy that you found it valuable.\nTheo But, as I told you over the phone, now we’re scaling up into a long-term project\nwith several developers working on a large code base. We came to the conclu-\nsion that DOP will not be a good fit at scale.\nJoe Could you share the reasons behind your conclusion?\nTheo There are many of them. First of all, as DOP deals only with generic data struc-\ntures, it’s hard to know what kind of data we have in hand, while in OOP, we\nknow the type of every piece of data. For the prototype, it was kind of OK. But\nas the code base grows and more developers are involved in the project, it\nwould be too painful.\nJoe I hear you. What else, my friend?\nTheo Our system is going to run on a multi-threaded environment. I reviewed the\nconcurrency control strategy that you presented, and it’s not thread-safe.\nJoe I hear you. What else, my friend?\nTheo I have been doing a bit of research about implementing immutable data struc-\ntures with structural sharing. I discovered that when the size of the data\nstructures grows, there is a significant performance hit.\nJoe I hear you. What else?\nTheo As our system grows, we will use a database to store the application data and\nexternal services to enrich book information, and in what you have showed me\nso far, data lives in memory.\nJoe I hear you. What else, my friend?\nTheo Don’t you think I have shared enough reasons to abandon DOP?\nJoe I think that your concerns about DOP at scale totally make sense. However, it\ndoesn’t mean that you should abandon DOP.\nTheo What do you mean?\nJoe With the help of meditation, I learned not be attached to the objections that\nflow in my mind while I’m practicing. Sometimes all that is needed to quiet our\nminds is to keep breathing; sometimes, a deeper level of practice is needed.\nTheo I don’t see how breathing would convince me to give DOP a second chance.\nJoe Breathing might not be enough in this case, but a deeper knowledge of DOP\ncould be helpful. Until now, I have shared with you only the material that was\nneeded in order to refactor your prototype. In order to use DOP in a big proj-\nect, a few more lessons are necessary.\nTheo But I don’t have time for more lessons. I need to work.\nJoe Have you heard the story about the young woodcutter and the old man?\nTheo No.\nJoe It goes like this.\n--- Page 167 ---\nPART 2 Scalability 139\nThe young woodcutter and the old man\nA young woodcutter strained to saw down a tree. An old man who was watching near-\nby asked, “What are you doing?”\n“Are you blind?” the woodcutter replied. “I’m cutting down this tree.”\nThe old man replied, “You look exhausted! Take a break. Sharpen your saw.”\nThe young woodcutter explained to the old man that he had been sawing for hours\nand did not have time to take a break.\nThe old man pushed back, “If you sharpen the saw, you would cut down the tree much\nfaster.”\nThe woodcutter said, “I don’t have time to sharpen the saw. Don’t you see, I’m too\nbusy!”\nTheo takes a moment to meditate on the story. He wonders if he needs to take the time to\nsharpen his saw and commit to a deeper level of practice.\nTheo Do you really think that with DOP, it will take much less time to deliver the\nproject?\nJoe I know so!\nTheo But if we miss the deadline, I will probably get fired. I’m the one that needs to\ntake the risk, not you.\nJoe Let’s make a deal. If you miss the deadline and get fired, I will hire you at my\ncompany for double the salary you make at Albatross.\nTheo And what if we meet the deadline?\nJoe If you meet the deadline, you will probably get promoted. In that case, I will\nask you to buy a gift for my son Neriah and my daughter Aurelia.\nTheo Deal! When will I get my first lesson about going deeper into DOP?\nJoe Why not start right now?\nTheo Let me reschedule my meetings.\n--- Page 168 ---\n\n--- Page 169 ---\nBasic data validation\nA solemn gift\nThis chapter covers\n The importance of validating data at system\nboundaries\n Validating data using the JSON Schema language\n Integrating data validation into an existing code\nbase\n Getting detailed information about data validation\nfailures\nAt first glance, it may seem that embracing DOP means accessing data without validat-\ning it and engaging in wishful thinking, where data is always valid. In fact, data valida-\ntion is not only possible but recommended when we follow data-oriented principles.\nThis chapter illustrates how to validate data when data is represented with\ngeneric data structures. It focuses on data validation occurring at the boundaries of\nthe system, while in part 3, we will deal with validating data as it flows through the\nsystem. This chapter is a deep dive into the fourth principle of DOP.\nPRINCIPLE #4 Separate data schema from data representation.\n141\n--- Page 170 ---\n142 CHAPTER 7 Basic data validation\n7.1 Data validation in DOP\nTheo has rescheduled his meetings. With such an imposing deadline, he’s still not sure if\nhe’s made a big mistake giving DOP a second chance.\n NOTE The reason why Theo rescheduled his meetings is explained in the opener\nfor part 2. Take a moment to read the opener if you missed it.\nJoe What aspect of OOP do you think you will miss the most in your big project?\nTheo Data validation.\nJoe Can you elaborate a bit?\nTheo In OOP, I have this strong guarantee that when a class is instantiated, its mem-\nber fields have the proper names and proper types. But with DOP, it’s so easy\nto have small mistakes in field names and field types.\nJoe Well, I have good news for you! There is a way to validate data in DOP.\nTheo How does it work? I thought DOP and data validation were two contradictory\nconcepts!\nJoe Not at all. It’s true that DOP doesn’t force you to validate data, but it doesn’t\nprevent you from doing so. In DOP, the data schema is separate from the data\nrepresentation.\nTheo I don’t get how that would eliminate data consistency issues.\nJoe According to DOP, the most important data to validate is data that crosses the\nboundaries of the system.\nTheo Which boundaries are you referring to?\nJoe In the case of a web server, it would be the areas where the web server commu-\nnicates with its clients and with its data sources.\nTheo A diagram might help me see it better.\nJoe goes to the whiteboard and picks up the pen. He then draws a diagram like the one in\nfigure 7.1.\nClient (e.g., web browser)\nData\nWeb server\nData Data\nWeb service Database Figure 7.1 High-level architecture of\na modern web server\n--- Page 171 ---\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n--- Page 172 ---\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n--- Page 173 ---\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n--- Page 174 ---\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n--- Page 175 ---\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer",
        "sections_found": []
      },
      "accurate_page_range": "152-175"
    },
    {
      "text": "- 6.4 Unit tests for mutations",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "raw_line": "- 6.4 Unit tests for mutations (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 52,
      "chapter_info": {
        "page": 152,
        "title": "Unit tests",
        "pattern_matched": "Chapter 6",
        "text_preview": "124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again "
      },
      "chapter_sections": {
        "start_page": 152,
        "end_page": 175,
        "content": "\n--- Page 152 ---\n124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again at the\ncode for Catalog.searchBooksByTitle.\nListing6.16 The code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nWriting the unit test for Catalog.searchBooksByTitle is a more pleasant experience for\nTheo than writing the unit test for Library.searchBooksByTitleJSON. He appreciates\nthis for two reasons:\n It’s not necessary to deserialize the output because the function returns data.\n It’s not necessary to wrap the catalog data in a library data map.\nListing6.17 Unit test for Catalog.searchBooksByTitle\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n--- Page 153 ---\n6.3 Unit tests for queries 125\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Watchmen\"), [bookInfo]);\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Batman\"), []);\nJoe That’s a good start!\nTheo I thought I was done. What did I miss?\nJoe You forgot to test cases where the query string is all lowercase.\nTheo You’re right! Let me quickly add one more test case.\nIn less than a minute, Theo creates an additional test case and shows it to Joe. What a dis-\nappointment when Theo discovers that the test case with \"watchmen\" in lowercase fails!\nListing6.18 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe Don’t be too upset, my friend. After all, the purpose of unit tests is to find bugs\nin the code so that you can fix them. Can you fix the code of Catalog-\nData.searchBooksByTitle?\nTheo Sure. All I need to do is to lowercase both the query string and the book title\nbefore comparing them. I’d probably do something like this.\nListing6.19 Fixed code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar queryLowerCased = query.toLowerCase();\nConverts the query\nvar matchingBooks = _.filter(allBooks, function(book) {\nto lowercase\nreturn _.get(book, \"title\")\n.toLowerCase()\nConverts the book\n.includes(queryLowerCased);\ntitle to lowercase\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nAfter fixing the code of Catalog.searchBooksByTitle, Theo runs all the test cases\nagain. This time, all of them pass—what a relief!\nListing6.20 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe It’s such good feeling when all the test cases pass.\nTheo Sure is.\nJoe I think we’ve written unit tests for all the search query code, so now we’re ready\nto write unit tests for mutations. Thank goodness the waiter just brought our\ncoffee orders.\n--- Page 154 ---\n126 CHAPTER 6 Unit tests\n6.4 Unit tests for mutations\nJoe Before writing unit tests for the add member mutation, let’s draw the tree of\nfunction calls for System.addMember.\nTheo I can do that.\nTheo takes a look at the code for the functions involved in the add member mutation. He\nnotices the code is spread over three classes: System, Library, and UserManagement.\nListing6.21 The functions involved in the add member mutation\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement, member);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nthrow \"Member already exists.\";\n}\nvar nextUserManagement = _.set(userManagement,\ninfoPath,\nmember);\nreturn nextUserManagement;\n};\nTheo grabs another napkin. Drawing the tree of function calls for System.addMember is\nnow quite easy (see figure 6.5).\nSystem.addMember\nSystemState.get SystemState.commit Library.addMember\n_.get _.set UserManagement.addMember\n_.has _.set\nFigure 6.5 The tree of function calls for System.addMember\n--- Page 155 ---\n6.4 Unit tests for mutations 127\nJoe Excellent! So which functions of the tree should be unit tested for the add\nmember mutation?\nTheo I think the functions we need to test are System.addMember, SystemState\n.get, SystemState.commit, Library.addMember, and UserManagement\n.addMember. That right?\nJoe You’re totally right. Let’s defer writing unit tests for functions that belong to\nSystemState until later. Those are generic functions that should be tested\noutside the context of a specific mutation. Let’s assume for now that we’ve\nalready written unit tests for the SystemState class. We’re left with three func-\ntions: System.addMember, Library.addMember, and UserManagement.add-\nMember.\nTheo In what order should we write the unit tests, bottom up or top down?\nJoe Let’s start where the real meat is—in UserManagement.addMember. The two\nother functions are just wrappers.\nTheo OK.\nJoe Writing a unit test for the main function of a mutation requires more effort\nthan writing the test for a query. The reason is that a query returns a response\nbased on the system data, whereas a mutation computes a new state of the system\nbased on the current state of the system and some arguments (see figure 6.6).\nSystemData Argument Argument SystemData\nMutation Query\nNextSystemData ResponseData\nFigure 6.6 The output of a mutation is more complex than\nthe output of a query.\nTIP Writing a unit test for the main function of a mutation requires more effort than\nfor a query.\nTheo It means that in the test cases of UserManagement.addMember, both the input\nand the expected output are maps that describe the state of the system.\nJoe Exactly. Let’s start with the simplest case, where the initial state of the system\nis empty.\nTheo You mean that userManagementData passed to UserManagement.addMember\nis an empty map?\nJoe Yes.\nOnce again, Theo places his hands over his laptop keyboard, thinks for a moment, and\nbegins typing. He reminds himself that the code needs to add a member to an empty user\n--- Page 156 ---\n128 CHAPTER 6 Unit tests\nmanagement map and to check that the resulting map is as expected. When he’s finished,\nhe shows his code to Joe.\nListing6.22 Test case for Catalog.addMember without members\nvar member = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, member);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Very nice! Keep going and write a test case when the initial state is not empty.\nTheo knows this requires a few more lines of code but nothing complicated. When he fin-\nishes, he once again shows the code to Joe.\nListing6.23 Test case for Catalog.addMember with existing members\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n--- Page 157 ---\n6.4 Unit tests for mutations 129\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, jessie);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Awesome! Can you think of other test cases for UserManagement.addMember?\nTheo No.\nJoe What about cases where the mutation fails?\nTheo Right! I always forget to think about negative test cases. I assume that relates to\nthe fact that I’m an optimistic person.\nTIP Don’t forget to include negative test cases in your unit tests.\nJoe Me too. The more I meditate, the more I’m able to focus on the positive side of\nlife. Anyway, how would you write a test case where the mutation fails?\nTheo I would pass to UserManagement.addMember a member that already exists in\nuserManagementStateBefore.\nJoe And how would you check that the code behaves as expected in case of a failure?\nTheo Let me see. When a member already exists, UserManagement.addMember\nthrows an exception. Therefore, what I need to do in my test case is to wrap the\ncode in a try/catch block.\nJoe Sounds good to me.\nOnce again, it doesn’t require too much of an effort for Theo to create a new test case.\nWhen he’s finished, he eagerly turns his laptop to Joe.\nListing6.24 Test case for UserManagement.addMember if it’s expected to fail\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\n--- Page 158 ---\n130 CHAPTER 6 Unit tests\nvar expectedException = \"Member already exists.\";\nvar exceptionInMutation;\ntry {\nUserManagement.addMember(userManagementStateBefore, jessie);\n} catch (e) {\nexceptionInMutation = e;\n}\n_.isEqual(exceptionInMutation, expectedException);\nTheo Now, I think I’m ready to move forward and write unit tests for Library.add-\nMember and System.addMember.\nJoe I agree with you. Please start with Library.addMember.\nTheo Library.addMember is quite similar to UserManagement.addMember. So I\nguess I’ll write similar test cases.\nJoe In fact, that won’t be required. As I told you when we wrote unit tests for a\nquery, when you write a unit test for a function, you can assume that the func-\ntions down the tree work as expected.\nTheo Right. So I’ll just write the test case for existing members.\nJoe Go for it!\nTheo starts with a copy-and-paste of the code from the UserManagement.addMember test\ncase with the existing members in listing 6.23. After a few modifications, the unit test for\nLibrary.addMember is ready.\nListing6.25 Unit test for Library.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 159 ---\n6.4 Unit tests for mutations 131\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar result = Library.addMember(libraryStateBefore, jessie);\n_.isEqual(result, expectedLibraryStateAfter);\nJoe Beautiful! Now, we’re ready for the last piece. Write a unit test for System\n.addMember. Before you start, could you please describe the input and the out-\nput of System.addMember?\nTheo takes another look at the code for System.addMember and hesitates; he’s a bit con-\nfused. The function doesn’t seem to return anything!\nListing6.26 The code of System.addMember\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nTheo The input of System.addMember is a system state instance and a member. But,\nI’m not sure what the output of System.addMember is.\nJoe In fact, System.addMember doesn’t have any output. It belongs to this stateful\npart of our code that doesn’t deal with data manipulation. Although DOP\nallows us to reduce the size of the stateful part of our code, it still exists. Here is\nhow I visualize it.\nJoe calls the waiter to see if he can get more napkins. With that problem resolved, he draws\nthe diagram in figure 6.7.\nSystemData Member\nMutation Change system state\nFigure 6.7 System.addMember\ndoesn’t return data—it changes the\nNothing system state!\n--- Page 160 ---\n132 CHAPTER 6 Unit tests\nTheo Then how do we validate that the code works as expected?\nJoe We’ll retrieve the system state after the code is executed and compare it to the\nexpected value of the state.\nTheo OK. I’ll try to write the unit test.\nJoe Writing unit tests for stateful code is more complicated than for data manipula-\ntion code. It requires the calm of the office.\nTheo Then let’s go back to the office. Waiter! Check, please.\nTheo picks up the tab, and he and Joe take the cable car back to Albatross. When they’re\nback at the office, Theo starts coding the unit test for Library.addMember.\nTheo Can we use _.isEqual with system state?\nJoe Definitely. The system state is a map like any other map.\nTIP The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state using\n_.isEqual\nTheo copies and pastes the code for Library.addMember (listing 6.21), which initializes\nthe data for the test. Then, he passes a SystemState object that is initialized with\nlibraryStateBefore to System.addMember. Finally, to complete the test, he compares\nthe system state after the mutation is executed with the expected value of the state.\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nwindow.SystemState = SystemState;\nListing6.27 Unit test for System.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 161 ---\n6.4 Unit tests for mutations 133\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\nCreates an empty\n}\nSystemState object\n}\n(see chapter 4)\n}\n};\nInitializes the system\nstate with the library\ndata before the\nvar systemState = new SystemState();\nmutation\nsystemState.commit(null, libraryStateBefore);\nSystem.addMember(systemState, jessie);\nExecutes the\nmutation on the\n_.isEqual(systemState.get(),\nSystemState object\nexpectedLibraryStateAfter);\nValidates the state after the\nmutation is executed\nJoe Wow, I’m impressed; you did it! Congratulations!\nTheo Thank you. I’m so glad that in DOP most of our code deals with data manipu-\nlation. It’s definitely more pleasant to write unit tests for stateless code that\nonly deals with data manipulation.\nJoe Now that you know the basics of DOP, would you like to refactor the code of\nyour Klafim prototype according to DOP principles?\nTheo Definitely. Nancy told me yesterday that Klafim is getting nice market traction.\nI’m supposed to have a meeting with her in a week or so about the next steps.\nHopefully, she’ll be willing to work with Albatross for the long term.\nJoe Exciting! Do you know what might influence Nancy’s decision?\nTheo Our cost estimate, certainly, but I know she’s in touch with other software com-\npanies. If we come up with a competitive proposal, I think we’ll get the deal.\nJoe I’m quite sure that after refactoring to DOP, features will take much less time\nto implement. That means you should be able to quote Nancy a lower total cost\nthan the competition, right?\nTheo I’ll keep my fingers crossed!\n--- Page 162 ---\n134 CHAPTER 6 Unit tests\nMoving forward\nThe meeting with Nancy went well. Albatross got the deal, Monica (Theo’s boss) is\npleased, and it’s going to be a long-term project with a nice budget. They’ll need to hire a\nteam of developers in order to meet the tough deadlines. While driving back to the office,\nTheo gets a phone call from Joe.\nJoe How was your meeting with Nancy?\nTheo We got the deal!\nJoe Awesome! I told you that with DOP the cost estimation would be lower.\nTheo In fact, we are not going to use DOP for this project.\nJoe Why?\nTheo After refactoring the Library Management System prototype to DOP, I did a\ndeep analysis with my engineers. We came to the conclusion that DOP might\nbe a good fit for the prototype phase, but it won’t work well at scale.\nJoe Could you share the details of your analysis?\nTheo I can’t right now. I’m driving.\nJoe Could we meet in your office later today?\nTheo I’m quite busy with the new project and the tough deadlines.\nJoe Let’s meet at least in order to have a proper farewell.\nTheo OK. Let’s meet at 4 PM, then.\n NOTE The story continues in the opener of part 2.\nSummary\n Most of the code in a data-oriented system deals with data manipulation.\n It’s straightforward to write unit tests for code that deals with data manipulation.\n Test cases follow the same simple general pattern:\na Generate data input\nb Generate expected data output\nc Compare the output of the function with the expected data output\n In order to compare the output of a function with the expected data output, we\nneed to recursively compare the two pieces of data.\n The recursive comparison of two pieces of data is implemented via a generic\nfunction.\n When a function returns a JSON string, we parse the string back to data so that\nwe deal with data comparison instead of string comparison.\n A tree of function calls for a function f is a tree where the root is f, and the chil-\ndren of a node g in the tree are the functions called by g.\n The leaves of the tree are functions that are not part of the code base of the\napplication and are functions that don’t call any other functions.\n The tree of function calls visualization guides us regarding the quality and\nquantity of the test cases in a unit test.\n--- Page 163 ---\nSummary 135\n Functions that appear in a lower level in the tree of function calls tend to involve\nless complex data than functions that appear in a higher level in the tree.\n Functions that appear in a lower level in the tree of function calls usually need\nto be covered with more test cases than functions that appear in a higher level\nin the tree.\n Unit tests for mutations focus on the calculation phase of the mutation.\n The validity of the data depends on the context.\n The smaller the data, the easier it is to manipulate.\n We compare the output and the expected output of our functions with a generic\nfunction that recursively compares two pieces of data (e.g., _.isEqual).\n When we write a unit test for a function, we assume that the functions called by\nthis function are covered by the unit tests and work as expected. This signifi-\ncantly reduces the quantity of test cases in our unit tests.\n We avoid using string comparison in unit tests for functions that deal with data.\n Writing a unit test for the main function of a mutation requires more effort\nthan for a query.\n Remember to include negative test cases in your unit tests.\n The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state\nusing a generic function like _.isEqual.\n--- Page 164 ---\n\n--- Page 165 ---\nPart 2\nScalability\nT\nheo feels a bit uncomfortable about the meeting with Joe. He was so enthusias-\ntic about DOP, and he was very good at teaching it. Every meeting with him was an\nopportunity to learn new things. Theo feels lot of gratitude for the time Joe spent\nwith him. He doesn’t want to hurt him in any fashion. Surprisingly, Joe enters the\noffice with the same relaxed attitude as usual, and he is even smiling.\nJoe I’m really glad that you got the deal with Nancy.\nTheo Yeah. There’s lot of excitement about it here in the office, and a bit of\nstress too.\nJoe What kind of stress?\nTheo You know.... We need to hire a team of developers, and the deadlines\nare quite tight.\nJoe But you told me that you won’t use DOP. I assume that you gave regular\ndeadlines?\nTheo No, my boss Monica really wanted to close the deal. She feels that success\nwith this project is strategically important for Albatross, so it’s worthwhile\nto accept some risk by giving what she calls an “optimistic” time estima-\ntion. I told her that it was really an unrealistic time estimation, but Mon-\nica insists that if we make smart decisions and bring in more developers,\nwe can do it.\nJoe I see. Now I understand why you told me over the phone that you were\nvery busy. Anyway, would you please share the reasons that made you\nthink DOP wouldn’t be a good fit at scale?\n--- Page 166 ---\n138 PART 2 Scalability\nTheo First of all, let me tell you that I feel lot of gratitude for all the teaching you\nshared with me. Reimplementing the Klafim prototype with DOP was really\nfun and productive due to the flexibility this paradigm offers.\nJoe I’m happy that you found it valuable.\nTheo But, as I told you over the phone, now we’re scaling up into a long-term project\nwith several developers working on a large code base. We came to the conclu-\nsion that DOP will not be a good fit at scale.\nJoe Could you share the reasons behind your conclusion?\nTheo There are many of them. First of all, as DOP deals only with generic data struc-\ntures, it’s hard to know what kind of data we have in hand, while in OOP, we\nknow the type of every piece of data. For the prototype, it was kind of OK. But\nas the code base grows and more developers are involved in the project, it\nwould be too painful.\nJoe I hear you. What else, my friend?\nTheo Our system is going to run on a multi-threaded environment. I reviewed the\nconcurrency control strategy that you presented, and it’s not thread-safe.\nJoe I hear you. What else, my friend?\nTheo I have been doing a bit of research about implementing immutable data struc-\ntures with structural sharing. I discovered that when the size of the data\nstructures grows, there is a significant performance hit.\nJoe I hear you. What else?\nTheo As our system grows, we will use a database to store the application data and\nexternal services to enrich book information, and in what you have showed me\nso far, data lives in memory.\nJoe I hear you. What else, my friend?\nTheo Don’t you think I have shared enough reasons to abandon DOP?\nJoe I think that your concerns about DOP at scale totally make sense. However, it\ndoesn’t mean that you should abandon DOP.\nTheo What do you mean?\nJoe With the help of meditation, I learned not be attached to the objections that\nflow in my mind while I’m practicing. Sometimes all that is needed to quiet our\nminds is to keep breathing; sometimes, a deeper level of practice is needed.\nTheo I don’t see how breathing would convince me to give DOP a second chance.\nJoe Breathing might not be enough in this case, but a deeper knowledge of DOP\ncould be helpful. Until now, I have shared with you only the material that was\nneeded in order to refactor your prototype. In order to use DOP in a big proj-\nect, a few more lessons are necessary.\nTheo But I don’t have time for more lessons. I need to work.\nJoe Have you heard the story about the young woodcutter and the old man?\nTheo No.\nJoe It goes like this.\n--- Page 167 ---\nPART 2 Scalability 139\nThe young woodcutter and the old man\nA young woodcutter strained to saw down a tree. An old man who was watching near-\nby asked, “What are you doing?”\n“Are you blind?” the woodcutter replied. “I’m cutting down this tree.”\nThe old man replied, “You look exhausted! Take a break. Sharpen your saw.”\nThe young woodcutter explained to the old man that he had been sawing for hours\nand did not have time to take a break.\nThe old man pushed back, “If you sharpen the saw, you would cut down the tree much\nfaster.”\nThe woodcutter said, “I don’t have time to sharpen the saw. Don’t you see, I’m too\nbusy!”\nTheo takes a moment to meditate on the story. He wonders if he needs to take the time to\nsharpen his saw and commit to a deeper level of practice.\nTheo Do you really think that with DOP, it will take much less time to deliver the\nproject?\nJoe I know so!\nTheo But if we miss the deadline, I will probably get fired. I’m the one that needs to\ntake the risk, not you.\nJoe Let’s make a deal. If you miss the deadline and get fired, I will hire you at my\ncompany for double the salary you make at Albatross.\nTheo And what if we meet the deadline?\nJoe If you meet the deadline, you will probably get promoted. In that case, I will\nask you to buy a gift for my son Neriah and my daughter Aurelia.\nTheo Deal! When will I get my first lesson about going deeper into DOP?\nJoe Why not start right now?\nTheo Let me reschedule my meetings.\n--- Page 168 ---\n\n--- Page 169 ---\nBasic data validation\nA solemn gift\nThis chapter covers\n The importance of validating data at system\nboundaries\n Validating data using the JSON Schema language\n Integrating data validation into an existing code\nbase\n Getting detailed information about data validation\nfailures\nAt first glance, it may seem that embracing DOP means accessing data without validat-\ning it and engaging in wishful thinking, where data is always valid. In fact, data valida-\ntion is not only possible but recommended when we follow data-oriented principles.\nThis chapter illustrates how to validate data when data is represented with\ngeneric data structures. It focuses on data validation occurring at the boundaries of\nthe system, while in part 3, we will deal with validating data as it flows through the\nsystem. This chapter is a deep dive into the fourth principle of DOP.\nPRINCIPLE #4 Separate data schema from data representation.\n141\n--- Page 170 ---\n142 CHAPTER 7 Basic data validation\n7.1 Data validation in DOP\nTheo has rescheduled his meetings. With such an imposing deadline, he’s still not sure if\nhe’s made a big mistake giving DOP a second chance.\n NOTE The reason why Theo rescheduled his meetings is explained in the opener\nfor part 2. Take a moment to read the opener if you missed it.\nJoe What aspect of OOP do you think you will miss the most in your big project?\nTheo Data validation.\nJoe Can you elaborate a bit?\nTheo In OOP, I have this strong guarantee that when a class is instantiated, its mem-\nber fields have the proper names and proper types. But with DOP, it’s so easy\nto have small mistakes in field names and field types.\nJoe Well, I have good news for you! There is a way to validate data in DOP.\nTheo How does it work? I thought DOP and data validation were two contradictory\nconcepts!\nJoe Not at all. It’s true that DOP doesn’t force you to validate data, but it doesn’t\nprevent you from doing so. In DOP, the data schema is separate from the data\nrepresentation.\nTheo I don’t get how that would eliminate data consistency issues.\nJoe According to DOP, the most important data to validate is data that crosses the\nboundaries of the system.\nTheo Which boundaries are you referring to?\nJoe In the case of a web server, it would be the areas where the web server commu-\nnicates with its clients and with its data sources.\nTheo A diagram might help me see it better.\nJoe goes to the whiteboard and picks up the pen. He then draws a diagram like the one in\nfigure 7.1.\nClient (e.g., web browser)\nData\nWeb server\nData Data\nWeb service Database Figure 7.1 High-level architecture of\na modern web server\n--- Page 171 ---\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n--- Page 172 ---\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n--- Page 173 ---\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n--- Page 174 ---\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n--- Page 175 ---\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer",
        "sections_found": []
      },
      "accurate_page_range": "152-175"
    },
    {
      "text": "- Moving forward",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "raw_line": "- Moving forward (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 53,
      "chapter_info": {
        "page": 152,
        "title": "Unit tests",
        "pattern_matched": "Chapter 6",
        "text_preview": "124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again "
      },
      "chapter_sections": {
        "start_page": 152,
        "end_page": 175,
        "content": "\n--- Page 152 ---\n124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again at the\ncode for Catalog.searchBooksByTitle.\nListing6.16 The code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nWriting the unit test for Catalog.searchBooksByTitle is a more pleasant experience for\nTheo than writing the unit test for Library.searchBooksByTitleJSON. He appreciates\nthis for two reasons:\n It’s not necessary to deserialize the output because the function returns data.\n It’s not necessary to wrap the catalog data in a library data map.\nListing6.17 Unit test for Catalog.searchBooksByTitle\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n--- Page 153 ---\n6.3 Unit tests for queries 125\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Watchmen\"), [bookInfo]);\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Batman\"), []);\nJoe That’s a good start!\nTheo I thought I was done. What did I miss?\nJoe You forgot to test cases where the query string is all lowercase.\nTheo You’re right! Let me quickly add one more test case.\nIn less than a minute, Theo creates an additional test case and shows it to Joe. What a dis-\nappointment when Theo discovers that the test case with \"watchmen\" in lowercase fails!\nListing6.18 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe Don’t be too upset, my friend. After all, the purpose of unit tests is to find bugs\nin the code so that you can fix them. Can you fix the code of Catalog-\nData.searchBooksByTitle?\nTheo Sure. All I need to do is to lowercase both the query string and the book title\nbefore comparing them. I’d probably do something like this.\nListing6.19 Fixed code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar queryLowerCased = query.toLowerCase();\nConverts the query\nvar matchingBooks = _.filter(allBooks, function(book) {\nto lowercase\nreturn _.get(book, \"title\")\n.toLowerCase()\nConverts the book\n.includes(queryLowerCased);\ntitle to lowercase\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nAfter fixing the code of Catalog.searchBooksByTitle, Theo runs all the test cases\nagain. This time, all of them pass—what a relief!\nListing6.20 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe It’s such good feeling when all the test cases pass.\nTheo Sure is.\nJoe I think we’ve written unit tests for all the search query code, so now we’re ready\nto write unit tests for mutations. Thank goodness the waiter just brought our\ncoffee orders.\n--- Page 154 ---\n126 CHAPTER 6 Unit tests\n6.4 Unit tests for mutations\nJoe Before writing unit tests for the add member mutation, let’s draw the tree of\nfunction calls for System.addMember.\nTheo I can do that.\nTheo takes a look at the code for the functions involved in the add member mutation. He\nnotices the code is spread over three classes: System, Library, and UserManagement.\nListing6.21 The functions involved in the add member mutation\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement, member);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nthrow \"Member already exists.\";\n}\nvar nextUserManagement = _.set(userManagement,\ninfoPath,\nmember);\nreturn nextUserManagement;\n};\nTheo grabs another napkin. Drawing the tree of function calls for System.addMember is\nnow quite easy (see figure 6.5).\nSystem.addMember\nSystemState.get SystemState.commit Library.addMember\n_.get _.set UserManagement.addMember\n_.has _.set\nFigure 6.5 The tree of function calls for System.addMember\n--- Page 155 ---\n6.4 Unit tests for mutations 127\nJoe Excellent! So which functions of the tree should be unit tested for the add\nmember mutation?\nTheo I think the functions we need to test are System.addMember, SystemState\n.get, SystemState.commit, Library.addMember, and UserManagement\n.addMember. That right?\nJoe You’re totally right. Let’s defer writing unit tests for functions that belong to\nSystemState until later. Those are generic functions that should be tested\noutside the context of a specific mutation. Let’s assume for now that we’ve\nalready written unit tests for the SystemState class. We’re left with three func-\ntions: System.addMember, Library.addMember, and UserManagement.add-\nMember.\nTheo In what order should we write the unit tests, bottom up or top down?\nJoe Let’s start where the real meat is—in UserManagement.addMember. The two\nother functions are just wrappers.\nTheo OK.\nJoe Writing a unit test for the main function of a mutation requires more effort\nthan writing the test for a query. The reason is that a query returns a response\nbased on the system data, whereas a mutation computes a new state of the system\nbased on the current state of the system and some arguments (see figure 6.6).\nSystemData Argument Argument SystemData\nMutation Query\nNextSystemData ResponseData\nFigure 6.6 The output of a mutation is more complex than\nthe output of a query.\nTIP Writing a unit test for the main function of a mutation requires more effort than\nfor a query.\nTheo It means that in the test cases of UserManagement.addMember, both the input\nand the expected output are maps that describe the state of the system.\nJoe Exactly. Let’s start with the simplest case, where the initial state of the system\nis empty.\nTheo You mean that userManagementData passed to UserManagement.addMember\nis an empty map?\nJoe Yes.\nOnce again, Theo places his hands over his laptop keyboard, thinks for a moment, and\nbegins typing. He reminds himself that the code needs to add a member to an empty user\n--- Page 156 ---\n128 CHAPTER 6 Unit tests\nmanagement map and to check that the resulting map is as expected. When he’s finished,\nhe shows his code to Joe.\nListing6.22 Test case for Catalog.addMember without members\nvar member = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, member);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Very nice! Keep going and write a test case when the initial state is not empty.\nTheo knows this requires a few more lines of code but nothing complicated. When he fin-\nishes, he once again shows the code to Joe.\nListing6.23 Test case for Catalog.addMember with existing members\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n--- Page 157 ---\n6.4 Unit tests for mutations 129\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, jessie);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Awesome! Can you think of other test cases for UserManagement.addMember?\nTheo No.\nJoe What about cases where the mutation fails?\nTheo Right! I always forget to think about negative test cases. I assume that relates to\nthe fact that I’m an optimistic person.\nTIP Don’t forget to include negative test cases in your unit tests.\nJoe Me too. The more I meditate, the more I’m able to focus on the positive side of\nlife. Anyway, how would you write a test case where the mutation fails?\nTheo I would pass to UserManagement.addMember a member that already exists in\nuserManagementStateBefore.\nJoe And how would you check that the code behaves as expected in case of a failure?\nTheo Let me see. When a member already exists, UserManagement.addMember\nthrows an exception. Therefore, what I need to do in my test case is to wrap the\ncode in a try/catch block.\nJoe Sounds good to me.\nOnce again, it doesn’t require too much of an effort for Theo to create a new test case.\nWhen he’s finished, he eagerly turns his laptop to Joe.\nListing6.24 Test case for UserManagement.addMember if it’s expected to fail\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\n--- Page 158 ---\n130 CHAPTER 6 Unit tests\nvar expectedException = \"Member already exists.\";\nvar exceptionInMutation;\ntry {\nUserManagement.addMember(userManagementStateBefore, jessie);\n} catch (e) {\nexceptionInMutation = e;\n}\n_.isEqual(exceptionInMutation, expectedException);\nTheo Now, I think I’m ready to move forward and write unit tests for Library.add-\nMember and System.addMember.\nJoe I agree with you. Please start with Library.addMember.\nTheo Library.addMember is quite similar to UserManagement.addMember. So I\nguess I’ll write similar test cases.\nJoe In fact, that won’t be required. As I told you when we wrote unit tests for a\nquery, when you write a unit test for a function, you can assume that the func-\ntions down the tree work as expected.\nTheo Right. So I’ll just write the test case for existing members.\nJoe Go for it!\nTheo starts with a copy-and-paste of the code from the UserManagement.addMember test\ncase with the existing members in listing 6.23. After a few modifications, the unit test for\nLibrary.addMember is ready.\nListing6.25 Unit test for Library.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 159 ---\n6.4 Unit tests for mutations 131\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar result = Library.addMember(libraryStateBefore, jessie);\n_.isEqual(result, expectedLibraryStateAfter);\nJoe Beautiful! Now, we’re ready for the last piece. Write a unit test for System\n.addMember. Before you start, could you please describe the input and the out-\nput of System.addMember?\nTheo takes another look at the code for System.addMember and hesitates; he’s a bit con-\nfused. The function doesn’t seem to return anything!\nListing6.26 The code of System.addMember\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nTheo The input of System.addMember is a system state instance and a member. But,\nI’m not sure what the output of System.addMember is.\nJoe In fact, System.addMember doesn’t have any output. It belongs to this stateful\npart of our code that doesn’t deal with data manipulation. Although DOP\nallows us to reduce the size of the stateful part of our code, it still exists. Here is\nhow I visualize it.\nJoe calls the waiter to see if he can get more napkins. With that problem resolved, he draws\nthe diagram in figure 6.7.\nSystemData Member\nMutation Change system state\nFigure 6.7 System.addMember\ndoesn’t return data—it changes the\nNothing system state!\n--- Page 160 ---\n132 CHAPTER 6 Unit tests\nTheo Then how do we validate that the code works as expected?\nJoe We’ll retrieve the system state after the code is executed and compare it to the\nexpected value of the state.\nTheo OK. I’ll try to write the unit test.\nJoe Writing unit tests for stateful code is more complicated than for data manipula-\ntion code. It requires the calm of the office.\nTheo Then let’s go back to the office. Waiter! Check, please.\nTheo picks up the tab, and he and Joe take the cable car back to Albatross. When they’re\nback at the office, Theo starts coding the unit test for Library.addMember.\nTheo Can we use _.isEqual with system state?\nJoe Definitely. The system state is a map like any other map.\nTIP The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state using\n_.isEqual\nTheo copies and pastes the code for Library.addMember (listing 6.21), which initializes\nthe data for the test. Then, he passes a SystemState object that is initialized with\nlibraryStateBefore to System.addMember. Finally, to complete the test, he compares\nthe system state after the mutation is executed with the expected value of the state.\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nwindow.SystemState = SystemState;\nListing6.27 Unit test for System.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 161 ---\n6.4 Unit tests for mutations 133\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\nCreates an empty\n}\nSystemState object\n}\n(see chapter 4)\n}\n};\nInitializes the system\nstate with the library\ndata before the\nvar systemState = new SystemState();\nmutation\nsystemState.commit(null, libraryStateBefore);\nSystem.addMember(systemState, jessie);\nExecutes the\nmutation on the\n_.isEqual(systemState.get(),\nSystemState object\nexpectedLibraryStateAfter);\nValidates the state after the\nmutation is executed\nJoe Wow, I’m impressed; you did it! Congratulations!\nTheo Thank you. I’m so glad that in DOP most of our code deals with data manipu-\nlation. It’s definitely more pleasant to write unit tests for stateless code that\nonly deals with data manipulation.\nJoe Now that you know the basics of DOP, would you like to refactor the code of\nyour Klafim prototype according to DOP principles?\nTheo Definitely. Nancy told me yesterday that Klafim is getting nice market traction.\nI’m supposed to have a meeting with her in a week or so about the next steps.\nHopefully, she’ll be willing to work with Albatross for the long term.\nJoe Exciting! Do you know what might influence Nancy’s decision?\nTheo Our cost estimate, certainly, but I know she’s in touch with other software com-\npanies. If we come up with a competitive proposal, I think we’ll get the deal.\nJoe I’m quite sure that after refactoring to DOP, features will take much less time\nto implement. That means you should be able to quote Nancy a lower total cost\nthan the competition, right?\nTheo I’ll keep my fingers crossed!\n--- Page 162 ---\n134 CHAPTER 6 Unit tests\nMoving forward\nThe meeting with Nancy went well. Albatross got the deal, Monica (Theo’s boss) is\npleased, and it’s going to be a long-term project with a nice budget. They’ll need to hire a\nteam of developers in order to meet the tough deadlines. While driving back to the office,\nTheo gets a phone call from Joe.\nJoe How was your meeting with Nancy?\nTheo We got the deal!\nJoe Awesome! I told you that with DOP the cost estimation would be lower.\nTheo In fact, we are not going to use DOP for this project.\nJoe Why?\nTheo After refactoring the Library Management System prototype to DOP, I did a\ndeep analysis with my engineers. We came to the conclusion that DOP might\nbe a good fit for the prototype phase, but it won’t work well at scale.\nJoe Could you share the details of your analysis?\nTheo I can’t right now. I’m driving.\nJoe Could we meet in your office later today?\nTheo I’m quite busy with the new project and the tough deadlines.\nJoe Let’s meet at least in order to have a proper farewell.\nTheo OK. Let’s meet at 4 PM, then.\n NOTE The story continues in the opener of part 2.\nSummary\n Most of the code in a data-oriented system deals with data manipulation.\n It’s straightforward to write unit tests for code that deals with data manipulation.\n Test cases follow the same simple general pattern:\na Generate data input\nb Generate expected data output\nc Compare the output of the function with the expected data output\n In order to compare the output of a function with the expected data output, we\nneed to recursively compare the two pieces of data.\n The recursive comparison of two pieces of data is implemented via a generic\nfunction.\n When a function returns a JSON string, we parse the string back to data so that\nwe deal with data comparison instead of string comparison.\n A tree of function calls for a function f is a tree where the root is f, and the chil-\ndren of a node g in the tree are the functions called by g.\n The leaves of the tree are functions that are not part of the code base of the\napplication and are functions that don’t call any other functions.\n The tree of function calls visualization guides us regarding the quality and\nquantity of the test cases in a unit test.\n--- Page 163 ---\nSummary 135\n Functions that appear in a lower level in the tree of function calls tend to involve\nless complex data than functions that appear in a higher level in the tree.\n Functions that appear in a lower level in the tree of function calls usually need\nto be covered with more test cases than functions that appear in a higher level\nin the tree.\n Unit tests for mutations focus on the calculation phase of the mutation.\n The validity of the data depends on the context.\n The smaller the data, the easier it is to manipulate.\n We compare the output and the expected output of our functions with a generic\nfunction that recursively compares two pieces of data (e.g., _.isEqual).\n When we write a unit test for a function, we assume that the functions called by\nthis function are covered by the unit tests and work as expected. This signifi-\ncantly reduces the quantity of test cases in our unit tests.\n We avoid using string comparison in unit tests for functions that deal with data.\n Writing a unit test for the main function of a mutation requires more effort\nthan for a query.\n Remember to include negative test cases in your unit tests.\n The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state\nusing a generic function like _.isEqual.\n--- Page 164 ---\n\n--- Page 165 ---\nPart 2\nScalability\nT\nheo feels a bit uncomfortable about the meeting with Joe. He was so enthusias-\ntic about DOP, and he was very good at teaching it. Every meeting with him was an\nopportunity to learn new things. Theo feels lot of gratitude for the time Joe spent\nwith him. He doesn’t want to hurt him in any fashion. Surprisingly, Joe enters the\noffice with the same relaxed attitude as usual, and he is even smiling.\nJoe I’m really glad that you got the deal with Nancy.\nTheo Yeah. There’s lot of excitement about it here in the office, and a bit of\nstress too.\nJoe What kind of stress?\nTheo You know.... We need to hire a team of developers, and the deadlines\nare quite tight.\nJoe But you told me that you won’t use DOP. I assume that you gave regular\ndeadlines?\nTheo No, my boss Monica really wanted to close the deal. She feels that success\nwith this project is strategically important for Albatross, so it’s worthwhile\nto accept some risk by giving what she calls an “optimistic” time estima-\ntion. I told her that it was really an unrealistic time estimation, but Mon-\nica insists that if we make smart decisions and bring in more developers,\nwe can do it.\nJoe I see. Now I understand why you told me over the phone that you were\nvery busy. Anyway, would you please share the reasons that made you\nthink DOP wouldn’t be a good fit at scale?\n--- Page 166 ---\n138 PART 2 Scalability\nTheo First of all, let me tell you that I feel lot of gratitude for all the teaching you\nshared with me. Reimplementing the Klafim prototype with DOP was really\nfun and productive due to the flexibility this paradigm offers.\nJoe I’m happy that you found it valuable.\nTheo But, as I told you over the phone, now we’re scaling up into a long-term project\nwith several developers working on a large code base. We came to the conclu-\nsion that DOP will not be a good fit at scale.\nJoe Could you share the reasons behind your conclusion?\nTheo There are many of them. First of all, as DOP deals only with generic data struc-\ntures, it’s hard to know what kind of data we have in hand, while in OOP, we\nknow the type of every piece of data. For the prototype, it was kind of OK. But\nas the code base grows and more developers are involved in the project, it\nwould be too painful.\nJoe I hear you. What else, my friend?\nTheo Our system is going to run on a multi-threaded environment. I reviewed the\nconcurrency control strategy that you presented, and it’s not thread-safe.\nJoe I hear you. What else, my friend?\nTheo I have been doing a bit of research about implementing immutable data struc-\ntures with structural sharing. I discovered that when the size of the data\nstructures grows, there is a significant performance hit.\nJoe I hear you. What else?\nTheo As our system grows, we will use a database to store the application data and\nexternal services to enrich book information, and in what you have showed me\nso far, data lives in memory.\nJoe I hear you. What else, my friend?\nTheo Don’t you think I have shared enough reasons to abandon DOP?\nJoe I think that your concerns about DOP at scale totally make sense. However, it\ndoesn’t mean that you should abandon DOP.\nTheo What do you mean?\nJoe With the help of meditation, I learned not be attached to the objections that\nflow in my mind while I’m practicing. Sometimes all that is needed to quiet our\nminds is to keep breathing; sometimes, a deeper level of practice is needed.\nTheo I don’t see how breathing would convince me to give DOP a second chance.\nJoe Breathing might not be enough in this case, but a deeper knowledge of DOP\ncould be helpful. Until now, I have shared with you only the material that was\nneeded in order to refactor your prototype. In order to use DOP in a big proj-\nect, a few more lessons are necessary.\nTheo But I don’t have time for more lessons. I need to work.\nJoe Have you heard the story about the young woodcutter and the old man?\nTheo No.\nJoe It goes like this.\n--- Page 167 ---\nPART 2 Scalability 139\nThe young woodcutter and the old man\nA young woodcutter strained to saw down a tree. An old man who was watching near-\nby asked, “What are you doing?”\n“Are you blind?” the woodcutter replied. “I’m cutting down this tree.”\nThe old man replied, “You look exhausted! Take a break. Sharpen your saw.”\nThe young woodcutter explained to the old man that he had been sawing for hours\nand did not have time to take a break.\nThe old man pushed back, “If you sharpen the saw, you would cut down the tree much\nfaster.”\nThe woodcutter said, “I don’t have time to sharpen the saw. Don’t you see, I’m too\nbusy!”\nTheo takes a moment to meditate on the story. He wonders if he needs to take the time to\nsharpen his saw and commit to a deeper level of practice.\nTheo Do you really think that with DOP, it will take much less time to deliver the\nproject?\nJoe I know so!\nTheo But if we miss the deadline, I will probably get fired. I’m the one that needs to\ntake the risk, not you.\nJoe Let’s make a deal. If you miss the deadline and get fired, I will hire you at my\ncompany for double the salary you make at Albatross.\nTheo And what if we meet the deadline?\nJoe If you meet the deadline, you will probably get promoted. In that case, I will\nask you to buy a gift for my son Neriah and my daughter Aurelia.\nTheo Deal! When will I get my first lesson about going deeper into DOP?\nJoe Why not start right now?\nTheo Let me reschedule my meetings.\n--- Page 168 ---\n\n--- Page 169 ---\nBasic data validation\nA solemn gift\nThis chapter covers\n The importance of validating data at system\nboundaries\n Validating data using the JSON Schema language\n Integrating data validation into an existing code\nbase\n Getting detailed information about data validation\nfailures\nAt first glance, it may seem that embracing DOP means accessing data without validat-\ning it and engaging in wishful thinking, where data is always valid. In fact, data valida-\ntion is not only possible but recommended when we follow data-oriented principles.\nThis chapter illustrates how to validate data when data is represented with\ngeneric data structures. It focuses on data validation occurring at the boundaries of\nthe system, while in part 3, we will deal with validating data as it flows through the\nsystem. This chapter is a deep dive into the fourth principle of DOP.\nPRINCIPLE #4 Separate data schema from data representation.\n141\n--- Page 170 ---\n142 CHAPTER 7 Basic data validation\n7.1 Data validation in DOP\nTheo has rescheduled his meetings. With such an imposing deadline, he’s still not sure if\nhe’s made a big mistake giving DOP a second chance.\n NOTE The reason why Theo rescheduled his meetings is explained in the opener\nfor part 2. Take a moment to read the opener if you missed it.\nJoe What aspect of OOP do you think you will miss the most in your big project?\nTheo Data validation.\nJoe Can you elaborate a bit?\nTheo In OOP, I have this strong guarantee that when a class is instantiated, its mem-\nber fields have the proper names and proper types. But with DOP, it’s so easy\nto have small mistakes in field names and field types.\nJoe Well, I have good news for you! There is a way to validate data in DOP.\nTheo How does it work? I thought DOP and data validation were two contradictory\nconcepts!\nJoe Not at all. It’s true that DOP doesn’t force you to validate data, but it doesn’t\nprevent you from doing so. In DOP, the data schema is separate from the data\nrepresentation.\nTheo I don’t get how that would eliminate data consistency issues.\nJoe According to DOP, the most important data to validate is data that crosses the\nboundaries of the system.\nTheo Which boundaries are you referring to?\nJoe In the case of a web server, it would be the areas where the web server commu-\nnicates with its clients and with its data sources.\nTheo A diagram might help me see it better.\nJoe goes to the whiteboard and picks up the pen. He then draws a diagram like the one in\nfigure 7.1.\nClient (e.g., web browser)\nData\nWeb server\nData Data\nWeb service Database Figure 7.1 High-level architecture of\na modern web server\n--- Page 171 ---\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n--- Page 172 ---\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n--- Page 173 ---\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n--- Page 174 ---\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n--- Page 175 ---\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer",
        "sections_found": []
      },
      "accurate_page_range": "152-175"
    },
    {
      "text": "- Summary",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "6 Unit tests",
      "raw_line": "- Summary (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 54,
      "chapter_info": {
        "page": 152,
        "title": "Unit tests",
        "pattern_matched": "Chapter 6",
        "text_preview": "124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again "
      },
      "chapter_sections": {
        "start_page": 152,
        "end_page": 175,
        "content": "\n--- Page 152 ---\n124 CHAPTER 6 Unit tests\nBecause Theo and Joe have been discussing unit tests for quite some time, he asks Joe if he\nwould like another espresso. They call the waiter and order, then Theo looks again at the\ncode for Catalog.searchBooksByTitle.\nListing6.16 The code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nWriting the unit test for Catalog.searchBooksByTitle is a more pleasant experience for\nTheo than writing the unit test for Library.searchBooksByTitleJSON. He appreciates\nthis for two reasons:\n It’s not necessary to deserialize the output because the function returns data.\n It’s not necessary to wrap the catalog data in a library data map.\nListing6.17 Unit test for Catalog.searchBooksByTitle\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n--- Page 153 ---\n6.3 Unit tests for queries 125\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Watchmen\"), [bookInfo]);\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"Batman\"), []);\nJoe That’s a good start!\nTheo I thought I was done. What did I miss?\nJoe You forgot to test cases where the query string is all lowercase.\nTheo You’re right! Let me quickly add one more test case.\nIn less than a minute, Theo creates an additional test case and shows it to Joe. What a dis-\nappointment when Theo discovers that the test case with \"watchmen\" in lowercase fails!\nListing6.18 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe Don’t be too upset, my friend. After all, the purpose of unit tests is to find bugs\nin the code so that you can fix them. Can you fix the code of Catalog-\nData.searchBooksByTitle?\nTheo Sure. All I need to do is to lowercase both the query string and the book title\nbefore comparing them. I’d probably do something like this.\nListing6.19 Fixed code of Catalog.searchBooksByTitle\nCatalog.searchBooksByTitle = function(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar queryLowerCased = query.toLowerCase();\nConverts the query\nvar matchingBooks = _.filter(allBooks, function(book) {\nto lowercase\nreturn _.get(book, \"title\")\n.toLowerCase()\nConverts the book\n.includes(queryLowerCased);\ntitle to lowercase\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n};\nAfter fixing the code of Catalog.searchBooksByTitle, Theo runs all the test cases\nagain. This time, all of them pass—what a relief!\nListing6.20 Additional test case for Catalog.searchBooksByTitle\n_.isEqual(Catalog.searchBooksByTitle(catalogData, \"watchmen\"),\n[bookInfo]);\nJoe It’s such good feeling when all the test cases pass.\nTheo Sure is.\nJoe I think we’ve written unit tests for all the search query code, so now we’re ready\nto write unit tests for mutations. Thank goodness the waiter just brought our\ncoffee orders.\n--- Page 154 ---\n126 CHAPTER 6 Unit tests\n6.4 Unit tests for mutations\nJoe Before writing unit tests for the add member mutation, let’s draw the tree of\nfunction calls for System.addMember.\nTheo I can do that.\nTheo takes a look at the code for the functions involved in the add member mutation. He\nnotices the code is spread over three classes: System, Library, and UserManagement.\nListing6.21 The functions involved in the add member mutation\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement, member);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nthrow \"Member already exists.\";\n}\nvar nextUserManagement = _.set(userManagement,\ninfoPath,\nmember);\nreturn nextUserManagement;\n};\nTheo grabs another napkin. Drawing the tree of function calls for System.addMember is\nnow quite easy (see figure 6.5).\nSystem.addMember\nSystemState.get SystemState.commit Library.addMember\n_.get _.set UserManagement.addMember\n_.has _.set\nFigure 6.5 The tree of function calls for System.addMember\n--- Page 155 ---\n6.4 Unit tests for mutations 127\nJoe Excellent! So which functions of the tree should be unit tested for the add\nmember mutation?\nTheo I think the functions we need to test are System.addMember, SystemState\n.get, SystemState.commit, Library.addMember, and UserManagement\n.addMember. That right?\nJoe You’re totally right. Let’s defer writing unit tests for functions that belong to\nSystemState until later. Those are generic functions that should be tested\noutside the context of a specific mutation. Let’s assume for now that we’ve\nalready written unit tests for the SystemState class. We’re left with three func-\ntions: System.addMember, Library.addMember, and UserManagement.add-\nMember.\nTheo In what order should we write the unit tests, bottom up or top down?\nJoe Let’s start where the real meat is—in UserManagement.addMember. The two\nother functions are just wrappers.\nTheo OK.\nJoe Writing a unit test for the main function of a mutation requires more effort\nthan writing the test for a query. The reason is that a query returns a response\nbased on the system data, whereas a mutation computes a new state of the system\nbased on the current state of the system and some arguments (see figure 6.6).\nSystemData Argument Argument SystemData\nMutation Query\nNextSystemData ResponseData\nFigure 6.6 The output of a mutation is more complex than\nthe output of a query.\nTIP Writing a unit test for the main function of a mutation requires more effort than\nfor a query.\nTheo It means that in the test cases of UserManagement.addMember, both the input\nand the expected output are maps that describe the state of the system.\nJoe Exactly. Let’s start with the simplest case, where the initial state of the system\nis empty.\nTheo You mean that userManagementData passed to UserManagement.addMember\nis an empty map?\nJoe Yes.\nOnce again, Theo places his hands over his laptop keyboard, thinks for a moment, and\nbegins typing. He reminds himself that the code needs to add a member to an empty user\n--- Page 156 ---\n128 CHAPTER 6 Unit tests\nmanagement map and to check that the resulting map is as expected. When he’s finished,\nhe shows his code to Joe.\nListing6.22 Test case for Catalog.addMember without members\nvar member = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, member);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Very nice! Keep going and write a test case when the initial state is not empty.\nTheo knows this requires a few more lines of code but nothing complicated. When he fin-\nishes, he once again shows the code to Joe.\nListing6.23 Test case for Catalog.addMember with existing members\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar expectedUserManagementStateAfter = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n--- Page 157 ---\n6.4 Unit tests for mutations 129\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n};\nvar result = UserManagement.addMember(userManagementStateBefore, jessie);\n_.isEqual(result, expectedUserManagementStateAfter);\nJoe Awesome! Can you think of other test cases for UserManagement.addMember?\nTheo No.\nJoe What about cases where the mutation fails?\nTheo Right! I always forget to think about negative test cases. I assume that relates to\nthe fact that I’m an optimistic person.\nTIP Don’t forget to include negative test cases in your unit tests.\nJoe Me too. The more I meditate, the more I’m able to focus on the positive side of\nlife. Anyway, how would you write a test case where the mutation fails?\nTheo I would pass to UserManagement.addMember a member that already exists in\nuserManagementStateBefore.\nJoe And how would you check that the code behaves as expected in case of a failure?\nTheo Let me see. When a member already exists, UserManagement.addMember\nthrows an exception. Therefore, what I need to do in my test case is to wrap the\ncode in a try/catch block.\nJoe Sounds good to me.\nOnce again, it doesn’t require too much of an effort for Theo to create a new test case.\nWhen he’s finished, he eagerly turns his laptop to Joe.\nListing6.24 Test case for UserManagement.addMember if it’s expected to fail\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar userManagementStateBefore = {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n}\n}\n};\n--- Page 158 ---\n130 CHAPTER 6 Unit tests\nvar expectedException = \"Member already exists.\";\nvar exceptionInMutation;\ntry {\nUserManagement.addMember(userManagementStateBefore, jessie);\n} catch (e) {\nexceptionInMutation = e;\n}\n_.isEqual(exceptionInMutation, expectedException);\nTheo Now, I think I’m ready to move forward and write unit tests for Library.add-\nMember and System.addMember.\nJoe I agree with you. Please start with Library.addMember.\nTheo Library.addMember is quite similar to UserManagement.addMember. So I\nguess I’ll write similar test cases.\nJoe In fact, that won’t be required. As I told you when we wrote unit tests for a\nquery, when you write a unit test for a function, you can assume that the func-\ntions down the tree work as expected.\nTheo Right. So I’ll just write the test case for existing members.\nJoe Go for it!\nTheo starts with a copy-and-paste of the code from the UserManagement.addMember test\ncase with the existing members in listing 6.23. After a few modifications, the unit test for\nLibrary.addMember is ready.\nListing6.25 Unit test for Library.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 159 ---\n6.4 Unit tests for mutations 131\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar result = Library.addMember(libraryStateBefore, jessie);\n_.isEqual(result, expectedLibraryStateAfter);\nJoe Beautiful! Now, we’re ready for the last piece. Write a unit test for System\n.addMember. Before you start, could you please describe the input and the out-\nput of System.addMember?\nTheo takes another look at the code for System.addMember and hesitates; he’s a bit con-\nfused. The function doesn’t seem to return anything!\nListing6.26 The code of System.addMember\nSystem.addMember = function(systemState, member) {\nvar previous = systemState.get();\nvar next = Library.addMember(previous, member);\nsystemState.commit(previous, next);\n};\nTheo The input of System.addMember is a system state instance and a member. But,\nI’m not sure what the output of System.addMember is.\nJoe In fact, System.addMember doesn’t have any output. It belongs to this stateful\npart of our code that doesn’t deal with data manipulation. Although DOP\nallows us to reduce the size of the stateful part of our code, it still exists. Here is\nhow I visualize it.\nJoe calls the waiter to see if he can get more napkins. With that problem resolved, he draws\nthe diagram in figure 6.7.\nSystemData Member\nMutation Change system state\nFigure 6.7 System.addMember\ndoesn’t return data—it changes the\nNothing system state!\n--- Page 160 ---\n132 CHAPTER 6 Unit tests\nTheo Then how do we validate that the code works as expected?\nJoe We’ll retrieve the system state after the code is executed and compare it to the\nexpected value of the state.\nTheo OK. I’ll try to write the unit test.\nJoe Writing unit tests for stateful code is more complicated than for data manipula-\ntion code. It requires the calm of the office.\nTheo Then let’s go back to the office. Waiter! Check, please.\nTheo picks up the tab, and he and Joe take the cable car back to Albatross. When they’re\nback at the office, Theo starts coding the unit test for Library.addMember.\nTheo Can we use _.isEqual with system state?\nJoe Definitely. The system state is a map like any other map.\nTIP The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state using\n_.isEqual\nTheo copies and pastes the code for Library.addMember (listing 6.21), which initializes\nthe data for the test. Then, he passes a SystemState object that is initialized with\nlibraryStateBefore to System.addMember. Finally, to complete the test, he compares\nthe system state after the mutation is executed with the expected value of the state.\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nwindow.SystemState = SystemState;\nListing6.27 Unit test for System.addMember\nvar jessie = {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n};\nvar franck = {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n};\nvar libraryStateBefore = {\n\"userManagement\": {\n\"membersByEmail\": {\n--- Page 161 ---\n6.4 Unit tests for mutations 133\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\n}\n}\n}\n};\nvar expectedLibraryStateAfter = {\n\"userManagement\": {\n\"membersByEmail\": {\n\"jessie@gmail.com\": {\n\"email\": \"jessie@gmail.com\",\n\"password\": \"my-secret\"\n},\n\"franck@gmail.com\": {\n\"email\": \"franck@gmail.com\",\n\"password\": \"my-top-secret\"\nCreates an empty\n}\nSystemState object\n}\n(see chapter 4)\n}\n};\nInitializes the system\nstate with the library\ndata before the\nvar systemState = new SystemState();\nmutation\nsystemState.commit(null, libraryStateBefore);\nSystem.addMember(systemState, jessie);\nExecutes the\nmutation on the\n_.isEqual(systemState.get(),\nSystemState object\nexpectedLibraryStateAfter);\nValidates the state after the\nmutation is executed\nJoe Wow, I’m impressed; you did it! Congratulations!\nTheo Thank you. I’m so glad that in DOP most of our code deals with data manipu-\nlation. It’s definitely more pleasant to write unit tests for stateless code that\nonly deals with data manipulation.\nJoe Now that you know the basics of DOP, would you like to refactor the code of\nyour Klafim prototype according to DOP principles?\nTheo Definitely. Nancy told me yesterday that Klafim is getting nice market traction.\nI’m supposed to have a meeting with her in a week or so about the next steps.\nHopefully, she’ll be willing to work with Albatross for the long term.\nJoe Exciting! Do you know what might influence Nancy’s decision?\nTheo Our cost estimate, certainly, but I know she’s in touch with other software com-\npanies. If we come up with a competitive proposal, I think we’ll get the deal.\nJoe I’m quite sure that after refactoring to DOP, features will take much less time\nto implement. That means you should be able to quote Nancy a lower total cost\nthan the competition, right?\nTheo I’ll keep my fingers crossed!\n--- Page 162 ---\n134 CHAPTER 6 Unit tests\nMoving forward\nThe meeting with Nancy went well. Albatross got the deal, Monica (Theo’s boss) is\npleased, and it’s going to be a long-term project with a nice budget. They’ll need to hire a\nteam of developers in order to meet the tough deadlines. While driving back to the office,\nTheo gets a phone call from Joe.\nJoe How was your meeting with Nancy?\nTheo We got the deal!\nJoe Awesome! I told you that with DOP the cost estimation would be lower.\nTheo In fact, we are not going to use DOP for this project.\nJoe Why?\nTheo After refactoring the Library Management System prototype to DOP, I did a\ndeep analysis with my engineers. We came to the conclusion that DOP might\nbe a good fit for the prototype phase, but it won’t work well at scale.\nJoe Could you share the details of your analysis?\nTheo I can’t right now. I’m driving.\nJoe Could we meet in your office later today?\nTheo I’m quite busy with the new project and the tough deadlines.\nJoe Let’s meet at least in order to have a proper farewell.\nTheo OK. Let’s meet at 4 PM, then.\n NOTE The story continues in the opener of part 2.\nSummary\n Most of the code in a data-oriented system deals with data manipulation.\n It’s straightforward to write unit tests for code that deals with data manipulation.\n Test cases follow the same simple general pattern:\na Generate data input\nb Generate expected data output\nc Compare the output of the function with the expected data output\n In order to compare the output of a function with the expected data output, we\nneed to recursively compare the two pieces of data.\n The recursive comparison of two pieces of data is implemented via a generic\nfunction.\n When a function returns a JSON string, we parse the string back to data so that\nwe deal with data comparison instead of string comparison.\n A tree of function calls for a function f is a tree where the root is f, and the chil-\ndren of a node g in the tree are the functions called by g.\n The leaves of the tree are functions that are not part of the code base of the\napplication and are functions that don’t call any other functions.\n The tree of function calls visualization guides us regarding the quality and\nquantity of the test cases in a unit test.\n--- Page 163 ---\nSummary 135\n Functions that appear in a lower level in the tree of function calls tend to involve\nless complex data than functions that appear in a higher level in the tree.\n Functions that appear in a lower level in the tree of function calls usually need\nto be covered with more test cases than functions that appear in a higher level\nin the tree.\n Unit tests for mutations focus on the calculation phase of the mutation.\n The validity of the data depends on the context.\n The smaller the data, the easier it is to manipulate.\n We compare the output and the expected output of our functions with a generic\nfunction that recursively compares two pieces of data (e.g., _.isEqual).\n When we write a unit test for a function, we assume that the functions called by\nthis function are covered by the unit tests and work as expected. This signifi-\ncantly reduces the quantity of test cases in our unit tests.\n We avoid using string comparison in unit tests for functions that deal with data.\n Writing a unit test for the main function of a mutation requires more effort\nthan for a query.\n Remember to include negative test cases in your unit tests.\n The system state is a map. Therefore, in the context of a test case, we can com-\npare the system state after a mutation is executed to the expected system state\nusing a generic function like _.isEqual.\n--- Page 164 ---\n\n--- Page 165 ---\nPart 2\nScalability\nT\nheo feels a bit uncomfortable about the meeting with Joe. He was so enthusias-\ntic about DOP, and he was very good at teaching it. Every meeting with him was an\nopportunity to learn new things. Theo feels lot of gratitude for the time Joe spent\nwith him. He doesn’t want to hurt him in any fashion. Surprisingly, Joe enters the\noffice with the same relaxed attitude as usual, and he is even smiling.\nJoe I’m really glad that you got the deal with Nancy.\nTheo Yeah. There’s lot of excitement about it here in the office, and a bit of\nstress too.\nJoe What kind of stress?\nTheo You know.... We need to hire a team of developers, and the deadlines\nare quite tight.\nJoe But you told me that you won’t use DOP. I assume that you gave regular\ndeadlines?\nTheo No, my boss Monica really wanted to close the deal. She feels that success\nwith this project is strategically important for Albatross, so it’s worthwhile\nto accept some risk by giving what she calls an “optimistic” time estima-\ntion. I told her that it was really an unrealistic time estimation, but Mon-\nica insists that if we make smart decisions and bring in more developers,\nwe can do it.\nJoe I see. Now I understand why you told me over the phone that you were\nvery busy. Anyway, would you please share the reasons that made you\nthink DOP wouldn’t be a good fit at scale?\n--- Page 166 ---\n138 PART 2 Scalability\nTheo First of all, let me tell you that I feel lot of gratitude for all the teaching you\nshared with me. Reimplementing the Klafim prototype with DOP was really\nfun and productive due to the flexibility this paradigm offers.\nJoe I’m happy that you found it valuable.\nTheo But, as I told you over the phone, now we’re scaling up into a long-term project\nwith several developers working on a large code base. We came to the conclu-\nsion that DOP will not be a good fit at scale.\nJoe Could you share the reasons behind your conclusion?\nTheo There are many of them. First of all, as DOP deals only with generic data struc-\ntures, it’s hard to know what kind of data we have in hand, while in OOP, we\nknow the type of every piece of data. For the prototype, it was kind of OK. But\nas the code base grows and more developers are involved in the project, it\nwould be too painful.\nJoe I hear you. What else, my friend?\nTheo Our system is going to run on a multi-threaded environment. I reviewed the\nconcurrency control strategy that you presented, and it’s not thread-safe.\nJoe I hear you. What else, my friend?\nTheo I have been doing a bit of research about implementing immutable data struc-\ntures with structural sharing. I discovered that when the size of the data\nstructures grows, there is a significant performance hit.\nJoe I hear you. What else?\nTheo As our system grows, we will use a database to store the application data and\nexternal services to enrich book information, and in what you have showed me\nso far, data lives in memory.\nJoe I hear you. What else, my friend?\nTheo Don’t you think I have shared enough reasons to abandon DOP?\nJoe I think that your concerns about DOP at scale totally make sense. However, it\ndoesn’t mean that you should abandon DOP.\nTheo What do you mean?\nJoe With the help of meditation, I learned not be attached to the objections that\nflow in my mind while I’m practicing. Sometimes all that is needed to quiet our\nminds is to keep breathing; sometimes, a deeper level of practice is needed.\nTheo I don’t see how breathing would convince me to give DOP a second chance.\nJoe Breathing might not be enough in this case, but a deeper knowledge of DOP\ncould be helpful. Until now, I have shared with you only the material that was\nneeded in order to refactor your prototype. In order to use DOP in a big proj-\nect, a few more lessons are necessary.\nTheo But I don’t have time for more lessons. I need to work.\nJoe Have you heard the story about the young woodcutter and the old man?\nTheo No.\nJoe It goes like this.\n--- Page 167 ---\nPART 2 Scalability 139\nThe young woodcutter and the old man\nA young woodcutter strained to saw down a tree. An old man who was watching near-\nby asked, “What are you doing?”\n“Are you blind?” the woodcutter replied. “I’m cutting down this tree.”\nThe old man replied, “You look exhausted! Take a break. Sharpen your saw.”\nThe young woodcutter explained to the old man that he had been sawing for hours\nand did not have time to take a break.\nThe old man pushed back, “If you sharpen the saw, you would cut down the tree much\nfaster.”\nThe woodcutter said, “I don’t have time to sharpen the saw. Don’t you see, I’m too\nbusy!”\nTheo takes a moment to meditate on the story. He wonders if he needs to take the time to\nsharpen his saw and commit to a deeper level of practice.\nTheo Do you really think that with DOP, it will take much less time to deliver the\nproject?\nJoe I know so!\nTheo But if we miss the deadline, I will probably get fired. I’m the one that needs to\ntake the risk, not you.\nJoe Let’s make a deal. If you miss the deadline and get fired, I will hire you at my\ncompany for double the salary you make at Albatross.\nTheo And what if we meet the deadline?\nJoe If you meet the deadline, you will probably get promoted. In that case, I will\nask you to buy a gift for my son Neriah and my daughter Aurelia.\nTheo Deal! When will I get my first lesson about going deeper into DOP?\nJoe Why not start right now?\nTheo Let me reschedule my meetings.\n--- Page 168 ---\n\n--- Page 169 ---\nBasic data validation\nA solemn gift\nThis chapter covers\n The importance of validating data at system\nboundaries\n Validating data using the JSON Schema language\n Integrating data validation into an existing code\nbase\n Getting detailed information about data validation\nfailures\nAt first glance, it may seem that embracing DOP means accessing data without validat-\ning it and engaging in wishful thinking, where data is always valid. In fact, data valida-\ntion is not only possible but recommended when we follow data-oriented principles.\nThis chapter illustrates how to validate data when data is represented with\ngeneric data structures. It focuses on data validation occurring at the boundaries of\nthe system, while in part 3, we will deal with validating data as it flows through the\nsystem. This chapter is a deep dive into the fourth principle of DOP.\nPRINCIPLE #4 Separate data schema from data representation.\n141\n--- Page 170 ---\n142 CHAPTER 7 Basic data validation\n7.1 Data validation in DOP\nTheo has rescheduled his meetings. With such an imposing deadline, he’s still not sure if\nhe’s made a big mistake giving DOP a second chance.\n NOTE The reason why Theo rescheduled his meetings is explained in the opener\nfor part 2. Take a moment to read the opener if you missed it.\nJoe What aspect of OOP do you think you will miss the most in your big project?\nTheo Data validation.\nJoe Can you elaborate a bit?\nTheo In OOP, I have this strong guarantee that when a class is instantiated, its mem-\nber fields have the proper names and proper types. But with DOP, it’s so easy\nto have small mistakes in field names and field types.\nJoe Well, I have good news for you! There is a way to validate data in DOP.\nTheo How does it work? I thought DOP and data validation were two contradictory\nconcepts!\nJoe Not at all. It’s true that DOP doesn’t force you to validate data, but it doesn’t\nprevent you from doing so. In DOP, the data schema is separate from the data\nrepresentation.\nTheo I don’t get how that would eliminate data consistency issues.\nJoe According to DOP, the most important data to validate is data that crosses the\nboundaries of the system.\nTheo Which boundaries are you referring to?\nJoe In the case of a web server, it would be the areas where the web server commu-\nnicates with its clients and with its data sources.\nTheo A diagram might help me see it better.\nJoe goes to the whiteboard and picks up the pen. He then draws a diagram like the one in\nfigure 7.1.\nClient (e.g., web browser)\nData\nWeb server\nData Data\nWeb service Database Figure 7.1 High-level architecture of\na modern web server\n--- Page 171 ---\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n--- Page 172 ---\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n--- Page 173 ---\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n--- Page 174 ---\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n--- Page 175 ---\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer",
        "sections_found": []
      },
      "accurate_page_range": "152-175"
    },
    {
      "text": "- Part2 Introduction content",
      "node_level": 3,
      "part": "Part2—Scalability",
      "chapter": "6 Unit tests",
      "raw_line": "- Part2 Introduction content (node3) **[LEAF]**",
      "is_part_intro": true,
      "id": 55,
      "accurate_page_range": "171-175",
      "extracted_content": "\n=== Page 171 ===\n7.2 JSON Schema in a nutshell 143\nJoe This architectural diagram defines what we call the boundaries of the system in\nterms of data exchange. Can you tell me what the three boundaries of the sys-\ntem are?\n NOTE The boundaries of a system are defined as the areas where the system exchanges\ndata.\nTheo Let me see. The first one is the client boundary, then we have the database\nboundary, and finally, the web service boundary.\nJoe Exactly! It’s important to identify the boundaries of a system because, in\nDOP, we differentiate between two kinds of data validation: validation that\noccurs at the boundaries of the system and validation that occurs inside the\nsystem. Today, we’re going to focus on validation that occurs at the boundar-\nies of the system.\nTheo Does that mean data validation at the boundaries of the system is more\nimportant?\nJoe Absolutely! Once you’ve ensured that data going into and out of the system is\nvalid, the odds for an unexpected piece of data inside the system are pretty low.\nTIP When data at system boundaries is validated, it’s not critical to validate data\nagain inside the system.\nTheo Why do we need data validation inside the system then?\nJoe It has to do with making it easier to code your system as your code base grows.\nTheo And, what’s the main purpose of data validation at the boundaries?\nJoe To prevent invalid data from going in and out of the system, and to display\ninformative errors when we encounter invalid data. Let me draw a table on the\nwhiteboard so you can see the distinction (table 7.1).\nTable 7.1 Two kinds of data validation\nKind of data validation Purpose Environment\nBoundaries Guardian Production\nInside Ease of development Dev\nTheo When will you teach me about data validation inside the system?\nJoe Later, when the code base is bigger.\n7.2 JSON Schema in a nutshell\nTheo For now, the Library Management System is an application that runs in mem-\nory, with no database and no HTTP clients connected to it. But Nancy will\nprobably want me to make the system into a real web server with clients, data-\nbase, and external services.\nJoe OK. Let’s imagine how a client request for searching books would look.\n\n=== Page 172 ===\n144 CHAPTER 7 Basic data validation\nTheo Basically, a search request is made of a string and the fields you’d like to\nretrieve for the books whose title contains the string. So the request has two\nfields: title, which is a string, and fields, which is an array of strings.\nTheo quickly writes on the whiteboard. When he finishes, he steps aside to let Joe view his\ncode for a search request.\nListing7.1 An example of a search request\n{\n\"title\": \"habit\",\n\"fields\": [\"title\", \"weight\", \"number_of_pages\"]\n}\nJoe I see. Let me show you how to express the schema of a search request sepa-\nrately from the representation of the search request data.\nTheo What do you mean exactly by “separately?”\nJoe Data representation stands on its own, and the data schema stands on its own.\nYou are free to validate that a piece of data conforms with a data schema as you\nwill and when you will.\nTIP In DOP, the data schema is separate from the data representation.\nTheo It’s a bit abstract for me.\nJoe I know. It will become much clearer in a moment. For now, I am going to show\nyou how to build the data schema for the search request in a schema language\ncalled JSON Schema.\nTheo I love JSON!\n NOTE Information on the JSON Schema language can be found at https://json\n-schema.org. The schemas in this book use JSON Schema version 2020-12.\nJoe First, we have to express the data type of the request. What’s the data type in\nthe case of a book search request?\nTheo It’s a map.\nJoe In JSON Schema, the data type for maps is called object. Look at this basic\nskeleton of a map. It’s a map with two fields: type and properties.\nJoe goes to the whiteboard. He quickly writes the code for the map with its two fields.\nListing7.2 Basic schema skeleton of a map\n{\n\"type\": \"object\",\n\"properties\": {...}\n}\n\n=== Page 173 ===\n7.2 JSON Schema in a nutshell 145\nJoe The value of type is \"object\", and the value of properties is a map with the\nschema for the map fields.\nTheo I assume that, inside properties, we are going to express the schema of the map\nfields as JSON Schema.\nJoe Correct.\nTheo I am starting to feel the dizziness of recursion.\nJoe In JSON Schema, a schema is usually a JSON object with a field called type,\nwhich specifies the data type. For example, the type for the title field is\nstring and...\nTheo ...the type for the fields field is array.\nJoe Yes!\nNow it’s Theo’s turn to go to the whiteboard. He fills the holes in the search request\nschema with the information about the fields.\nListing7.3 Schema skeleton for search request\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\"type\": \"array\"}\n}\n}\nOn Theo’s way back from the whiteboard to his desk, Joe makes a sign with his right hand\nthat says, “Stay near the whiteboard, please.” Theo turns and goes back to the whiteboard.\nJoe We can be a little more precise about the fields property by providing infor-\nmation about the type of the elements in the array. In JSON Schema, an array\nschema has a property called items, whose value is the schema for the array\nelements.\nWithout any hesitation, Theo adds this information on the whiteboard. Stepping aside, he\nshows Joe the result.\nListing7.4 Schema for search request with information about array elements\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\"type\": \"string\"}\n}\n}\n}\n\n=== Page 174 ===\n146 CHAPTER 7 Basic data validation\nBefore going back to his desk, Theo asks Joe:\nTheo Are we done now?\nJoe Not yet. We can be more precise about the fields field in the search request.\nI assume that the fields in the request should be part of a closed list of fields.\nTherefore, instead of allowing any string, we could have a list of allowed values.\nTheo Like an enumeration value?\nJoe Exactly! In fact, JSON Schema supports enumeration values with the enum key-\nword. Instead of {\"type\": \"string\"}, you need to have {\"enum\": […]} and\nreplace the dots with the supported fields.\nOnce again, Theo turns to the whiteboard. He replaces the dots with the information Joe\nrequests.\nListing7.5 Schema for the search request with enumeration values\n{\n\"type\": \"object\",\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n}\n}\nTheo Are we done, now?\nJoe Almost. We need to decide whether the fields of our search request are optional\nor required. In our case, both title and fields are required.\nTheo How do we express this information in JSON Schema?\nJoe There is a field called required whose value is an array made of the names of\nthe required fields in the map.\nAfter adding the required field, Theo looks at Joe. This time he makes a move with his\nright hand that says, “Now you can go back to your desk.”\nListing7.6 Schema of a search request\nvar searchBooksRequestSchema = {\n\"type\": \"object\",\n\n=== Page 175 ===\n7.2 JSON Schema in a nutshell 147\n\"properties\": {\n\"title\": {\"type\": \"string\"},\n\"fields\": {\n\"type\": \"array\",\n\"items\": {\n\"enum\": [\n\"publishers\",\n\"number_of_pages\",\n\"weight\",\n\"physical_format\",\n\"subjects\",\n\"publish_date\",\n\"physical_dimensions\"\n]\n}\n}\n},\n\"required\": [\"title\", \"fields\"]\n};\nJoe Now I’ll show you how to validate a piece of data according to a schema.\nTheo What do you mean, validate?\nJoe Validating data according to a schema means checking whether data conforms\nto the schema. In our case, it means checking whether a piece of data is a valid\nsearch books request.\nTIP Data validation in DOP means checking whether a piece of data conforms to a\nschema.\nTheo I see.\nJoe There are a couple of libraries that provide JSON Schema validation. They\nhave a validate function that receives a schema and a piece of data and\nreturns true when the data is valid and false when the data is not valid. I just\nhappen to have a file in my laptop that provides a table with a list of schema\nvalidation libraries (table 7.2). We can print it out if you like.\nTheo turns on the printer as Joe scans through his laptop for the table. When he has it up,\nhe checks with Theo and presses Print.\nTable 7.2 Libraries for JSON Schema validation\nLanguage Library URL\nJavaScript Ajv https://github.com/ajv-validator/ajv\nJava Snow https://github.com/ssilverman/snowy-json\nC# JSON.net Schema https://www.newtonsoft.com/jsonschema\nPython jschon https://github.com/marksparkza/jschon\nRuby JSONSchemer https://github.com/davishmcclurg/json_schemer"
    }
  ]
}