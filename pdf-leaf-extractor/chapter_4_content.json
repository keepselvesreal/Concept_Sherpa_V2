{
  "chapter": "4",
  "title": "State management",
  "page_info": {
    "page": 102,
    "title": "State management",
    "pattern_matched": "Chapter 4",
    "text_preview": "74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead"
  },
  "leaf_nodes": [
    {
      "text": "- 4.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "raw_line": "- 4.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 29,
      "chapter_info": {
        "page": 102,
        "title": "State management",
        "pattern_matched": "Chapter 4",
        "text_preview": "74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead"
      },
      "chapter_sections": {
        "start_page": 102,
        "end_page": 125,
        "content": "\n--- Page 102 ---\n74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead of being copied.\nThis technique efficiently creates new versions of the system data, both in\nterms of memory and computation.\nTheo I’m intrigued.\nTIP With structural sharing, it’s efficient (in terms of memory and computation) to\ncreate new versions of data.\nJoe I’ll explain in detail how structural sharing works in a moment.\nTheo takes another look at the diagram in figure 4.1, which illustrates how the system state\nrefers to a version of the system data. Suddenly, a question emerges.\nTheo Are the previous versions of the system data kept?\nJoe In a simple application, previous versions are automatically removed by the\ngarbage collector. But, in some cases, we maintain historical references to pre-\nvious versions of the data.\nTheo What kind of cases?\nJoe For example, if we want to support time travel in our system, as in Git, we can\nmove the system back to a previous version of the state easily.\nTheo Now I understand what you mean by data is immutable, but the state reference\nis mutable!\n4.2 Structural sharing\nAs mentioned in the previous section, structural sharing enables the efficient cre-\nation of new versions of immutable data. In DOP, we use structural sharing in the\ncalculation phase of a mutation to compute the next state of the system based on\nthe current state of the system. Inside the calculation phase, we don’t have to deal\nwith state management; that is delayed to the commit phase. As a consequence, the\ncode involved in the calculation phase of a mutation is stateless and is as simple as\nthe code of a query.\nTheo I’m really intrigued by this more efficient way to create new versions of data.\nHow does it work?\nJoe Let’s take a simple example from our library system. Imagine that you want to\nmodify the value of a field in a book in the catalog; for instance, the publica-\ntion year of Watchmen. Can you tell me the information path for Watchmen’s\npublication year?\nTheo takes a quick look at the catalog data in figure 4.2. Then he answers Joe’s question.\n--- Page 103 ---\n4.2 Structural sharing 75\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 4.2 Visualization of the catalog data. The nodes in the information path to Watchmen’s publication\nyear are marked with a dotted border.\nTheo The information path for Watchmen’s publication year is [\"catalog\", \"books-\nByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Now, let me show how you to use the immutable function _.set that Lodash\nalso provides.\nTheo Wait! What do you mean by an immutable function? When I looked at the\nLodash documentation for _.set on their website, it said that it mutates the\nobject.\nJoe You’re right, but the default Lodash functions are not immutable. In order to\nuse an immutable version of the functions, we need to use the Lodash FP mod-\nule as explained in the Lodash FP guide.\n NOTE See https://lodash.com/docs/4.17.15#set to view Lodash’s documentation\nfor _.set, and see https://github.com/lodash/lodash/wiki/FP-Guide to view the\nLodash FP guide.\nTheo Do the immutable functions have the same signature as the mutable functions?\nJoe By default, the order of the arguments in immutable functions is shuffled.\nThe Lodash FP guide explains how to resolve this. With this piece of code,\n--- Page 104 ---\n76 CHAPTER 4 State management\nthe signature of the immutable functions is exactly the same as the mutable\nfunctions.\nListing4.1 Configuring Lodash so immutable and mutable functions have same signature\n_ = fp.convert({\n\"cap\": false,\n\"curry\": false,\n\"fixed\": false,\n\"immutable\": true,\n\"rearg\": false\n});\nTIP In order to use Lodash immutable functions, we use Lodash’s FP module, and\nwe configure it so that the signature of the immutable functions is the same as in the\nLodash documentation web site.\nTheo So basically, I can still rely on Lodash documentation when using immutable\nversions of the functions.\nJoe Except for the piece in the documentation that says the function mutates the\nobject.\nTheo Of course!\nJoe Now I’ll show you how to write code that creates a version of the library data\nwith the immutable function _.set.\nJoe’s fingers fly across Theo’s keyboard. Theo then looks at Joe’s code, which creates a ver-\nsion of the library data where the Watchmen publication year is set to 1986.\nListing4.2 Using _.set as an immutable function\nvar nextLibraryData = _.set(libraryData,\n[\"catalog\", \"booksByIsbn\",\n\"978-1779501127\", \"publicationYear\"],\n1986);\n NOTE A function is said to be immutable when, instead of mutating the data, it cre-\nates a new version of the data without changing the data it receives.\nTheo You told me earlier that structural sharing allowed immutable functions to be\nefficient in terms of memory and computation. Can you tell me what makes\nthem efficient?\nJoe With pleasure, but before that, you have to answer a series of questions. Are\nyou ready?\nTheo Yes, sure...\nJoe What part of the library data is impacted by updating the Watchmen publication\nyear: the UserManagement or the Catalog?\n--- Page 105 ---\n4.2 Structural sharing 77\nTheo Only the Catalog.\nJoe What part of the Catalog?\nTheo Only the booksByIsbn index.\nJoe What part of the booksByIsbn index?\nTheo Only the Book record that holds the information about Watchmen.\nJoe What part of the Book record?\nTheo Only the publicationYear field.\nJoe Perfect! Now, suppose that the current version of the library data looks like\nthis.\nJoe goes to the whiteboard and draws a diagram. Figure 4.3 shows the result.\nLibrary\nCatalog UserManagement\nauthorsByld booksBylsbn ...\n... watchmen\ntitle:Watchmen publicationYear:1987 authorlds\n...\nFigure 4.3 High-level visualization of the current version of Library\nTheo So far, so good...\nJoe Next, let me show you what an immutable function does when you use it to cre-\nate a new version of Library, where the publication year of Watchmen is set to\n1986 instead of 1987.\nJoe updates his diagram on the whiteboard. It now looks like figure 4.4.\n--- Page 106 ---\n78 CHAPTER 4 State management\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.4 Structural sharing provides an efficient way to create a new version of the data.\nNext Library is recursively made of nodes that use the parts of Library that are\ncommon between the two.\nTheo Could you explain?\nJoe The immutable function creates a fresh Library hash map, which recursively\nuses the parts of the current Library that are common between the two ver-\nsions instead of deeply copying them.\nTheo It’s a bit abstract for me.\nJoe The next version of Library uses the same UserManagement hash map as the\nold one. The Catalog inside the next Library uses the same authorsById as\nthe current Catalog. The Watchmen Book record inside the next Catalog uses\nall the fields of the current Book except for the publicationYear field.\nTheo So, in fact, most parts of the data are shared between the two versions. Right?\nJoe Exactly! That’s why this technique is called structural sharing.\nTIP Structural sharing provides an efficient way (both in terms of memory and com-\nputation) to create a new version of the data by recursively sharing the parts that don’t\nneed to change.\nTheo That’s very cool!\nJoe Indeed. Now let’s look at how to write a mutation for adding a member using\nimmutable functions.\n--- Page 107 ---\n4.2 Structural sharing 79\nOnce again, Joe goes to the whiteboard. Figure 4.5 shows the diagram that Joe draws to\nillustrate how structural sharing looks when we add a member.\n«Next»\nLibrary\nLibrary\n«Next»\nUserManagement Catalog\nuserManagement\n«Next»\nmembers librarians ...\nmembers\nFigure 4.5 Adding a member\nwith structural sharing. Most of\nthe data is shared between the\n... member0 member1\ntwo versions.\nTheo Awesome! The Catalog and the librarians hash maps don’t have to be copied!\nJoe Now, in terms of code, we have to write a Library.addMember function that\ndelegates to UserManagement.addMember.\nTheo I guess it’s going to be similar to the code we wrote earlier to implement the\nsearch books query, where Library.searchBooksByTitleJSON delegates to\nCatalog.searchBooksByTitle.\nJoe Similar in the sense that all the functions are static, and they receive the data\nthey manipulate as an argument. But there are two differences. First, a muta-\ntion could fail, for instance, if the member to be added already exists. Second,\nthe code for Library.addMember is a bit more elaborate than the code for\nLibrary.searchBooksByTitleJSON because we have to create a new version\nof Library that refers to the new version of UserManagement. Here, let me\nshow you an example.\nListing4.3 The code for the mutation that adds a member\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nChecks if a member with\nthrow \"Member already exists.\";\nthe same email address\n}\nalready exists\nvar nextUserManagement = _.set(\nuserManagement,\nCreates a new version of\ninfoPath,\nuserManagement that\nmember);\nincludes the member\nreturn nextUserManagement;\n};\n--- Page 108 ---\n80 CHAPTER 4 State management\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library,\n\"userManagement\",\nnextUserManagement);\nCreates a new version of\nreturn nextLibrary;\nlibrary that contains the new\n};\nversion of userManagement\nTheo To me, it’s a bit weird that immutable functions return an updated version of\nthe data instead of changing it in place.\nJoe It was also weird for me when I first encountered immutable data in Clojure\nseven years ago.\nTheo How long did it take you to get used to it?\nJoe A couple of weeks.\n4.3 Implementing structural sharing\nWhen Joe leaves the office, Theo meets Dave near the coffee machine. Dave looks perplexed.\nDave Who’s the guy that just left the office?\nTheo It’s Joe. My DOP mentor.\nDave What’s DOP?\nTheo DOP refers to data-oriented programming.\nDave I never heard that term before.\nTheo It’s not well-known by programmers yet, but it’s quite a powerful programming\nparadigm. From what I’ve seen so far, it makes programming much simpler.\nDave Can you give me an example?\nTheo I just learned about structural sharing and how it makes it possible to create\nnew versions of data, effectively without copying.\nDave How does that work?\nTheo takes Dave to his office and shows him Joe’s diagram on the whiteboard (see figure 4.6).\nIt takes Theo a few minutes to explain to Dave what it does exactly, but in the end, Dave\ngets it.\nDave What does the implementation of structural sharing look like?\nTheo I don’t know. I used the _.set function from Lodash.\nDave It sounds like an interesting challenge.\nTheo Take the challenge if you want. Right now, I’m too tired for this recursive algo-\nrithmic stuff.\n--- Page 109 ---\n4.3 Implementing structural sharing 81\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.6 Structural sharing in action\nThe next day, Theo stops by Dave’s cubicle before heading to his office. Dave, with a touch\nof pride, shows Theo his implementation of structural sharing. Theo is amazed by the fact\nthat it’s only 11 lines of JavaScript code!\nListing4.4 The implementation of structural sharing\nfunction setImmutable(map, path, v) {\nvar modifiedNode = v;\nvar k = path[0];\nvar restOfPath = path.slice(1);\nif (restOfPath.length > 0) {\nmodifiedNode = setImmutable(map[k], restOfPath, v);\n}\nvar res = Object.assign({}, map);\nShallow\nres[k] = modifiedNode;\nclones a map\nreturn res;\nin JavaScript.\n}\nTheo Dave, you’re brilliant!\nDave (smiling) Aw, shucks.\nTheo Oops, I have to go. I’m already late for my session with Joe! Joe is probably wait-\ning in my office, biting his nails.\n--- Page 110 ---\n82 CHAPTER 4 State management\n4.4 Data safety\nJoe is about to start the day’s lesson. Theo asks him a question about yesterday’s material\ninstead.\nTheo Something isn’t clear to me regarding this structural sharing stuff. What hap-\npens if we write code that modifies the data part that’s shared between the two\nversions of the data? Does the change affect both versions?\nJoe Could you please write a code snippet that illustrates your question?\nTheo starts typing on his laptop. He comes up with this code to illustrate modifying a piece\nof data shared between two versions.\nListing4.5 Modifying data that’s shared between two versions\nvar books = {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n};\nvar nextBooks = _.set(books, [\"978-1779501127\", \"publicationYear\"], 1986)\nconsole.log(\"Before:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\nbooks[\"978-1779501127\"][\"authorIds\"][1] = \"dave-chester-gibbons\";\nconsole.log(\"After:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\n// → Before: dave-gibbons\n// → After: dave-chester-gibbons\nTheo My question is, what is the value of isBlocked in updatedMember?\nJoe The answer is that mutating data via the native hash map setter is forbidden.\nAll the data manipulation must be done via immutable functions.\n NOTE All data manipulation must be done with immutable functions. It is forbid-\nden to use the native hash map setter.\nTheo When you say “forbidden,” you mean that it’s up to the developer to make sure\nit doesn’t happen. Right?\nJoe Exactly.\nTheo Is there a way to protect our system from a developer’s mistake?\nJoe Yes, there is a way to ensure the immutability of the data at the level of the data\nstructure. It’s called persistent data structures.\nTheo Are persistent data structures also efficient in terms of memory and computation?\nJoe Actually, the way data is organized inside persistent data structures make them\neven more efficient than immutable functions.\n--- Page 111 ---\n4.5 The commit phase of a mutation 83\nTIP Persistent data structures are immutable at the level of the data. There is no way\nto mutate them, even by mistake.\nTheo Are there libraries providing persistent data structures?\nJoe Definitely. I just happen to have a list of those libraries on my computer.\nJoe, being well-organized for a programmer, quickly brings up his list. He shows it to Theo:\n Immutable.js in JavaScript at https://immutable-js.com/\n Paguro in Java at https://github.com/GlenKPeterson/Paguro\n Immutable Collections in C# at http://mng.bz/y4Ke\n Pyrsistent in Python at https://github.com/tobgu/pyrsistent\n Hamster in Ruby at https://github.com/hamstergem/hamster\nTheo Why not use persistent data structures instead of immutable functions?\nJoe The drawback of persistent data structures is that they are not native. This\nmeans that working with them requires conversion from native to persistent\nand from persistent to native.\nTheo What approach would you recommend?\nJoe If you want to play around a bit, then start with immutable functions. But for a\nproduction application, I’d recommend using persistent data structures.\nTheo Too bad the native data structures aren’t persistent!\nJoe That’s one of the reasons why I love Clojure—the native data structures of the\nlanguage are immutable!\n4.5 The commit phase of a mutation\nSo far, we saw how to implement the calculation phase of a mutation. The calculation\nphase is stateless in the sense that it doesn’t make any change to the system. Now, let’s\nsee how to update the state of the system inside the commit phase.\nTheo takes another look at the code for Library.addMember. Something bothers him:\nthis function returns a new state of the library that contains an additional member, but it\ndoesn’t affect the current state of the library.\nListing4.6 The commit phase moves the system state forward\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nTheo I see that Library.addMember doesn’t change the state of the library. How\ndoes the library state get updated?\n--- Page 112 ---\n84 CHAPTER 4 State management\nJoe That’s an excellent question. Library.addMember deals only with data calcula-\ntion and is stateless. The state is updated in the commit phase by moving for-\nward the version of the state that the system state refers to.\nTheo What do you mean by that?\nJoe Here’s what happens when we add a member to the system. The calculation\nphase creates a version of the state that has two members. Before the commit\nphase, the system state refers to the version of the state with one member. The\nresponsibility of the commit phase is to move the system state forward so that it\nrefers to the version of the state with two members.\nTIP The responsibility of the commit phase is to move the system state forward to the\nversion of the state returned by the calculation phase.\nJoe draws another illustration on the whiteboard (figure 4.7). He hopes it helps to clear up\nany misunderstanding Theo may have.\nBefore Commit After Commit\nState with one State with one\nSystem State\nmember member\naddMember addMember\nState with two State with two\nSystem State\nmembers members\nFigure 4.7 The commit phase moves the system state forward.\nTheo How is this implemented?\nJoe The code is made of two classes: System, a singleton stateful class that imple-\nments the mutations, and SystemState, a singleton stateful class that manages\nthe system state.\nTheo It sounds to me like classic OOP.\nJoe Right, and this part of the system being stateful is OOP-like.\nTheo I’m happy to see that you still find some utility in OOP.\nJoe Meditation taught me that every part of our universe has a role to play.\nTheo Nice! Could you show me some code?\nJoe Sure.\nJoe thinks for a moment before starting to type. He wants to show the System class and its\nimplementation of the addMember mutation.\nListing4.7 The System class\nclass System {\naddMember(member) {\nvar previous = SystemState.get();\n--- Page 113 ---\n4.6 Ensuring system state integrity 85\nvar next = Library.addMember(previous, member);\nSystemState.commit(previous, next);\nSystemState is covered\n}\nin listing 4.8.\n}\nTheo What does SystemState look like?\nJoe I had a feeling you were going to ask that. Here’s the code for the System-\nState class, which is a stateful class!\nListing4.8 The SystemState class\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nTheo I don’t get the point of SystemState. It’s a simple class with a getter and a\ncommit function, right?\nJoe In a moment, we are going to enrich the code of the SystemState.commit\nmethod so that it provides data validation and history tracking. For now, the\nimportant thing to notice is that the code of the calculation phase is stateless\nand is decoupled from the code of the commit phase, which is stateful.\nTIP The calculation phase is stateless. The commit phase is stateful.\n4.6 Ensuring system state integrity\nTheo Something still bothers me about the way functions manipulate immutable\ndata in the calculation phase. How do we preserve data integrity?\nJoe What do you mean?\nTheo In OOP, data is manipulated only by methods that belong to the same class as\nthe data. It prevents other classes from corrupting the inner state of the class.\nJoe Could you give me an example of an invalid state of the library?\nTheo For example, imagine that the code of a mutation adds a book item to the\nbook lendings of a member without marking the book item as lent in the cata-\nlog. Then the system data would be corrupted.\nJoe In DOP, we have the privilege of ensuring data integrity at the level of the\nwhole system instead of scattering the validation among many classes.\nTheo How does that work?\nJoe The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system data in a central place. At the beginning of the\ncommit phase, there is a step that checks whether the version of the system\n--- Page 114 ---\n86 CHAPTER 4 State management\nstate to be committed is valid. If the data is invalid, the commit is rejected.\nHere let me show you.\nListing4.9 Data validation inside the commit phase\nSystemState.commit = function(previous, next) {\nif(!SystemValidity.validate(previous, next)) { // not implemented for now\nthrow \"The system data to be committed is not valid!\";\n};\nthis.systemData = next;\n};\nTheo It sounds similar to a commit hook in Git.\nJoe I like your analogy!\nTheo Why are you passing the previous state in previous and the next state in next\nto SystemValidity.validate?\nJoe Because it allows SystemValidity.validate to optimize the validation in\nterms of computation. For example, we could validate just the data that has\nchanged.\nTIP In DOP, we validate the system data as a whole. Data validation is decoupled\nfrom data manipulation.\nTheo What does the code of SystemValidity.validate look like?\nJoe Someday, I will show you how to define a data schema and to validate that a\npiece of data conforms to a schema.\n NOTE See chapters 7 and 12 to see how Joe defines this data schema.\n4.7 Restoring previous states\nAnother advantage of the multi-version state approach with immutable data that is\nmanipulated via structural sharing is that we can keep track of the history of all the\nversions of the data without exploding the memory of our program. It allows us, for\ninstance, to restore the system back to an earlier state easily.\nTheo You told me earlier that it was easy to restore the system to a previous state.\nCould you show me how?\nJoe Happily, but before that, I’d like to make sure you understand why keeping\ntrack of all the versions of the data is efficient in terms of memory.\nTheo I think it’s related to the fact that immutable functions use structural sharing,\nand most of the data between subsequent versions of the state is shared.\nTIP Structural sharing allows us to keep many versions of the system state without\nexploding memory use.\nJoe Perfect! Now, I’ll show you how simple it is to undo a mutation. In order to\nimplement an undo mechanism, our SystemState class needs to have two\n--- Page 115 ---\n4.7 Restoring previous states 87\nreferences to the system data: systemData references the current state of the\nsystem, and previousSystemData references the previous state of the system.\nTheo That makes sense.\nJoe In the commit phase, we update both previousSystemData and systemData.\nTheo What does it take to implement an undo mechanism?\nJoe The undo is achieved by having systemData reference the same version of the\nsystem data as previousSystemData.\nTheo Could you walk me through an example?\nJoe To make things simple, I am going to give a number to each version of the sys-\ntem state. It starts at V0, and each time a mutation is committed, the version is\nincremented: V1, V2, V3, and so forth.\nTheo OK.\nJoe Let’s say that currently our system state is at V12 (see figure 4.8). In the\nSystemState object, systemData refers to V12, and previousSystemData\nrefers to V11.\npreviousSystemData\nMutationA Mutation B\nData V10 Data V11 Data V12\nsystemData\nFigure 4.8 When the system state is at V12, systemData refers to V12, and\npreviousSystemData refers to V11.\nTheo So far, so good...\nJoe Now, when a mutation is committed (for instance, adding a member), both\nreferences move forward: systemData refers to V13, and previousSystem-\nData refers to V12.\nJoe erases the whiteboard to make room for another diagram (figure 4.9). When he’s\nthrough with his drawing, he shows it to Theo.\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.9 When a mutation is committed, systemData refers to V13, and\npreviousSystemData refers to V12.\n--- Page 116 ---\n88 CHAPTER 4 State management\nTheo I suppose that when we undo the mutation, both references move backward.\nJoe In theory, yes, but in practice, it’s necessary to maintain a stack of all the state\nreferences. For now, to simplify things, we’ll maintain only a reference to the\nprevious version. As a consequence, when we undo the mutation, both refer-\nences refer to V12. Let me draw another diagram on the whiteboard that shows\nthis state (see figure 4.10).\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.10 When a mutation is undone, both systemData and previousSystemData refer\nto V12.\nTheo Could you show me how to implement this undo mechanism?\nJoe Actually, it takes only a couple of changes to the SystemState class. Pay atten-\ntion to the changes in the commit function. Inside systemDataBeforeUpdate,\nwe keep a reference to the current state of the system. If the validation and\nthe conflict resolution succeed, we update both previousSystemData and\nsystemData.\nListing4.10 The SystemState class with undo capability\nclass SystemState {\nsystemData;\npreviousSystemData;\nget() {\nreturn this.systemData;\n}\ncommit(previous, next) {\nvar systemDataBeforeUpdate = this.systemData;\nif(!Consistency.validate(previous, next)) {\nthrow \"The system data to be committed is not valid!\";\n}\nthis.systemData = next;\nthis.previousSystemData = systemDataBeforeUpdate;\n}\nundoLastMutation() {\nthis.systemData = this.previousSystemData;\n}\n}\n--- Page 117 ---\nSummary 89\nTheo I see that implementing System.undoLastMutation is simply a matter of hav-\ning systemData refer the same value as previousSystemData.\nJoe As I told you, if we need to allow multiple undos, the code would be a bit more\ncomplicated, but you get the idea.\nTheo I think so. Although Back to the Future belongs to the realm of science fiction, in\nDOP, time travel is real.\nSummary\n DOP principle #3 states that data is immutable.\n A mutation is an operation that changes the state of the system.\n In a multi-version approach to state management, mutations are split into cal-\nculation and commit phases.\n All data manipulation must be done via immutable functions. It is forbidden to\nuse the native hash map setter.\n Structural sharing allows us to create new versions of data efficiently (in terms of\nmemory and computation), where data that is common between the two ver-\nsions is shared instead of being copied.\n Structural sharing creates a new version of the data by recursively sharing the\nparts that don’t need to change.\n A mutation is split in two phases: calculation and commit.\n A function is said to be immutable when, instead of mutating the data, it creates\na new version of the data without changing the data it receives.\n During the calculation phase, data is manipulated with immutable functions that\nuse structural sharing.\n The calculation phase is stateless.\n During the commit phase, we update the system state.\n The responsibility of the commit phase is to move the system state forward to\nthe version of the state returned by the calculation phase.\n The data is immutable, but the state reference is mutable.\n The commit phase is stateful.\n We validate the system data as a whole. Data validation is decoupled from data\nmanipulation.\n The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system state in a central place before we update the\nstate.\n Keeping the history of the versions of the system data is memory efficient due to\nstructural sharing.\n Restoring the system to one of its previous states is straightforward due to the\nclear separation between the calculation phase and the commit phase.\n--- Page 118 ---\n90 CHAPTER 4 State management\n In order to use Lodash immutable functions, we use the Lodash FP module\n(https://github.com/lodash/lodash/wiki/FP-Guide).\nLodash functions introduced in this chapter\nFunction Description\nset(map, path, value) Creates a map with the same fields as map with the addition of a\n<path, value> field\n--- Page 119 ---\nBasic concurrency control\nConflicts at home\nThis chapter covers\n Managing concurrent mutations with a lock-free\noptimistic concurrency control strategy\n Supporting high throughput of reads and writes\n Reconciliation between concurrent mutations\nThe changes required for system manage concurrency are only in the commit\nphase. They involve a reconciliation algorithm that is universal, in the sense that it\ncan be used in any system where data is represented as an immutable hash map.\nThe implementation of the reconciliation algorithm is efficient because subse-\nquent versions of the system state are created via structural sharing.\nIn the previous chapter, we illustrated the multiversion approach to state man-\nagement, where a mutation is split into two distinct phases: the calculation phase\nthat deals only with computation, and the commit phase that moves the state ref-\nerence forward. Usually, in a production system, mutations occur concurrently.\nMoving the state forward naively like we did in the previous chapter is not appro-\npriate. In the present chapter, we are going to learn how to handle concurrent\nmutations.\n91\n--- Page 120 ---\n92 CHAPTER 5 Basic concurrency control\nIn DOP, because only the code of the commit phase is stateful, that allows us to use\nan optimistic concurrency control strategy that doesn’t involve any locking mechanism. As\na consequence, the throughput of reads and writes is high. The modifications to the\ncode are not trivial, as we have to implement an algorithm that reconciles concurrent\nmutations. But the modifications impact only the commit phase. The code for the cal-\nculation phase stays the same as in the previous chapter.\n NOTE This chapter requires more of an effort to grasp. The flow of the reconcilia-\ntion algorithm is definitely not trivial, and the implementation involves a nontrivial\nrecursion.\n5.1 Optimistic concurrency control\nThis morning, before getting to work, Theo takes Joe to the fitness room in the office and,\nwhile running on the step machine, the two men talk about their personal lives again. Joe\ntalks about a fight he had last night with Kay, who thinks that he pays more attention to his\nwork than to his family. Theo recounts the painful conflict he had with Jane, his wife,\nabout house budget management. They went to see a therapist, an expert in Imago Rela-\ntionship Therapy. Imago allowed them to transform their conflict into an opportunity to\ngrow and heal.\nJoe’s ears perk up when he hears the word conflict because today’s lesson is going to be\nabout resolving conflicts and concurrent mutations. A different kind of conflict, though....\nAfter a shower and a healthy breakfast, Theo and Joe get down to work.\nJoe Yesterday, I showed you how to manage state with immutable data, assuming\nthat no mutations occur concurrently. Today, I am going to show you how to\ndeal with concurrency control in DOP.\nTheo I’m curious to discover what kind of lock mechanisms you use in DOP to syn-\nchronize concurrent mutations.\nJoe In fact, we don’t use any lock mechanism!\nTheo Why not?\nJoe Locks hit performance, and if you’re not careful, your system could get into a\ndeadlock.\nTheo So, how do you handle possible conflicts between concurrent mutations in\nDOP?\nJoe In DOP, we use a lock-free strategy called optimistic concurrency control. It’s a\nstrategy that allows databases like Elasticsearch to be highly scalable.\n NOTE See https://www.elastic.co/elasticsearch/ to find out more about Elastic-\nsearch.\nTheo You sound like my couples therapist and her anger-free, optimistic conflict\nresolution strategy.\nJoe Optimistic concurrency control and DOP fit together well. As you will see in a\nmoment, optimistic concurrency control is super efficient when the system\ndata is immutable.\n--- Page 121 ---\n5.1 Optimistic concurrency control 93\nTIP Optimistic concurrency control with immutable data is super efficient.\nTheo How does it work?\nJoe Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTIP Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTheo What do you mean?\nJoe The calculation phase does its calculation as if it were the only mutation run-\nning. The commit phase is responsible for reconciling concurrent mutations\nwhen they don’t conflict or for aborting the mutation.\nTIP The calculation phase does its calculation as if it were the only mutation running.\nThe commit phase is responsible for trying to reconcile concurrent mutations.\nTheo That sounds quite challenging to implement.\nJoe Dealing with state is never trivial. But the good news is that the code for the\nreconciliation logic in the commit phase is universal.\nTheo Does that mean that the same code for the commit phase can be used in any\nDOP system?\nJoe Definitely. The code that implements the commit phase assumes nothing\nabout the details of the system except that the system data is represented as an\nimmutable map.\nTIP The implementation of the commit phase in optimistic concurrency control is\nuniversal. It can be used in any system where the data is represented by an immutable\nhash map.\nTheo That’s awesome!\nJoe Another cool thing is that handling concurrency doesn’t require any changes\nto the code in the calculation phase. From the calculation phase perspective,\nthe next version of the system data is computed in isolation as if no other muta-\ntions were running concurrently.\nJoe stands up to illustrate what he means on the whiteboard. While Theo looks at the draw-\ning in figure 5.1, Joe summarizes the information in table 5.1.\nTable 5.1 The two phases of a mutation with optimistic concurrency control\nPhase Responsibility State Implementation\nCalculation Compute next state in isolation Stateless Specific\nCommit Reconcile and update system state Stateful Common\n--- Page 122 ---\n94 CHAPTER 5 Basic concurrency control\nCalculation phase\nCapturesystem state\nComputenext version\nCommit phase\nYes No\nConcurrent mutations?\nYes No\nConflict?\nUpdatesystem state\nAbortmutation Reconcilemutations\nUpdatesystem state\nFigure 5.1 The logic flow\nof optimistic concurrency\ncontrol\n5.2 Reconciliation between concurrent mutations\nTheo Could you give me some examples of conflicting concurrent mutations?\nJoe Sure. One example would be two members trying to borrow the same book\ncopy. Another example might be when two librarians update the publication\nyear of the same book.\nTheo You mentioned that the code for the reconciliation logic in the commit phase\nis universal. What do you mean exactly by reconciliation logic?\nJoe It’s quite similar to what could happen in Git when you merge a branch back\ninto the main branch.\nTheo I love it when the main branch stays the same.\nJoe Yes, it’s nice when the merge has no conflicts and can be done automatically.\nDo you remember how Git handles the merge in that case?\nTheo Git does a fast-forward; it updates the main branch to be the same as the merge\nbranch.\nJoe Right! And what happens when you discover that, meanwhile, another devel-\noper has committed their code to the main branch?\nTheo Then Git does a three-way merge, trying to combine all the changes from the\ntwo merge branches with the main branch.\nJoe Does it always go smoothly?\nTheo Usually, yes, but it’s possible that two developers have modified the same line\nin the same file. I then have to manually resolve the conflict. I hate when that\nhappens!\nTIP In a production system, multiple mutations run concurrently. Before updating\nthe state, we need to reconcile the conflicts between possible concurrent mutations.\n--- Page 123 ---\n5.2 Reconciliation between concurrent mutations 95\nJoe In DOP, the reconciliation algorithm in the commit phase is quite similar to a\nmerge in Git, except instead of a manual conflict resolution, we abort the\nmutation. There are three possibilities to reconcile between possible concur-\nrent mutations: fast-forward, three-way merge, or abort.\nJoe goes to the whiteboard again. He draws the two diagrams shown in figures 5.2 and 5.3.\nYes No\nState has stayed the same\nYes No\nConcurrent mutations compatible?\nFast forward\n3-way Merge Abort\nFigure 5.2 The\nreconciliation flow\nThe version during\nthe Commit phase\ncurrent\nprevious\nnext\nThe base version\nfor the Calculation\nThe version Figure 5.3 When the commit phase\nphase\nreturned by the starts, there are three versions of the\nCalculation phase system state.\nTheo Could you explain in more detail?\nJoe When the commit phase of a mutation starts, we have three versions of the sys-\ntem state: previous, which is the version on which the calculation phase based\nits computation; current, which is the current version during the commit\nphase; and next, which is the version returned by the calculation phase.\nTheo Why would current be different than previous?\nJoe It happens when other mutations have run concurrently with our mutation.\nTheo I see.\nJoe If we are in a situation where the current state is the same as the previous state,\nit means that no mutations run concurrently. Therefore, as in Git, we can\nsafely fast-forward and update the state of the system with the next version.\nTheo What if the state has not stayed the same?\nJoe Then it means that mutations have run concurrently. We have to check for\nconflicts in a way similar to the three-way merge used by Git. The difference is\nthat instead of comparing lines, we compare fields of the system hash map.\nTheo Could you explain that?\n--- Page 124 ---\n96 CHAPTER 5 Basic concurrency control\nJoe We calculate the diff between previous and next and between previous and\ncurrent. If the two diffs have no fields in common, then there is no conflict\nbetween the mutations that have run concurrently. We can safely apply the\nchanges from previous to next into current.\nJoe makes his explanation visual with another diagram on the whiteboard. He then shows\nfigure 5.4 to Theo.\ndiffPreviousCurrent diffPreviousNext\ncurrent\nprevious merged\ndiffPreviousNext\nnext\nFigure 5.4 In a three-way merge, we calculate the diff between previous and\nnext, and we apply it to current.\nTheo What if there is a conflict?\nJoe Then we abort the mutation.\nTheo Aborting a user request seems unacceptable.\nJoe In fact, in a user-facing system, conflicting concurrent mutations are fairly rare.\nThat’s why it’s OK to abort and let the user run the mutation again. Here, let\nme draft a table to show you the differences between Git and DOP (table 5.2).\nTable 5.2 The analogy between Git and data-oriented programming\nData-oriented programming Git\nConcurrent mutations Different branches\nA version of the system data A commit\nState A reference\nCalculation phase Branching\nValidation Precommit hook\nReconciliation Merge\nFast-forward Fast-forward\nThree-way merge Three-way merge\nAbort Manual conflict resolution\nHash map Tree (folder)\nLeaf node Blob (file)\nData field Line of code\n--- Page 125 ---\n5.3 Reducing collections 97\nTheo Great! That helps, but in cases where two mutations update the same field of\nthe same entity, I think it’s fair enough to let the user know that the request\ncan’t be processed.\nTIP In a user-facing system, conflicting concurrent mutations are fairly rare.\n5.3 Reducing collections\nJoe Are you ready to challenge your mind with the implementation of the diff\nalgorithm?\nTheo Let’s take a short coffee break before, if you don’t mind. Then, I’ll be ready to\ntackle anything.\nAfter enjoying large mug of hot coffee and a few butter cookies, Theo and Joe are back to\nwork. Their discussion on the diff algorithm continues.\nJoe In the implementation of the diff algorithm, we’re going to reduce collections.\nTheo I heard about reducing collections in a talk about FP, but I don’t remember\nthe details. Could you remind me how this works?\nJoe Imagine you want to calculate the sum of the elements in a collection of num-\nbers. With Lodash’s _.reduce, it would look like this.\nListing5.1 Summing numbers with _.reduce\n_.reduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nTheo I don’t understand.\nJoe goes to the whiteboard and writes the description of _.reduce. Theo waits patiently\nuntil Joe puts the pen down before looking at the description.\nDescription of _.reduce\n_.reduce receives three arguments:\n coll—A collection of elements\n f—A function that receives two arguments\n initVal—A value\nLogic flow:\n1 Initialize currentRes with initVal.\n2 For each element x of coll, update currentRes with f(currentRes, x).\n3 Return currentRes.",
        "sections_found": []
      },
      "accurate_page_range": "102-125"
    },
    {
      "text": "- 4.1 Multiple versions of the system data",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "raw_line": "- 4.1 Multiple versions of the system data (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 30,
      "chapter_info": {
        "page": 102,
        "title": "State management",
        "pattern_matched": "Chapter 4",
        "text_preview": "74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead"
      },
      "chapter_sections": {
        "start_page": 102,
        "end_page": 125,
        "content": "\n--- Page 102 ---\n74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead of being copied.\nThis technique efficiently creates new versions of the system data, both in\nterms of memory and computation.\nTheo I’m intrigued.\nTIP With structural sharing, it’s efficient (in terms of memory and computation) to\ncreate new versions of data.\nJoe I’ll explain in detail how structural sharing works in a moment.\nTheo takes another look at the diagram in figure 4.1, which illustrates how the system state\nrefers to a version of the system data. Suddenly, a question emerges.\nTheo Are the previous versions of the system data kept?\nJoe In a simple application, previous versions are automatically removed by the\ngarbage collector. But, in some cases, we maintain historical references to pre-\nvious versions of the data.\nTheo What kind of cases?\nJoe For example, if we want to support time travel in our system, as in Git, we can\nmove the system back to a previous version of the state easily.\nTheo Now I understand what you mean by data is immutable, but the state reference\nis mutable!\n4.2 Structural sharing\nAs mentioned in the previous section, structural sharing enables the efficient cre-\nation of new versions of immutable data. In DOP, we use structural sharing in the\ncalculation phase of a mutation to compute the next state of the system based on\nthe current state of the system. Inside the calculation phase, we don’t have to deal\nwith state management; that is delayed to the commit phase. As a consequence, the\ncode involved in the calculation phase of a mutation is stateless and is as simple as\nthe code of a query.\nTheo I’m really intrigued by this more efficient way to create new versions of data.\nHow does it work?\nJoe Let’s take a simple example from our library system. Imagine that you want to\nmodify the value of a field in a book in the catalog; for instance, the publica-\ntion year of Watchmen. Can you tell me the information path for Watchmen’s\npublication year?\nTheo takes a quick look at the catalog data in figure 4.2. Then he answers Joe’s question.\n--- Page 103 ---\n4.2 Structural sharing 75\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 4.2 Visualization of the catalog data. The nodes in the information path to Watchmen’s publication\nyear are marked with a dotted border.\nTheo The information path for Watchmen’s publication year is [\"catalog\", \"books-\nByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Now, let me show how you to use the immutable function _.set that Lodash\nalso provides.\nTheo Wait! What do you mean by an immutable function? When I looked at the\nLodash documentation for _.set on their website, it said that it mutates the\nobject.\nJoe You’re right, but the default Lodash functions are not immutable. In order to\nuse an immutable version of the functions, we need to use the Lodash FP mod-\nule as explained in the Lodash FP guide.\n NOTE See https://lodash.com/docs/4.17.15#set to view Lodash’s documentation\nfor _.set, and see https://github.com/lodash/lodash/wiki/FP-Guide to view the\nLodash FP guide.\nTheo Do the immutable functions have the same signature as the mutable functions?\nJoe By default, the order of the arguments in immutable functions is shuffled.\nThe Lodash FP guide explains how to resolve this. With this piece of code,\n--- Page 104 ---\n76 CHAPTER 4 State management\nthe signature of the immutable functions is exactly the same as the mutable\nfunctions.\nListing4.1 Configuring Lodash so immutable and mutable functions have same signature\n_ = fp.convert({\n\"cap\": false,\n\"curry\": false,\n\"fixed\": false,\n\"immutable\": true,\n\"rearg\": false\n});\nTIP In order to use Lodash immutable functions, we use Lodash’s FP module, and\nwe configure it so that the signature of the immutable functions is the same as in the\nLodash documentation web site.\nTheo So basically, I can still rely on Lodash documentation when using immutable\nversions of the functions.\nJoe Except for the piece in the documentation that says the function mutates the\nobject.\nTheo Of course!\nJoe Now I’ll show you how to write code that creates a version of the library data\nwith the immutable function _.set.\nJoe’s fingers fly across Theo’s keyboard. Theo then looks at Joe’s code, which creates a ver-\nsion of the library data where the Watchmen publication year is set to 1986.\nListing4.2 Using _.set as an immutable function\nvar nextLibraryData = _.set(libraryData,\n[\"catalog\", \"booksByIsbn\",\n\"978-1779501127\", \"publicationYear\"],\n1986);\n NOTE A function is said to be immutable when, instead of mutating the data, it cre-\nates a new version of the data without changing the data it receives.\nTheo You told me earlier that structural sharing allowed immutable functions to be\nefficient in terms of memory and computation. Can you tell me what makes\nthem efficient?\nJoe With pleasure, but before that, you have to answer a series of questions. Are\nyou ready?\nTheo Yes, sure...\nJoe What part of the library data is impacted by updating the Watchmen publication\nyear: the UserManagement or the Catalog?\n--- Page 105 ---\n4.2 Structural sharing 77\nTheo Only the Catalog.\nJoe What part of the Catalog?\nTheo Only the booksByIsbn index.\nJoe What part of the booksByIsbn index?\nTheo Only the Book record that holds the information about Watchmen.\nJoe What part of the Book record?\nTheo Only the publicationYear field.\nJoe Perfect! Now, suppose that the current version of the library data looks like\nthis.\nJoe goes to the whiteboard and draws a diagram. Figure 4.3 shows the result.\nLibrary\nCatalog UserManagement\nauthorsByld booksBylsbn ...\n... watchmen\ntitle:Watchmen publicationYear:1987 authorlds\n...\nFigure 4.3 High-level visualization of the current version of Library\nTheo So far, so good...\nJoe Next, let me show you what an immutable function does when you use it to cre-\nate a new version of Library, where the publication year of Watchmen is set to\n1986 instead of 1987.\nJoe updates his diagram on the whiteboard. It now looks like figure 4.4.\n--- Page 106 ---\n78 CHAPTER 4 State management\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.4 Structural sharing provides an efficient way to create a new version of the data.\nNext Library is recursively made of nodes that use the parts of Library that are\ncommon between the two.\nTheo Could you explain?\nJoe The immutable function creates a fresh Library hash map, which recursively\nuses the parts of the current Library that are common between the two ver-\nsions instead of deeply copying them.\nTheo It’s a bit abstract for me.\nJoe The next version of Library uses the same UserManagement hash map as the\nold one. The Catalog inside the next Library uses the same authorsById as\nthe current Catalog. The Watchmen Book record inside the next Catalog uses\nall the fields of the current Book except for the publicationYear field.\nTheo So, in fact, most parts of the data are shared between the two versions. Right?\nJoe Exactly! That’s why this technique is called structural sharing.\nTIP Structural sharing provides an efficient way (both in terms of memory and com-\nputation) to create a new version of the data by recursively sharing the parts that don’t\nneed to change.\nTheo That’s very cool!\nJoe Indeed. Now let’s look at how to write a mutation for adding a member using\nimmutable functions.\n--- Page 107 ---\n4.2 Structural sharing 79\nOnce again, Joe goes to the whiteboard. Figure 4.5 shows the diagram that Joe draws to\nillustrate how structural sharing looks when we add a member.\n«Next»\nLibrary\nLibrary\n«Next»\nUserManagement Catalog\nuserManagement\n«Next»\nmembers librarians ...\nmembers\nFigure 4.5 Adding a member\nwith structural sharing. Most of\nthe data is shared between the\n... member0 member1\ntwo versions.\nTheo Awesome! The Catalog and the librarians hash maps don’t have to be copied!\nJoe Now, in terms of code, we have to write a Library.addMember function that\ndelegates to UserManagement.addMember.\nTheo I guess it’s going to be similar to the code we wrote earlier to implement the\nsearch books query, where Library.searchBooksByTitleJSON delegates to\nCatalog.searchBooksByTitle.\nJoe Similar in the sense that all the functions are static, and they receive the data\nthey manipulate as an argument. But there are two differences. First, a muta-\ntion could fail, for instance, if the member to be added already exists. Second,\nthe code for Library.addMember is a bit more elaborate than the code for\nLibrary.searchBooksByTitleJSON because we have to create a new version\nof Library that refers to the new version of UserManagement. Here, let me\nshow you an example.\nListing4.3 The code for the mutation that adds a member\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nChecks if a member with\nthrow \"Member already exists.\";\nthe same email address\n}\nalready exists\nvar nextUserManagement = _.set(\nuserManagement,\nCreates a new version of\ninfoPath,\nuserManagement that\nmember);\nincludes the member\nreturn nextUserManagement;\n};\n--- Page 108 ---\n80 CHAPTER 4 State management\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library,\n\"userManagement\",\nnextUserManagement);\nCreates a new version of\nreturn nextLibrary;\nlibrary that contains the new\n};\nversion of userManagement\nTheo To me, it’s a bit weird that immutable functions return an updated version of\nthe data instead of changing it in place.\nJoe It was also weird for me when I first encountered immutable data in Clojure\nseven years ago.\nTheo How long did it take you to get used to it?\nJoe A couple of weeks.\n4.3 Implementing structural sharing\nWhen Joe leaves the office, Theo meets Dave near the coffee machine. Dave looks perplexed.\nDave Who’s the guy that just left the office?\nTheo It’s Joe. My DOP mentor.\nDave What’s DOP?\nTheo DOP refers to data-oriented programming.\nDave I never heard that term before.\nTheo It’s not well-known by programmers yet, but it’s quite a powerful programming\nparadigm. From what I’ve seen so far, it makes programming much simpler.\nDave Can you give me an example?\nTheo I just learned about structural sharing and how it makes it possible to create\nnew versions of data, effectively without copying.\nDave How does that work?\nTheo takes Dave to his office and shows him Joe’s diagram on the whiteboard (see figure 4.6).\nIt takes Theo a few minutes to explain to Dave what it does exactly, but in the end, Dave\ngets it.\nDave What does the implementation of structural sharing look like?\nTheo I don’t know. I used the _.set function from Lodash.\nDave It sounds like an interesting challenge.\nTheo Take the challenge if you want. Right now, I’m too tired for this recursive algo-\nrithmic stuff.\n--- Page 109 ---\n4.3 Implementing structural sharing 81\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.6 Structural sharing in action\nThe next day, Theo stops by Dave’s cubicle before heading to his office. Dave, with a touch\nof pride, shows Theo his implementation of structural sharing. Theo is amazed by the fact\nthat it’s only 11 lines of JavaScript code!\nListing4.4 The implementation of structural sharing\nfunction setImmutable(map, path, v) {\nvar modifiedNode = v;\nvar k = path[0];\nvar restOfPath = path.slice(1);\nif (restOfPath.length > 0) {\nmodifiedNode = setImmutable(map[k], restOfPath, v);\n}\nvar res = Object.assign({}, map);\nShallow\nres[k] = modifiedNode;\nclones a map\nreturn res;\nin JavaScript.\n}\nTheo Dave, you’re brilliant!\nDave (smiling) Aw, shucks.\nTheo Oops, I have to go. I’m already late for my session with Joe! Joe is probably wait-\ning in my office, biting his nails.\n--- Page 110 ---\n82 CHAPTER 4 State management\n4.4 Data safety\nJoe is about to start the day’s lesson. Theo asks him a question about yesterday’s material\ninstead.\nTheo Something isn’t clear to me regarding this structural sharing stuff. What hap-\npens if we write code that modifies the data part that’s shared between the two\nversions of the data? Does the change affect both versions?\nJoe Could you please write a code snippet that illustrates your question?\nTheo starts typing on his laptop. He comes up with this code to illustrate modifying a piece\nof data shared between two versions.\nListing4.5 Modifying data that’s shared between two versions\nvar books = {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n};\nvar nextBooks = _.set(books, [\"978-1779501127\", \"publicationYear\"], 1986)\nconsole.log(\"Before:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\nbooks[\"978-1779501127\"][\"authorIds\"][1] = \"dave-chester-gibbons\";\nconsole.log(\"After:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\n// → Before: dave-gibbons\n// → After: dave-chester-gibbons\nTheo My question is, what is the value of isBlocked in updatedMember?\nJoe The answer is that mutating data via the native hash map setter is forbidden.\nAll the data manipulation must be done via immutable functions.\n NOTE All data manipulation must be done with immutable functions. It is forbid-\nden to use the native hash map setter.\nTheo When you say “forbidden,” you mean that it’s up to the developer to make sure\nit doesn’t happen. Right?\nJoe Exactly.\nTheo Is there a way to protect our system from a developer’s mistake?\nJoe Yes, there is a way to ensure the immutability of the data at the level of the data\nstructure. It’s called persistent data structures.\nTheo Are persistent data structures also efficient in terms of memory and computation?\nJoe Actually, the way data is organized inside persistent data structures make them\neven more efficient than immutable functions.\n--- Page 111 ---\n4.5 The commit phase of a mutation 83\nTIP Persistent data structures are immutable at the level of the data. There is no way\nto mutate them, even by mistake.\nTheo Are there libraries providing persistent data structures?\nJoe Definitely. I just happen to have a list of those libraries on my computer.\nJoe, being well-organized for a programmer, quickly brings up his list. He shows it to Theo:\n Immutable.js in JavaScript at https://immutable-js.com/\n Paguro in Java at https://github.com/GlenKPeterson/Paguro\n Immutable Collections in C# at http://mng.bz/y4Ke\n Pyrsistent in Python at https://github.com/tobgu/pyrsistent\n Hamster in Ruby at https://github.com/hamstergem/hamster\nTheo Why not use persistent data structures instead of immutable functions?\nJoe The drawback of persistent data structures is that they are not native. This\nmeans that working with them requires conversion from native to persistent\nand from persistent to native.\nTheo What approach would you recommend?\nJoe If you want to play around a bit, then start with immutable functions. But for a\nproduction application, I’d recommend using persistent data structures.\nTheo Too bad the native data structures aren’t persistent!\nJoe That’s one of the reasons why I love Clojure—the native data structures of the\nlanguage are immutable!\n4.5 The commit phase of a mutation\nSo far, we saw how to implement the calculation phase of a mutation. The calculation\nphase is stateless in the sense that it doesn’t make any change to the system. Now, let’s\nsee how to update the state of the system inside the commit phase.\nTheo takes another look at the code for Library.addMember. Something bothers him:\nthis function returns a new state of the library that contains an additional member, but it\ndoesn’t affect the current state of the library.\nListing4.6 The commit phase moves the system state forward\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nTheo I see that Library.addMember doesn’t change the state of the library. How\ndoes the library state get updated?\n--- Page 112 ---\n84 CHAPTER 4 State management\nJoe That’s an excellent question. Library.addMember deals only with data calcula-\ntion and is stateless. The state is updated in the commit phase by moving for-\nward the version of the state that the system state refers to.\nTheo What do you mean by that?\nJoe Here’s what happens when we add a member to the system. The calculation\nphase creates a version of the state that has two members. Before the commit\nphase, the system state refers to the version of the state with one member. The\nresponsibility of the commit phase is to move the system state forward so that it\nrefers to the version of the state with two members.\nTIP The responsibility of the commit phase is to move the system state forward to the\nversion of the state returned by the calculation phase.\nJoe draws another illustration on the whiteboard (figure 4.7). He hopes it helps to clear up\nany misunderstanding Theo may have.\nBefore Commit After Commit\nState with one State with one\nSystem State\nmember member\naddMember addMember\nState with two State with two\nSystem State\nmembers members\nFigure 4.7 The commit phase moves the system state forward.\nTheo How is this implemented?\nJoe The code is made of two classes: System, a singleton stateful class that imple-\nments the mutations, and SystemState, a singleton stateful class that manages\nthe system state.\nTheo It sounds to me like classic OOP.\nJoe Right, and this part of the system being stateful is OOP-like.\nTheo I’m happy to see that you still find some utility in OOP.\nJoe Meditation taught me that every part of our universe has a role to play.\nTheo Nice! Could you show me some code?\nJoe Sure.\nJoe thinks for a moment before starting to type. He wants to show the System class and its\nimplementation of the addMember mutation.\nListing4.7 The System class\nclass System {\naddMember(member) {\nvar previous = SystemState.get();\n--- Page 113 ---\n4.6 Ensuring system state integrity 85\nvar next = Library.addMember(previous, member);\nSystemState.commit(previous, next);\nSystemState is covered\n}\nin listing 4.8.\n}\nTheo What does SystemState look like?\nJoe I had a feeling you were going to ask that. Here’s the code for the System-\nState class, which is a stateful class!\nListing4.8 The SystemState class\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nTheo I don’t get the point of SystemState. It’s a simple class with a getter and a\ncommit function, right?\nJoe In a moment, we are going to enrich the code of the SystemState.commit\nmethod so that it provides data validation and history tracking. For now, the\nimportant thing to notice is that the code of the calculation phase is stateless\nand is decoupled from the code of the commit phase, which is stateful.\nTIP The calculation phase is stateless. The commit phase is stateful.\n4.6 Ensuring system state integrity\nTheo Something still bothers me about the way functions manipulate immutable\ndata in the calculation phase. How do we preserve data integrity?\nJoe What do you mean?\nTheo In OOP, data is manipulated only by methods that belong to the same class as\nthe data. It prevents other classes from corrupting the inner state of the class.\nJoe Could you give me an example of an invalid state of the library?\nTheo For example, imagine that the code of a mutation adds a book item to the\nbook lendings of a member without marking the book item as lent in the cata-\nlog. Then the system data would be corrupted.\nJoe In DOP, we have the privilege of ensuring data integrity at the level of the\nwhole system instead of scattering the validation among many classes.\nTheo How does that work?\nJoe The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system data in a central place. At the beginning of the\ncommit phase, there is a step that checks whether the version of the system\n--- Page 114 ---\n86 CHAPTER 4 State management\nstate to be committed is valid. If the data is invalid, the commit is rejected.\nHere let me show you.\nListing4.9 Data validation inside the commit phase\nSystemState.commit = function(previous, next) {\nif(!SystemValidity.validate(previous, next)) { // not implemented for now\nthrow \"The system data to be committed is not valid!\";\n};\nthis.systemData = next;\n};\nTheo It sounds similar to a commit hook in Git.\nJoe I like your analogy!\nTheo Why are you passing the previous state in previous and the next state in next\nto SystemValidity.validate?\nJoe Because it allows SystemValidity.validate to optimize the validation in\nterms of computation. For example, we could validate just the data that has\nchanged.\nTIP In DOP, we validate the system data as a whole. Data validation is decoupled\nfrom data manipulation.\nTheo What does the code of SystemValidity.validate look like?\nJoe Someday, I will show you how to define a data schema and to validate that a\npiece of data conforms to a schema.\n NOTE See chapters 7 and 12 to see how Joe defines this data schema.\n4.7 Restoring previous states\nAnother advantage of the multi-version state approach with immutable data that is\nmanipulated via structural sharing is that we can keep track of the history of all the\nversions of the data without exploding the memory of our program. It allows us, for\ninstance, to restore the system back to an earlier state easily.\nTheo You told me earlier that it was easy to restore the system to a previous state.\nCould you show me how?\nJoe Happily, but before that, I’d like to make sure you understand why keeping\ntrack of all the versions of the data is efficient in terms of memory.\nTheo I think it’s related to the fact that immutable functions use structural sharing,\nand most of the data between subsequent versions of the state is shared.\nTIP Structural sharing allows us to keep many versions of the system state without\nexploding memory use.\nJoe Perfect! Now, I’ll show you how simple it is to undo a mutation. In order to\nimplement an undo mechanism, our SystemState class needs to have two\n--- Page 115 ---\n4.7 Restoring previous states 87\nreferences to the system data: systemData references the current state of the\nsystem, and previousSystemData references the previous state of the system.\nTheo That makes sense.\nJoe In the commit phase, we update both previousSystemData and systemData.\nTheo What does it take to implement an undo mechanism?\nJoe The undo is achieved by having systemData reference the same version of the\nsystem data as previousSystemData.\nTheo Could you walk me through an example?\nJoe To make things simple, I am going to give a number to each version of the sys-\ntem state. It starts at V0, and each time a mutation is committed, the version is\nincremented: V1, V2, V3, and so forth.\nTheo OK.\nJoe Let’s say that currently our system state is at V12 (see figure 4.8). In the\nSystemState object, systemData refers to V12, and previousSystemData\nrefers to V11.\npreviousSystemData\nMutationA Mutation B\nData V10 Data V11 Data V12\nsystemData\nFigure 4.8 When the system state is at V12, systemData refers to V12, and\npreviousSystemData refers to V11.\nTheo So far, so good...\nJoe Now, when a mutation is committed (for instance, adding a member), both\nreferences move forward: systemData refers to V13, and previousSystem-\nData refers to V12.\nJoe erases the whiteboard to make room for another diagram (figure 4.9). When he’s\nthrough with his drawing, he shows it to Theo.\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.9 When a mutation is committed, systemData refers to V13, and\npreviousSystemData refers to V12.\n--- Page 116 ---\n88 CHAPTER 4 State management\nTheo I suppose that when we undo the mutation, both references move backward.\nJoe In theory, yes, but in practice, it’s necessary to maintain a stack of all the state\nreferences. For now, to simplify things, we’ll maintain only a reference to the\nprevious version. As a consequence, when we undo the mutation, both refer-\nences refer to V12. Let me draw another diagram on the whiteboard that shows\nthis state (see figure 4.10).\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.10 When a mutation is undone, both systemData and previousSystemData refer\nto V12.\nTheo Could you show me how to implement this undo mechanism?\nJoe Actually, it takes only a couple of changes to the SystemState class. Pay atten-\ntion to the changes in the commit function. Inside systemDataBeforeUpdate,\nwe keep a reference to the current state of the system. If the validation and\nthe conflict resolution succeed, we update both previousSystemData and\nsystemData.\nListing4.10 The SystemState class with undo capability\nclass SystemState {\nsystemData;\npreviousSystemData;\nget() {\nreturn this.systemData;\n}\ncommit(previous, next) {\nvar systemDataBeforeUpdate = this.systemData;\nif(!Consistency.validate(previous, next)) {\nthrow \"The system data to be committed is not valid!\";\n}\nthis.systemData = next;\nthis.previousSystemData = systemDataBeforeUpdate;\n}\nundoLastMutation() {\nthis.systemData = this.previousSystemData;\n}\n}\n--- Page 117 ---\nSummary 89\nTheo I see that implementing System.undoLastMutation is simply a matter of hav-\ning systemData refer the same value as previousSystemData.\nJoe As I told you, if we need to allow multiple undos, the code would be a bit more\ncomplicated, but you get the idea.\nTheo I think so. Although Back to the Future belongs to the realm of science fiction, in\nDOP, time travel is real.\nSummary\n DOP principle #3 states that data is immutable.\n A mutation is an operation that changes the state of the system.\n In a multi-version approach to state management, mutations are split into cal-\nculation and commit phases.\n All data manipulation must be done via immutable functions. It is forbidden to\nuse the native hash map setter.\n Structural sharing allows us to create new versions of data efficiently (in terms of\nmemory and computation), where data that is common between the two ver-\nsions is shared instead of being copied.\n Structural sharing creates a new version of the data by recursively sharing the\nparts that don’t need to change.\n A mutation is split in two phases: calculation and commit.\n A function is said to be immutable when, instead of mutating the data, it creates\na new version of the data without changing the data it receives.\n During the calculation phase, data is manipulated with immutable functions that\nuse structural sharing.\n The calculation phase is stateless.\n During the commit phase, we update the system state.\n The responsibility of the commit phase is to move the system state forward to\nthe version of the state returned by the calculation phase.\n The data is immutable, but the state reference is mutable.\n The commit phase is stateful.\n We validate the system data as a whole. Data validation is decoupled from data\nmanipulation.\n The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system state in a central place before we update the\nstate.\n Keeping the history of the versions of the system data is memory efficient due to\nstructural sharing.\n Restoring the system to one of its previous states is straightforward due to the\nclear separation between the calculation phase and the commit phase.\n--- Page 118 ---\n90 CHAPTER 4 State management\n In order to use Lodash immutable functions, we use the Lodash FP module\n(https://github.com/lodash/lodash/wiki/FP-Guide).\nLodash functions introduced in this chapter\nFunction Description\nset(map, path, value) Creates a map with the same fields as map with the addition of a\n<path, value> field\n--- Page 119 ---\nBasic concurrency control\nConflicts at home\nThis chapter covers\n Managing concurrent mutations with a lock-free\noptimistic concurrency control strategy\n Supporting high throughput of reads and writes\n Reconciliation between concurrent mutations\nThe changes required for system manage concurrency are only in the commit\nphase. They involve a reconciliation algorithm that is universal, in the sense that it\ncan be used in any system where data is represented as an immutable hash map.\nThe implementation of the reconciliation algorithm is efficient because subse-\nquent versions of the system state are created via structural sharing.\nIn the previous chapter, we illustrated the multiversion approach to state man-\nagement, where a mutation is split into two distinct phases: the calculation phase\nthat deals only with computation, and the commit phase that moves the state ref-\nerence forward. Usually, in a production system, mutations occur concurrently.\nMoving the state forward naively like we did in the previous chapter is not appro-\npriate. In the present chapter, we are going to learn how to handle concurrent\nmutations.\n91\n--- Page 120 ---\n92 CHAPTER 5 Basic concurrency control\nIn DOP, because only the code of the commit phase is stateful, that allows us to use\nan optimistic concurrency control strategy that doesn’t involve any locking mechanism. As\na consequence, the throughput of reads and writes is high. The modifications to the\ncode are not trivial, as we have to implement an algorithm that reconciles concurrent\nmutations. But the modifications impact only the commit phase. The code for the cal-\nculation phase stays the same as in the previous chapter.\n NOTE This chapter requires more of an effort to grasp. The flow of the reconcilia-\ntion algorithm is definitely not trivial, and the implementation involves a nontrivial\nrecursion.\n5.1 Optimistic concurrency control\nThis morning, before getting to work, Theo takes Joe to the fitness room in the office and,\nwhile running on the step machine, the two men talk about their personal lives again. Joe\ntalks about a fight he had last night with Kay, who thinks that he pays more attention to his\nwork than to his family. Theo recounts the painful conflict he had with Jane, his wife,\nabout house budget management. They went to see a therapist, an expert in Imago Rela-\ntionship Therapy. Imago allowed them to transform their conflict into an opportunity to\ngrow and heal.\nJoe’s ears perk up when he hears the word conflict because today’s lesson is going to be\nabout resolving conflicts and concurrent mutations. A different kind of conflict, though....\nAfter a shower and a healthy breakfast, Theo and Joe get down to work.\nJoe Yesterday, I showed you how to manage state with immutable data, assuming\nthat no mutations occur concurrently. Today, I am going to show you how to\ndeal with concurrency control in DOP.\nTheo I’m curious to discover what kind of lock mechanisms you use in DOP to syn-\nchronize concurrent mutations.\nJoe In fact, we don’t use any lock mechanism!\nTheo Why not?\nJoe Locks hit performance, and if you’re not careful, your system could get into a\ndeadlock.\nTheo So, how do you handle possible conflicts between concurrent mutations in\nDOP?\nJoe In DOP, we use a lock-free strategy called optimistic concurrency control. It’s a\nstrategy that allows databases like Elasticsearch to be highly scalable.\n NOTE See https://www.elastic.co/elasticsearch/ to find out more about Elastic-\nsearch.\nTheo You sound like my couples therapist and her anger-free, optimistic conflict\nresolution strategy.\nJoe Optimistic concurrency control and DOP fit together well. As you will see in a\nmoment, optimistic concurrency control is super efficient when the system\ndata is immutable.\n--- Page 121 ---\n5.1 Optimistic concurrency control 93\nTIP Optimistic concurrency control with immutable data is super efficient.\nTheo How does it work?\nJoe Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTIP Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTheo What do you mean?\nJoe The calculation phase does its calculation as if it were the only mutation run-\nning. The commit phase is responsible for reconciling concurrent mutations\nwhen they don’t conflict or for aborting the mutation.\nTIP The calculation phase does its calculation as if it were the only mutation running.\nThe commit phase is responsible for trying to reconcile concurrent mutations.\nTheo That sounds quite challenging to implement.\nJoe Dealing with state is never trivial. But the good news is that the code for the\nreconciliation logic in the commit phase is universal.\nTheo Does that mean that the same code for the commit phase can be used in any\nDOP system?\nJoe Definitely. The code that implements the commit phase assumes nothing\nabout the details of the system except that the system data is represented as an\nimmutable map.\nTIP The implementation of the commit phase in optimistic concurrency control is\nuniversal. It can be used in any system where the data is represented by an immutable\nhash map.\nTheo That’s awesome!\nJoe Another cool thing is that handling concurrency doesn’t require any changes\nto the code in the calculation phase. From the calculation phase perspective,\nthe next version of the system data is computed in isolation as if no other muta-\ntions were running concurrently.\nJoe stands up to illustrate what he means on the whiteboard. While Theo looks at the draw-\ning in figure 5.1, Joe summarizes the information in table 5.1.\nTable 5.1 The two phases of a mutation with optimistic concurrency control\nPhase Responsibility State Implementation\nCalculation Compute next state in isolation Stateless Specific\nCommit Reconcile and update system state Stateful Common\n--- Page 122 ---\n94 CHAPTER 5 Basic concurrency control\nCalculation phase\nCapturesystem state\nComputenext version\nCommit phase\nYes No\nConcurrent mutations?\nYes No\nConflict?\nUpdatesystem state\nAbortmutation Reconcilemutations\nUpdatesystem state\nFigure 5.1 The logic flow\nof optimistic concurrency\ncontrol\n5.2 Reconciliation between concurrent mutations\nTheo Could you give me some examples of conflicting concurrent mutations?\nJoe Sure. One example would be two members trying to borrow the same book\ncopy. Another example might be when two librarians update the publication\nyear of the same book.\nTheo You mentioned that the code for the reconciliation logic in the commit phase\nis universal. What do you mean exactly by reconciliation logic?\nJoe It’s quite similar to what could happen in Git when you merge a branch back\ninto the main branch.\nTheo I love it when the main branch stays the same.\nJoe Yes, it’s nice when the merge has no conflicts and can be done automatically.\nDo you remember how Git handles the merge in that case?\nTheo Git does a fast-forward; it updates the main branch to be the same as the merge\nbranch.\nJoe Right! And what happens when you discover that, meanwhile, another devel-\noper has committed their code to the main branch?\nTheo Then Git does a three-way merge, trying to combine all the changes from the\ntwo merge branches with the main branch.\nJoe Does it always go smoothly?\nTheo Usually, yes, but it’s possible that two developers have modified the same line\nin the same file. I then have to manually resolve the conflict. I hate when that\nhappens!\nTIP In a production system, multiple mutations run concurrently. Before updating\nthe state, we need to reconcile the conflicts between possible concurrent mutations.\n--- Page 123 ---\n5.2 Reconciliation between concurrent mutations 95\nJoe In DOP, the reconciliation algorithm in the commit phase is quite similar to a\nmerge in Git, except instead of a manual conflict resolution, we abort the\nmutation. There are three possibilities to reconcile between possible concur-\nrent mutations: fast-forward, three-way merge, or abort.\nJoe goes to the whiteboard again. He draws the two diagrams shown in figures 5.2 and 5.3.\nYes No\nState has stayed the same\nYes No\nConcurrent mutations compatible?\nFast forward\n3-way Merge Abort\nFigure 5.2 The\nreconciliation flow\nThe version during\nthe Commit phase\ncurrent\nprevious\nnext\nThe base version\nfor the Calculation\nThe version Figure 5.3 When the commit phase\nphase\nreturned by the starts, there are three versions of the\nCalculation phase system state.\nTheo Could you explain in more detail?\nJoe When the commit phase of a mutation starts, we have three versions of the sys-\ntem state: previous, which is the version on which the calculation phase based\nits computation; current, which is the current version during the commit\nphase; and next, which is the version returned by the calculation phase.\nTheo Why would current be different than previous?\nJoe It happens when other mutations have run concurrently with our mutation.\nTheo I see.\nJoe If we are in a situation where the current state is the same as the previous state,\nit means that no mutations run concurrently. Therefore, as in Git, we can\nsafely fast-forward and update the state of the system with the next version.\nTheo What if the state has not stayed the same?\nJoe Then it means that mutations have run concurrently. We have to check for\nconflicts in a way similar to the three-way merge used by Git. The difference is\nthat instead of comparing lines, we compare fields of the system hash map.\nTheo Could you explain that?\n--- Page 124 ---\n96 CHAPTER 5 Basic concurrency control\nJoe We calculate the diff between previous and next and between previous and\ncurrent. If the two diffs have no fields in common, then there is no conflict\nbetween the mutations that have run concurrently. We can safely apply the\nchanges from previous to next into current.\nJoe makes his explanation visual with another diagram on the whiteboard. He then shows\nfigure 5.4 to Theo.\ndiffPreviousCurrent diffPreviousNext\ncurrent\nprevious merged\ndiffPreviousNext\nnext\nFigure 5.4 In a three-way merge, we calculate the diff between previous and\nnext, and we apply it to current.\nTheo What if there is a conflict?\nJoe Then we abort the mutation.\nTheo Aborting a user request seems unacceptable.\nJoe In fact, in a user-facing system, conflicting concurrent mutations are fairly rare.\nThat’s why it’s OK to abort and let the user run the mutation again. Here, let\nme draft a table to show you the differences between Git and DOP (table 5.2).\nTable 5.2 The analogy between Git and data-oriented programming\nData-oriented programming Git\nConcurrent mutations Different branches\nA version of the system data A commit\nState A reference\nCalculation phase Branching\nValidation Precommit hook\nReconciliation Merge\nFast-forward Fast-forward\nThree-way merge Three-way merge\nAbort Manual conflict resolution\nHash map Tree (folder)\nLeaf node Blob (file)\nData field Line of code\n--- Page 125 ---\n5.3 Reducing collections 97\nTheo Great! That helps, but in cases where two mutations update the same field of\nthe same entity, I think it’s fair enough to let the user know that the request\ncan’t be processed.\nTIP In a user-facing system, conflicting concurrent mutations are fairly rare.\n5.3 Reducing collections\nJoe Are you ready to challenge your mind with the implementation of the diff\nalgorithm?\nTheo Let’s take a short coffee break before, if you don’t mind. Then, I’ll be ready to\ntackle anything.\nAfter enjoying large mug of hot coffee and a few butter cookies, Theo and Joe are back to\nwork. Their discussion on the diff algorithm continues.\nJoe In the implementation of the diff algorithm, we’re going to reduce collections.\nTheo I heard about reducing collections in a talk about FP, but I don’t remember\nthe details. Could you remind me how this works?\nJoe Imagine you want to calculate the sum of the elements in a collection of num-\nbers. With Lodash’s _.reduce, it would look like this.\nListing5.1 Summing numbers with _.reduce\n_.reduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nTheo I don’t understand.\nJoe goes to the whiteboard and writes the description of _.reduce. Theo waits patiently\nuntil Joe puts the pen down before looking at the description.\nDescription of _.reduce\n_.reduce receives three arguments:\n coll—A collection of elements\n f—A function that receives two arguments\n initVal—A value\nLogic flow:\n1 Initialize currentRes with initVal.\n2 For each element x of coll, update currentRes with f(currentRes, x).\n3 Return currentRes.",
        "sections_found": []
      },
      "accurate_page_range": "102-125"
    },
    {
      "text": "- 4.2 Structural sharing",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "raw_line": "- 4.2 Structural sharing (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 31,
      "chapter_info": {
        "page": 102,
        "title": "State management",
        "pattern_matched": "Chapter 4",
        "text_preview": "74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead"
      },
      "chapter_sections": {
        "start_page": 102,
        "end_page": 125,
        "content": "\n--- Page 102 ---\n74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead of being copied.\nThis technique efficiently creates new versions of the system data, both in\nterms of memory and computation.\nTheo I’m intrigued.\nTIP With structural sharing, it’s efficient (in terms of memory and computation) to\ncreate new versions of data.\nJoe I’ll explain in detail how structural sharing works in a moment.\nTheo takes another look at the diagram in figure 4.1, which illustrates how the system state\nrefers to a version of the system data. Suddenly, a question emerges.\nTheo Are the previous versions of the system data kept?\nJoe In a simple application, previous versions are automatically removed by the\ngarbage collector. But, in some cases, we maintain historical references to pre-\nvious versions of the data.\nTheo What kind of cases?\nJoe For example, if we want to support time travel in our system, as in Git, we can\nmove the system back to a previous version of the state easily.\nTheo Now I understand what you mean by data is immutable, but the state reference\nis mutable!\n4.2 Structural sharing\nAs mentioned in the previous section, structural sharing enables the efficient cre-\nation of new versions of immutable data. In DOP, we use structural sharing in the\ncalculation phase of a mutation to compute the next state of the system based on\nthe current state of the system. Inside the calculation phase, we don’t have to deal\nwith state management; that is delayed to the commit phase. As a consequence, the\ncode involved in the calculation phase of a mutation is stateless and is as simple as\nthe code of a query.\nTheo I’m really intrigued by this more efficient way to create new versions of data.\nHow does it work?\nJoe Let’s take a simple example from our library system. Imagine that you want to\nmodify the value of a field in a book in the catalog; for instance, the publica-\ntion year of Watchmen. Can you tell me the information path for Watchmen’s\npublication year?\nTheo takes a quick look at the catalog data in figure 4.2. Then he answers Joe’s question.\n--- Page 103 ---\n4.2 Structural sharing 75\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 4.2 Visualization of the catalog data. The nodes in the information path to Watchmen’s publication\nyear are marked with a dotted border.\nTheo The information path for Watchmen’s publication year is [\"catalog\", \"books-\nByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Now, let me show how you to use the immutable function _.set that Lodash\nalso provides.\nTheo Wait! What do you mean by an immutable function? When I looked at the\nLodash documentation for _.set on their website, it said that it mutates the\nobject.\nJoe You’re right, but the default Lodash functions are not immutable. In order to\nuse an immutable version of the functions, we need to use the Lodash FP mod-\nule as explained in the Lodash FP guide.\n NOTE See https://lodash.com/docs/4.17.15#set to view Lodash’s documentation\nfor _.set, and see https://github.com/lodash/lodash/wiki/FP-Guide to view the\nLodash FP guide.\nTheo Do the immutable functions have the same signature as the mutable functions?\nJoe By default, the order of the arguments in immutable functions is shuffled.\nThe Lodash FP guide explains how to resolve this. With this piece of code,\n--- Page 104 ---\n76 CHAPTER 4 State management\nthe signature of the immutable functions is exactly the same as the mutable\nfunctions.\nListing4.1 Configuring Lodash so immutable and mutable functions have same signature\n_ = fp.convert({\n\"cap\": false,\n\"curry\": false,\n\"fixed\": false,\n\"immutable\": true,\n\"rearg\": false\n});\nTIP In order to use Lodash immutable functions, we use Lodash’s FP module, and\nwe configure it so that the signature of the immutable functions is the same as in the\nLodash documentation web site.\nTheo So basically, I can still rely on Lodash documentation when using immutable\nversions of the functions.\nJoe Except for the piece in the documentation that says the function mutates the\nobject.\nTheo Of course!\nJoe Now I’ll show you how to write code that creates a version of the library data\nwith the immutable function _.set.\nJoe’s fingers fly across Theo’s keyboard. Theo then looks at Joe’s code, which creates a ver-\nsion of the library data where the Watchmen publication year is set to 1986.\nListing4.2 Using _.set as an immutable function\nvar nextLibraryData = _.set(libraryData,\n[\"catalog\", \"booksByIsbn\",\n\"978-1779501127\", \"publicationYear\"],\n1986);\n NOTE A function is said to be immutable when, instead of mutating the data, it cre-\nates a new version of the data without changing the data it receives.\nTheo You told me earlier that structural sharing allowed immutable functions to be\nefficient in terms of memory and computation. Can you tell me what makes\nthem efficient?\nJoe With pleasure, but before that, you have to answer a series of questions. Are\nyou ready?\nTheo Yes, sure...\nJoe What part of the library data is impacted by updating the Watchmen publication\nyear: the UserManagement or the Catalog?\n--- Page 105 ---\n4.2 Structural sharing 77\nTheo Only the Catalog.\nJoe What part of the Catalog?\nTheo Only the booksByIsbn index.\nJoe What part of the booksByIsbn index?\nTheo Only the Book record that holds the information about Watchmen.\nJoe What part of the Book record?\nTheo Only the publicationYear field.\nJoe Perfect! Now, suppose that the current version of the library data looks like\nthis.\nJoe goes to the whiteboard and draws a diagram. Figure 4.3 shows the result.\nLibrary\nCatalog UserManagement\nauthorsByld booksBylsbn ...\n... watchmen\ntitle:Watchmen publicationYear:1987 authorlds\n...\nFigure 4.3 High-level visualization of the current version of Library\nTheo So far, so good...\nJoe Next, let me show you what an immutable function does when you use it to cre-\nate a new version of Library, where the publication year of Watchmen is set to\n1986 instead of 1987.\nJoe updates his diagram on the whiteboard. It now looks like figure 4.4.\n--- Page 106 ---\n78 CHAPTER 4 State management\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.4 Structural sharing provides an efficient way to create a new version of the data.\nNext Library is recursively made of nodes that use the parts of Library that are\ncommon between the two.\nTheo Could you explain?\nJoe The immutable function creates a fresh Library hash map, which recursively\nuses the parts of the current Library that are common between the two ver-\nsions instead of deeply copying them.\nTheo It’s a bit abstract for me.\nJoe The next version of Library uses the same UserManagement hash map as the\nold one. The Catalog inside the next Library uses the same authorsById as\nthe current Catalog. The Watchmen Book record inside the next Catalog uses\nall the fields of the current Book except for the publicationYear field.\nTheo So, in fact, most parts of the data are shared between the two versions. Right?\nJoe Exactly! That’s why this technique is called structural sharing.\nTIP Structural sharing provides an efficient way (both in terms of memory and com-\nputation) to create a new version of the data by recursively sharing the parts that don’t\nneed to change.\nTheo That’s very cool!\nJoe Indeed. Now let’s look at how to write a mutation for adding a member using\nimmutable functions.\n--- Page 107 ---\n4.2 Structural sharing 79\nOnce again, Joe goes to the whiteboard. Figure 4.5 shows the diagram that Joe draws to\nillustrate how structural sharing looks when we add a member.\n«Next»\nLibrary\nLibrary\n«Next»\nUserManagement Catalog\nuserManagement\n«Next»\nmembers librarians ...\nmembers\nFigure 4.5 Adding a member\nwith structural sharing. Most of\nthe data is shared between the\n... member0 member1\ntwo versions.\nTheo Awesome! The Catalog and the librarians hash maps don’t have to be copied!\nJoe Now, in terms of code, we have to write a Library.addMember function that\ndelegates to UserManagement.addMember.\nTheo I guess it’s going to be similar to the code we wrote earlier to implement the\nsearch books query, where Library.searchBooksByTitleJSON delegates to\nCatalog.searchBooksByTitle.\nJoe Similar in the sense that all the functions are static, and they receive the data\nthey manipulate as an argument. But there are two differences. First, a muta-\ntion could fail, for instance, if the member to be added already exists. Second,\nthe code for Library.addMember is a bit more elaborate than the code for\nLibrary.searchBooksByTitleJSON because we have to create a new version\nof Library that refers to the new version of UserManagement. Here, let me\nshow you an example.\nListing4.3 The code for the mutation that adds a member\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nChecks if a member with\nthrow \"Member already exists.\";\nthe same email address\n}\nalready exists\nvar nextUserManagement = _.set(\nuserManagement,\nCreates a new version of\ninfoPath,\nuserManagement that\nmember);\nincludes the member\nreturn nextUserManagement;\n};\n--- Page 108 ---\n80 CHAPTER 4 State management\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library,\n\"userManagement\",\nnextUserManagement);\nCreates a new version of\nreturn nextLibrary;\nlibrary that contains the new\n};\nversion of userManagement\nTheo To me, it’s a bit weird that immutable functions return an updated version of\nthe data instead of changing it in place.\nJoe It was also weird for me when I first encountered immutable data in Clojure\nseven years ago.\nTheo How long did it take you to get used to it?\nJoe A couple of weeks.\n4.3 Implementing structural sharing\nWhen Joe leaves the office, Theo meets Dave near the coffee machine. Dave looks perplexed.\nDave Who’s the guy that just left the office?\nTheo It’s Joe. My DOP mentor.\nDave What’s DOP?\nTheo DOP refers to data-oriented programming.\nDave I never heard that term before.\nTheo It’s not well-known by programmers yet, but it’s quite a powerful programming\nparadigm. From what I’ve seen so far, it makes programming much simpler.\nDave Can you give me an example?\nTheo I just learned about structural sharing and how it makes it possible to create\nnew versions of data, effectively without copying.\nDave How does that work?\nTheo takes Dave to his office and shows him Joe’s diagram on the whiteboard (see figure 4.6).\nIt takes Theo a few minutes to explain to Dave what it does exactly, but in the end, Dave\ngets it.\nDave What does the implementation of structural sharing look like?\nTheo I don’t know. I used the _.set function from Lodash.\nDave It sounds like an interesting challenge.\nTheo Take the challenge if you want. Right now, I’m too tired for this recursive algo-\nrithmic stuff.\n--- Page 109 ---\n4.3 Implementing structural sharing 81\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.6 Structural sharing in action\nThe next day, Theo stops by Dave’s cubicle before heading to his office. Dave, with a touch\nof pride, shows Theo his implementation of structural sharing. Theo is amazed by the fact\nthat it’s only 11 lines of JavaScript code!\nListing4.4 The implementation of structural sharing\nfunction setImmutable(map, path, v) {\nvar modifiedNode = v;\nvar k = path[0];\nvar restOfPath = path.slice(1);\nif (restOfPath.length > 0) {\nmodifiedNode = setImmutable(map[k], restOfPath, v);\n}\nvar res = Object.assign({}, map);\nShallow\nres[k] = modifiedNode;\nclones a map\nreturn res;\nin JavaScript.\n}\nTheo Dave, you’re brilliant!\nDave (smiling) Aw, shucks.\nTheo Oops, I have to go. I’m already late for my session with Joe! Joe is probably wait-\ning in my office, biting his nails.\n--- Page 110 ---\n82 CHAPTER 4 State management\n4.4 Data safety\nJoe is about to start the day’s lesson. Theo asks him a question about yesterday’s material\ninstead.\nTheo Something isn’t clear to me regarding this structural sharing stuff. What hap-\npens if we write code that modifies the data part that’s shared between the two\nversions of the data? Does the change affect both versions?\nJoe Could you please write a code snippet that illustrates your question?\nTheo starts typing on his laptop. He comes up with this code to illustrate modifying a piece\nof data shared between two versions.\nListing4.5 Modifying data that’s shared between two versions\nvar books = {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n};\nvar nextBooks = _.set(books, [\"978-1779501127\", \"publicationYear\"], 1986)\nconsole.log(\"Before:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\nbooks[\"978-1779501127\"][\"authorIds\"][1] = \"dave-chester-gibbons\";\nconsole.log(\"After:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\n// → Before: dave-gibbons\n// → After: dave-chester-gibbons\nTheo My question is, what is the value of isBlocked in updatedMember?\nJoe The answer is that mutating data via the native hash map setter is forbidden.\nAll the data manipulation must be done via immutable functions.\n NOTE All data manipulation must be done with immutable functions. It is forbid-\nden to use the native hash map setter.\nTheo When you say “forbidden,” you mean that it’s up to the developer to make sure\nit doesn’t happen. Right?\nJoe Exactly.\nTheo Is there a way to protect our system from a developer’s mistake?\nJoe Yes, there is a way to ensure the immutability of the data at the level of the data\nstructure. It’s called persistent data structures.\nTheo Are persistent data structures also efficient in terms of memory and computation?\nJoe Actually, the way data is organized inside persistent data structures make them\neven more efficient than immutable functions.\n--- Page 111 ---\n4.5 The commit phase of a mutation 83\nTIP Persistent data structures are immutable at the level of the data. There is no way\nto mutate them, even by mistake.\nTheo Are there libraries providing persistent data structures?\nJoe Definitely. I just happen to have a list of those libraries on my computer.\nJoe, being well-organized for a programmer, quickly brings up his list. He shows it to Theo:\n Immutable.js in JavaScript at https://immutable-js.com/\n Paguro in Java at https://github.com/GlenKPeterson/Paguro\n Immutable Collections in C# at http://mng.bz/y4Ke\n Pyrsistent in Python at https://github.com/tobgu/pyrsistent\n Hamster in Ruby at https://github.com/hamstergem/hamster\nTheo Why not use persistent data structures instead of immutable functions?\nJoe The drawback of persistent data structures is that they are not native. This\nmeans that working with them requires conversion from native to persistent\nand from persistent to native.\nTheo What approach would you recommend?\nJoe If you want to play around a bit, then start with immutable functions. But for a\nproduction application, I’d recommend using persistent data structures.\nTheo Too bad the native data structures aren’t persistent!\nJoe That’s one of the reasons why I love Clojure—the native data structures of the\nlanguage are immutable!\n4.5 The commit phase of a mutation\nSo far, we saw how to implement the calculation phase of a mutation. The calculation\nphase is stateless in the sense that it doesn’t make any change to the system. Now, let’s\nsee how to update the state of the system inside the commit phase.\nTheo takes another look at the code for Library.addMember. Something bothers him:\nthis function returns a new state of the library that contains an additional member, but it\ndoesn’t affect the current state of the library.\nListing4.6 The commit phase moves the system state forward\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nTheo I see that Library.addMember doesn’t change the state of the library. How\ndoes the library state get updated?\n--- Page 112 ---\n84 CHAPTER 4 State management\nJoe That’s an excellent question. Library.addMember deals only with data calcula-\ntion and is stateless. The state is updated in the commit phase by moving for-\nward the version of the state that the system state refers to.\nTheo What do you mean by that?\nJoe Here’s what happens when we add a member to the system. The calculation\nphase creates a version of the state that has two members. Before the commit\nphase, the system state refers to the version of the state with one member. The\nresponsibility of the commit phase is to move the system state forward so that it\nrefers to the version of the state with two members.\nTIP The responsibility of the commit phase is to move the system state forward to the\nversion of the state returned by the calculation phase.\nJoe draws another illustration on the whiteboard (figure 4.7). He hopes it helps to clear up\nany misunderstanding Theo may have.\nBefore Commit After Commit\nState with one State with one\nSystem State\nmember member\naddMember addMember\nState with two State with two\nSystem State\nmembers members\nFigure 4.7 The commit phase moves the system state forward.\nTheo How is this implemented?\nJoe The code is made of two classes: System, a singleton stateful class that imple-\nments the mutations, and SystemState, a singleton stateful class that manages\nthe system state.\nTheo It sounds to me like classic OOP.\nJoe Right, and this part of the system being stateful is OOP-like.\nTheo I’m happy to see that you still find some utility in OOP.\nJoe Meditation taught me that every part of our universe has a role to play.\nTheo Nice! Could you show me some code?\nJoe Sure.\nJoe thinks for a moment before starting to type. He wants to show the System class and its\nimplementation of the addMember mutation.\nListing4.7 The System class\nclass System {\naddMember(member) {\nvar previous = SystemState.get();\n--- Page 113 ---\n4.6 Ensuring system state integrity 85\nvar next = Library.addMember(previous, member);\nSystemState.commit(previous, next);\nSystemState is covered\n}\nin listing 4.8.\n}\nTheo What does SystemState look like?\nJoe I had a feeling you were going to ask that. Here’s the code for the System-\nState class, which is a stateful class!\nListing4.8 The SystemState class\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nTheo I don’t get the point of SystemState. It’s a simple class with a getter and a\ncommit function, right?\nJoe In a moment, we are going to enrich the code of the SystemState.commit\nmethod so that it provides data validation and history tracking. For now, the\nimportant thing to notice is that the code of the calculation phase is stateless\nand is decoupled from the code of the commit phase, which is stateful.\nTIP The calculation phase is stateless. The commit phase is stateful.\n4.6 Ensuring system state integrity\nTheo Something still bothers me about the way functions manipulate immutable\ndata in the calculation phase. How do we preserve data integrity?\nJoe What do you mean?\nTheo In OOP, data is manipulated only by methods that belong to the same class as\nthe data. It prevents other classes from corrupting the inner state of the class.\nJoe Could you give me an example of an invalid state of the library?\nTheo For example, imagine that the code of a mutation adds a book item to the\nbook lendings of a member without marking the book item as lent in the cata-\nlog. Then the system data would be corrupted.\nJoe In DOP, we have the privilege of ensuring data integrity at the level of the\nwhole system instead of scattering the validation among many classes.\nTheo How does that work?\nJoe The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system data in a central place. At the beginning of the\ncommit phase, there is a step that checks whether the version of the system\n--- Page 114 ---\n86 CHAPTER 4 State management\nstate to be committed is valid. If the data is invalid, the commit is rejected.\nHere let me show you.\nListing4.9 Data validation inside the commit phase\nSystemState.commit = function(previous, next) {\nif(!SystemValidity.validate(previous, next)) { // not implemented for now\nthrow \"The system data to be committed is not valid!\";\n};\nthis.systemData = next;\n};\nTheo It sounds similar to a commit hook in Git.\nJoe I like your analogy!\nTheo Why are you passing the previous state in previous and the next state in next\nto SystemValidity.validate?\nJoe Because it allows SystemValidity.validate to optimize the validation in\nterms of computation. For example, we could validate just the data that has\nchanged.\nTIP In DOP, we validate the system data as a whole. Data validation is decoupled\nfrom data manipulation.\nTheo What does the code of SystemValidity.validate look like?\nJoe Someday, I will show you how to define a data schema and to validate that a\npiece of data conforms to a schema.\n NOTE See chapters 7 and 12 to see how Joe defines this data schema.\n4.7 Restoring previous states\nAnother advantage of the multi-version state approach with immutable data that is\nmanipulated via structural sharing is that we can keep track of the history of all the\nversions of the data without exploding the memory of our program. It allows us, for\ninstance, to restore the system back to an earlier state easily.\nTheo You told me earlier that it was easy to restore the system to a previous state.\nCould you show me how?\nJoe Happily, but before that, I’d like to make sure you understand why keeping\ntrack of all the versions of the data is efficient in terms of memory.\nTheo I think it’s related to the fact that immutable functions use structural sharing,\nand most of the data between subsequent versions of the state is shared.\nTIP Structural sharing allows us to keep many versions of the system state without\nexploding memory use.\nJoe Perfect! Now, I’ll show you how simple it is to undo a mutation. In order to\nimplement an undo mechanism, our SystemState class needs to have two\n--- Page 115 ---\n4.7 Restoring previous states 87\nreferences to the system data: systemData references the current state of the\nsystem, and previousSystemData references the previous state of the system.\nTheo That makes sense.\nJoe In the commit phase, we update both previousSystemData and systemData.\nTheo What does it take to implement an undo mechanism?\nJoe The undo is achieved by having systemData reference the same version of the\nsystem data as previousSystemData.\nTheo Could you walk me through an example?\nJoe To make things simple, I am going to give a number to each version of the sys-\ntem state. It starts at V0, and each time a mutation is committed, the version is\nincremented: V1, V2, V3, and so forth.\nTheo OK.\nJoe Let’s say that currently our system state is at V12 (see figure 4.8). In the\nSystemState object, systemData refers to V12, and previousSystemData\nrefers to V11.\npreviousSystemData\nMutationA Mutation B\nData V10 Data V11 Data V12\nsystemData\nFigure 4.8 When the system state is at V12, systemData refers to V12, and\npreviousSystemData refers to V11.\nTheo So far, so good...\nJoe Now, when a mutation is committed (for instance, adding a member), both\nreferences move forward: systemData refers to V13, and previousSystem-\nData refers to V12.\nJoe erases the whiteboard to make room for another diagram (figure 4.9). When he’s\nthrough with his drawing, he shows it to Theo.\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.9 When a mutation is committed, systemData refers to V13, and\npreviousSystemData refers to V12.\n--- Page 116 ---\n88 CHAPTER 4 State management\nTheo I suppose that when we undo the mutation, both references move backward.\nJoe In theory, yes, but in practice, it’s necessary to maintain a stack of all the state\nreferences. For now, to simplify things, we’ll maintain only a reference to the\nprevious version. As a consequence, when we undo the mutation, both refer-\nences refer to V12. Let me draw another diagram on the whiteboard that shows\nthis state (see figure 4.10).\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.10 When a mutation is undone, both systemData and previousSystemData refer\nto V12.\nTheo Could you show me how to implement this undo mechanism?\nJoe Actually, it takes only a couple of changes to the SystemState class. Pay atten-\ntion to the changes in the commit function. Inside systemDataBeforeUpdate,\nwe keep a reference to the current state of the system. If the validation and\nthe conflict resolution succeed, we update both previousSystemData and\nsystemData.\nListing4.10 The SystemState class with undo capability\nclass SystemState {\nsystemData;\npreviousSystemData;\nget() {\nreturn this.systemData;\n}\ncommit(previous, next) {\nvar systemDataBeforeUpdate = this.systemData;\nif(!Consistency.validate(previous, next)) {\nthrow \"The system data to be committed is not valid!\";\n}\nthis.systemData = next;\nthis.previousSystemData = systemDataBeforeUpdate;\n}\nundoLastMutation() {\nthis.systemData = this.previousSystemData;\n}\n}\n--- Page 117 ---\nSummary 89\nTheo I see that implementing System.undoLastMutation is simply a matter of hav-\ning systemData refer the same value as previousSystemData.\nJoe As I told you, if we need to allow multiple undos, the code would be a bit more\ncomplicated, but you get the idea.\nTheo I think so. Although Back to the Future belongs to the realm of science fiction, in\nDOP, time travel is real.\nSummary\n DOP principle #3 states that data is immutable.\n A mutation is an operation that changes the state of the system.\n In a multi-version approach to state management, mutations are split into cal-\nculation and commit phases.\n All data manipulation must be done via immutable functions. It is forbidden to\nuse the native hash map setter.\n Structural sharing allows us to create new versions of data efficiently (in terms of\nmemory and computation), where data that is common between the two ver-\nsions is shared instead of being copied.\n Structural sharing creates a new version of the data by recursively sharing the\nparts that don’t need to change.\n A mutation is split in two phases: calculation and commit.\n A function is said to be immutable when, instead of mutating the data, it creates\na new version of the data without changing the data it receives.\n During the calculation phase, data is manipulated with immutable functions that\nuse structural sharing.\n The calculation phase is stateless.\n During the commit phase, we update the system state.\n The responsibility of the commit phase is to move the system state forward to\nthe version of the state returned by the calculation phase.\n The data is immutable, but the state reference is mutable.\n The commit phase is stateful.\n We validate the system data as a whole. Data validation is decoupled from data\nmanipulation.\n The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system state in a central place before we update the\nstate.\n Keeping the history of the versions of the system data is memory efficient due to\nstructural sharing.\n Restoring the system to one of its previous states is straightforward due to the\nclear separation between the calculation phase and the commit phase.\n--- Page 118 ---\n90 CHAPTER 4 State management\n In order to use Lodash immutable functions, we use the Lodash FP module\n(https://github.com/lodash/lodash/wiki/FP-Guide).\nLodash functions introduced in this chapter\nFunction Description\nset(map, path, value) Creates a map with the same fields as map with the addition of a\n<path, value> field\n--- Page 119 ---\nBasic concurrency control\nConflicts at home\nThis chapter covers\n Managing concurrent mutations with a lock-free\noptimistic concurrency control strategy\n Supporting high throughput of reads and writes\n Reconciliation between concurrent mutations\nThe changes required for system manage concurrency are only in the commit\nphase. They involve a reconciliation algorithm that is universal, in the sense that it\ncan be used in any system where data is represented as an immutable hash map.\nThe implementation of the reconciliation algorithm is efficient because subse-\nquent versions of the system state are created via structural sharing.\nIn the previous chapter, we illustrated the multiversion approach to state man-\nagement, where a mutation is split into two distinct phases: the calculation phase\nthat deals only with computation, and the commit phase that moves the state ref-\nerence forward. Usually, in a production system, mutations occur concurrently.\nMoving the state forward naively like we did in the previous chapter is not appro-\npriate. In the present chapter, we are going to learn how to handle concurrent\nmutations.\n91\n--- Page 120 ---\n92 CHAPTER 5 Basic concurrency control\nIn DOP, because only the code of the commit phase is stateful, that allows us to use\nan optimistic concurrency control strategy that doesn’t involve any locking mechanism. As\na consequence, the throughput of reads and writes is high. The modifications to the\ncode are not trivial, as we have to implement an algorithm that reconciles concurrent\nmutations. But the modifications impact only the commit phase. The code for the cal-\nculation phase stays the same as in the previous chapter.\n NOTE This chapter requires more of an effort to grasp. The flow of the reconcilia-\ntion algorithm is definitely not trivial, and the implementation involves a nontrivial\nrecursion.\n5.1 Optimistic concurrency control\nThis morning, before getting to work, Theo takes Joe to the fitness room in the office and,\nwhile running on the step machine, the two men talk about their personal lives again. Joe\ntalks about a fight he had last night with Kay, who thinks that he pays more attention to his\nwork than to his family. Theo recounts the painful conflict he had with Jane, his wife,\nabout house budget management. They went to see a therapist, an expert in Imago Rela-\ntionship Therapy. Imago allowed them to transform their conflict into an opportunity to\ngrow and heal.\nJoe’s ears perk up when he hears the word conflict because today’s lesson is going to be\nabout resolving conflicts and concurrent mutations. A different kind of conflict, though....\nAfter a shower and a healthy breakfast, Theo and Joe get down to work.\nJoe Yesterday, I showed you how to manage state with immutable data, assuming\nthat no mutations occur concurrently. Today, I am going to show you how to\ndeal with concurrency control in DOP.\nTheo I’m curious to discover what kind of lock mechanisms you use in DOP to syn-\nchronize concurrent mutations.\nJoe In fact, we don’t use any lock mechanism!\nTheo Why not?\nJoe Locks hit performance, and if you’re not careful, your system could get into a\ndeadlock.\nTheo So, how do you handle possible conflicts between concurrent mutations in\nDOP?\nJoe In DOP, we use a lock-free strategy called optimistic concurrency control. It’s a\nstrategy that allows databases like Elasticsearch to be highly scalable.\n NOTE See https://www.elastic.co/elasticsearch/ to find out more about Elastic-\nsearch.\nTheo You sound like my couples therapist and her anger-free, optimistic conflict\nresolution strategy.\nJoe Optimistic concurrency control and DOP fit together well. As you will see in a\nmoment, optimistic concurrency control is super efficient when the system\ndata is immutable.\n--- Page 121 ---\n5.1 Optimistic concurrency control 93\nTIP Optimistic concurrency control with immutable data is super efficient.\nTheo How does it work?\nJoe Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTIP Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTheo What do you mean?\nJoe The calculation phase does its calculation as if it were the only mutation run-\nning. The commit phase is responsible for reconciling concurrent mutations\nwhen they don’t conflict or for aborting the mutation.\nTIP The calculation phase does its calculation as if it were the only mutation running.\nThe commit phase is responsible for trying to reconcile concurrent mutations.\nTheo That sounds quite challenging to implement.\nJoe Dealing with state is never trivial. But the good news is that the code for the\nreconciliation logic in the commit phase is universal.\nTheo Does that mean that the same code for the commit phase can be used in any\nDOP system?\nJoe Definitely. The code that implements the commit phase assumes nothing\nabout the details of the system except that the system data is represented as an\nimmutable map.\nTIP The implementation of the commit phase in optimistic concurrency control is\nuniversal. It can be used in any system where the data is represented by an immutable\nhash map.\nTheo That’s awesome!\nJoe Another cool thing is that handling concurrency doesn’t require any changes\nto the code in the calculation phase. From the calculation phase perspective,\nthe next version of the system data is computed in isolation as if no other muta-\ntions were running concurrently.\nJoe stands up to illustrate what he means on the whiteboard. While Theo looks at the draw-\ning in figure 5.1, Joe summarizes the information in table 5.1.\nTable 5.1 The two phases of a mutation with optimistic concurrency control\nPhase Responsibility State Implementation\nCalculation Compute next state in isolation Stateless Specific\nCommit Reconcile and update system state Stateful Common\n--- Page 122 ---\n94 CHAPTER 5 Basic concurrency control\nCalculation phase\nCapturesystem state\nComputenext version\nCommit phase\nYes No\nConcurrent mutations?\nYes No\nConflict?\nUpdatesystem state\nAbortmutation Reconcilemutations\nUpdatesystem state\nFigure 5.1 The logic flow\nof optimistic concurrency\ncontrol\n5.2 Reconciliation between concurrent mutations\nTheo Could you give me some examples of conflicting concurrent mutations?\nJoe Sure. One example would be two members trying to borrow the same book\ncopy. Another example might be when two librarians update the publication\nyear of the same book.\nTheo You mentioned that the code for the reconciliation logic in the commit phase\nis universal. What do you mean exactly by reconciliation logic?\nJoe It’s quite similar to what could happen in Git when you merge a branch back\ninto the main branch.\nTheo I love it when the main branch stays the same.\nJoe Yes, it’s nice when the merge has no conflicts and can be done automatically.\nDo you remember how Git handles the merge in that case?\nTheo Git does a fast-forward; it updates the main branch to be the same as the merge\nbranch.\nJoe Right! And what happens when you discover that, meanwhile, another devel-\noper has committed their code to the main branch?\nTheo Then Git does a three-way merge, trying to combine all the changes from the\ntwo merge branches with the main branch.\nJoe Does it always go smoothly?\nTheo Usually, yes, but it’s possible that two developers have modified the same line\nin the same file. I then have to manually resolve the conflict. I hate when that\nhappens!\nTIP In a production system, multiple mutations run concurrently. Before updating\nthe state, we need to reconcile the conflicts between possible concurrent mutations.\n--- Page 123 ---\n5.2 Reconciliation between concurrent mutations 95\nJoe In DOP, the reconciliation algorithm in the commit phase is quite similar to a\nmerge in Git, except instead of a manual conflict resolution, we abort the\nmutation. There are three possibilities to reconcile between possible concur-\nrent mutations: fast-forward, three-way merge, or abort.\nJoe goes to the whiteboard again. He draws the two diagrams shown in figures 5.2 and 5.3.\nYes No\nState has stayed the same\nYes No\nConcurrent mutations compatible?\nFast forward\n3-way Merge Abort\nFigure 5.2 The\nreconciliation flow\nThe version during\nthe Commit phase\ncurrent\nprevious\nnext\nThe base version\nfor the Calculation\nThe version Figure 5.3 When the commit phase\nphase\nreturned by the starts, there are three versions of the\nCalculation phase system state.\nTheo Could you explain in more detail?\nJoe When the commit phase of a mutation starts, we have three versions of the sys-\ntem state: previous, which is the version on which the calculation phase based\nits computation; current, which is the current version during the commit\nphase; and next, which is the version returned by the calculation phase.\nTheo Why would current be different than previous?\nJoe It happens when other mutations have run concurrently with our mutation.\nTheo I see.\nJoe If we are in a situation where the current state is the same as the previous state,\nit means that no mutations run concurrently. Therefore, as in Git, we can\nsafely fast-forward and update the state of the system with the next version.\nTheo What if the state has not stayed the same?\nJoe Then it means that mutations have run concurrently. We have to check for\nconflicts in a way similar to the three-way merge used by Git. The difference is\nthat instead of comparing lines, we compare fields of the system hash map.\nTheo Could you explain that?\n--- Page 124 ---\n96 CHAPTER 5 Basic concurrency control\nJoe We calculate the diff between previous and next and between previous and\ncurrent. If the two diffs have no fields in common, then there is no conflict\nbetween the mutations that have run concurrently. We can safely apply the\nchanges from previous to next into current.\nJoe makes his explanation visual with another diagram on the whiteboard. He then shows\nfigure 5.4 to Theo.\ndiffPreviousCurrent diffPreviousNext\ncurrent\nprevious merged\ndiffPreviousNext\nnext\nFigure 5.4 In a three-way merge, we calculate the diff between previous and\nnext, and we apply it to current.\nTheo What if there is a conflict?\nJoe Then we abort the mutation.\nTheo Aborting a user request seems unacceptable.\nJoe In fact, in a user-facing system, conflicting concurrent mutations are fairly rare.\nThat’s why it’s OK to abort and let the user run the mutation again. Here, let\nme draft a table to show you the differences between Git and DOP (table 5.2).\nTable 5.2 The analogy between Git and data-oriented programming\nData-oriented programming Git\nConcurrent mutations Different branches\nA version of the system data A commit\nState A reference\nCalculation phase Branching\nValidation Precommit hook\nReconciliation Merge\nFast-forward Fast-forward\nThree-way merge Three-way merge\nAbort Manual conflict resolution\nHash map Tree (folder)\nLeaf node Blob (file)\nData field Line of code\n--- Page 125 ---\n5.3 Reducing collections 97\nTheo Great! That helps, but in cases where two mutations update the same field of\nthe same entity, I think it’s fair enough to let the user know that the request\ncan’t be processed.\nTIP In a user-facing system, conflicting concurrent mutations are fairly rare.\n5.3 Reducing collections\nJoe Are you ready to challenge your mind with the implementation of the diff\nalgorithm?\nTheo Let’s take a short coffee break before, if you don’t mind. Then, I’ll be ready to\ntackle anything.\nAfter enjoying large mug of hot coffee and a few butter cookies, Theo and Joe are back to\nwork. Their discussion on the diff algorithm continues.\nJoe In the implementation of the diff algorithm, we’re going to reduce collections.\nTheo I heard about reducing collections in a talk about FP, but I don’t remember\nthe details. Could you remind me how this works?\nJoe Imagine you want to calculate the sum of the elements in a collection of num-\nbers. With Lodash’s _.reduce, it would look like this.\nListing5.1 Summing numbers with _.reduce\n_.reduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nTheo I don’t understand.\nJoe goes to the whiteboard and writes the description of _.reduce. Theo waits patiently\nuntil Joe puts the pen down before looking at the description.\nDescription of _.reduce\n_.reduce receives three arguments:\n coll—A collection of elements\n f—A function that receives two arguments\n initVal—A value\nLogic flow:\n1 Initialize currentRes with initVal.\n2 For each element x of coll, update currentRes with f(currentRes, x).\n3 Return currentRes.",
        "sections_found": []
      },
      "accurate_page_range": "102-125"
    },
    {
      "text": "- 4.3 Implementing structural sharing",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "raw_line": "- 4.3 Implementing structural sharing (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 32,
      "chapter_info": {
        "page": 102,
        "title": "State management",
        "pattern_matched": "Chapter 4",
        "text_preview": "74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead"
      },
      "chapter_sections": {
        "start_page": 102,
        "end_page": 125,
        "content": "\n--- Page 102 ---\n74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead of being copied.\nThis technique efficiently creates new versions of the system data, both in\nterms of memory and computation.\nTheo I’m intrigued.\nTIP With structural sharing, it’s efficient (in terms of memory and computation) to\ncreate new versions of data.\nJoe I’ll explain in detail how structural sharing works in a moment.\nTheo takes another look at the diagram in figure 4.1, which illustrates how the system state\nrefers to a version of the system data. Suddenly, a question emerges.\nTheo Are the previous versions of the system data kept?\nJoe In a simple application, previous versions are automatically removed by the\ngarbage collector. But, in some cases, we maintain historical references to pre-\nvious versions of the data.\nTheo What kind of cases?\nJoe For example, if we want to support time travel in our system, as in Git, we can\nmove the system back to a previous version of the state easily.\nTheo Now I understand what you mean by data is immutable, but the state reference\nis mutable!\n4.2 Structural sharing\nAs mentioned in the previous section, structural sharing enables the efficient cre-\nation of new versions of immutable data. In DOP, we use structural sharing in the\ncalculation phase of a mutation to compute the next state of the system based on\nthe current state of the system. Inside the calculation phase, we don’t have to deal\nwith state management; that is delayed to the commit phase. As a consequence, the\ncode involved in the calculation phase of a mutation is stateless and is as simple as\nthe code of a query.\nTheo I’m really intrigued by this more efficient way to create new versions of data.\nHow does it work?\nJoe Let’s take a simple example from our library system. Imagine that you want to\nmodify the value of a field in a book in the catalog; for instance, the publica-\ntion year of Watchmen. Can you tell me the information path for Watchmen’s\npublication year?\nTheo takes a quick look at the catalog data in figure 4.2. Then he answers Joe’s question.\n--- Page 103 ---\n4.2 Structural sharing 75\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 4.2 Visualization of the catalog data. The nodes in the information path to Watchmen’s publication\nyear are marked with a dotted border.\nTheo The information path for Watchmen’s publication year is [\"catalog\", \"books-\nByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Now, let me show how you to use the immutable function _.set that Lodash\nalso provides.\nTheo Wait! What do you mean by an immutable function? When I looked at the\nLodash documentation for _.set on their website, it said that it mutates the\nobject.\nJoe You’re right, but the default Lodash functions are not immutable. In order to\nuse an immutable version of the functions, we need to use the Lodash FP mod-\nule as explained in the Lodash FP guide.\n NOTE See https://lodash.com/docs/4.17.15#set to view Lodash’s documentation\nfor _.set, and see https://github.com/lodash/lodash/wiki/FP-Guide to view the\nLodash FP guide.\nTheo Do the immutable functions have the same signature as the mutable functions?\nJoe By default, the order of the arguments in immutable functions is shuffled.\nThe Lodash FP guide explains how to resolve this. With this piece of code,\n--- Page 104 ---\n76 CHAPTER 4 State management\nthe signature of the immutable functions is exactly the same as the mutable\nfunctions.\nListing4.1 Configuring Lodash so immutable and mutable functions have same signature\n_ = fp.convert({\n\"cap\": false,\n\"curry\": false,\n\"fixed\": false,\n\"immutable\": true,\n\"rearg\": false\n});\nTIP In order to use Lodash immutable functions, we use Lodash’s FP module, and\nwe configure it so that the signature of the immutable functions is the same as in the\nLodash documentation web site.\nTheo So basically, I can still rely on Lodash documentation when using immutable\nversions of the functions.\nJoe Except for the piece in the documentation that says the function mutates the\nobject.\nTheo Of course!\nJoe Now I’ll show you how to write code that creates a version of the library data\nwith the immutable function _.set.\nJoe’s fingers fly across Theo’s keyboard. Theo then looks at Joe’s code, which creates a ver-\nsion of the library data where the Watchmen publication year is set to 1986.\nListing4.2 Using _.set as an immutable function\nvar nextLibraryData = _.set(libraryData,\n[\"catalog\", \"booksByIsbn\",\n\"978-1779501127\", \"publicationYear\"],\n1986);\n NOTE A function is said to be immutable when, instead of mutating the data, it cre-\nates a new version of the data without changing the data it receives.\nTheo You told me earlier that structural sharing allowed immutable functions to be\nefficient in terms of memory and computation. Can you tell me what makes\nthem efficient?\nJoe With pleasure, but before that, you have to answer a series of questions. Are\nyou ready?\nTheo Yes, sure...\nJoe What part of the library data is impacted by updating the Watchmen publication\nyear: the UserManagement or the Catalog?\n--- Page 105 ---\n4.2 Structural sharing 77\nTheo Only the Catalog.\nJoe What part of the Catalog?\nTheo Only the booksByIsbn index.\nJoe What part of the booksByIsbn index?\nTheo Only the Book record that holds the information about Watchmen.\nJoe What part of the Book record?\nTheo Only the publicationYear field.\nJoe Perfect! Now, suppose that the current version of the library data looks like\nthis.\nJoe goes to the whiteboard and draws a diagram. Figure 4.3 shows the result.\nLibrary\nCatalog UserManagement\nauthorsByld booksBylsbn ...\n... watchmen\ntitle:Watchmen publicationYear:1987 authorlds\n...\nFigure 4.3 High-level visualization of the current version of Library\nTheo So far, so good...\nJoe Next, let me show you what an immutable function does when you use it to cre-\nate a new version of Library, where the publication year of Watchmen is set to\n1986 instead of 1987.\nJoe updates his diagram on the whiteboard. It now looks like figure 4.4.\n--- Page 106 ---\n78 CHAPTER 4 State management\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.4 Structural sharing provides an efficient way to create a new version of the data.\nNext Library is recursively made of nodes that use the parts of Library that are\ncommon between the two.\nTheo Could you explain?\nJoe The immutable function creates a fresh Library hash map, which recursively\nuses the parts of the current Library that are common between the two ver-\nsions instead of deeply copying them.\nTheo It’s a bit abstract for me.\nJoe The next version of Library uses the same UserManagement hash map as the\nold one. The Catalog inside the next Library uses the same authorsById as\nthe current Catalog. The Watchmen Book record inside the next Catalog uses\nall the fields of the current Book except for the publicationYear field.\nTheo So, in fact, most parts of the data are shared between the two versions. Right?\nJoe Exactly! That’s why this technique is called structural sharing.\nTIP Structural sharing provides an efficient way (both in terms of memory and com-\nputation) to create a new version of the data by recursively sharing the parts that don’t\nneed to change.\nTheo That’s very cool!\nJoe Indeed. Now let’s look at how to write a mutation for adding a member using\nimmutable functions.\n--- Page 107 ---\n4.2 Structural sharing 79\nOnce again, Joe goes to the whiteboard. Figure 4.5 shows the diagram that Joe draws to\nillustrate how structural sharing looks when we add a member.\n«Next»\nLibrary\nLibrary\n«Next»\nUserManagement Catalog\nuserManagement\n«Next»\nmembers librarians ...\nmembers\nFigure 4.5 Adding a member\nwith structural sharing. Most of\nthe data is shared between the\n... member0 member1\ntwo versions.\nTheo Awesome! The Catalog and the librarians hash maps don’t have to be copied!\nJoe Now, in terms of code, we have to write a Library.addMember function that\ndelegates to UserManagement.addMember.\nTheo I guess it’s going to be similar to the code we wrote earlier to implement the\nsearch books query, where Library.searchBooksByTitleJSON delegates to\nCatalog.searchBooksByTitle.\nJoe Similar in the sense that all the functions are static, and they receive the data\nthey manipulate as an argument. But there are two differences. First, a muta-\ntion could fail, for instance, if the member to be added already exists. Second,\nthe code for Library.addMember is a bit more elaborate than the code for\nLibrary.searchBooksByTitleJSON because we have to create a new version\nof Library that refers to the new version of UserManagement. Here, let me\nshow you an example.\nListing4.3 The code for the mutation that adds a member\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nChecks if a member with\nthrow \"Member already exists.\";\nthe same email address\n}\nalready exists\nvar nextUserManagement = _.set(\nuserManagement,\nCreates a new version of\ninfoPath,\nuserManagement that\nmember);\nincludes the member\nreturn nextUserManagement;\n};\n--- Page 108 ---\n80 CHAPTER 4 State management\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library,\n\"userManagement\",\nnextUserManagement);\nCreates a new version of\nreturn nextLibrary;\nlibrary that contains the new\n};\nversion of userManagement\nTheo To me, it’s a bit weird that immutable functions return an updated version of\nthe data instead of changing it in place.\nJoe It was also weird for me when I first encountered immutable data in Clojure\nseven years ago.\nTheo How long did it take you to get used to it?\nJoe A couple of weeks.\n4.3 Implementing structural sharing\nWhen Joe leaves the office, Theo meets Dave near the coffee machine. Dave looks perplexed.\nDave Who’s the guy that just left the office?\nTheo It’s Joe. My DOP mentor.\nDave What’s DOP?\nTheo DOP refers to data-oriented programming.\nDave I never heard that term before.\nTheo It’s not well-known by programmers yet, but it’s quite a powerful programming\nparadigm. From what I’ve seen so far, it makes programming much simpler.\nDave Can you give me an example?\nTheo I just learned about structural sharing and how it makes it possible to create\nnew versions of data, effectively without copying.\nDave How does that work?\nTheo takes Dave to his office and shows him Joe’s diagram on the whiteboard (see figure 4.6).\nIt takes Theo a few minutes to explain to Dave what it does exactly, but in the end, Dave\ngets it.\nDave What does the implementation of structural sharing look like?\nTheo I don’t know. I used the _.set function from Lodash.\nDave It sounds like an interesting challenge.\nTheo Take the challenge if you want. Right now, I’m too tired for this recursive algo-\nrithmic stuff.\n--- Page 109 ---\n4.3 Implementing structural sharing 81\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.6 Structural sharing in action\nThe next day, Theo stops by Dave’s cubicle before heading to his office. Dave, with a touch\nof pride, shows Theo his implementation of structural sharing. Theo is amazed by the fact\nthat it’s only 11 lines of JavaScript code!\nListing4.4 The implementation of structural sharing\nfunction setImmutable(map, path, v) {\nvar modifiedNode = v;\nvar k = path[0];\nvar restOfPath = path.slice(1);\nif (restOfPath.length > 0) {\nmodifiedNode = setImmutable(map[k], restOfPath, v);\n}\nvar res = Object.assign({}, map);\nShallow\nres[k] = modifiedNode;\nclones a map\nreturn res;\nin JavaScript.\n}\nTheo Dave, you’re brilliant!\nDave (smiling) Aw, shucks.\nTheo Oops, I have to go. I’m already late for my session with Joe! Joe is probably wait-\ning in my office, biting his nails.\n--- Page 110 ---\n82 CHAPTER 4 State management\n4.4 Data safety\nJoe is about to start the day’s lesson. Theo asks him a question about yesterday’s material\ninstead.\nTheo Something isn’t clear to me regarding this structural sharing stuff. What hap-\npens if we write code that modifies the data part that’s shared between the two\nversions of the data? Does the change affect both versions?\nJoe Could you please write a code snippet that illustrates your question?\nTheo starts typing on his laptop. He comes up with this code to illustrate modifying a piece\nof data shared between two versions.\nListing4.5 Modifying data that’s shared between two versions\nvar books = {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n};\nvar nextBooks = _.set(books, [\"978-1779501127\", \"publicationYear\"], 1986)\nconsole.log(\"Before:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\nbooks[\"978-1779501127\"][\"authorIds\"][1] = \"dave-chester-gibbons\";\nconsole.log(\"After:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\n// → Before: dave-gibbons\n// → After: dave-chester-gibbons\nTheo My question is, what is the value of isBlocked in updatedMember?\nJoe The answer is that mutating data via the native hash map setter is forbidden.\nAll the data manipulation must be done via immutable functions.\n NOTE All data manipulation must be done with immutable functions. It is forbid-\nden to use the native hash map setter.\nTheo When you say “forbidden,” you mean that it’s up to the developer to make sure\nit doesn’t happen. Right?\nJoe Exactly.\nTheo Is there a way to protect our system from a developer’s mistake?\nJoe Yes, there is a way to ensure the immutability of the data at the level of the data\nstructure. It’s called persistent data structures.\nTheo Are persistent data structures also efficient in terms of memory and computation?\nJoe Actually, the way data is organized inside persistent data structures make them\neven more efficient than immutable functions.\n--- Page 111 ---\n4.5 The commit phase of a mutation 83\nTIP Persistent data structures are immutable at the level of the data. There is no way\nto mutate them, even by mistake.\nTheo Are there libraries providing persistent data structures?\nJoe Definitely. I just happen to have a list of those libraries on my computer.\nJoe, being well-organized for a programmer, quickly brings up his list. He shows it to Theo:\n Immutable.js in JavaScript at https://immutable-js.com/\n Paguro in Java at https://github.com/GlenKPeterson/Paguro\n Immutable Collections in C# at http://mng.bz/y4Ke\n Pyrsistent in Python at https://github.com/tobgu/pyrsistent\n Hamster in Ruby at https://github.com/hamstergem/hamster\nTheo Why not use persistent data structures instead of immutable functions?\nJoe The drawback of persistent data structures is that they are not native. This\nmeans that working with them requires conversion from native to persistent\nand from persistent to native.\nTheo What approach would you recommend?\nJoe If you want to play around a bit, then start with immutable functions. But for a\nproduction application, I’d recommend using persistent data structures.\nTheo Too bad the native data structures aren’t persistent!\nJoe That’s one of the reasons why I love Clojure—the native data structures of the\nlanguage are immutable!\n4.5 The commit phase of a mutation\nSo far, we saw how to implement the calculation phase of a mutation. The calculation\nphase is stateless in the sense that it doesn’t make any change to the system. Now, let’s\nsee how to update the state of the system inside the commit phase.\nTheo takes another look at the code for Library.addMember. Something bothers him:\nthis function returns a new state of the library that contains an additional member, but it\ndoesn’t affect the current state of the library.\nListing4.6 The commit phase moves the system state forward\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nTheo I see that Library.addMember doesn’t change the state of the library. How\ndoes the library state get updated?\n--- Page 112 ---\n84 CHAPTER 4 State management\nJoe That’s an excellent question. Library.addMember deals only with data calcula-\ntion and is stateless. The state is updated in the commit phase by moving for-\nward the version of the state that the system state refers to.\nTheo What do you mean by that?\nJoe Here’s what happens when we add a member to the system. The calculation\nphase creates a version of the state that has two members. Before the commit\nphase, the system state refers to the version of the state with one member. The\nresponsibility of the commit phase is to move the system state forward so that it\nrefers to the version of the state with two members.\nTIP The responsibility of the commit phase is to move the system state forward to the\nversion of the state returned by the calculation phase.\nJoe draws another illustration on the whiteboard (figure 4.7). He hopes it helps to clear up\nany misunderstanding Theo may have.\nBefore Commit After Commit\nState with one State with one\nSystem State\nmember member\naddMember addMember\nState with two State with two\nSystem State\nmembers members\nFigure 4.7 The commit phase moves the system state forward.\nTheo How is this implemented?\nJoe The code is made of two classes: System, a singleton stateful class that imple-\nments the mutations, and SystemState, a singleton stateful class that manages\nthe system state.\nTheo It sounds to me like classic OOP.\nJoe Right, and this part of the system being stateful is OOP-like.\nTheo I’m happy to see that you still find some utility in OOP.\nJoe Meditation taught me that every part of our universe has a role to play.\nTheo Nice! Could you show me some code?\nJoe Sure.\nJoe thinks for a moment before starting to type. He wants to show the System class and its\nimplementation of the addMember mutation.\nListing4.7 The System class\nclass System {\naddMember(member) {\nvar previous = SystemState.get();\n--- Page 113 ---\n4.6 Ensuring system state integrity 85\nvar next = Library.addMember(previous, member);\nSystemState.commit(previous, next);\nSystemState is covered\n}\nin listing 4.8.\n}\nTheo What does SystemState look like?\nJoe I had a feeling you were going to ask that. Here’s the code for the System-\nState class, which is a stateful class!\nListing4.8 The SystemState class\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nTheo I don’t get the point of SystemState. It’s a simple class with a getter and a\ncommit function, right?\nJoe In a moment, we are going to enrich the code of the SystemState.commit\nmethod so that it provides data validation and history tracking. For now, the\nimportant thing to notice is that the code of the calculation phase is stateless\nand is decoupled from the code of the commit phase, which is stateful.\nTIP The calculation phase is stateless. The commit phase is stateful.\n4.6 Ensuring system state integrity\nTheo Something still bothers me about the way functions manipulate immutable\ndata in the calculation phase. How do we preserve data integrity?\nJoe What do you mean?\nTheo In OOP, data is manipulated only by methods that belong to the same class as\nthe data. It prevents other classes from corrupting the inner state of the class.\nJoe Could you give me an example of an invalid state of the library?\nTheo For example, imagine that the code of a mutation adds a book item to the\nbook lendings of a member without marking the book item as lent in the cata-\nlog. Then the system data would be corrupted.\nJoe In DOP, we have the privilege of ensuring data integrity at the level of the\nwhole system instead of scattering the validation among many classes.\nTheo How does that work?\nJoe The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system data in a central place. At the beginning of the\ncommit phase, there is a step that checks whether the version of the system\n--- Page 114 ---\n86 CHAPTER 4 State management\nstate to be committed is valid. If the data is invalid, the commit is rejected.\nHere let me show you.\nListing4.9 Data validation inside the commit phase\nSystemState.commit = function(previous, next) {\nif(!SystemValidity.validate(previous, next)) { // not implemented for now\nthrow \"The system data to be committed is not valid!\";\n};\nthis.systemData = next;\n};\nTheo It sounds similar to a commit hook in Git.\nJoe I like your analogy!\nTheo Why are you passing the previous state in previous and the next state in next\nto SystemValidity.validate?\nJoe Because it allows SystemValidity.validate to optimize the validation in\nterms of computation. For example, we could validate just the data that has\nchanged.\nTIP In DOP, we validate the system data as a whole. Data validation is decoupled\nfrom data manipulation.\nTheo What does the code of SystemValidity.validate look like?\nJoe Someday, I will show you how to define a data schema and to validate that a\npiece of data conforms to a schema.\n NOTE See chapters 7 and 12 to see how Joe defines this data schema.\n4.7 Restoring previous states\nAnother advantage of the multi-version state approach with immutable data that is\nmanipulated via structural sharing is that we can keep track of the history of all the\nversions of the data without exploding the memory of our program. It allows us, for\ninstance, to restore the system back to an earlier state easily.\nTheo You told me earlier that it was easy to restore the system to a previous state.\nCould you show me how?\nJoe Happily, but before that, I’d like to make sure you understand why keeping\ntrack of all the versions of the data is efficient in terms of memory.\nTheo I think it’s related to the fact that immutable functions use structural sharing,\nand most of the data between subsequent versions of the state is shared.\nTIP Structural sharing allows us to keep many versions of the system state without\nexploding memory use.\nJoe Perfect! Now, I’ll show you how simple it is to undo a mutation. In order to\nimplement an undo mechanism, our SystemState class needs to have two\n--- Page 115 ---\n4.7 Restoring previous states 87\nreferences to the system data: systemData references the current state of the\nsystem, and previousSystemData references the previous state of the system.\nTheo That makes sense.\nJoe In the commit phase, we update both previousSystemData and systemData.\nTheo What does it take to implement an undo mechanism?\nJoe The undo is achieved by having systemData reference the same version of the\nsystem data as previousSystemData.\nTheo Could you walk me through an example?\nJoe To make things simple, I am going to give a number to each version of the sys-\ntem state. It starts at V0, and each time a mutation is committed, the version is\nincremented: V1, V2, V3, and so forth.\nTheo OK.\nJoe Let’s say that currently our system state is at V12 (see figure 4.8). In the\nSystemState object, systemData refers to V12, and previousSystemData\nrefers to V11.\npreviousSystemData\nMutationA Mutation B\nData V10 Data V11 Data V12\nsystemData\nFigure 4.8 When the system state is at V12, systemData refers to V12, and\npreviousSystemData refers to V11.\nTheo So far, so good...\nJoe Now, when a mutation is committed (for instance, adding a member), both\nreferences move forward: systemData refers to V13, and previousSystem-\nData refers to V12.\nJoe erases the whiteboard to make room for another diagram (figure 4.9). When he’s\nthrough with his drawing, he shows it to Theo.\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.9 When a mutation is committed, systemData refers to V13, and\npreviousSystemData refers to V12.\n--- Page 116 ---\n88 CHAPTER 4 State management\nTheo I suppose that when we undo the mutation, both references move backward.\nJoe In theory, yes, but in practice, it’s necessary to maintain a stack of all the state\nreferences. For now, to simplify things, we’ll maintain only a reference to the\nprevious version. As a consequence, when we undo the mutation, both refer-\nences refer to V12. Let me draw another diagram on the whiteboard that shows\nthis state (see figure 4.10).\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.10 When a mutation is undone, both systemData and previousSystemData refer\nto V12.\nTheo Could you show me how to implement this undo mechanism?\nJoe Actually, it takes only a couple of changes to the SystemState class. Pay atten-\ntion to the changes in the commit function. Inside systemDataBeforeUpdate,\nwe keep a reference to the current state of the system. If the validation and\nthe conflict resolution succeed, we update both previousSystemData and\nsystemData.\nListing4.10 The SystemState class with undo capability\nclass SystemState {\nsystemData;\npreviousSystemData;\nget() {\nreturn this.systemData;\n}\ncommit(previous, next) {\nvar systemDataBeforeUpdate = this.systemData;\nif(!Consistency.validate(previous, next)) {\nthrow \"The system data to be committed is not valid!\";\n}\nthis.systemData = next;\nthis.previousSystemData = systemDataBeforeUpdate;\n}\nundoLastMutation() {\nthis.systemData = this.previousSystemData;\n}\n}\n--- Page 117 ---\nSummary 89\nTheo I see that implementing System.undoLastMutation is simply a matter of hav-\ning systemData refer the same value as previousSystemData.\nJoe As I told you, if we need to allow multiple undos, the code would be a bit more\ncomplicated, but you get the idea.\nTheo I think so. Although Back to the Future belongs to the realm of science fiction, in\nDOP, time travel is real.\nSummary\n DOP principle #3 states that data is immutable.\n A mutation is an operation that changes the state of the system.\n In a multi-version approach to state management, mutations are split into cal-\nculation and commit phases.\n All data manipulation must be done via immutable functions. It is forbidden to\nuse the native hash map setter.\n Structural sharing allows us to create new versions of data efficiently (in terms of\nmemory and computation), where data that is common between the two ver-\nsions is shared instead of being copied.\n Structural sharing creates a new version of the data by recursively sharing the\nparts that don’t need to change.\n A mutation is split in two phases: calculation and commit.\n A function is said to be immutable when, instead of mutating the data, it creates\na new version of the data without changing the data it receives.\n During the calculation phase, data is manipulated with immutable functions that\nuse structural sharing.\n The calculation phase is stateless.\n During the commit phase, we update the system state.\n The responsibility of the commit phase is to move the system state forward to\nthe version of the state returned by the calculation phase.\n The data is immutable, but the state reference is mutable.\n The commit phase is stateful.\n We validate the system data as a whole. Data validation is decoupled from data\nmanipulation.\n The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system state in a central place before we update the\nstate.\n Keeping the history of the versions of the system data is memory efficient due to\nstructural sharing.\n Restoring the system to one of its previous states is straightforward due to the\nclear separation between the calculation phase and the commit phase.\n--- Page 118 ---\n90 CHAPTER 4 State management\n In order to use Lodash immutable functions, we use the Lodash FP module\n(https://github.com/lodash/lodash/wiki/FP-Guide).\nLodash functions introduced in this chapter\nFunction Description\nset(map, path, value) Creates a map with the same fields as map with the addition of a\n<path, value> field\n--- Page 119 ---\nBasic concurrency control\nConflicts at home\nThis chapter covers\n Managing concurrent mutations with a lock-free\noptimistic concurrency control strategy\n Supporting high throughput of reads and writes\n Reconciliation between concurrent mutations\nThe changes required for system manage concurrency are only in the commit\nphase. They involve a reconciliation algorithm that is universal, in the sense that it\ncan be used in any system where data is represented as an immutable hash map.\nThe implementation of the reconciliation algorithm is efficient because subse-\nquent versions of the system state are created via structural sharing.\nIn the previous chapter, we illustrated the multiversion approach to state man-\nagement, where a mutation is split into two distinct phases: the calculation phase\nthat deals only with computation, and the commit phase that moves the state ref-\nerence forward. Usually, in a production system, mutations occur concurrently.\nMoving the state forward naively like we did in the previous chapter is not appro-\npriate. In the present chapter, we are going to learn how to handle concurrent\nmutations.\n91\n--- Page 120 ---\n92 CHAPTER 5 Basic concurrency control\nIn DOP, because only the code of the commit phase is stateful, that allows us to use\nan optimistic concurrency control strategy that doesn’t involve any locking mechanism. As\na consequence, the throughput of reads and writes is high. The modifications to the\ncode are not trivial, as we have to implement an algorithm that reconciles concurrent\nmutations. But the modifications impact only the commit phase. The code for the cal-\nculation phase stays the same as in the previous chapter.\n NOTE This chapter requires more of an effort to grasp. The flow of the reconcilia-\ntion algorithm is definitely not trivial, and the implementation involves a nontrivial\nrecursion.\n5.1 Optimistic concurrency control\nThis morning, before getting to work, Theo takes Joe to the fitness room in the office and,\nwhile running on the step machine, the two men talk about their personal lives again. Joe\ntalks about a fight he had last night with Kay, who thinks that he pays more attention to his\nwork than to his family. Theo recounts the painful conflict he had with Jane, his wife,\nabout house budget management. They went to see a therapist, an expert in Imago Rela-\ntionship Therapy. Imago allowed them to transform their conflict into an opportunity to\ngrow and heal.\nJoe’s ears perk up when he hears the word conflict because today’s lesson is going to be\nabout resolving conflicts and concurrent mutations. A different kind of conflict, though....\nAfter a shower and a healthy breakfast, Theo and Joe get down to work.\nJoe Yesterday, I showed you how to manage state with immutable data, assuming\nthat no mutations occur concurrently. Today, I am going to show you how to\ndeal with concurrency control in DOP.\nTheo I’m curious to discover what kind of lock mechanisms you use in DOP to syn-\nchronize concurrent mutations.\nJoe In fact, we don’t use any lock mechanism!\nTheo Why not?\nJoe Locks hit performance, and if you’re not careful, your system could get into a\ndeadlock.\nTheo So, how do you handle possible conflicts between concurrent mutations in\nDOP?\nJoe In DOP, we use a lock-free strategy called optimistic concurrency control. It’s a\nstrategy that allows databases like Elasticsearch to be highly scalable.\n NOTE See https://www.elastic.co/elasticsearch/ to find out more about Elastic-\nsearch.\nTheo You sound like my couples therapist and her anger-free, optimistic conflict\nresolution strategy.\nJoe Optimistic concurrency control and DOP fit together well. As you will see in a\nmoment, optimistic concurrency control is super efficient when the system\ndata is immutable.\n--- Page 121 ---\n5.1 Optimistic concurrency control 93\nTIP Optimistic concurrency control with immutable data is super efficient.\nTheo How does it work?\nJoe Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTIP Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTheo What do you mean?\nJoe The calculation phase does its calculation as if it were the only mutation run-\nning. The commit phase is responsible for reconciling concurrent mutations\nwhen they don’t conflict or for aborting the mutation.\nTIP The calculation phase does its calculation as if it were the only mutation running.\nThe commit phase is responsible for trying to reconcile concurrent mutations.\nTheo That sounds quite challenging to implement.\nJoe Dealing with state is never trivial. But the good news is that the code for the\nreconciliation logic in the commit phase is universal.\nTheo Does that mean that the same code for the commit phase can be used in any\nDOP system?\nJoe Definitely. The code that implements the commit phase assumes nothing\nabout the details of the system except that the system data is represented as an\nimmutable map.\nTIP The implementation of the commit phase in optimistic concurrency control is\nuniversal. It can be used in any system where the data is represented by an immutable\nhash map.\nTheo That’s awesome!\nJoe Another cool thing is that handling concurrency doesn’t require any changes\nto the code in the calculation phase. From the calculation phase perspective,\nthe next version of the system data is computed in isolation as if no other muta-\ntions were running concurrently.\nJoe stands up to illustrate what he means on the whiteboard. While Theo looks at the draw-\ning in figure 5.1, Joe summarizes the information in table 5.1.\nTable 5.1 The two phases of a mutation with optimistic concurrency control\nPhase Responsibility State Implementation\nCalculation Compute next state in isolation Stateless Specific\nCommit Reconcile and update system state Stateful Common\n--- Page 122 ---\n94 CHAPTER 5 Basic concurrency control\nCalculation phase\nCapturesystem state\nComputenext version\nCommit phase\nYes No\nConcurrent mutations?\nYes No\nConflict?\nUpdatesystem state\nAbortmutation Reconcilemutations\nUpdatesystem state\nFigure 5.1 The logic flow\nof optimistic concurrency\ncontrol\n5.2 Reconciliation between concurrent mutations\nTheo Could you give me some examples of conflicting concurrent mutations?\nJoe Sure. One example would be two members trying to borrow the same book\ncopy. Another example might be when two librarians update the publication\nyear of the same book.\nTheo You mentioned that the code for the reconciliation logic in the commit phase\nis universal. What do you mean exactly by reconciliation logic?\nJoe It’s quite similar to what could happen in Git when you merge a branch back\ninto the main branch.\nTheo I love it when the main branch stays the same.\nJoe Yes, it’s nice when the merge has no conflicts and can be done automatically.\nDo you remember how Git handles the merge in that case?\nTheo Git does a fast-forward; it updates the main branch to be the same as the merge\nbranch.\nJoe Right! And what happens when you discover that, meanwhile, another devel-\noper has committed their code to the main branch?\nTheo Then Git does a three-way merge, trying to combine all the changes from the\ntwo merge branches with the main branch.\nJoe Does it always go smoothly?\nTheo Usually, yes, but it’s possible that two developers have modified the same line\nin the same file. I then have to manually resolve the conflict. I hate when that\nhappens!\nTIP In a production system, multiple mutations run concurrently. Before updating\nthe state, we need to reconcile the conflicts between possible concurrent mutations.\n--- Page 123 ---\n5.2 Reconciliation between concurrent mutations 95\nJoe In DOP, the reconciliation algorithm in the commit phase is quite similar to a\nmerge in Git, except instead of a manual conflict resolution, we abort the\nmutation. There are three possibilities to reconcile between possible concur-\nrent mutations: fast-forward, three-way merge, or abort.\nJoe goes to the whiteboard again. He draws the two diagrams shown in figures 5.2 and 5.3.\nYes No\nState has stayed the same\nYes No\nConcurrent mutations compatible?\nFast forward\n3-way Merge Abort\nFigure 5.2 The\nreconciliation flow\nThe version during\nthe Commit phase\ncurrent\nprevious\nnext\nThe base version\nfor the Calculation\nThe version Figure 5.3 When the commit phase\nphase\nreturned by the starts, there are three versions of the\nCalculation phase system state.\nTheo Could you explain in more detail?\nJoe When the commit phase of a mutation starts, we have three versions of the sys-\ntem state: previous, which is the version on which the calculation phase based\nits computation; current, which is the current version during the commit\nphase; and next, which is the version returned by the calculation phase.\nTheo Why would current be different than previous?\nJoe It happens when other mutations have run concurrently with our mutation.\nTheo I see.\nJoe If we are in a situation where the current state is the same as the previous state,\nit means that no mutations run concurrently. Therefore, as in Git, we can\nsafely fast-forward and update the state of the system with the next version.\nTheo What if the state has not stayed the same?\nJoe Then it means that mutations have run concurrently. We have to check for\nconflicts in a way similar to the three-way merge used by Git. The difference is\nthat instead of comparing lines, we compare fields of the system hash map.\nTheo Could you explain that?\n--- Page 124 ---\n96 CHAPTER 5 Basic concurrency control\nJoe We calculate the diff between previous and next and between previous and\ncurrent. If the two diffs have no fields in common, then there is no conflict\nbetween the mutations that have run concurrently. We can safely apply the\nchanges from previous to next into current.\nJoe makes his explanation visual with another diagram on the whiteboard. He then shows\nfigure 5.4 to Theo.\ndiffPreviousCurrent diffPreviousNext\ncurrent\nprevious merged\ndiffPreviousNext\nnext\nFigure 5.4 In a three-way merge, we calculate the diff between previous and\nnext, and we apply it to current.\nTheo What if there is a conflict?\nJoe Then we abort the mutation.\nTheo Aborting a user request seems unacceptable.\nJoe In fact, in a user-facing system, conflicting concurrent mutations are fairly rare.\nThat’s why it’s OK to abort and let the user run the mutation again. Here, let\nme draft a table to show you the differences between Git and DOP (table 5.2).\nTable 5.2 The analogy between Git and data-oriented programming\nData-oriented programming Git\nConcurrent mutations Different branches\nA version of the system data A commit\nState A reference\nCalculation phase Branching\nValidation Precommit hook\nReconciliation Merge\nFast-forward Fast-forward\nThree-way merge Three-way merge\nAbort Manual conflict resolution\nHash map Tree (folder)\nLeaf node Blob (file)\nData field Line of code\n--- Page 125 ---\n5.3 Reducing collections 97\nTheo Great! That helps, but in cases where two mutations update the same field of\nthe same entity, I think it’s fair enough to let the user know that the request\ncan’t be processed.\nTIP In a user-facing system, conflicting concurrent mutations are fairly rare.\n5.3 Reducing collections\nJoe Are you ready to challenge your mind with the implementation of the diff\nalgorithm?\nTheo Let’s take a short coffee break before, if you don’t mind. Then, I’ll be ready to\ntackle anything.\nAfter enjoying large mug of hot coffee and a few butter cookies, Theo and Joe are back to\nwork. Their discussion on the diff algorithm continues.\nJoe In the implementation of the diff algorithm, we’re going to reduce collections.\nTheo I heard about reducing collections in a talk about FP, but I don’t remember\nthe details. Could you remind me how this works?\nJoe Imagine you want to calculate the sum of the elements in a collection of num-\nbers. With Lodash’s _.reduce, it would look like this.\nListing5.1 Summing numbers with _.reduce\n_.reduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nTheo I don’t understand.\nJoe goes to the whiteboard and writes the description of _.reduce. Theo waits patiently\nuntil Joe puts the pen down before looking at the description.\nDescription of _.reduce\n_.reduce receives three arguments:\n coll—A collection of elements\n f—A function that receives two arguments\n initVal—A value\nLogic flow:\n1 Initialize currentRes with initVal.\n2 For each element x of coll, update currentRes with f(currentRes, x).\n3 Return currentRes.",
        "sections_found": []
      },
      "accurate_page_range": "102-125"
    },
    {
      "text": "- 4.4 Data safety",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "raw_line": "- 4.4 Data safety (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 33,
      "chapter_info": {
        "page": 102,
        "title": "State management",
        "pattern_matched": "Chapter 4",
        "text_preview": "74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead"
      },
      "chapter_sections": {
        "start_page": 102,
        "end_page": 125,
        "content": "\n--- Page 102 ---\n74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead of being copied.\nThis technique efficiently creates new versions of the system data, both in\nterms of memory and computation.\nTheo I’m intrigued.\nTIP With structural sharing, it’s efficient (in terms of memory and computation) to\ncreate new versions of data.\nJoe I’ll explain in detail how structural sharing works in a moment.\nTheo takes another look at the diagram in figure 4.1, which illustrates how the system state\nrefers to a version of the system data. Suddenly, a question emerges.\nTheo Are the previous versions of the system data kept?\nJoe In a simple application, previous versions are automatically removed by the\ngarbage collector. But, in some cases, we maintain historical references to pre-\nvious versions of the data.\nTheo What kind of cases?\nJoe For example, if we want to support time travel in our system, as in Git, we can\nmove the system back to a previous version of the state easily.\nTheo Now I understand what you mean by data is immutable, but the state reference\nis mutable!\n4.2 Structural sharing\nAs mentioned in the previous section, structural sharing enables the efficient cre-\nation of new versions of immutable data. In DOP, we use structural sharing in the\ncalculation phase of a mutation to compute the next state of the system based on\nthe current state of the system. Inside the calculation phase, we don’t have to deal\nwith state management; that is delayed to the commit phase. As a consequence, the\ncode involved in the calculation phase of a mutation is stateless and is as simple as\nthe code of a query.\nTheo I’m really intrigued by this more efficient way to create new versions of data.\nHow does it work?\nJoe Let’s take a simple example from our library system. Imagine that you want to\nmodify the value of a field in a book in the catalog; for instance, the publica-\ntion year of Watchmen. Can you tell me the information path for Watchmen’s\npublication year?\nTheo takes a quick look at the catalog data in figure 4.2. Then he answers Joe’s question.\n--- Page 103 ---\n4.2 Structural sharing 75\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 4.2 Visualization of the catalog data. The nodes in the information path to Watchmen’s publication\nyear are marked with a dotted border.\nTheo The information path for Watchmen’s publication year is [\"catalog\", \"books-\nByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Now, let me show how you to use the immutable function _.set that Lodash\nalso provides.\nTheo Wait! What do you mean by an immutable function? When I looked at the\nLodash documentation for _.set on their website, it said that it mutates the\nobject.\nJoe You’re right, but the default Lodash functions are not immutable. In order to\nuse an immutable version of the functions, we need to use the Lodash FP mod-\nule as explained in the Lodash FP guide.\n NOTE See https://lodash.com/docs/4.17.15#set to view Lodash’s documentation\nfor _.set, and see https://github.com/lodash/lodash/wiki/FP-Guide to view the\nLodash FP guide.\nTheo Do the immutable functions have the same signature as the mutable functions?\nJoe By default, the order of the arguments in immutable functions is shuffled.\nThe Lodash FP guide explains how to resolve this. With this piece of code,\n--- Page 104 ---\n76 CHAPTER 4 State management\nthe signature of the immutable functions is exactly the same as the mutable\nfunctions.\nListing4.1 Configuring Lodash so immutable and mutable functions have same signature\n_ = fp.convert({\n\"cap\": false,\n\"curry\": false,\n\"fixed\": false,\n\"immutable\": true,\n\"rearg\": false\n});\nTIP In order to use Lodash immutable functions, we use Lodash’s FP module, and\nwe configure it so that the signature of the immutable functions is the same as in the\nLodash documentation web site.\nTheo So basically, I can still rely on Lodash documentation when using immutable\nversions of the functions.\nJoe Except for the piece in the documentation that says the function mutates the\nobject.\nTheo Of course!\nJoe Now I’ll show you how to write code that creates a version of the library data\nwith the immutable function _.set.\nJoe’s fingers fly across Theo’s keyboard. Theo then looks at Joe’s code, which creates a ver-\nsion of the library data where the Watchmen publication year is set to 1986.\nListing4.2 Using _.set as an immutable function\nvar nextLibraryData = _.set(libraryData,\n[\"catalog\", \"booksByIsbn\",\n\"978-1779501127\", \"publicationYear\"],\n1986);\n NOTE A function is said to be immutable when, instead of mutating the data, it cre-\nates a new version of the data without changing the data it receives.\nTheo You told me earlier that structural sharing allowed immutable functions to be\nefficient in terms of memory and computation. Can you tell me what makes\nthem efficient?\nJoe With pleasure, but before that, you have to answer a series of questions. Are\nyou ready?\nTheo Yes, sure...\nJoe What part of the library data is impacted by updating the Watchmen publication\nyear: the UserManagement or the Catalog?\n--- Page 105 ---\n4.2 Structural sharing 77\nTheo Only the Catalog.\nJoe What part of the Catalog?\nTheo Only the booksByIsbn index.\nJoe What part of the booksByIsbn index?\nTheo Only the Book record that holds the information about Watchmen.\nJoe What part of the Book record?\nTheo Only the publicationYear field.\nJoe Perfect! Now, suppose that the current version of the library data looks like\nthis.\nJoe goes to the whiteboard and draws a diagram. Figure 4.3 shows the result.\nLibrary\nCatalog UserManagement\nauthorsByld booksBylsbn ...\n... watchmen\ntitle:Watchmen publicationYear:1987 authorlds\n...\nFigure 4.3 High-level visualization of the current version of Library\nTheo So far, so good...\nJoe Next, let me show you what an immutable function does when you use it to cre-\nate a new version of Library, where the publication year of Watchmen is set to\n1986 instead of 1987.\nJoe updates his diagram on the whiteboard. It now looks like figure 4.4.\n--- Page 106 ---\n78 CHAPTER 4 State management\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.4 Structural sharing provides an efficient way to create a new version of the data.\nNext Library is recursively made of nodes that use the parts of Library that are\ncommon between the two.\nTheo Could you explain?\nJoe The immutable function creates a fresh Library hash map, which recursively\nuses the parts of the current Library that are common between the two ver-\nsions instead of deeply copying them.\nTheo It’s a bit abstract for me.\nJoe The next version of Library uses the same UserManagement hash map as the\nold one. The Catalog inside the next Library uses the same authorsById as\nthe current Catalog. The Watchmen Book record inside the next Catalog uses\nall the fields of the current Book except for the publicationYear field.\nTheo So, in fact, most parts of the data are shared between the two versions. Right?\nJoe Exactly! That’s why this technique is called structural sharing.\nTIP Structural sharing provides an efficient way (both in terms of memory and com-\nputation) to create a new version of the data by recursively sharing the parts that don’t\nneed to change.\nTheo That’s very cool!\nJoe Indeed. Now let’s look at how to write a mutation for adding a member using\nimmutable functions.\n--- Page 107 ---\n4.2 Structural sharing 79\nOnce again, Joe goes to the whiteboard. Figure 4.5 shows the diagram that Joe draws to\nillustrate how structural sharing looks when we add a member.\n«Next»\nLibrary\nLibrary\n«Next»\nUserManagement Catalog\nuserManagement\n«Next»\nmembers librarians ...\nmembers\nFigure 4.5 Adding a member\nwith structural sharing. Most of\nthe data is shared between the\n... member0 member1\ntwo versions.\nTheo Awesome! The Catalog and the librarians hash maps don’t have to be copied!\nJoe Now, in terms of code, we have to write a Library.addMember function that\ndelegates to UserManagement.addMember.\nTheo I guess it’s going to be similar to the code we wrote earlier to implement the\nsearch books query, where Library.searchBooksByTitleJSON delegates to\nCatalog.searchBooksByTitle.\nJoe Similar in the sense that all the functions are static, and they receive the data\nthey manipulate as an argument. But there are two differences. First, a muta-\ntion could fail, for instance, if the member to be added already exists. Second,\nthe code for Library.addMember is a bit more elaborate than the code for\nLibrary.searchBooksByTitleJSON because we have to create a new version\nof Library that refers to the new version of UserManagement. Here, let me\nshow you an example.\nListing4.3 The code for the mutation that adds a member\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nChecks if a member with\nthrow \"Member already exists.\";\nthe same email address\n}\nalready exists\nvar nextUserManagement = _.set(\nuserManagement,\nCreates a new version of\ninfoPath,\nuserManagement that\nmember);\nincludes the member\nreturn nextUserManagement;\n};\n--- Page 108 ---\n80 CHAPTER 4 State management\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library,\n\"userManagement\",\nnextUserManagement);\nCreates a new version of\nreturn nextLibrary;\nlibrary that contains the new\n};\nversion of userManagement\nTheo To me, it’s a bit weird that immutable functions return an updated version of\nthe data instead of changing it in place.\nJoe It was also weird for me when I first encountered immutable data in Clojure\nseven years ago.\nTheo How long did it take you to get used to it?\nJoe A couple of weeks.\n4.3 Implementing structural sharing\nWhen Joe leaves the office, Theo meets Dave near the coffee machine. Dave looks perplexed.\nDave Who’s the guy that just left the office?\nTheo It’s Joe. My DOP mentor.\nDave What’s DOP?\nTheo DOP refers to data-oriented programming.\nDave I never heard that term before.\nTheo It’s not well-known by programmers yet, but it’s quite a powerful programming\nparadigm. From what I’ve seen so far, it makes programming much simpler.\nDave Can you give me an example?\nTheo I just learned about structural sharing and how it makes it possible to create\nnew versions of data, effectively without copying.\nDave How does that work?\nTheo takes Dave to his office and shows him Joe’s diagram on the whiteboard (see figure 4.6).\nIt takes Theo a few minutes to explain to Dave what it does exactly, but in the end, Dave\ngets it.\nDave What does the implementation of structural sharing look like?\nTheo I don’t know. I used the _.set function from Lodash.\nDave It sounds like an interesting challenge.\nTheo Take the challenge if you want. Right now, I’m too tired for this recursive algo-\nrithmic stuff.\n--- Page 109 ---\n4.3 Implementing structural sharing 81\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.6 Structural sharing in action\nThe next day, Theo stops by Dave’s cubicle before heading to his office. Dave, with a touch\nof pride, shows Theo his implementation of structural sharing. Theo is amazed by the fact\nthat it’s only 11 lines of JavaScript code!\nListing4.4 The implementation of structural sharing\nfunction setImmutable(map, path, v) {\nvar modifiedNode = v;\nvar k = path[0];\nvar restOfPath = path.slice(1);\nif (restOfPath.length > 0) {\nmodifiedNode = setImmutable(map[k], restOfPath, v);\n}\nvar res = Object.assign({}, map);\nShallow\nres[k] = modifiedNode;\nclones a map\nreturn res;\nin JavaScript.\n}\nTheo Dave, you’re brilliant!\nDave (smiling) Aw, shucks.\nTheo Oops, I have to go. I’m already late for my session with Joe! Joe is probably wait-\ning in my office, biting his nails.\n--- Page 110 ---\n82 CHAPTER 4 State management\n4.4 Data safety\nJoe is about to start the day’s lesson. Theo asks him a question about yesterday’s material\ninstead.\nTheo Something isn’t clear to me regarding this structural sharing stuff. What hap-\npens if we write code that modifies the data part that’s shared between the two\nversions of the data? Does the change affect both versions?\nJoe Could you please write a code snippet that illustrates your question?\nTheo starts typing on his laptop. He comes up with this code to illustrate modifying a piece\nof data shared between two versions.\nListing4.5 Modifying data that’s shared between two versions\nvar books = {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n};\nvar nextBooks = _.set(books, [\"978-1779501127\", \"publicationYear\"], 1986)\nconsole.log(\"Before:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\nbooks[\"978-1779501127\"][\"authorIds\"][1] = \"dave-chester-gibbons\";\nconsole.log(\"After:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\n// → Before: dave-gibbons\n// → After: dave-chester-gibbons\nTheo My question is, what is the value of isBlocked in updatedMember?\nJoe The answer is that mutating data via the native hash map setter is forbidden.\nAll the data manipulation must be done via immutable functions.\n NOTE All data manipulation must be done with immutable functions. It is forbid-\nden to use the native hash map setter.\nTheo When you say “forbidden,” you mean that it’s up to the developer to make sure\nit doesn’t happen. Right?\nJoe Exactly.\nTheo Is there a way to protect our system from a developer’s mistake?\nJoe Yes, there is a way to ensure the immutability of the data at the level of the data\nstructure. It’s called persistent data structures.\nTheo Are persistent data structures also efficient in terms of memory and computation?\nJoe Actually, the way data is organized inside persistent data structures make them\neven more efficient than immutable functions.\n--- Page 111 ---\n4.5 The commit phase of a mutation 83\nTIP Persistent data structures are immutable at the level of the data. There is no way\nto mutate them, even by mistake.\nTheo Are there libraries providing persistent data structures?\nJoe Definitely. I just happen to have a list of those libraries on my computer.\nJoe, being well-organized for a programmer, quickly brings up his list. He shows it to Theo:\n Immutable.js in JavaScript at https://immutable-js.com/\n Paguro in Java at https://github.com/GlenKPeterson/Paguro\n Immutable Collections in C# at http://mng.bz/y4Ke\n Pyrsistent in Python at https://github.com/tobgu/pyrsistent\n Hamster in Ruby at https://github.com/hamstergem/hamster\nTheo Why not use persistent data structures instead of immutable functions?\nJoe The drawback of persistent data structures is that they are not native. This\nmeans that working with them requires conversion from native to persistent\nand from persistent to native.\nTheo What approach would you recommend?\nJoe If you want to play around a bit, then start with immutable functions. But for a\nproduction application, I’d recommend using persistent data structures.\nTheo Too bad the native data structures aren’t persistent!\nJoe That’s one of the reasons why I love Clojure—the native data structures of the\nlanguage are immutable!\n4.5 The commit phase of a mutation\nSo far, we saw how to implement the calculation phase of a mutation. The calculation\nphase is stateless in the sense that it doesn’t make any change to the system. Now, let’s\nsee how to update the state of the system inside the commit phase.\nTheo takes another look at the code for Library.addMember. Something bothers him:\nthis function returns a new state of the library that contains an additional member, but it\ndoesn’t affect the current state of the library.\nListing4.6 The commit phase moves the system state forward\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nTheo I see that Library.addMember doesn’t change the state of the library. How\ndoes the library state get updated?\n--- Page 112 ---\n84 CHAPTER 4 State management\nJoe That’s an excellent question. Library.addMember deals only with data calcula-\ntion and is stateless. The state is updated in the commit phase by moving for-\nward the version of the state that the system state refers to.\nTheo What do you mean by that?\nJoe Here’s what happens when we add a member to the system. The calculation\nphase creates a version of the state that has two members. Before the commit\nphase, the system state refers to the version of the state with one member. The\nresponsibility of the commit phase is to move the system state forward so that it\nrefers to the version of the state with two members.\nTIP The responsibility of the commit phase is to move the system state forward to the\nversion of the state returned by the calculation phase.\nJoe draws another illustration on the whiteboard (figure 4.7). He hopes it helps to clear up\nany misunderstanding Theo may have.\nBefore Commit After Commit\nState with one State with one\nSystem State\nmember member\naddMember addMember\nState with two State with two\nSystem State\nmembers members\nFigure 4.7 The commit phase moves the system state forward.\nTheo How is this implemented?\nJoe The code is made of two classes: System, a singleton stateful class that imple-\nments the mutations, and SystemState, a singleton stateful class that manages\nthe system state.\nTheo It sounds to me like classic OOP.\nJoe Right, and this part of the system being stateful is OOP-like.\nTheo I’m happy to see that you still find some utility in OOP.\nJoe Meditation taught me that every part of our universe has a role to play.\nTheo Nice! Could you show me some code?\nJoe Sure.\nJoe thinks for a moment before starting to type. He wants to show the System class and its\nimplementation of the addMember mutation.\nListing4.7 The System class\nclass System {\naddMember(member) {\nvar previous = SystemState.get();\n--- Page 113 ---\n4.6 Ensuring system state integrity 85\nvar next = Library.addMember(previous, member);\nSystemState.commit(previous, next);\nSystemState is covered\n}\nin listing 4.8.\n}\nTheo What does SystemState look like?\nJoe I had a feeling you were going to ask that. Here’s the code for the System-\nState class, which is a stateful class!\nListing4.8 The SystemState class\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nTheo I don’t get the point of SystemState. It’s a simple class with a getter and a\ncommit function, right?\nJoe In a moment, we are going to enrich the code of the SystemState.commit\nmethod so that it provides data validation and history tracking. For now, the\nimportant thing to notice is that the code of the calculation phase is stateless\nand is decoupled from the code of the commit phase, which is stateful.\nTIP The calculation phase is stateless. The commit phase is stateful.\n4.6 Ensuring system state integrity\nTheo Something still bothers me about the way functions manipulate immutable\ndata in the calculation phase. How do we preserve data integrity?\nJoe What do you mean?\nTheo In OOP, data is manipulated only by methods that belong to the same class as\nthe data. It prevents other classes from corrupting the inner state of the class.\nJoe Could you give me an example of an invalid state of the library?\nTheo For example, imagine that the code of a mutation adds a book item to the\nbook lendings of a member without marking the book item as lent in the cata-\nlog. Then the system data would be corrupted.\nJoe In DOP, we have the privilege of ensuring data integrity at the level of the\nwhole system instead of scattering the validation among many classes.\nTheo How does that work?\nJoe The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system data in a central place. At the beginning of the\ncommit phase, there is a step that checks whether the version of the system\n--- Page 114 ---\n86 CHAPTER 4 State management\nstate to be committed is valid. If the data is invalid, the commit is rejected.\nHere let me show you.\nListing4.9 Data validation inside the commit phase\nSystemState.commit = function(previous, next) {\nif(!SystemValidity.validate(previous, next)) { // not implemented for now\nthrow \"The system data to be committed is not valid!\";\n};\nthis.systemData = next;\n};\nTheo It sounds similar to a commit hook in Git.\nJoe I like your analogy!\nTheo Why are you passing the previous state in previous and the next state in next\nto SystemValidity.validate?\nJoe Because it allows SystemValidity.validate to optimize the validation in\nterms of computation. For example, we could validate just the data that has\nchanged.\nTIP In DOP, we validate the system data as a whole. Data validation is decoupled\nfrom data manipulation.\nTheo What does the code of SystemValidity.validate look like?\nJoe Someday, I will show you how to define a data schema and to validate that a\npiece of data conforms to a schema.\n NOTE See chapters 7 and 12 to see how Joe defines this data schema.\n4.7 Restoring previous states\nAnother advantage of the multi-version state approach with immutable data that is\nmanipulated via structural sharing is that we can keep track of the history of all the\nversions of the data without exploding the memory of our program. It allows us, for\ninstance, to restore the system back to an earlier state easily.\nTheo You told me earlier that it was easy to restore the system to a previous state.\nCould you show me how?\nJoe Happily, but before that, I’d like to make sure you understand why keeping\ntrack of all the versions of the data is efficient in terms of memory.\nTheo I think it’s related to the fact that immutable functions use structural sharing,\nand most of the data between subsequent versions of the state is shared.\nTIP Structural sharing allows us to keep many versions of the system state without\nexploding memory use.\nJoe Perfect! Now, I’ll show you how simple it is to undo a mutation. In order to\nimplement an undo mechanism, our SystemState class needs to have two\n--- Page 115 ---\n4.7 Restoring previous states 87\nreferences to the system data: systemData references the current state of the\nsystem, and previousSystemData references the previous state of the system.\nTheo That makes sense.\nJoe In the commit phase, we update both previousSystemData and systemData.\nTheo What does it take to implement an undo mechanism?\nJoe The undo is achieved by having systemData reference the same version of the\nsystem data as previousSystemData.\nTheo Could you walk me through an example?\nJoe To make things simple, I am going to give a number to each version of the sys-\ntem state. It starts at V0, and each time a mutation is committed, the version is\nincremented: V1, V2, V3, and so forth.\nTheo OK.\nJoe Let’s say that currently our system state is at V12 (see figure 4.8). In the\nSystemState object, systemData refers to V12, and previousSystemData\nrefers to V11.\npreviousSystemData\nMutationA Mutation B\nData V10 Data V11 Data V12\nsystemData\nFigure 4.8 When the system state is at V12, systemData refers to V12, and\npreviousSystemData refers to V11.\nTheo So far, so good...\nJoe Now, when a mutation is committed (for instance, adding a member), both\nreferences move forward: systemData refers to V13, and previousSystem-\nData refers to V12.\nJoe erases the whiteboard to make room for another diagram (figure 4.9). When he’s\nthrough with his drawing, he shows it to Theo.\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.9 When a mutation is committed, systemData refers to V13, and\npreviousSystemData refers to V12.\n--- Page 116 ---\n88 CHAPTER 4 State management\nTheo I suppose that when we undo the mutation, both references move backward.\nJoe In theory, yes, but in practice, it’s necessary to maintain a stack of all the state\nreferences. For now, to simplify things, we’ll maintain only a reference to the\nprevious version. As a consequence, when we undo the mutation, both refer-\nences refer to V12. Let me draw another diagram on the whiteboard that shows\nthis state (see figure 4.10).\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.10 When a mutation is undone, both systemData and previousSystemData refer\nto V12.\nTheo Could you show me how to implement this undo mechanism?\nJoe Actually, it takes only a couple of changes to the SystemState class. Pay atten-\ntion to the changes in the commit function. Inside systemDataBeforeUpdate,\nwe keep a reference to the current state of the system. If the validation and\nthe conflict resolution succeed, we update both previousSystemData and\nsystemData.\nListing4.10 The SystemState class with undo capability\nclass SystemState {\nsystemData;\npreviousSystemData;\nget() {\nreturn this.systemData;\n}\ncommit(previous, next) {\nvar systemDataBeforeUpdate = this.systemData;\nif(!Consistency.validate(previous, next)) {\nthrow \"The system data to be committed is not valid!\";\n}\nthis.systemData = next;\nthis.previousSystemData = systemDataBeforeUpdate;\n}\nundoLastMutation() {\nthis.systemData = this.previousSystemData;\n}\n}\n--- Page 117 ---\nSummary 89\nTheo I see that implementing System.undoLastMutation is simply a matter of hav-\ning systemData refer the same value as previousSystemData.\nJoe As I told you, if we need to allow multiple undos, the code would be a bit more\ncomplicated, but you get the idea.\nTheo I think so. Although Back to the Future belongs to the realm of science fiction, in\nDOP, time travel is real.\nSummary\n DOP principle #3 states that data is immutable.\n A mutation is an operation that changes the state of the system.\n In a multi-version approach to state management, mutations are split into cal-\nculation and commit phases.\n All data manipulation must be done via immutable functions. It is forbidden to\nuse the native hash map setter.\n Structural sharing allows us to create new versions of data efficiently (in terms of\nmemory and computation), where data that is common between the two ver-\nsions is shared instead of being copied.\n Structural sharing creates a new version of the data by recursively sharing the\nparts that don’t need to change.\n A mutation is split in two phases: calculation and commit.\n A function is said to be immutable when, instead of mutating the data, it creates\na new version of the data without changing the data it receives.\n During the calculation phase, data is manipulated with immutable functions that\nuse structural sharing.\n The calculation phase is stateless.\n During the commit phase, we update the system state.\n The responsibility of the commit phase is to move the system state forward to\nthe version of the state returned by the calculation phase.\n The data is immutable, but the state reference is mutable.\n The commit phase is stateful.\n We validate the system data as a whole. Data validation is decoupled from data\nmanipulation.\n The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system state in a central place before we update the\nstate.\n Keeping the history of the versions of the system data is memory efficient due to\nstructural sharing.\n Restoring the system to one of its previous states is straightforward due to the\nclear separation between the calculation phase and the commit phase.\n--- Page 118 ---\n90 CHAPTER 4 State management\n In order to use Lodash immutable functions, we use the Lodash FP module\n(https://github.com/lodash/lodash/wiki/FP-Guide).\nLodash functions introduced in this chapter\nFunction Description\nset(map, path, value) Creates a map with the same fields as map with the addition of a\n<path, value> field\n--- Page 119 ---\nBasic concurrency control\nConflicts at home\nThis chapter covers\n Managing concurrent mutations with a lock-free\noptimistic concurrency control strategy\n Supporting high throughput of reads and writes\n Reconciliation between concurrent mutations\nThe changes required for system manage concurrency are only in the commit\nphase. They involve a reconciliation algorithm that is universal, in the sense that it\ncan be used in any system where data is represented as an immutable hash map.\nThe implementation of the reconciliation algorithm is efficient because subse-\nquent versions of the system state are created via structural sharing.\nIn the previous chapter, we illustrated the multiversion approach to state man-\nagement, where a mutation is split into two distinct phases: the calculation phase\nthat deals only with computation, and the commit phase that moves the state ref-\nerence forward. Usually, in a production system, mutations occur concurrently.\nMoving the state forward naively like we did in the previous chapter is not appro-\npriate. In the present chapter, we are going to learn how to handle concurrent\nmutations.\n91\n--- Page 120 ---\n92 CHAPTER 5 Basic concurrency control\nIn DOP, because only the code of the commit phase is stateful, that allows us to use\nan optimistic concurrency control strategy that doesn’t involve any locking mechanism. As\na consequence, the throughput of reads and writes is high. The modifications to the\ncode are not trivial, as we have to implement an algorithm that reconciles concurrent\nmutations. But the modifications impact only the commit phase. The code for the cal-\nculation phase stays the same as in the previous chapter.\n NOTE This chapter requires more of an effort to grasp. The flow of the reconcilia-\ntion algorithm is definitely not trivial, and the implementation involves a nontrivial\nrecursion.\n5.1 Optimistic concurrency control\nThis morning, before getting to work, Theo takes Joe to the fitness room in the office and,\nwhile running on the step machine, the two men talk about their personal lives again. Joe\ntalks about a fight he had last night with Kay, who thinks that he pays more attention to his\nwork than to his family. Theo recounts the painful conflict he had with Jane, his wife,\nabout house budget management. They went to see a therapist, an expert in Imago Rela-\ntionship Therapy. Imago allowed them to transform their conflict into an opportunity to\ngrow and heal.\nJoe’s ears perk up when he hears the word conflict because today’s lesson is going to be\nabout resolving conflicts and concurrent mutations. A different kind of conflict, though....\nAfter a shower and a healthy breakfast, Theo and Joe get down to work.\nJoe Yesterday, I showed you how to manage state with immutable data, assuming\nthat no mutations occur concurrently. Today, I am going to show you how to\ndeal with concurrency control in DOP.\nTheo I’m curious to discover what kind of lock mechanisms you use in DOP to syn-\nchronize concurrent mutations.\nJoe In fact, we don’t use any lock mechanism!\nTheo Why not?\nJoe Locks hit performance, and if you’re not careful, your system could get into a\ndeadlock.\nTheo So, how do you handle possible conflicts between concurrent mutations in\nDOP?\nJoe In DOP, we use a lock-free strategy called optimistic concurrency control. It’s a\nstrategy that allows databases like Elasticsearch to be highly scalable.\n NOTE See https://www.elastic.co/elasticsearch/ to find out more about Elastic-\nsearch.\nTheo You sound like my couples therapist and her anger-free, optimistic conflict\nresolution strategy.\nJoe Optimistic concurrency control and DOP fit together well. As you will see in a\nmoment, optimistic concurrency control is super efficient when the system\ndata is immutable.\n--- Page 121 ---\n5.1 Optimistic concurrency control 93\nTIP Optimistic concurrency control with immutable data is super efficient.\nTheo How does it work?\nJoe Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTIP Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTheo What do you mean?\nJoe The calculation phase does its calculation as if it were the only mutation run-\nning. The commit phase is responsible for reconciling concurrent mutations\nwhen they don’t conflict or for aborting the mutation.\nTIP The calculation phase does its calculation as if it were the only mutation running.\nThe commit phase is responsible for trying to reconcile concurrent mutations.\nTheo That sounds quite challenging to implement.\nJoe Dealing with state is never trivial. But the good news is that the code for the\nreconciliation logic in the commit phase is universal.\nTheo Does that mean that the same code for the commit phase can be used in any\nDOP system?\nJoe Definitely. The code that implements the commit phase assumes nothing\nabout the details of the system except that the system data is represented as an\nimmutable map.\nTIP The implementation of the commit phase in optimistic concurrency control is\nuniversal. It can be used in any system where the data is represented by an immutable\nhash map.\nTheo That’s awesome!\nJoe Another cool thing is that handling concurrency doesn’t require any changes\nto the code in the calculation phase. From the calculation phase perspective,\nthe next version of the system data is computed in isolation as if no other muta-\ntions were running concurrently.\nJoe stands up to illustrate what he means on the whiteboard. While Theo looks at the draw-\ning in figure 5.1, Joe summarizes the information in table 5.1.\nTable 5.1 The two phases of a mutation with optimistic concurrency control\nPhase Responsibility State Implementation\nCalculation Compute next state in isolation Stateless Specific\nCommit Reconcile and update system state Stateful Common\n--- Page 122 ---\n94 CHAPTER 5 Basic concurrency control\nCalculation phase\nCapturesystem state\nComputenext version\nCommit phase\nYes No\nConcurrent mutations?\nYes No\nConflict?\nUpdatesystem state\nAbortmutation Reconcilemutations\nUpdatesystem state\nFigure 5.1 The logic flow\nof optimistic concurrency\ncontrol\n5.2 Reconciliation between concurrent mutations\nTheo Could you give me some examples of conflicting concurrent mutations?\nJoe Sure. One example would be two members trying to borrow the same book\ncopy. Another example might be when two librarians update the publication\nyear of the same book.\nTheo You mentioned that the code for the reconciliation logic in the commit phase\nis universal. What do you mean exactly by reconciliation logic?\nJoe It’s quite similar to what could happen in Git when you merge a branch back\ninto the main branch.\nTheo I love it when the main branch stays the same.\nJoe Yes, it’s nice when the merge has no conflicts and can be done automatically.\nDo you remember how Git handles the merge in that case?\nTheo Git does a fast-forward; it updates the main branch to be the same as the merge\nbranch.\nJoe Right! And what happens when you discover that, meanwhile, another devel-\noper has committed their code to the main branch?\nTheo Then Git does a three-way merge, trying to combine all the changes from the\ntwo merge branches with the main branch.\nJoe Does it always go smoothly?\nTheo Usually, yes, but it’s possible that two developers have modified the same line\nin the same file. I then have to manually resolve the conflict. I hate when that\nhappens!\nTIP In a production system, multiple mutations run concurrently. Before updating\nthe state, we need to reconcile the conflicts between possible concurrent mutations.\n--- Page 123 ---\n5.2 Reconciliation between concurrent mutations 95\nJoe In DOP, the reconciliation algorithm in the commit phase is quite similar to a\nmerge in Git, except instead of a manual conflict resolution, we abort the\nmutation. There are three possibilities to reconcile between possible concur-\nrent mutations: fast-forward, three-way merge, or abort.\nJoe goes to the whiteboard again. He draws the two diagrams shown in figures 5.2 and 5.3.\nYes No\nState has stayed the same\nYes No\nConcurrent mutations compatible?\nFast forward\n3-way Merge Abort\nFigure 5.2 The\nreconciliation flow\nThe version during\nthe Commit phase\ncurrent\nprevious\nnext\nThe base version\nfor the Calculation\nThe version Figure 5.3 When the commit phase\nphase\nreturned by the starts, there are three versions of the\nCalculation phase system state.\nTheo Could you explain in more detail?\nJoe When the commit phase of a mutation starts, we have three versions of the sys-\ntem state: previous, which is the version on which the calculation phase based\nits computation; current, which is the current version during the commit\nphase; and next, which is the version returned by the calculation phase.\nTheo Why would current be different than previous?\nJoe It happens when other mutations have run concurrently with our mutation.\nTheo I see.\nJoe If we are in a situation where the current state is the same as the previous state,\nit means that no mutations run concurrently. Therefore, as in Git, we can\nsafely fast-forward and update the state of the system with the next version.\nTheo What if the state has not stayed the same?\nJoe Then it means that mutations have run concurrently. We have to check for\nconflicts in a way similar to the three-way merge used by Git. The difference is\nthat instead of comparing lines, we compare fields of the system hash map.\nTheo Could you explain that?\n--- Page 124 ---\n96 CHAPTER 5 Basic concurrency control\nJoe We calculate the diff between previous and next and between previous and\ncurrent. If the two diffs have no fields in common, then there is no conflict\nbetween the mutations that have run concurrently. We can safely apply the\nchanges from previous to next into current.\nJoe makes his explanation visual with another diagram on the whiteboard. He then shows\nfigure 5.4 to Theo.\ndiffPreviousCurrent diffPreviousNext\ncurrent\nprevious merged\ndiffPreviousNext\nnext\nFigure 5.4 In a three-way merge, we calculate the diff between previous and\nnext, and we apply it to current.\nTheo What if there is a conflict?\nJoe Then we abort the mutation.\nTheo Aborting a user request seems unacceptable.\nJoe In fact, in a user-facing system, conflicting concurrent mutations are fairly rare.\nThat’s why it’s OK to abort and let the user run the mutation again. Here, let\nme draft a table to show you the differences between Git and DOP (table 5.2).\nTable 5.2 The analogy between Git and data-oriented programming\nData-oriented programming Git\nConcurrent mutations Different branches\nA version of the system data A commit\nState A reference\nCalculation phase Branching\nValidation Precommit hook\nReconciliation Merge\nFast-forward Fast-forward\nThree-way merge Three-way merge\nAbort Manual conflict resolution\nHash map Tree (folder)\nLeaf node Blob (file)\nData field Line of code\n--- Page 125 ---\n5.3 Reducing collections 97\nTheo Great! That helps, but in cases where two mutations update the same field of\nthe same entity, I think it’s fair enough to let the user know that the request\ncan’t be processed.\nTIP In a user-facing system, conflicting concurrent mutations are fairly rare.\n5.3 Reducing collections\nJoe Are you ready to challenge your mind with the implementation of the diff\nalgorithm?\nTheo Let’s take a short coffee break before, if you don’t mind. Then, I’ll be ready to\ntackle anything.\nAfter enjoying large mug of hot coffee and a few butter cookies, Theo and Joe are back to\nwork. Their discussion on the diff algorithm continues.\nJoe In the implementation of the diff algorithm, we’re going to reduce collections.\nTheo I heard about reducing collections in a talk about FP, but I don’t remember\nthe details. Could you remind me how this works?\nJoe Imagine you want to calculate the sum of the elements in a collection of num-\nbers. With Lodash’s _.reduce, it would look like this.\nListing5.1 Summing numbers with _.reduce\n_.reduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nTheo I don’t understand.\nJoe goes to the whiteboard and writes the description of _.reduce. Theo waits patiently\nuntil Joe puts the pen down before looking at the description.\nDescription of _.reduce\n_.reduce receives three arguments:\n coll—A collection of elements\n f—A function that receives two arguments\n initVal—A value\nLogic flow:\n1 Initialize currentRes with initVal.\n2 For each element x of coll, update currentRes with f(currentRes, x).\n3 Return currentRes.",
        "sections_found": []
      },
      "accurate_page_range": "102-125"
    },
    {
      "text": "- 4.5 The commit phase of a mutation",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "raw_line": "- 4.5 The commit phase of a mutation (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 34,
      "chapter_info": {
        "page": 102,
        "title": "State management",
        "pattern_matched": "Chapter 4",
        "text_preview": "74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead"
      },
      "chapter_sections": {
        "start_page": 102,
        "end_page": 125,
        "content": "\n--- Page 102 ---\n74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead of being copied.\nThis technique efficiently creates new versions of the system data, both in\nterms of memory and computation.\nTheo I’m intrigued.\nTIP With structural sharing, it’s efficient (in terms of memory and computation) to\ncreate new versions of data.\nJoe I’ll explain in detail how structural sharing works in a moment.\nTheo takes another look at the diagram in figure 4.1, which illustrates how the system state\nrefers to a version of the system data. Suddenly, a question emerges.\nTheo Are the previous versions of the system data kept?\nJoe In a simple application, previous versions are automatically removed by the\ngarbage collector. But, in some cases, we maintain historical references to pre-\nvious versions of the data.\nTheo What kind of cases?\nJoe For example, if we want to support time travel in our system, as in Git, we can\nmove the system back to a previous version of the state easily.\nTheo Now I understand what you mean by data is immutable, but the state reference\nis mutable!\n4.2 Structural sharing\nAs mentioned in the previous section, structural sharing enables the efficient cre-\nation of new versions of immutable data. In DOP, we use structural sharing in the\ncalculation phase of a mutation to compute the next state of the system based on\nthe current state of the system. Inside the calculation phase, we don’t have to deal\nwith state management; that is delayed to the commit phase. As a consequence, the\ncode involved in the calculation phase of a mutation is stateless and is as simple as\nthe code of a query.\nTheo I’m really intrigued by this more efficient way to create new versions of data.\nHow does it work?\nJoe Let’s take a simple example from our library system. Imagine that you want to\nmodify the value of a field in a book in the catalog; for instance, the publica-\ntion year of Watchmen. Can you tell me the information path for Watchmen’s\npublication year?\nTheo takes a quick look at the catalog data in figure 4.2. Then he answers Joe’s question.\n--- Page 103 ---\n4.2 Structural sharing 75\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 4.2 Visualization of the catalog data. The nodes in the information path to Watchmen’s publication\nyear are marked with a dotted border.\nTheo The information path for Watchmen’s publication year is [\"catalog\", \"books-\nByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Now, let me show how you to use the immutable function _.set that Lodash\nalso provides.\nTheo Wait! What do you mean by an immutable function? When I looked at the\nLodash documentation for _.set on their website, it said that it mutates the\nobject.\nJoe You’re right, but the default Lodash functions are not immutable. In order to\nuse an immutable version of the functions, we need to use the Lodash FP mod-\nule as explained in the Lodash FP guide.\n NOTE See https://lodash.com/docs/4.17.15#set to view Lodash’s documentation\nfor _.set, and see https://github.com/lodash/lodash/wiki/FP-Guide to view the\nLodash FP guide.\nTheo Do the immutable functions have the same signature as the mutable functions?\nJoe By default, the order of the arguments in immutable functions is shuffled.\nThe Lodash FP guide explains how to resolve this. With this piece of code,\n--- Page 104 ---\n76 CHAPTER 4 State management\nthe signature of the immutable functions is exactly the same as the mutable\nfunctions.\nListing4.1 Configuring Lodash so immutable and mutable functions have same signature\n_ = fp.convert({\n\"cap\": false,\n\"curry\": false,\n\"fixed\": false,\n\"immutable\": true,\n\"rearg\": false\n});\nTIP In order to use Lodash immutable functions, we use Lodash’s FP module, and\nwe configure it so that the signature of the immutable functions is the same as in the\nLodash documentation web site.\nTheo So basically, I can still rely on Lodash documentation when using immutable\nversions of the functions.\nJoe Except for the piece in the documentation that says the function mutates the\nobject.\nTheo Of course!\nJoe Now I’ll show you how to write code that creates a version of the library data\nwith the immutable function _.set.\nJoe’s fingers fly across Theo’s keyboard. Theo then looks at Joe’s code, which creates a ver-\nsion of the library data where the Watchmen publication year is set to 1986.\nListing4.2 Using _.set as an immutable function\nvar nextLibraryData = _.set(libraryData,\n[\"catalog\", \"booksByIsbn\",\n\"978-1779501127\", \"publicationYear\"],\n1986);\n NOTE A function is said to be immutable when, instead of mutating the data, it cre-\nates a new version of the data without changing the data it receives.\nTheo You told me earlier that structural sharing allowed immutable functions to be\nefficient in terms of memory and computation. Can you tell me what makes\nthem efficient?\nJoe With pleasure, but before that, you have to answer a series of questions. Are\nyou ready?\nTheo Yes, sure...\nJoe What part of the library data is impacted by updating the Watchmen publication\nyear: the UserManagement or the Catalog?\n--- Page 105 ---\n4.2 Structural sharing 77\nTheo Only the Catalog.\nJoe What part of the Catalog?\nTheo Only the booksByIsbn index.\nJoe What part of the booksByIsbn index?\nTheo Only the Book record that holds the information about Watchmen.\nJoe What part of the Book record?\nTheo Only the publicationYear field.\nJoe Perfect! Now, suppose that the current version of the library data looks like\nthis.\nJoe goes to the whiteboard and draws a diagram. Figure 4.3 shows the result.\nLibrary\nCatalog UserManagement\nauthorsByld booksBylsbn ...\n... watchmen\ntitle:Watchmen publicationYear:1987 authorlds\n...\nFigure 4.3 High-level visualization of the current version of Library\nTheo So far, so good...\nJoe Next, let me show you what an immutable function does when you use it to cre-\nate a new version of Library, where the publication year of Watchmen is set to\n1986 instead of 1987.\nJoe updates his diagram on the whiteboard. It now looks like figure 4.4.\n--- Page 106 ---\n78 CHAPTER 4 State management\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.4 Structural sharing provides an efficient way to create a new version of the data.\nNext Library is recursively made of nodes that use the parts of Library that are\ncommon between the two.\nTheo Could you explain?\nJoe The immutable function creates a fresh Library hash map, which recursively\nuses the parts of the current Library that are common between the two ver-\nsions instead of deeply copying them.\nTheo It’s a bit abstract for me.\nJoe The next version of Library uses the same UserManagement hash map as the\nold one. The Catalog inside the next Library uses the same authorsById as\nthe current Catalog. The Watchmen Book record inside the next Catalog uses\nall the fields of the current Book except for the publicationYear field.\nTheo So, in fact, most parts of the data are shared between the two versions. Right?\nJoe Exactly! That’s why this technique is called structural sharing.\nTIP Structural sharing provides an efficient way (both in terms of memory and com-\nputation) to create a new version of the data by recursively sharing the parts that don’t\nneed to change.\nTheo That’s very cool!\nJoe Indeed. Now let’s look at how to write a mutation for adding a member using\nimmutable functions.\n--- Page 107 ---\n4.2 Structural sharing 79\nOnce again, Joe goes to the whiteboard. Figure 4.5 shows the diagram that Joe draws to\nillustrate how structural sharing looks when we add a member.\n«Next»\nLibrary\nLibrary\n«Next»\nUserManagement Catalog\nuserManagement\n«Next»\nmembers librarians ...\nmembers\nFigure 4.5 Adding a member\nwith structural sharing. Most of\nthe data is shared between the\n... member0 member1\ntwo versions.\nTheo Awesome! The Catalog and the librarians hash maps don’t have to be copied!\nJoe Now, in terms of code, we have to write a Library.addMember function that\ndelegates to UserManagement.addMember.\nTheo I guess it’s going to be similar to the code we wrote earlier to implement the\nsearch books query, where Library.searchBooksByTitleJSON delegates to\nCatalog.searchBooksByTitle.\nJoe Similar in the sense that all the functions are static, and they receive the data\nthey manipulate as an argument. But there are two differences. First, a muta-\ntion could fail, for instance, if the member to be added already exists. Second,\nthe code for Library.addMember is a bit more elaborate than the code for\nLibrary.searchBooksByTitleJSON because we have to create a new version\nof Library that refers to the new version of UserManagement. Here, let me\nshow you an example.\nListing4.3 The code for the mutation that adds a member\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nChecks if a member with\nthrow \"Member already exists.\";\nthe same email address\n}\nalready exists\nvar nextUserManagement = _.set(\nuserManagement,\nCreates a new version of\ninfoPath,\nuserManagement that\nmember);\nincludes the member\nreturn nextUserManagement;\n};\n--- Page 108 ---\n80 CHAPTER 4 State management\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library,\n\"userManagement\",\nnextUserManagement);\nCreates a new version of\nreturn nextLibrary;\nlibrary that contains the new\n};\nversion of userManagement\nTheo To me, it’s a bit weird that immutable functions return an updated version of\nthe data instead of changing it in place.\nJoe It was also weird for me when I first encountered immutable data in Clojure\nseven years ago.\nTheo How long did it take you to get used to it?\nJoe A couple of weeks.\n4.3 Implementing structural sharing\nWhen Joe leaves the office, Theo meets Dave near the coffee machine. Dave looks perplexed.\nDave Who’s the guy that just left the office?\nTheo It’s Joe. My DOP mentor.\nDave What’s DOP?\nTheo DOP refers to data-oriented programming.\nDave I never heard that term before.\nTheo It’s not well-known by programmers yet, but it’s quite a powerful programming\nparadigm. From what I’ve seen so far, it makes programming much simpler.\nDave Can you give me an example?\nTheo I just learned about structural sharing and how it makes it possible to create\nnew versions of data, effectively without copying.\nDave How does that work?\nTheo takes Dave to his office and shows him Joe’s diagram on the whiteboard (see figure 4.6).\nIt takes Theo a few minutes to explain to Dave what it does exactly, but in the end, Dave\ngets it.\nDave What does the implementation of structural sharing look like?\nTheo I don’t know. I used the _.set function from Lodash.\nDave It sounds like an interesting challenge.\nTheo Take the challenge if you want. Right now, I’m too tired for this recursive algo-\nrithmic stuff.\n--- Page 109 ---\n4.3 Implementing structural sharing 81\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.6 Structural sharing in action\nThe next day, Theo stops by Dave’s cubicle before heading to his office. Dave, with a touch\nof pride, shows Theo his implementation of structural sharing. Theo is amazed by the fact\nthat it’s only 11 lines of JavaScript code!\nListing4.4 The implementation of structural sharing\nfunction setImmutable(map, path, v) {\nvar modifiedNode = v;\nvar k = path[0];\nvar restOfPath = path.slice(1);\nif (restOfPath.length > 0) {\nmodifiedNode = setImmutable(map[k], restOfPath, v);\n}\nvar res = Object.assign({}, map);\nShallow\nres[k] = modifiedNode;\nclones a map\nreturn res;\nin JavaScript.\n}\nTheo Dave, you’re brilliant!\nDave (smiling) Aw, shucks.\nTheo Oops, I have to go. I’m already late for my session with Joe! Joe is probably wait-\ning in my office, biting his nails.\n--- Page 110 ---\n82 CHAPTER 4 State management\n4.4 Data safety\nJoe is about to start the day’s lesson. Theo asks him a question about yesterday’s material\ninstead.\nTheo Something isn’t clear to me regarding this structural sharing stuff. What hap-\npens if we write code that modifies the data part that’s shared between the two\nversions of the data? Does the change affect both versions?\nJoe Could you please write a code snippet that illustrates your question?\nTheo starts typing on his laptop. He comes up with this code to illustrate modifying a piece\nof data shared between two versions.\nListing4.5 Modifying data that’s shared between two versions\nvar books = {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n};\nvar nextBooks = _.set(books, [\"978-1779501127\", \"publicationYear\"], 1986)\nconsole.log(\"Before:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\nbooks[\"978-1779501127\"][\"authorIds\"][1] = \"dave-chester-gibbons\";\nconsole.log(\"After:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\n// → Before: dave-gibbons\n// → After: dave-chester-gibbons\nTheo My question is, what is the value of isBlocked in updatedMember?\nJoe The answer is that mutating data via the native hash map setter is forbidden.\nAll the data manipulation must be done via immutable functions.\n NOTE All data manipulation must be done with immutable functions. It is forbid-\nden to use the native hash map setter.\nTheo When you say “forbidden,” you mean that it’s up to the developer to make sure\nit doesn’t happen. Right?\nJoe Exactly.\nTheo Is there a way to protect our system from a developer’s mistake?\nJoe Yes, there is a way to ensure the immutability of the data at the level of the data\nstructure. It’s called persistent data structures.\nTheo Are persistent data structures also efficient in terms of memory and computation?\nJoe Actually, the way data is organized inside persistent data structures make them\neven more efficient than immutable functions.\n--- Page 111 ---\n4.5 The commit phase of a mutation 83\nTIP Persistent data structures are immutable at the level of the data. There is no way\nto mutate them, even by mistake.\nTheo Are there libraries providing persistent data structures?\nJoe Definitely. I just happen to have a list of those libraries on my computer.\nJoe, being well-organized for a programmer, quickly brings up his list. He shows it to Theo:\n Immutable.js in JavaScript at https://immutable-js.com/\n Paguro in Java at https://github.com/GlenKPeterson/Paguro\n Immutable Collections in C# at http://mng.bz/y4Ke\n Pyrsistent in Python at https://github.com/tobgu/pyrsistent\n Hamster in Ruby at https://github.com/hamstergem/hamster\nTheo Why not use persistent data structures instead of immutable functions?\nJoe The drawback of persistent data structures is that they are not native. This\nmeans that working with them requires conversion from native to persistent\nand from persistent to native.\nTheo What approach would you recommend?\nJoe If you want to play around a bit, then start with immutable functions. But for a\nproduction application, I’d recommend using persistent data structures.\nTheo Too bad the native data structures aren’t persistent!\nJoe That’s one of the reasons why I love Clojure—the native data structures of the\nlanguage are immutable!\n4.5 The commit phase of a mutation\nSo far, we saw how to implement the calculation phase of a mutation. The calculation\nphase is stateless in the sense that it doesn’t make any change to the system. Now, let’s\nsee how to update the state of the system inside the commit phase.\nTheo takes another look at the code for Library.addMember. Something bothers him:\nthis function returns a new state of the library that contains an additional member, but it\ndoesn’t affect the current state of the library.\nListing4.6 The commit phase moves the system state forward\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nTheo I see that Library.addMember doesn’t change the state of the library. How\ndoes the library state get updated?\n--- Page 112 ---\n84 CHAPTER 4 State management\nJoe That’s an excellent question. Library.addMember deals only with data calcula-\ntion and is stateless. The state is updated in the commit phase by moving for-\nward the version of the state that the system state refers to.\nTheo What do you mean by that?\nJoe Here’s what happens when we add a member to the system. The calculation\nphase creates a version of the state that has two members. Before the commit\nphase, the system state refers to the version of the state with one member. The\nresponsibility of the commit phase is to move the system state forward so that it\nrefers to the version of the state with two members.\nTIP The responsibility of the commit phase is to move the system state forward to the\nversion of the state returned by the calculation phase.\nJoe draws another illustration on the whiteboard (figure 4.7). He hopes it helps to clear up\nany misunderstanding Theo may have.\nBefore Commit After Commit\nState with one State with one\nSystem State\nmember member\naddMember addMember\nState with two State with two\nSystem State\nmembers members\nFigure 4.7 The commit phase moves the system state forward.\nTheo How is this implemented?\nJoe The code is made of two classes: System, a singleton stateful class that imple-\nments the mutations, and SystemState, a singleton stateful class that manages\nthe system state.\nTheo It sounds to me like classic OOP.\nJoe Right, and this part of the system being stateful is OOP-like.\nTheo I’m happy to see that you still find some utility in OOP.\nJoe Meditation taught me that every part of our universe has a role to play.\nTheo Nice! Could you show me some code?\nJoe Sure.\nJoe thinks for a moment before starting to type. He wants to show the System class and its\nimplementation of the addMember mutation.\nListing4.7 The System class\nclass System {\naddMember(member) {\nvar previous = SystemState.get();\n--- Page 113 ---\n4.6 Ensuring system state integrity 85\nvar next = Library.addMember(previous, member);\nSystemState.commit(previous, next);\nSystemState is covered\n}\nin listing 4.8.\n}\nTheo What does SystemState look like?\nJoe I had a feeling you were going to ask that. Here’s the code for the System-\nState class, which is a stateful class!\nListing4.8 The SystemState class\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nTheo I don’t get the point of SystemState. It’s a simple class with a getter and a\ncommit function, right?\nJoe In a moment, we are going to enrich the code of the SystemState.commit\nmethod so that it provides data validation and history tracking. For now, the\nimportant thing to notice is that the code of the calculation phase is stateless\nand is decoupled from the code of the commit phase, which is stateful.\nTIP The calculation phase is stateless. The commit phase is stateful.\n4.6 Ensuring system state integrity\nTheo Something still bothers me about the way functions manipulate immutable\ndata in the calculation phase. How do we preserve data integrity?\nJoe What do you mean?\nTheo In OOP, data is manipulated only by methods that belong to the same class as\nthe data. It prevents other classes from corrupting the inner state of the class.\nJoe Could you give me an example of an invalid state of the library?\nTheo For example, imagine that the code of a mutation adds a book item to the\nbook lendings of a member without marking the book item as lent in the cata-\nlog. Then the system data would be corrupted.\nJoe In DOP, we have the privilege of ensuring data integrity at the level of the\nwhole system instead of scattering the validation among many classes.\nTheo How does that work?\nJoe The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system data in a central place. At the beginning of the\ncommit phase, there is a step that checks whether the version of the system\n--- Page 114 ---\n86 CHAPTER 4 State management\nstate to be committed is valid. If the data is invalid, the commit is rejected.\nHere let me show you.\nListing4.9 Data validation inside the commit phase\nSystemState.commit = function(previous, next) {\nif(!SystemValidity.validate(previous, next)) { // not implemented for now\nthrow \"The system data to be committed is not valid!\";\n};\nthis.systemData = next;\n};\nTheo It sounds similar to a commit hook in Git.\nJoe I like your analogy!\nTheo Why are you passing the previous state in previous and the next state in next\nto SystemValidity.validate?\nJoe Because it allows SystemValidity.validate to optimize the validation in\nterms of computation. For example, we could validate just the data that has\nchanged.\nTIP In DOP, we validate the system data as a whole. Data validation is decoupled\nfrom data manipulation.\nTheo What does the code of SystemValidity.validate look like?\nJoe Someday, I will show you how to define a data schema and to validate that a\npiece of data conforms to a schema.\n NOTE See chapters 7 and 12 to see how Joe defines this data schema.\n4.7 Restoring previous states\nAnother advantage of the multi-version state approach with immutable data that is\nmanipulated via structural sharing is that we can keep track of the history of all the\nversions of the data without exploding the memory of our program. It allows us, for\ninstance, to restore the system back to an earlier state easily.\nTheo You told me earlier that it was easy to restore the system to a previous state.\nCould you show me how?\nJoe Happily, but before that, I’d like to make sure you understand why keeping\ntrack of all the versions of the data is efficient in terms of memory.\nTheo I think it’s related to the fact that immutable functions use structural sharing,\nand most of the data between subsequent versions of the state is shared.\nTIP Structural sharing allows us to keep many versions of the system state without\nexploding memory use.\nJoe Perfect! Now, I’ll show you how simple it is to undo a mutation. In order to\nimplement an undo mechanism, our SystemState class needs to have two\n--- Page 115 ---\n4.7 Restoring previous states 87\nreferences to the system data: systemData references the current state of the\nsystem, and previousSystemData references the previous state of the system.\nTheo That makes sense.\nJoe In the commit phase, we update both previousSystemData and systemData.\nTheo What does it take to implement an undo mechanism?\nJoe The undo is achieved by having systemData reference the same version of the\nsystem data as previousSystemData.\nTheo Could you walk me through an example?\nJoe To make things simple, I am going to give a number to each version of the sys-\ntem state. It starts at V0, and each time a mutation is committed, the version is\nincremented: V1, V2, V3, and so forth.\nTheo OK.\nJoe Let’s say that currently our system state is at V12 (see figure 4.8). In the\nSystemState object, systemData refers to V12, and previousSystemData\nrefers to V11.\npreviousSystemData\nMutationA Mutation B\nData V10 Data V11 Data V12\nsystemData\nFigure 4.8 When the system state is at V12, systemData refers to V12, and\npreviousSystemData refers to V11.\nTheo So far, so good...\nJoe Now, when a mutation is committed (for instance, adding a member), both\nreferences move forward: systemData refers to V13, and previousSystem-\nData refers to V12.\nJoe erases the whiteboard to make room for another diagram (figure 4.9). When he’s\nthrough with his drawing, he shows it to Theo.\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.9 When a mutation is committed, systemData refers to V13, and\npreviousSystemData refers to V12.\n--- Page 116 ---\n88 CHAPTER 4 State management\nTheo I suppose that when we undo the mutation, both references move backward.\nJoe In theory, yes, but in practice, it’s necessary to maintain a stack of all the state\nreferences. For now, to simplify things, we’ll maintain only a reference to the\nprevious version. As a consequence, when we undo the mutation, both refer-\nences refer to V12. Let me draw another diagram on the whiteboard that shows\nthis state (see figure 4.10).\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.10 When a mutation is undone, both systemData and previousSystemData refer\nto V12.\nTheo Could you show me how to implement this undo mechanism?\nJoe Actually, it takes only a couple of changes to the SystemState class. Pay atten-\ntion to the changes in the commit function. Inside systemDataBeforeUpdate,\nwe keep a reference to the current state of the system. If the validation and\nthe conflict resolution succeed, we update both previousSystemData and\nsystemData.\nListing4.10 The SystemState class with undo capability\nclass SystemState {\nsystemData;\npreviousSystemData;\nget() {\nreturn this.systemData;\n}\ncommit(previous, next) {\nvar systemDataBeforeUpdate = this.systemData;\nif(!Consistency.validate(previous, next)) {\nthrow \"The system data to be committed is not valid!\";\n}\nthis.systemData = next;\nthis.previousSystemData = systemDataBeforeUpdate;\n}\nundoLastMutation() {\nthis.systemData = this.previousSystemData;\n}\n}\n--- Page 117 ---\nSummary 89\nTheo I see that implementing System.undoLastMutation is simply a matter of hav-\ning systemData refer the same value as previousSystemData.\nJoe As I told you, if we need to allow multiple undos, the code would be a bit more\ncomplicated, but you get the idea.\nTheo I think so. Although Back to the Future belongs to the realm of science fiction, in\nDOP, time travel is real.\nSummary\n DOP principle #3 states that data is immutable.\n A mutation is an operation that changes the state of the system.\n In a multi-version approach to state management, mutations are split into cal-\nculation and commit phases.\n All data manipulation must be done via immutable functions. It is forbidden to\nuse the native hash map setter.\n Structural sharing allows us to create new versions of data efficiently (in terms of\nmemory and computation), where data that is common between the two ver-\nsions is shared instead of being copied.\n Structural sharing creates a new version of the data by recursively sharing the\nparts that don’t need to change.\n A mutation is split in two phases: calculation and commit.\n A function is said to be immutable when, instead of mutating the data, it creates\na new version of the data without changing the data it receives.\n During the calculation phase, data is manipulated with immutable functions that\nuse structural sharing.\n The calculation phase is stateless.\n During the commit phase, we update the system state.\n The responsibility of the commit phase is to move the system state forward to\nthe version of the state returned by the calculation phase.\n The data is immutable, but the state reference is mutable.\n The commit phase is stateful.\n We validate the system data as a whole. Data validation is decoupled from data\nmanipulation.\n The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system state in a central place before we update the\nstate.\n Keeping the history of the versions of the system data is memory efficient due to\nstructural sharing.\n Restoring the system to one of its previous states is straightforward due to the\nclear separation between the calculation phase and the commit phase.\n--- Page 118 ---\n90 CHAPTER 4 State management\n In order to use Lodash immutable functions, we use the Lodash FP module\n(https://github.com/lodash/lodash/wiki/FP-Guide).\nLodash functions introduced in this chapter\nFunction Description\nset(map, path, value) Creates a map with the same fields as map with the addition of a\n<path, value> field\n--- Page 119 ---\nBasic concurrency control\nConflicts at home\nThis chapter covers\n Managing concurrent mutations with a lock-free\noptimistic concurrency control strategy\n Supporting high throughput of reads and writes\n Reconciliation between concurrent mutations\nThe changes required for system manage concurrency are only in the commit\nphase. They involve a reconciliation algorithm that is universal, in the sense that it\ncan be used in any system where data is represented as an immutable hash map.\nThe implementation of the reconciliation algorithm is efficient because subse-\nquent versions of the system state are created via structural sharing.\nIn the previous chapter, we illustrated the multiversion approach to state man-\nagement, where a mutation is split into two distinct phases: the calculation phase\nthat deals only with computation, and the commit phase that moves the state ref-\nerence forward. Usually, in a production system, mutations occur concurrently.\nMoving the state forward naively like we did in the previous chapter is not appro-\npriate. In the present chapter, we are going to learn how to handle concurrent\nmutations.\n91\n--- Page 120 ---\n92 CHAPTER 5 Basic concurrency control\nIn DOP, because only the code of the commit phase is stateful, that allows us to use\nan optimistic concurrency control strategy that doesn’t involve any locking mechanism. As\na consequence, the throughput of reads and writes is high. The modifications to the\ncode are not trivial, as we have to implement an algorithm that reconciles concurrent\nmutations. But the modifications impact only the commit phase. The code for the cal-\nculation phase stays the same as in the previous chapter.\n NOTE This chapter requires more of an effort to grasp. The flow of the reconcilia-\ntion algorithm is definitely not trivial, and the implementation involves a nontrivial\nrecursion.\n5.1 Optimistic concurrency control\nThis morning, before getting to work, Theo takes Joe to the fitness room in the office and,\nwhile running on the step machine, the two men talk about their personal lives again. Joe\ntalks about a fight he had last night with Kay, who thinks that he pays more attention to his\nwork than to his family. Theo recounts the painful conflict he had with Jane, his wife,\nabout house budget management. They went to see a therapist, an expert in Imago Rela-\ntionship Therapy. Imago allowed them to transform their conflict into an opportunity to\ngrow and heal.\nJoe’s ears perk up when he hears the word conflict because today’s lesson is going to be\nabout resolving conflicts and concurrent mutations. A different kind of conflict, though....\nAfter a shower and a healthy breakfast, Theo and Joe get down to work.\nJoe Yesterday, I showed you how to manage state with immutable data, assuming\nthat no mutations occur concurrently. Today, I am going to show you how to\ndeal with concurrency control in DOP.\nTheo I’m curious to discover what kind of lock mechanisms you use in DOP to syn-\nchronize concurrent mutations.\nJoe In fact, we don’t use any lock mechanism!\nTheo Why not?\nJoe Locks hit performance, and if you’re not careful, your system could get into a\ndeadlock.\nTheo So, how do you handle possible conflicts between concurrent mutations in\nDOP?\nJoe In DOP, we use a lock-free strategy called optimistic concurrency control. It’s a\nstrategy that allows databases like Elasticsearch to be highly scalable.\n NOTE See https://www.elastic.co/elasticsearch/ to find out more about Elastic-\nsearch.\nTheo You sound like my couples therapist and her anger-free, optimistic conflict\nresolution strategy.\nJoe Optimistic concurrency control and DOP fit together well. As you will see in a\nmoment, optimistic concurrency control is super efficient when the system\ndata is immutable.\n--- Page 121 ---\n5.1 Optimistic concurrency control 93\nTIP Optimistic concurrency control with immutable data is super efficient.\nTheo How does it work?\nJoe Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTIP Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTheo What do you mean?\nJoe The calculation phase does its calculation as if it were the only mutation run-\nning. The commit phase is responsible for reconciling concurrent mutations\nwhen they don’t conflict or for aborting the mutation.\nTIP The calculation phase does its calculation as if it were the only mutation running.\nThe commit phase is responsible for trying to reconcile concurrent mutations.\nTheo That sounds quite challenging to implement.\nJoe Dealing with state is never trivial. But the good news is that the code for the\nreconciliation logic in the commit phase is universal.\nTheo Does that mean that the same code for the commit phase can be used in any\nDOP system?\nJoe Definitely. The code that implements the commit phase assumes nothing\nabout the details of the system except that the system data is represented as an\nimmutable map.\nTIP The implementation of the commit phase in optimistic concurrency control is\nuniversal. It can be used in any system where the data is represented by an immutable\nhash map.\nTheo That’s awesome!\nJoe Another cool thing is that handling concurrency doesn’t require any changes\nto the code in the calculation phase. From the calculation phase perspective,\nthe next version of the system data is computed in isolation as if no other muta-\ntions were running concurrently.\nJoe stands up to illustrate what he means on the whiteboard. While Theo looks at the draw-\ning in figure 5.1, Joe summarizes the information in table 5.1.\nTable 5.1 The two phases of a mutation with optimistic concurrency control\nPhase Responsibility State Implementation\nCalculation Compute next state in isolation Stateless Specific\nCommit Reconcile and update system state Stateful Common\n--- Page 122 ---\n94 CHAPTER 5 Basic concurrency control\nCalculation phase\nCapturesystem state\nComputenext version\nCommit phase\nYes No\nConcurrent mutations?\nYes No\nConflict?\nUpdatesystem state\nAbortmutation Reconcilemutations\nUpdatesystem state\nFigure 5.1 The logic flow\nof optimistic concurrency\ncontrol\n5.2 Reconciliation between concurrent mutations\nTheo Could you give me some examples of conflicting concurrent mutations?\nJoe Sure. One example would be two members trying to borrow the same book\ncopy. Another example might be when two librarians update the publication\nyear of the same book.\nTheo You mentioned that the code for the reconciliation logic in the commit phase\nis universal. What do you mean exactly by reconciliation logic?\nJoe It’s quite similar to what could happen in Git when you merge a branch back\ninto the main branch.\nTheo I love it when the main branch stays the same.\nJoe Yes, it’s nice when the merge has no conflicts and can be done automatically.\nDo you remember how Git handles the merge in that case?\nTheo Git does a fast-forward; it updates the main branch to be the same as the merge\nbranch.\nJoe Right! And what happens when you discover that, meanwhile, another devel-\noper has committed their code to the main branch?\nTheo Then Git does a three-way merge, trying to combine all the changes from the\ntwo merge branches with the main branch.\nJoe Does it always go smoothly?\nTheo Usually, yes, but it’s possible that two developers have modified the same line\nin the same file. I then have to manually resolve the conflict. I hate when that\nhappens!\nTIP In a production system, multiple mutations run concurrently. Before updating\nthe state, we need to reconcile the conflicts between possible concurrent mutations.\n--- Page 123 ---\n5.2 Reconciliation between concurrent mutations 95\nJoe In DOP, the reconciliation algorithm in the commit phase is quite similar to a\nmerge in Git, except instead of a manual conflict resolution, we abort the\nmutation. There are three possibilities to reconcile between possible concur-\nrent mutations: fast-forward, three-way merge, or abort.\nJoe goes to the whiteboard again. He draws the two diagrams shown in figures 5.2 and 5.3.\nYes No\nState has stayed the same\nYes No\nConcurrent mutations compatible?\nFast forward\n3-way Merge Abort\nFigure 5.2 The\nreconciliation flow\nThe version during\nthe Commit phase\ncurrent\nprevious\nnext\nThe base version\nfor the Calculation\nThe version Figure 5.3 When the commit phase\nphase\nreturned by the starts, there are three versions of the\nCalculation phase system state.\nTheo Could you explain in more detail?\nJoe When the commit phase of a mutation starts, we have three versions of the sys-\ntem state: previous, which is the version on which the calculation phase based\nits computation; current, which is the current version during the commit\nphase; and next, which is the version returned by the calculation phase.\nTheo Why would current be different than previous?\nJoe It happens when other mutations have run concurrently with our mutation.\nTheo I see.\nJoe If we are in a situation where the current state is the same as the previous state,\nit means that no mutations run concurrently. Therefore, as in Git, we can\nsafely fast-forward and update the state of the system with the next version.\nTheo What if the state has not stayed the same?\nJoe Then it means that mutations have run concurrently. We have to check for\nconflicts in a way similar to the three-way merge used by Git. The difference is\nthat instead of comparing lines, we compare fields of the system hash map.\nTheo Could you explain that?\n--- Page 124 ---\n96 CHAPTER 5 Basic concurrency control\nJoe We calculate the diff between previous and next and between previous and\ncurrent. If the two diffs have no fields in common, then there is no conflict\nbetween the mutations that have run concurrently. We can safely apply the\nchanges from previous to next into current.\nJoe makes his explanation visual with another diagram on the whiteboard. He then shows\nfigure 5.4 to Theo.\ndiffPreviousCurrent diffPreviousNext\ncurrent\nprevious merged\ndiffPreviousNext\nnext\nFigure 5.4 In a three-way merge, we calculate the diff between previous and\nnext, and we apply it to current.\nTheo What if there is a conflict?\nJoe Then we abort the mutation.\nTheo Aborting a user request seems unacceptable.\nJoe In fact, in a user-facing system, conflicting concurrent mutations are fairly rare.\nThat’s why it’s OK to abort and let the user run the mutation again. Here, let\nme draft a table to show you the differences between Git and DOP (table 5.2).\nTable 5.2 The analogy between Git and data-oriented programming\nData-oriented programming Git\nConcurrent mutations Different branches\nA version of the system data A commit\nState A reference\nCalculation phase Branching\nValidation Precommit hook\nReconciliation Merge\nFast-forward Fast-forward\nThree-way merge Three-way merge\nAbort Manual conflict resolution\nHash map Tree (folder)\nLeaf node Blob (file)\nData field Line of code\n--- Page 125 ---\n5.3 Reducing collections 97\nTheo Great! That helps, but in cases where two mutations update the same field of\nthe same entity, I think it’s fair enough to let the user know that the request\ncan’t be processed.\nTIP In a user-facing system, conflicting concurrent mutations are fairly rare.\n5.3 Reducing collections\nJoe Are you ready to challenge your mind with the implementation of the diff\nalgorithm?\nTheo Let’s take a short coffee break before, if you don’t mind. Then, I’ll be ready to\ntackle anything.\nAfter enjoying large mug of hot coffee and a few butter cookies, Theo and Joe are back to\nwork. Their discussion on the diff algorithm continues.\nJoe In the implementation of the diff algorithm, we’re going to reduce collections.\nTheo I heard about reducing collections in a talk about FP, but I don’t remember\nthe details. Could you remind me how this works?\nJoe Imagine you want to calculate the sum of the elements in a collection of num-\nbers. With Lodash’s _.reduce, it would look like this.\nListing5.1 Summing numbers with _.reduce\n_.reduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nTheo I don’t understand.\nJoe goes to the whiteboard and writes the description of _.reduce. Theo waits patiently\nuntil Joe puts the pen down before looking at the description.\nDescription of _.reduce\n_.reduce receives three arguments:\n coll—A collection of elements\n f—A function that receives two arguments\n initVal—A value\nLogic flow:\n1 Initialize currentRes with initVal.\n2 For each element x of coll, update currentRes with f(currentRes, x).\n3 Return currentRes.",
        "sections_found": []
      },
      "accurate_page_range": "102-125"
    },
    {
      "text": "- 4.6 Ensuring system state integrity",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "raw_line": "- 4.6 Ensuring system state integrity (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 35,
      "chapter_info": {
        "page": 102,
        "title": "State management",
        "pattern_matched": "Chapter 4",
        "text_preview": "74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead"
      },
      "chapter_sections": {
        "start_page": 102,
        "end_page": 125,
        "content": "\n--- Page 102 ---\n74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead of being copied.\nThis technique efficiently creates new versions of the system data, both in\nterms of memory and computation.\nTheo I’m intrigued.\nTIP With structural sharing, it’s efficient (in terms of memory and computation) to\ncreate new versions of data.\nJoe I’ll explain in detail how structural sharing works in a moment.\nTheo takes another look at the diagram in figure 4.1, which illustrates how the system state\nrefers to a version of the system data. Suddenly, a question emerges.\nTheo Are the previous versions of the system data kept?\nJoe In a simple application, previous versions are automatically removed by the\ngarbage collector. But, in some cases, we maintain historical references to pre-\nvious versions of the data.\nTheo What kind of cases?\nJoe For example, if we want to support time travel in our system, as in Git, we can\nmove the system back to a previous version of the state easily.\nTheo Now I understand what you mean by data is immutable, but the state reference\nis mutable!\n4.2 Structural sharing\nAs mentioned in the previous section, structural sharing enables the efficient cre-\nation of new versions of immutable data. In DOP, we use structural sharing in the\ncalculation phase of a mutation to compute the next state of the system based on\nthe current state of the system. Inside the calculation phase, we don’t have to deal\nwith state management; that is delayed to the commit phase. As a consequence, the\ncode involved in the calculation phase of a mutation is stateless and is as simple as\nthe code of a query.\nTheo I’m really intrigued by this more efficient way to create new versions of data.\nHow does it work?\nJoe Let’s take a simple example from our library system. Imagine that you want to\nmodify the value of a field in a book in the catalog; for instance, the publica-\ntion year of Watchmen. Can you tell me the information path for Watchmen’s\npublication year?\nTheo takes a quick look at the catalog data in figure 4.2. Then he answers Joe’s question.\n--- Page 103 ---\n4.2 Structural sharing 75\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 4.2 Visualization of the catalog data. The nodes in the information path to Watchmen’s publication\nyear are marked with a dotted border.\nTheo The information path for Watchmen’s publication year is [\"catalog\", \"books-\nByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Now, let me show how you to use the immutable function _.set that Lodash\nalso provides.\nTheo Wait! What do you mean by an immutable function? When I looked at the\nLodash documentation for _.set on their website, it said that it mutates the\nobject.\nJoe You’re right, but the default Lodash functions are not immutable. In order to\nuse an immutable version of the functions, we need to use the Lodash FP mod-\nule as explained in the Lodash FP guide.\n NOTE See https://lodash.com/docs/4.17.15#set to view Lodash’s documentation\nfor _.set, and see https://github.com/lodash/lodash/wiki/FP-Guide to view the\nLodash FP guide.\nTheo Do the immutable functions have the same signature as the mutable functions?\nJoe By default, the order of the arguments in immutable functions is shuffled.\nThe Lodash FP guide explains how to resolve this. With this piece of code,\n--- Page 104 ---\n76 CHAPTER 4 State management\nthe signature of the immutable functions is exactly the same as the mutable\nfunctions.\nListing4.1 Configuring Lodash so immutable and mutable functions have same signature\n_ = fp.convert({\n\"cap\": false,\n\"curry\": false,\n\"fixed\": false,\n\"immutable\": true,\n\"rearg\": false\n});\nTIP In order to use Lodash immutable functions, we use Lodash’s FP module, and\nwe configure it so that the signature of the immutable functions is the same as in the\nLodash documentation web site.\nTheo So basically, I can still rely on Lodash documentation when using immutable\nversions of the functions.\nJoe Except for the piece in the documentation that says the function mutates the\nobject.\nTheo Of course!\nJoe Now I’ll show you how to write code that creates a version of the library data\nwith the immutable function _.set.\nJoe’s fingers fly across Theo’s keyboard. Theo then looks at Joe’s code, which creates a ver-\nsion of the library data where the Watchmen publication year is set to 1986.\nListing4.2 Using _.set as an immutable function\nvar nextLibraryData = _.set(libraryData,\n[\"catalog\", \"booksByIsbn\",\n\"978-1779501127\", \"publicationYear\"],\n1986);\n NOTE A function is said to be immutable when, instead of mutating the data, it cre-\nates a new version of the data without changing the data it receives.\nTheo You told me earlier that structural sharing allowed immutable functions to be\nefficient in terms of memory and computation. Can you tell me what makes\nthem efficient?\nJoe With pleasure, but before that, you have to answer a series of questions. Are\nyou ready?\nTheo Yes, sure...\nJoe What part of the library data is impacted by updating the Watchmen publication\nyear: the UserManagement or the Catalog?\n--- Page 105 ---\n4.2 Structural sharing 77\nTheo Only the Catalog.\nJoe What part of the Catalog?\nTheo Only the booksByIsbn index.\nJoe What part of the booksByIsbn index?\nTheo Only the Book record that holds the information about Watchmen.\nJoe What part of the Book record?\nTheo Only the publicationYear field.\nJoe Perfect! Now, suppose that the current version of the library data looks like\nthis.\nJoe goes to the whiteboard and draws a diagram. Figure 4.3 shows the result.\nLibrary\nCatalog UserManagement\nauthorsByld booksBylsbn ...\n... watchmen\ntitle:Watchmen publicationYear:1987 authorlds\n...\nFigure 4.3 High-level visualization of the current version of Library\nTheo So far, so good...\nJoe Next, let me show you what an immutable function does when you use it to cre-\nate a new version of Library, where the publication year of Watchmen is set to\n1986 instead of 1987.\nJoe updates his diagram on the whiteboard. It now looks like figure 4.4.\n--- Page 106 ---\n78 CHAPTER 4 State management\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.4 Structural sharing provides an efficient way to create a new version of the data.\nNext Library is recursively made of nodes that use the parts of Library that are\ncommon between the two.\nTheo Could you explain?\nJoe The immutable function creates a fresh Library hash map, which recursively\nuses the parts of the current Library that are common between the two ver-\nsions instead of deeply copying them.\nTheo It’s a bit abstract for me.\nJoe The next version of Library uses the same UserManagement hash map as the\nold one. The Catalog inside the next Library uses the same authorsById as\nthe current Catalog. The Watchmen Book record inside the next Catalog uses\nall the fields of the current Book except for the publicationYear field.\nTheo So, in fact, most parts of the data are shared between the two versions. Right?\nJoe Exactly! That’s why this technique is called structural sharing.\nTIP Structural sharing provides an efficient way (both in terms of memory and com-\nputation) to create a new version of the data by recursively sharing the parts that don’t\nneed to change.\nTheo That’s very cool!\nJoe Indeed. Now let’s look at how to write a mutation for adding a member using\nimmutable functions.\n--- Page 107 ---\n4.2 Structural sharing 79\nOnce again, Joe goes to the whiteboard. Figure 4.5 shows the diagram that Joe draws to\nillustrate how structural sharing looks when we add a member.\n«Next»\nLibrary\nLibrary\n«Next»\nUserManagement Catalog\nuserManagement\n«Next»\nmembers librarians ...\nmembers\nFigure 4.5 Adding a member\nwith structural sharing. Most of\nthe data is shared between the\n... member0 member1\ntwo versions.\nTheo Awesome! The Catalog and the librarians hash maps don’t have to be copied!\nJoe Now, in terms of code, we have to write a Library.addMember function that\ndelegates to UserManagement.addMember.\nTheo I guess it’s going to be similar to the code we wrote earlier to implement the\nsearch books query, where Library.searchBooksByTitleJSON delegates to\nCatalog.searchBooksByTitle.\nJoe Similar in the sense that all the functions are static, and they receive the data\nthey manipulate as an argument. But there are two differences. First, a muta-\ntion could fail, for instance, if the member to be added already exists. Second,\nthe code for Library.addMember is a bit more elaborate than the code for\nLibrary.searchBooksByTitleJSON because we have to create a new version\nof Library that refers to the new version of UserManagement. Here, let me\nshow you an example.\nListing4.3 The code for the mutation that adds a member\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nChecks if a member with\nthrow \"Member already exists.\";\nthe same email address\n}\nalready exists\nvar nextUserManagement = _.set(\nuserManagement,\nCreates a new version of\ninfoPath,\nuserManagement that\nmember);\nincludes the member\nreturn nextUserManagement;\n};\n--- Page 108 ---\n80 CHAPTER 4 State management\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library,\n\"userManagement\",\nnextUserManagement);\nCreates a new version of\nreturn nextLibrary;\nlibrary that contains the new\n};\nversion of userManagement\nTheo To me, it’s a bit weird that immutable functions return an updated version of\nthe data instead of changing it in place.\nJoe It was also weird for me when I first encountered immutable data in Clojure\nseven years ago.\nTheo How long did it take you to get used to it?\nJoe A couple of weeks.\n4.3 Implementing structural sharing\nWhen Joe leaves the office, Theo meets Dave near the coffee machine. Dave looks perplexed.\nDave Who’s the guy that just left the office?\nTheo It’s Joe. My DOP mentor.\nDave What’s DOP?\nTheo DOP refers to data-oriented programming.\nDave I never heard that term before.\nTheo It’s not well-known by programmers yet, but it’s quite a powerful programming\nparadigm. From what I’ve seen so far, it makes programming much simpler.\nDave Can you give me an example?\nTheo I just learned about structural sharing and how it makes it possible to create\nnew versions of data, effectively without copying.\nDave How does that work?\nTheo takes Dave to his office and shows him Joe’s diagram on the whiteboard (see figure 4.6).\nIt takes Theo a few minutes to explain to Dave what it does exactly, but in the end, Dave\ngets it.\nDave What does the implementation of structural sharing look like?\nTheo I don’t know. I used the _.set function from Lodash.\nDave It sounds like an interesting challenge.\nTheo Take the challenge if you want. Right now, I’m too tired for this recursive algo-\nrithmic stuff.\n--- Page 109 ---\n4.3 Implementing structural sharing 81\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.6 Structural sharing in action\nThe next day, Theo stops by Dave’s cubicle before heading to his office. Dave, with a touch\nof pride, shows Theo his implementation of structural sharing. Theo is amazed by the fact\nthat it’s only 11 lines of JavaScript code!\nListing4.4 The implementation of structural sharing\nfunction setImmutable(map, path, v) {\nvar modifiedNode = v;\nvar k = path[0];\nvar restOfPath = path.slice(1);\nif (restOfPath.length > 0) {\nmodifiedNode = setImmutable(map[k], restOfPath, v);\n}\nvar res = Object.assign({}, map);\nShallow\nres[k] = modifiedNode;\nclones a map\nreturn res;\nin JavaScript.\n}\nTheo Dave, you’re brilliant!\nDave (smiling) Aw, shucks.\nTheo Oops, I have to go. I’m already late for my session with Joe! Joe is probably wait-\ning in my office, biting his nails.\n--- Page 110 ---\n82 CHAPTER 4 State management\n4.4 Data safety\nJoe is about to start the day’s lesson. Theo asks him a question about yesterday’s material\ninstead.\nTheo Something isn’t clear to me regarding this structural sharing stuff. What hap-\npens if we write code that modifies the data part that’s shared between the two\nversions of the data? Does the change affect both versions?\nJoe Could you please write a code snippet that illustrates your question?\nTheo starts typing on his laptop. He comes up with this code to illustrate modifying a piece\nof data shared between two versions.\nListing4.5 Modifying data that’s shared between two versions\nvar books = {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n};\nvar nextBooks = _.set(books, [\"978-1779501127\", \"publicationYear\"], 1986)\nconsole.log(\"Before:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\nbooks[\"978-1779501127\"][\"authorIds\"][1] = \"dave-chester-gibbons\";\nconsole.log(\"After:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\n// → Before: dave-gibbons\n// → After: dave-chester-gibbons\nTheo My question is, what is the value of isBlocked in updatedMember?\nJoe The answer is that mutating data via the native hash map setter is forbidden.\nAll the data manipulation must be done via immutable functions.\n NOTE All data manipulation must be done with immutable functions. It is forbid-\nden to use the native hash map setter.\nTheo When you say “forbidden,” you mean that it’s up to the developer to make sure\nit doesn’t happen. Right?\nJoe Exactly.\nTheo Is there a way to protect our system from a developer’s mistake?\nJoe Yes, there is a way to ensure the immutability of the data at the level of the data\nstructure. It’s called persistent data structures.\nTheo Are persistent data structures also efficient in terms of memory and computation?\nJoe Actually, the way data is organized inside persistent data structures make them\neven more efficient than immutable functions.\n--- Page 111 ---\n4.5 The commit phase of a mutation 83\nTIP Persistent data structures are immutable at the level of the data. There is no way\nto mutate them, even by mistake.\nTheo Are there libraries providing persistent data structures?\nJoe Definitely. I just happen to have a list of those libraries on my computer.\nJoe, being well-organized for a programmer, quickly brings up his list. He shows it to Theo:\n Immutable.js in JavaScript at https://immutable-js.com/\n Paguro in Java at https://github.com/GlenKPeterson/Paguro\n Immutable Collections in C# at http://mng.bz/y4Ke\n Pyrsistent in Python at https://github.com/tobgu/pyrsistent\n Hamster in Ruby at https://github.com/hamstergem/hamster\nTheo Why not use persistent data structures instead of immutable functions?\nJoe The drawback of persistent data structures is that they are not native. This\nmeans that working with them requires conversion from native to persistent\nand from persistent to native.\nTheo What approach would you recommend?\nJoe If you want to play around a bit, then start with immutable functions. But for a\nproduction application, I’d recommend using persistent data structures.\nTheo Too bad the native data structures aren’t persistent!\nJoe That’s one of the reasons why I love Clojure—the native data structures of the\nlanguage are immutable!\n4.5 The commit phase of a mutation\nSo far, we saw how to implement the calculation phase of a mutation. The calculation\nphase is stateless in the sense that it doesn’t make any change to the system. Now, let’s\nsee how to update the state of the system inside the commit phase.\nTheo takes another look at the code for Library.addMember. Something bothers him:\nthis function returns a new state of the library that contains an additional member, but it\ndoesn’t affect the current state of the library.\nListing4.6 The commit phase moves the system state forward\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nTheo I see that Library.addMember doesn’t change the state of the library. How\ndoes the library state get updated?\n--- Page 112 ---\n84 CHAPTER 4 State management\nJoe That’s an excellent question. Library.addMember deals only with data calcula-\ntion and is stateless. The state is updated in the commit phase by moving for-\nward the version of the state that the system state refers to.\nTheo What do you mean by that?\nJoe Here’s what happens when we add a member to the system. The calculation\nphase creates a version of the state that has two members. Before the commit\nphase, the system state refers to the version of the state with one member. The\nresponsibility of the commit phase is to move the system state forward so that it\nrefers to the version of the state with two members.\nTIP The responsibility of the commit phase is to move the system state forward to the\nversion of the state returned by the calculation phase.\nJoe draws another illustration on the whiteboard (figure 4.7). He hopes it helps to clear up\nany misunderstanding Theo may have.\nBefore Commit After Commit\nState with one State with one\nSystem State\nmember member\naddMember addMember\nState with two State with two\nSystem State\nmembers members\nFigure 4.7 The commit phase moves the system state forward.\nTheo How is this implemented?\nJoe The code is made of two classes: System, a singleton stateful class that imple-\nments the mutations, and SystemState, a singleton stateful class that manages\nthe system state.\nTheo It sounds to me like classic OOP.\nJoe Right, and this part of the system being stateful is OOP-like.\nTheo I’m happy to see that you still find some utility in OOP.\nJoe Meditation taught me that every part of our universe has a role to play.\nTheo Nice! Could you show me some code?\nJoe Sure.\nJoe thinks for a moment before starting to type. He wants to show the System class and its\nimplementation of the addMember mutation.\nListing4.7 The System class\nclass System {\naddMember(member) {\nvar previous = SystemState.get();\n--- Page 113 ---\n4.6 Ensuring system state integrity 85\nvar next = Library.addMember(previous, member);\nSystemState.commit(previous, next);\nSystemState is covered\n}\nin listing 4.8.\n}\nTheo What does SystemState look like?\nJoe I had a feeling you were going to ask that. Here’s the code for the System-\nState class, which is a stateful class!\nListing4.8 The SystemState class\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nTheo I don’t get the point of SystemState. It’s a simple class with a getter and a\ncommit function, right?\nJoe In a moment, we are going to enrich the code of the SystemState.commit\nmethod so that it provides data validation and history tracking. For now, the\nimportant thing to notice is that the code of the calculation phase is stateless\nand is decoupled from the code of the commit phase, which is stateful.\nTIP The calculation phase is stateless. The commit phase is stateful.\n4.6 Ensuring system state integrity\nTheo Something still bothers me about the way functions manipulate immutable\ndata in the calculation phase. How do we preserve data integrity?\nJoe What do you mean?\nTheo In OOP, data is manipulated only by methods that belong to the same class as\nthe data. It prevents other classes from corrupting the inner state of the class.\nJoe Could you give me an example of an invalid state of the library?\nTheo For example, imagine that the code of a mutation adds a book item to the\nbook lendings of a member without marking the book item as lent in the cata-\nlog. Then the system data would be corrupted.\nJoe In DOP, we have the privilege of ensuring data integrity at the level of the\nwhole system instead of scattering the validation among many classes.\nTheo How does that work?\nJoe The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system data in a central place. At the beginning of the\ncommit phase, there is a step that checks whether the version of the system\n--- Page 114 ---\n86 CHAPTER 4 State management\nstate to be committed is valid. If the data is invalid, the commit is rejected.\nHere let me show you.\nListing4.9 Data validation inside the commit phase\nSystemState.commit = function(previous, next) {\nif(!SystemValidity.validate(previous, next)) { // not implemented for now\nthrow \"The system data to be committed is not valid!\";\n};\nthis.systemData = next;\n};\nTheo It sounds similar to a commit hook in Git.\nJoe I like your analogy!\nTheo Why are you passing the previous state in previous and the next state in next\nto SystemValidity.validate?\nJoe Because it allows SystemValidity.validate to optimize the validation in\nterms of computation. For example, we could validate just the data that has\nchanged.\nTIP In DOP, we validate the system data as a whole. Data validation is decoupled\nfrom data manipulation.\nTheo What does the code of SystemValidity.validate look like?\nJoe Someday, I will show you how to define a data schema and to validate that a\npiece of data conforms to a schema.\n NOTE See chapters 7 and 12 to see how Joe defines this data schema.\n4.7 Restoring previous states\nAnother advantage of the multi-version state approach with immutable data that is\nmanipulated via structural sharing is that we can keep track of the history of all the\nversions of the data without exploding the memory of our program. It allows us, for\ninstance, to restore the system back to an earlier state easily.\nTheo You told me earlier that it was easy to restore the system to a previous state.\nCould you show me how?\nJoe Happily, but before that, I’d like to make sure you understand why keeping\ntrack of all the versions of the data is efficient in terms of memory.\nTheo I think it’s related to the fact that immutable functions use structural sharing,\nand most of the data between subsequent versions of the state is shared.\nTIP Structural sharing allows us to keep many versions of the system state without\nexploding memory use.\nJoe Perfect! Now, I’ll show you how simple it is to undo a mutation. In order to\nimplement an undo mechanism, our SystemState class needs to have two\n--- Page 115 ---\n4.7 Restoring previous states 87\nreferences to the system data: systemData references the current state of the\nsystem, and previousSystemData references the previous state of the system.\nTheo That makes sense.\nJoe In the commit phase, we update both previousSystemData and systemData.\nTheo What does it take to implement an undo mechanism?\nJoe The undo is achieved by having systemData reference the same version of the\nsystem data as previousSystemData.\nTheo Could you walk me through an example?\nJoe To make things simple, I am going to give a number to each version of the sys-\ntem state. It starts at V0, and each time a mutation is committed, the version is\nincremented: V1, V2, V3, and so forth.\nTheo OK.\nJoe Let’s say that currently our system state is at V12 (see figure 4.8). In the\nSystemState object, systemData refers to V12, and previousSystemData\nrefers to V11.\npreviousSystemData\nMutationA Mutation B\nData V10 Data V11 Data V12\nsystemData\nFigure 4.8 When the system state is at V12, systemData refers to V12, and\npreviousSystemData refers to V11.\nTheo So far, so good...\nJoe Now, when a mutation is committed (for instance, adding a member), both\nreferences move forward: systemData refers to V13, and previousSystem-\nData refers to V12.\nJoe erases the whiteboard to make room for another diagram (figure 4.9). When he’s\nthrough with his drawing, he shows it to Theo.\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.9 When a mutation is committed, systemData refers to V13, and\npreviousSystemData refers to V12.\n--- Page 116 ---\n88 CHAPTER 4 State management\nTheo I suppose that when we undo the mutation, both references move backward.\nJoe In theory, yes, but in practice, it’s necessary to maintain a stack of all the state\nreferences. For now, to simplify things, we’ll maintain only a reference to the\nprevious version. As a consequence, when we undo the mutation, both refer-\nences refer to V12. Let me draw another diagram on the whiteboard that shows\nthis state (see figure 4.10).\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.10 When a mutation is undone, both systemData and previousSystemData refer\nto V12.\nTheo Could you show me how to implement this undo mechanism?\nJoe Actually, it takes only a couple of changes to the SystemState class. Pay atten-\ntion to the changes in the commit function. Inside systemDataBeforeUpdate,\nwe keep a reference to the current state of the system. If the validation and\nthe conflict resolution succeed, we update both previousSystemData and\nsystemData.\nListing4.10 The SystemState class with undo capability\nclass SystemState {\nsystemData;\npreviousSystemData;\nget() {\nreturn this.systemData;\n}\ncommit(previous, next) {\nvar systemDataBeforeUpdate = this.systemData;\nif(!Consistency.validate(previous, next)) {\nthrow \"The system data to be committed is not valid!\";\n}\nthis.systemData = next;\nthis.previousSystemData = systemDataBeforeUpdate;\n}\nundoLastMutation() {\nthis.systemData = this.previousSystemData;\n}\n}\n--- Page 117 ---\nSummary 89\nTheo I see that implementing System.undoLastMutation is simply a matter of hav-\ning systemData refer the same value as previousSystemData.\nJoe As I told you, if we need to allow multiple undos, the code would be a bit more\ncomplicated, but you get the idea.\nTheo I think so. Although Back to the Future belongs to the realm of science fiction, in\nDOP, time travel is real.\nSummary\n DOP principle #3 states that data is immutable.\n A mutation is an operation that changes the state of the system.\n In a multi-version approach to state management, mutations are split into cal-\nculation and commit phases.\n All data manipulation must be done via immutable functions. It is forbidden to\nuse the native hash map setter.\n Structural sharing allows us to create new versions of data efficiently (in terms of\nmemory and computation), where data that is common between the two ver-\nsions is shared instead of being copied.\n Structural sharing creates a new version of the data by recursively sharing the\nparts that don’t need to change.\n A mutation is split in two phases: calculation and commit.\n A function is said to be immutable when, instead of mutating the data, it creates\na new version of the data without changing the data it receives.\n During the calculation phase, data is manipulated with immutable functions that\nuse structural sharing.\n The calculation phase is stateless.\n During the commit phase, we update the system state.\n The responsibility of the commit phase is to move the system state forward to\nthe version of the state returned by the calculation phase.\n The data is immutable, but the state reference is mutable.\n The commit phase is stateful.\n We validate the system data as a whole. Data validation is decoupled from data\nmanipulation.\n The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system state in a central place before we update the\nstate.\n Keeping the history of the versions of the system data is memory efficient due to\nstructural sharing.\n Restoring the system to one of its previous states is straightforward due to the\nclear separation between the calculation phase and the commit phase.\n--- Page 118 ---\n90 CHAPTER 4 State management\n In order to use Lodash immutable functions, we use the Lodash FP module\n(https://github.com/lodash/lodash/wiki/FP-Guide).\nLodash functions introduced in this chapter\nFunction Description\nset(map, path, value) Creates a map with the same fields as map with the addition of a\n<path, value> field\n--- Page 119 ---\nBasic concurrency control\nConflicts at home\nThis chapter covers\n Managing concurrent mutations with a lock-free\noptimistic concurrency control strategy\n Supporting high throughput of reads and writes\n Reconciliation between concurrent mutations\nThe changes required for system manage concurrency are only in the commit\nphase. They involve a reconciliation algorithm that is universal, in the sense that it\ncan be used in any system where data is represented as an immutable hash map.\nThe implementation of the reconciliation algorithm is efficient because subse-\nquent versions of the system state are created via structural sharing.\nIn the previous chapter, we illustrated the multiversion approach to state man-\nagement, where a mutation is split into two distinct phases: the calculation phase\nthat deals only with computation, and the commit phase that moves the state ref-\nerence forward. Usually, in a production system, mutations occur concurrently.\nMoving the state forward naively like we did in the previous chapter is not appro-\npriate. In the present chapter, we are going to learn how to handle concurrent\nmutations.\n91\n--- Page 120 ---\n92 CHAPTER 5 Basic concurrency control\nIn DOP, because only the code of the commit phase is stateful, that allows us to use\nan optimistic concurrency control strategy that doesn’t involve any locking mechanism. As\na consequence, the throughput of reads and writes is high. The modifications to the\ncode are not trivial, as we have to implement an algorithm that reconciles concurrent\nmutations. But the modifications impact only the commit phase. The code for the cal-\nculation phase stays the same as in the previous chapter.\n NOTE This chapter requires more of an effort to grasp. The flow of the reconcilia-\ntion algorithm is definitely not trivial, and the implementation involves a nontrivial\nrecursion.\n5.1 Optimistic concurrency control\nThis morning, before getting to work, Theo takes Joe to the fitness room in the office and,\nwhile running on the step machine, the two men talk about their personal lives again. Joe\ntalks about a fight he had last night with Kay, who thinks that he pays more attention to his\nwork than to his family. Theo recounts the painful conflict he had with Jane, his wife,\nabout house budget management. They went to see a therapist, an expert in Imago Rela-\ntionship Therapy. Imago allowed them to transform their conflict into an opportunity to\ngrow and heal.\nJoe’s ears perk up when he hears the word conflict because today’s lesson is going to be\nabout resolving conflicts and concurrent mutations. A different kind of conflict, though....\nAfter a shower and a healthy breakfast, Theo and Joe get down to work.\nJoe Yesterday, I showed you how to manage state with immutable data, assuming\nthat no mutations occur concurrently. Today, I am going to show you how to\ndeal with concurrency control in DOP.\nTheo I’m curious to discover what kind of lock mechanisms you use in DOP to syn-\nchronize concurrent mutations.\nJoe In fact, we don’t use any lock mechanism!\nTheo Why not?\nJoe Locks hit performance, and if you’re not careful, your system could get into a\ndeadlock.\nTheo So, how do you handle possible conflicts between concurrent mutations in\nDOP?\nJoe In DOP, we use a lock-free strategy called optimistic concurrency control. It’s a\nstrategy that allows databases like Elasticsearch to be highly scalable.\n NOTE See https://www.elastic.co/elasticsearch/ to find out more about Elastic-\nsearch.\nTheo You sound like my couples therapist and her anger-free, optimistic conflict\nresolution strategy.\nJoe Optimistic concurrency control and DOP fit together well. As you will see in a\nmoment, optimistic concurrency control is super efficient when the system\ndata is immutable.\n--- Page 121 ---\n5.1 Optimistic concurrency control 93\nTIP Optimistic concurrency control with immutable data is super efficient.\nTheo How does it work?\nJoe Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTIP Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTheo What do you mean?\nJoe The calculation phase does its calculation as if it were the only mutation run-\nning. The commit phase is responsible for reconciling concurrent mutations\nwhen they don’t conflict or for aborting the mutation.\nTIP The calculation phase does its calculation as if it were the only mutation running.\nThe commit phase is responsible for trying to reconcile concurrent mutations.\nTheo That sounds quite challenging to implement.\nJoe Dealing with state is never trivial. But the good news is that the code for the\nreconciliation logic in the commit phase is universal.\nTheo Does that mean that the same code for the commit phase can be used in any\nDOP system?\nJoe Definitely. The code that implements the commit phase assumes nothing\nabout the details of the system except that the system data is represented as an\nimmutable map.\nTIP The implementation of the commit phase in optimistic concurrency control is\nuniversal. It can be used in any system where the data is represented by an immutable\nhash map.\nTheo That’s awesome!\nJoe Another cool thing is that handling concurrency doesn’t require any changes\nto the code in the calculation phase. From the calculation phase perspective,\nthe next version of the system data is computed in isolation as if no other muta-\ntions were running concurrently.\nJoe stands up to illustrate what he means on the whiteboard. While Theo looks at the draw-\ning in figure 5.1, Joe summarizes the information in table 5.1.\nTable 5.1 The two phases of a mutation with optimistic concurrency control\nPhase Responsibility State Implementation\nCalculation Compute next state in isolation Stateless Specific\nCommit Reconcile and update system state Stateful Common\n--- Page 122 ---\n94 CHAPTER 5 Basic concurrency control\nCalculation phase\nCapturesystem state\nComputenext version\nCommit phase\nYes No\nConcurrent mutations?\nYes No\nConflict?\nUpdatesystem state\nAbortmutation Reconcilemutations\nUpdatesystem state\nFigure 5.1 The logic flow\nof optimistic concurrency\ncontrol\n5.2 Reconciliation between concurrent mutations\nTheo Could you give me some examples of conflicting concurrent mutations?\nJoe Sure. One example would be two members trying to borrow the same book\ncopy. Another example might be when two librarians update the publication\nyear of the same book.\nTheo You mentioned that the code for the reconciliation logic in the commit phase\nis universal. What do you mean exactly by reconciliation logic?\nJoe It’s quite similar to what could happen in Git when you merge a branch back\ninto the main branch.\nTheo I love it when the main branch stays the same.\nJoe Yes, it’s nice when the merge has no conflicts and can be done automatically.\nDo you remember how Git handles the merge in that case?\nTheo Git does a fast-forward; it updates the main branch to be the same as the merge\nbranch.\nJoe Right! And what happens when you discover that, meanwhile, another devel-\noper has committed their code to the main branch?\nTheo Then Git does a three-way merge, trying to combine all the changes from the\ntwo merge branches with the main branch.\nJoe Does it always go smoothly?\nTheo Usually, yes, but it’s possible that two developers have modified the same line\nin the same file. I then have to manually resolve the conflict. I hate when that\nhappens!\nTIP In a production system, multiple mutations run concurrently. Before updating\nthe state, we need to reconcile the conflicts between possible concurrent mutations.\n--- Page 123 ---\n5.2 Reconciliation between concurrent mutations 95\nJoe In DOP, the reconciliation algorithm in the commit phase is quite similar to a\nmerge in Git, except instead of a manual conflict resolution, we abort the\nmutation. There are three possibilities to reconcile between possible concur-\nrent mutations: fast-forward, three-way merge, or abort.\nJoe goes to the whiteboard again. He draws the two diagrams shown in figures 5.2 and 5.3.\nYes No\nState has stayed the same\nYes No\nConcurrent mutations compatible?\nFast forward\n3-way Merge Abort\nFigure 5.2 The\nreconciliation flow\nThe version during\nthe Commit phase\ncurrent\nprevious\nnext\nThe base version\nfor the Calculation\nThe version Figure 5.3 When the commit phase\nphase\nreturned by the starts, there are three versions of the\nCalculation phase system state.\nTheo Could you explain in more detail?\nJoe When the commit phase of a mutation starts, we have three versions of the sys-\ntem state: previous, which is the version on which the calculation phase based\nits computation; current, which is the current version during the commit\nphase; and next, which is the version returned by the calculation phase.\nTheo Why would current be different than previous?\nJoe It happens when other mutations have run concurrently with our mutation.\nTheo I see.\nJoe If we are in a situation where the current state is the same as the previous state,\nit means that no mutations run concurrently. Therefore, as in Git, we can\nsafely fast-forward and update the state of the system with the next version.\nTheo What if the state has not stayed the same?\nJoe Then it means that mutations have run concurrently. We have to check for\nconflicts in a way similar to the three-way merge used by Git. The difference is\nthat instead of comparing lines, we compare fields of the system hash map.\nTheo Could you explain that?\n--- Page 124 ---\n96 CHAPTER 5 Basic concurrency control\nJoe We calculate the diff between previous and next and between previous and\ncurrent. If the two diffs have no fields in common, then there is no conflict\nbetween the mutations that have run concurrently. We can safely apply the\nchanges from previous to next into current.\nJoe makes his explanation visual with another diagram on the whiteboard. He then shows\nfigure 5.4 to Theo.\ndiffPreviousCurrent diffPreviousNext\ncurrent\nprevious merged\ndiffPreviousNext\nnext\nFigure 5.4 In a three-way merge, we calculate the diff between previous and\nnext, and we apply it to current.\nTheo What if there is a conflict?\nJoe Then we abort the mutation.\nTheo Aborting a user request seems unacceptable.\nJoe In fact, in a user-facing system, conflicting concurrent mutations are fairly rare.\nThat’s why it’s OK to abort and let the user run the mutation again. Here, let\nme draft a table to show you the differences between Git and DOP (table 5.2).\nTable 5.2 The analogy between Git and data-oriented programming\nData-oriented programming Git\nConcurrent mutations Different branches\nA version of the system data A commit\nState A reference\nCalculation phase Branching\nValidation Precommit hook\nReconciliation Merge\nFast-forward Fast-forward\nThree-way merge Three-way merge\nAbort Manual conflict resolution\nHash map Tree (folder)\nLeaf node Blob (file)\nData field Line of code\n--- Page 125 ---\n5.3 Reducing collections 97\nTheo Great! That helps, but in cases where two mutations update the same field of\nthe same entity, I think it’s fair enough to let the user know that the request\ncan’t be processed.\nTIP In a user-facing system, conflicting concurrent mutations are fairly rare.\n5.3 Reducing collections\nJoe Are you ready to challenge your mind with the implementation of the diff\nalgorithm?\nTheo Let’s take a short coffee break before, if you don’t mind. Then, I’ll be ready to\ntackle anything.\nAfter enjoying large mug of hot coffee and a few butter cookies, Theo and Joe are back to\nwork. Their discussion on the diff algorithm continues.\nJoe In the implementation of the diff algorithm, we’re going to reduce collections.\nTheo I heard about reducing collections in a talk about FP, but I don’t remember\nthe details. Could you remind me how this works?\nJoe Imagine you want to calculate the sum of the elements in a collection of num-\nbers. With Lodash’s _.reduce, it would look like this.\nListing5.1 Summing numbers with _.reduce\n_.reduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nTheo I don’t understand.\nJoe goes to the whiteboard and writes the description of _.reduce. Theo waits patiently\nuntil Joe puts the pen down before looking at the description.\nDescription of _.reduce\n_.reduce receives three arguments:\n coll—A collection of elements\n f—A function that receives two arguments\n initVal—A value\nLogic flow:\n1 Initialize currentRes with initVal.\n2 For each element x of coll, update currentRes with f(currentRes, x).\n3 Return currentRes.",
        "sections_found": []
      },
      "accurate_page_range": "102-125"
    },
    {
      "text": "- 4.7 Restoring previous states",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "raw_line": "- 4.7 Restoring previous states (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 36,
      "chapter_info": {
        "page": 102,
        "title": "State management",
        "pattern_matched": "Chapter 4",
        "text_preview": "74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead"
      },
      "chapter_sections": {
        "start_page": 102,
        "end_page": 125,
        "content": "\n--- Page 102 ---\n74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead of being copied.\nThis technique efficiently creates new versions of the system data, both in\nterms of memory and computation.\nTheo I’m intrigued.\nTIP With structural sharing, it’s efficient (in terms of memory and computation) to\ncreate new versions of data.\nJoe I’ll explain in detail how structural sharing works in a moment.\nTheo takes another look at the diagram in figure 4.1, which illustrates how the system state\nrefers to a version of the system data. Suddenly, a question emerges.\nTheo Are the previous versions of the system data kept?\nJoe In a simple application, previous versions are automatically removed by the\ngarbage collector. But, in some cases, we maintain historical references to pre-\nvious versions of the data.\nTheo What kind of cases?\nJoe For example, if we want to support time travel in our system, as in Git, we can\nmove the system back to a previous version of the state easily.\nTheo Now I understand what you mean by data is immutable, but the state reference\nis mutable!\n4.2 Structural sharing\nAs mentioned in the previous section, structural sharing enables the efficient cre-\nation of new versions of immutable data. In DOP, we use structural sharing in the\ncalculation phase of a mutation to compute the next state of the system based on\nthe current state of the system. Inside the calculation phase, we don’t have to deal\nwith state management; that is delayed to the commit phase. As a consequence, the\ncode involved in the calculation phase of a mutation is stateless and is as simple as\nthe code of a query.\nTheo I’m really intrigued by this more efficient way to create new versions of data.\nHow does it work?\nJoe Let’s take a simple example from our library system. Imagine that you want to\nmodify the value of a field in a book in the catalog; for instance, the publica-\ntion year of Watchmen. Can you tell me the information path for Watchmen’s\npublication year?\nTheo takes a quick look at the catalog data in figure 4.2. Then he answers Joe’s question.\n--- Page 103 ---\n4.2 Structural sharing 75\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 4.2 Visualization of the catalog data. The nodes in the information path to Watchmen’s publication\nyear are marked with a dotted border.\nTheo The information path for Watchmen’s publication year is [\"catalog\", \"books-\nByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Now, let me show how you to use the immutable function _.set that Lodash\nalso provides.\nTheo Wait! What do you mean by an immutable function? When I looked at the\nLodash documentation for _.set on their website, it said that it mutates the\nobject.\nJoe You’re right, but the default Lodash functions are not immutable. In order to\nuse an immutable version of the functions, we need to use the Lodash FP mod-\nule as explained in the Lodash FP guide.\n NOTE See https://lodash.com/docs/4.17.15#set to view Lodash’s documentation\nfor _.set, and see https://github.com/lodash/lodash/wiki/FP-Guide to view the\nLodash FP guide.\nTheo Do the immutable functions have the same signature as the mutable functions?\nJoe By default, the order of the arguments in immutable functions is shuffled.\nThe Lodash FP guide explains how to resolve this. With this piece of code,\n--- Page 104 ---\n76 CHAPTER 4 State management\nthe signature of the immutable functions is exactly the same as the mutable\nfunctions.\nListing4.1 Configuring Lodash so immutable and mutable functions have same signature\n_ = fp.convert({\n\"cap\": false,\n\"curry\": false,\n\"fixed\": false,\n\"immutable\": true,\n\"rearg\": false\n});\nTIP In order to use Lodash immutable functions, we use Lodash’s FP module, and\nwe configure it so that the signature of the immutable functions is the same as in the\nLodash documentation web site.\nTheo So basically, I can still rely on Lodash documentation when using immutable\nversions of the functions.\nJoe Except for the piece in the documentation that says the function mutates the\nobject.\nTheo Of course!\nJoe Now I’ll show you how to write code that creates a version of the library data\nwith the immutable function _.set.\nJoe’s fingers fly across Theo’s keyboard. Theo then looks at Joe’s code, which creates a ver-\nsion of the library data where the Watchmen publication year is set to 1986.\nListing4.2 Using _.set as an immutable function\nvar nextLibraryData = _.set(libraryData,\n[\"catalog\", \"booksByIsbn\",\n\"978-1779501127\", \"publicationYear\"],\n1986);\n NOTE A function is said to be immutable when, instead of mutating the data, it cre-\nates a new version of the data without changing the data it receives.\nTheo You told me earlier that structural sharing allowed immutable functions to be\nefficient in terms of memory and computation. Can you tell me what makes\nthem efficient?\nJoe With pleasure, but before that, you have to answer a series of questions. Are\nyou ready?\nTheo Yes, sure...\nJoe What part of the library data is impacted by updating the Watchmen publication\nyear: the UserManagement or the Catalog?\n--- Page 105 ---\n4.2 Structural sharing 77\nTheo Only the Catalog.\nJoe What part of the Catalog?\nTheo Only the booksByIsbn index.\nJoe What part of the booksByIsbn index?\nTheo Only the Book record that holds the information about Watchmen.\nJoe What part of the Book record?\nTheo Only the publicationYear field.\nJoe Perfect! Now, suppose that the current version of the library data looks like\nthis.\nJoe goes to the whiteboard and draws a diagram. Figure 4.3 shows the result.\nLibrary\nCatalog UserManagement\nauthorsByld booksBylsbn ...\n... watchmen\ntitle:Watchmen publicationYear:1987 authorlds\n...\nFigure 4.3 High-level visualization of the current version of Library\nTheo So far, so good...\nJoe Next, let me show you what an immutable function does when you use it to cre-\nate a new version of Library, where the publication year of Watchmen is set to\n1986 instead of 1987.\nJoe updates his diagram on the whiteboard. It now looks like figure 4.4.\n--- Page 106 ---\n78 CHAPTER 4 State management\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.4 Structural sharing provides an efficient way to create a new version of the data.\nNext Library is recursively made of nodes that use the parts of Library that are\ncommon between the two.\nTheo Could you explain?\nJoe The immutable function creates a fresh Library hash map, which recursively\nuses the parts of the current Library that are common between the two ver-\nsions instead of deeply copying them.\nTheo It’s a bit abstract for me.\nJoe The next version of Library uses the same UserManagement hash map as the\nold one. The Catalog inside the next Library uses the same authorsById as\nthe current Catalog. The Watchmen Book record inside the next Catalog uses\nall the fields of the current Book except for the publicationYear field.\nTheo So, in fact, most parts of the data are shared between the two versions. Right?\nJoe Exactly! That’s why this technique is called structural sharing.\nTIP Structural sharing provides an efficient way (both in terms of memory and com-\nputation) to create a new version of the data by recursively sharing the parts that don’t\nneed to change.\nTheo That’s very cool!\nJoe Indeed. Now let’s look at how to write a mutation for adding a member using\nimmutable functions.\n--- Page 107 ---\n4.2 Structural sharing 79\nOnce again, Joe goes to the whiteboard. Figure 4.5 shows the diagram that Joe draws to\nillustrate how structural sharing looks when we add a member.\n«Next»\nLibrary\nLibrary\n«Next»\nUserManagement Catalog\nuserManagement\n«Next»\nmembers librarians ...\nmembers\nFigure 4.5 Adding a member\nwith structural sharing. Most of\nthe data is shared between the\n... member0 member1\ntwo versions.\nTheo Awesome! The Catalog and the librarians hash maps don’t have to be copied!\nJoe Now, in terms of code, we have to write a Library.addMember function that\ndelegates to UserManagement.addMember.\nTheo I guess it’s going to be similar to the code we wrote earlier to implement the\nsearch books query, where Library.searchBooksByTitleJSON delegates to\nCatalog.searchBooksByTitle.\nJoe Similar in the sense that all the functions are static, and they receive the data\nthey manipulate as an argument. But there are two differences. First, a muta-\ntion could fail, for instance, if the member to be added already exists. Second,\nthe code for Library.addMember is a bit more elaborate than the code for\nLibrary.searchBooksByTitleJSON because we have to create a new version\nof Library that refers to the new version of UserManagement. Here, let me\nshow you an example.\nListing4.3 The code for the mutation that adds a member\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nChecks if a member with\nthrow \"Member already exists.\";\nthe same email address\n}\nalready exists\nvar nextUserManagement = _.set(\nuserManagement,\nCreates a new version of\ninfoPath,\nuserManagement that\nmember);\nincludes the member\nreturn nextUserManagement;\n};\n--- Page 108 ---\n80 CHAPTER 4 State management\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library,\n\"userManagement\",\nnextUserManagement);\nCreates a new version of\nreturn nextLibrary;\nlibrary that contains the new\n};\nversion of userManagement\nTheo To me, it’s a bit weird that immutable functions return an updated version of\nthe data instead of changing it in place.\nJoe It was also weird for me when I first encountered immutable data in Clojure\nseven years ago.\nTheo How long did it take you to get used to it?\nJoe A couple of weeks.\n4.3 Implementing structural sharing\nWhen Joe leaves the office, Theo meets Dave near the coffee machine. Dave looks perplexed.\nDave Who’s the guy that just left the office?\nTheo It’s Joe. My DOP mentor.\nDave What’s DOP?\nTheo DOP refers to data-oriented programming.\nDave I never heard that term before.\nTheo It’s not well-known by programmers yet, but it’s quite a powerful programming\nparadigm. From what I’ve seen so far, it makes programming much simpler.\nDave Can you give me an example?\nTheo I just learned about structural sharing and how it makes it possible to create\nnew versions of data, effectively without copying.\nDave How does that work?\nTheo takes Dave to his office and shows him Joe’s diagram on the whiteboard (see figure 4.6).\nIt takes Theo a few minutes to explain to Dave what it does exactly, but in the end, Dave\ngets it.\nDave What does the implementation of structural sharing look like?\nTheo I don’t know. I used the _.set function from Lodash.\nDave It sounds like an interesting challenge.\nTheo Take the challenge if you want. Right now, I’m too tired for this recursive algo-\nrithmic stuff.\n--- Page 109 ---\n4.3 Implementing structural sharing 81\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.6 Structural sharing in action\nThe next day, Theo stops by Dave’s cubicle before heading to his office. Dave, with a touch\nof pride, shows Theo his implementation of structural sharing. Theo is amazed by the fact\nthat it’s only 11 lines of JavaScript code!\nListing4.4 The implementation of structural sharing\nfunction setImmutable(map, path, v) {\nvar modifiedNode = v;\nvar k = path[0];\nvar restOfPath = path.slice(1);\nif (restOfPath.length > 0) {\nmodifiedNode = setImmutable(map[k], restOfPath, v);\n}\nvar res = Object.assign({}, map);\nShallow\nres[k] = modifiedNode;\nclones a map\nreturn res;\nin JavaScript.\n}\nTheo Dave, you’re brilliant!\nDave (smiling) Aw, shucks.\nTheo Oops, I have to go. I’m already late for my session with Joe! Joe is probably wait-\ning in my office, biting his nails.\n--- Page 110 ---\n82 CHAPTER 4 State management\n4.4 Data safety\nJoe is about to start the day’s lesson. Theo asks him a question about yesterday’s material\ninstead.\nTheo Something isn’t clear to me regarding this structural sharing stuff. What hap-\npens if we write code that modifies the data part that’s shared between the two\nversions of the data? Does the change affect both versions?\nJoe Could you please write a code snippet that illustrates your question?\nTheo starts typing on his laptop. He comes up with this code to illustrate modifying a piece\nof data shared between two versions.\nListing4.5 Modifying data that’s shared between two versions\nvar books = {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n};\nvar nextBooks = _.set(books, [\"978-1779501127\", \"publicationYear\"], 1986)\nconsole.log(\"Before:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\nbooks[\"978-1779501127\"][\"authorIds\"][1] = \"dave-chester-gibbons\";\nconsole.log(\"After:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\n// → Before: dave-gibbons\n// → After: dave-chester-gibbons\nTheo My question is, what is the value of isBlocked in updatedMember?\nJoe The answer is that mutating data via the native hash map setter is forbidden.\nAll the data manipulation must be done via immutable functions.\n NOTE All data manipulation must be done with immutable functions. It is forbid-\nden to use the native hash map setter.\nTheo When you say “forbidden,” you mean that it’s up to the developer to make sure\nit doesn’t happen. Right?\nJoe Exactly.\nTheo Is there a way to protect our system from a developer’s mistake?\nJoe Yes, there is a way to ensure the immutability of the data at the level of the data\nstructure. It’s called persistent data structures.\nTheo Are persistent data structures also efficient in terms of memory and computation?\nJoe Actually, the way data is organized inside persistent data structures make them\neven more efficient than immutable functions.\n--- Page 111 ---\n4.5 The commit phase of a mutation 83\nTIP Persistent data structures are immutable at the level of the data. There is no way\nto mutate them, even by mistake.\nTheo Are there libraries providing persistent data structures?\nJoe Definitely. I just happen to have a list of those libraries on my computer.\nJoe, being well-organized for a programmer, quickly brings up his list. He shows it to Theo:\n Immutable.js in JavaScript at https://immutable-js.com/\n Paguro in Java at https://github.com/GlenKPeterson/Paguro\n Immutable Collections in C# at http://mng.bz/y4Ke\n Pyrsistent in Python at https://github.com/tobgu/pyrsistent\n Hamster in Ruby at https://github.com/hamstergem/hamster\nTheo Why not use persistent data structures instead of immutable functions?\nJoe The drawback of persistent data structures is that they are not native. This\nmeans that working with them requires conversion from native to persistent\nand from persistent to native.\nTheo What approach would you recommend?\nJoe If you want to play around a bit, then start with immutable functions. But for a\nproduction application, I’d recommend using persistent data structures.\nTheo Too bad the native data structures aren’t persistent!\nJoe That’s one of the reasons why I love Clojure—the native data structures of the\nlanguage are immutable!\n4.5 The commit phase of a mutation\nSo far, we saw how to implement the calculation phase of a mutation. The calculation\nphase is stateless in the sense that it doesn’t make any change to the system. Now, let’s\nsee how to update the state of the system inside the commit phase.\nTheo takes another look at the code for Library.addMember. Something bothers him:\nthis function returns a new state of the library that contains an additional member, but it\ndoesn’t affect the current state of the library.\nListing4.6 The commit phase moves the system state forward\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nTheo I see that Library.addMember doesn’t change the state of the library. How\ndoes the library state get updated?\n--- Page 112 ---\n84 CHAPTER 4 State management\nJoe That’s an excellent question. Library.addMember deals only with data calcula-\ntion and is stateless. The state is updated in the commit phase by moving for-\nward the version of the state that the system state refers to.\nTheo What do you mean by that?\nJoe Here’s what happens when we add a member to the system. The calculation\nphase creates a version of the state that has two members. Before the commit\nphase, the system state refers to the version of the state with one member. The\nresponsibility of the commit phase is to move the system state forward so that it\nrefers to the version of the state with two members.\nTIP The responsibility of the commit phase is to move the system state forward to the\nversion of the state returned by the calculation phase.\nJoe draws another illustration on the whiteboard (figure 4.7). He hopes it helps to clear up\nany misunderstanding Theo may have.\nBefore Commit After Commit\nState with one State with one\nSystem State\nmember member\naddMember addMember\nState with two State with two\nSystem State\nmembers members\nFigure 4.7 The commit phase moves the system state forward.\nTheo How is this implemented?\nJoe The code is made of two classes: System, a singleton stateful class that imple-\nments the mutations, and SystemState, a singleton stateful class that manages\nthe system state.\nTheo It sounds to me like classic OOP.\nJoe Right, and this part of the system being stateful is OOP-like.\nTheo I’m happy to see that you still find some utility in OOP.\nJoe Meditation taught me that every part of our universe has a role to play.\nTheo Nice! Could you show me some code?\nJoe Sure.\nJoe thinks for a moment before starting to type. He wants to show the System class and its\nimplementation of the addMember mutation.\nListing4.7 The System class\nclass System {\naddMember(member) {\nvar previous = SystemState.get();\n--- Page 113 ---\n4.6 Ensuring system state integrity 85\nvar next = Library.addMember(previous, member);\nSystemState.commit(previous, next);\nSystemState is covered\n}\nin listing 4.8.\n}\nTheo What does SystemState look like?\nJoe I had a feeling you were going to ask that. Here’s the code for the System-\nState class, which is a stateful class!\nListing4.8 The SystemState class\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nTheo I don’t get the point of SystemState. It’s a simple class with a getter and a\ncommit function, right?\nJoe In a moment, we are going to enrich the code of the SystemState.commit\nmethod so that it provides data validation and history tracking. For now, the\nimportant thing to notice is that the code of the calculation phase is stateless\nand is decoupled from the code of the commit phase, which is stateful.\nTIP The calculation phase is stateless. The commit phase is stateful.\n4.6 Ensuring system state integrity\nTheo Something still bothers me about the way functions manipulate immutable\ndata in the calculation phase. How do we preserve data integrity?\nJoe What do you mean?\nTheo In OOP, data is manipulated only by methods that belong to the same class as\nthe data. It prevents other classes from corrupting the inner state of the class.\nJoe Could you give me an example of an invalid state of the library?\nTheo For example, imagine that the code of a mutation adds a book item to the\nbook lendings of a member without marking the book item as lent in the cata-\nlog. Then the system data would be corrupted.\nJoe In DOP, we have the privilege of ensuring data integrity at the level of the\nwhole system instead of scattering the validation among many classes.\nTheo How does that work?\nJoe The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system data in a central place. At the beginning of the\ncommit phase, there is a step that checks whether the version of the system\n--- Page 114 ---\n86 CHAPTER 4 State management\nstate to be committed is valid. If the data is invalid, the commit is rejected.\nHere let me show you.\nListing4.9 Data validation inside the commit phase\nSystemState.commit = function(previous, next) {\nif(!SystemValidity.validate(previous, next)) { // not implemented for now\nthrow \"The system data to be committed is not valid!\";\n};\nthis.systemData = next;\n};\nTheo It sounds similar to a commit hook in Git.\nJoe I like your analogy!\nTheo Why are you passing the previous state in previous and the next state in next\nto SystemValidity.validate?\nJoe Because it allows SystemValidity.validate to optimize the validation in\nterms of computation. For example, we could validate just the data that has\nchanged.\nTIP In DOP, we validate the system data as a whole. Data validation is decoupled\nfrom data manipulation.\nTheo What does the code of SystemValidity.validate look like?\nJoe Someday, I will show you how to define a data schema and to validate that a\npiece of data conforms to a schema.\n NOTE See chapters 7 and 12 to see how Joe defines this data schema.\n4.7 Restoring previous states\nAnother advantage of the multi-version state approach with immutable data that is\nmanipulated via structural sharing is that we can keep track of the history of all the\nversions of the data without exploding the memory of our program. It allows us, for\ninstance, to restore the system back to an earlier state easily.\nTheo You told me earlier that it was easy to restore the system to a previous state.\nCould you show me how?\nJoe Happily, but before that, I’d like to make sure you understand why keeping\ntrack of all the versions of the data is efficient in terms of memory.\nTheo I think it’s related to the fact that immutable functions use structural sharing,\nand most of the data between subsequent versions of the state is shared.\nTIP Structural sharing allows us to keep many versions of the system state without\nexploding memory use.\nJoe Perfect! Now, I’ll show you how simple it is to undo a mutation. In order to\nimplement an undo mechanism, our SystemState class needs to have two\n--- Page 115 ---\n4.7 Restoring previous states 87\nreferences to the system data: systemData references the current state of the\nsystem, and previousSystemData references the previous state of the system.\nTheo That makes sense.\nJoe In the commit phase, we update both previousSystemData and systemData.\nTheo What does it take to implement an undo mechanism?\nJoe The undo is achieved by having systemData reference the same version of the\nsystem data as previousSystemData.\nTheo Could you walk me through an example?\nJoe To make things simple, I am going to give a number to each version of the sys-\ntem state. It starts at V0, and each time a mutation is committed, the version is\nincremented: V1, V2, V3, and so forth.\nTheo OK.\nJoe Let’s say that currently our system state is at V12 (see figure 4.8). In the\nSystemState object, systemData refers to V12, and previousSystemData\nrefers to V11.\npreviousSystemData\nMutationA Mutation B\nData V10 Data V11 Data V12\nsystemData\nFigure 4.8 When the system state is at V12, systemData refers to V12, and\npreviousSystemData refers to V11.\nTheo So far, so good...\nJoe Now, when a mutation is committed (for instance, adding a member), both\nreferences move forward: systemData refers to V13, and previousSystem-\nData refers to V12.\nJoe erases the whiteboard to make room for another diagram (figure 4.9). When he’s\nthrough with his drawing, he shows it to Theo.\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.9 When a mutation is committed, systemData refers to V13, and\npreviousSystemData refers to V12.\n--- Page 116 ---\n88 CHAPTER 4 State management\nTheo I suppose that when we undo the mutation, both references move backward.\nJoe In theory, yes, but in practice, it’s necessary to maintain a stack of all the state\nreferences. For now, to simplify things, we’ll maintain only a reference to the\nprevious version. As a consequence, when we undo the mutation, both refer-\nences refer to V12. Let me draw another diagram on the whiteboard that shows\nthis state (see figure 4.10).\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.10 When a mutation is undone, both systemData and previousSystemData refer\nto V12.\nTheo Could you show me how to implement this undo mechanism?\nJoe Actually, it takes only a couple of changes to the SystemState class. Pay atten-\ntion to the changes in the commit function. Inside systemDataBeforeUpdate,\nwe keep a reference to the current state of the system. If the validation and\nthe conflict resolution succeed, we update both previousSystemData and\nsystemData.\nListing4.10 The SystemState class with undo capability\nclass SystemState {\nsystemData;\npreviousSystemData;\nget() {\nreturn this.systemData;\n}\ncommit(previous, next) {\nvar systemDataBeforeUpdate = this.systemData;\nif(!Consistency.validate(previous, next)) {\nthrow \"The system data to be committed is not valid!\";\n}\nthis.systemData = next;\nthis.previousSystemData = systemDataBeforeUpdate;\n}\nundoLastMutation() {\nthis.systemData = this.previousSystemData;\n}\n}\n--- Page 117 ---\nSummary 89\nTheo I see that implementing System.undoLastMutation is simply a matter of hav-\ning systemData refer the same value as previousSystemData.\nJoe As I told you, if we need to allow multiple undos, the code would be a bit more\ncomplicated, but you get the idea.\nTheo I think so. Although Back to the Future belongs to the realm of science fiction, in\nDOP, time travel is real.\nSummary\n DOP principle #3 states that data is immutable.\n A mutation is an operation that changes the state of the system.\n In a multi-version approach to state management, mutations are split into cal-\nculation and commit phases.\n All data manipulation must be done via immutable functions. It is forbidden to\nuse the native hash map setter.\n Structural sharing allows us to create new versions of data efficiently (in terms of\nmemory and computation), where data that is common between the two ver-\nsions is shared instead of being copied.\n Structural sharing creates a new version of the data by recursively sharing the\nparts that don’t need to change.\n A mutation is split in two phases: calculation and commit.\n A function is said to be immutable when, instead of mutating the data, it creates\na new version of the data without changing the data it receives.\n During the calculation phase, data is manipulated with immutable functions that\nuse structural sharing.\n The calculation phase is stateless.\n During the commit phase, we update the system state.\n The responsibility of the commit phase is to move the system state forward to\nthe version of the state returned by the calculation phase.\n The data is immutable, but the state reference is mutable.\n The commit phase is stateful.\n We validate the system data as a whole. Data validation is decoupled from data\nmanipulation.\n The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system state in a central place before we update the\nstate.\n Keeping the history of the versions of the system data is memory efficient due to\nstructural sharing.\n Restoring the system to one of its previous states is straightforward due to the\nclear separation between the calculation phase and the commit phase.\n--- Page 118 ---\n90 CHAPTER 4 State management\n In order to use Lodash immutable functions, we use the Lodash FP module\n(https://github.com/lodash/lodash/wiki/FP-Guide).\nLodash functions introduced in this chapter\nFunction Description\nset(map, path, value) Creates a map with the same fields as map with the addition of a\n<path, value> field\n--- Page 119 ---\nBasic concurrency control\nConflicts at home\nThis chapter covers\n Managing concurrent mutations with a lock-free\noptimistic concurrency control strategy\n Supporting high throughput of reads and writes\n Reconciliation between concurrent mutations\nThe changes required for system manage concurrency are only in the commit\nphase. They involve a reconciliation algorithm that is universal, in the sense that it\ncan be used in any system where data is represented as an immutable hash map.\nThe implementation of the reconciliation algorithm is efficient because subse-\nquent versions of the system state are created via structural sharing.\nIn the previous chapter, we illustrated the multiversion approach to state man-\nagement, where a mutation is split into two distinct phases: the calculation phase\nthat deals only with computation, and the commit phase that moves the state ref-\nerence forward. Usually, in a production system, mutations occur concurrently.\nMoving the state forward naively like we did in the previous chapter is not appro-\npriate. In the present chapter, we are going to learn how to handle concurrent\nmutations.\n91\n--- Page 120 ---\n92 CHAPTER 5 Basic concurrency control\nIn DOP, because only the code of the commit phase is stateful, that allows us to use\nan optimistic concurrency control strategy that doesn’t involve any locking mechanism. As\na consequence, the throughput of reads and writes is high. The modifications to the\ncode are not trivial, as we have to implement an algorithm that reconciles concurrent\nmutations. But the modifications impact only the commit phase. The code for the cal-\nculation phase stays the same as in the previous chapter.\n NOTE This chapter requires more of an effort to grasp. The flow of the reconcilia-\ntion algorithm is definitely not trivial, and the implementation involves a nontrivial\nrecursion.\n5.1 Optimistic concurrency control\nThis morning, before getting to work, Theo takes Joe to the fitness room in the office and,\nwhile running on the step machine, the two men talk about their personal lives again. Joe\ntalks about a fight he had last night with Kay, who thinks that he pays more attention to his\nwork than to his family. Theo recounts the painful conflict he had with Jane, his wife,\nabout house budget management. They went to see a therapist, an expert in Imago Rela-\ntionship Therapy. Imago allowed them to transform their conflict into an opportunity to\ngrow and heal.\nJoe’s ears perk up when he hears the word conflict because today’s lesson is going to be\nabout resolving conflicts and concurrent mutations. A different kind of conflict, though....\nAfter a shower and a healthy breakfast, Theo and Joe get down to work.\nJoe Yesterday, I showed you how to manage state with immutable data, assuming\nthat no mutations occur concurrently. Today, I am going to show you how to\ndeal with concurrency control in DOP.\nTheo I’m curious to discover what kind of lock mechanisms you use in DOP to syn-\nchronize concurrent mutations.\nJoe In fact, we don’t use any lock mechanism!\nTheo Why not?\nJoe Locks hit performance, and if you’re not careful, your system could get into a\ndeadlock.\nTheo So, how do you handle possible conflicts between concurrent mutations in\nDOP?\nJoe In DOP, we use a lock-free strategy called optimistic concurrency control. It’s a\nstrategy that allows databases like Elasticsearch to be highly scalable.\n NOTE See https://www.elastic.co/elasticsearch/ to find out more about Elastic-\nsearch.\nTheo You sound like my couples therapist and her anger-free, optimistic conflict\nresolution strategy.\nJoe Optimistic concurrency control and DOP fit together well. As you will see in a\nmoment, optimistic concurrency control is super efficient when the system\ndata is immutable.\n--- Page 121 ---\n5.1 Optimistic concurrency control 93\nTIP Optimistic concurrency control with immutable data is super efficient.\nTheo How does it work?\nJoe Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTIP Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTheo What do you mean?\nJoe The calculation phase does its calculation as if it were the only mutation run-\nning. The commit phase is responsible for reconciling concurrent mutations\nwhen they don’t conflict or for aborting the mutation.\nTIP The calculation phase does its calculation as if it were the only mutation running.\nThe commit phase is responsible for trying to reconcile concurrent mutations.\nTheo That sounds quite challenging to implement.\nJoe Dealing with state is never trivial. But the good news is that the code for the\nreconciliation logic in the commit phase is universal.\nTheo Does that mean that the same code for the commit phase can be used in any\nDOP system?\nJoe Definitely. The code that implements the commit phase assumes nothing\nabout the details of the system except that the system data is represented as an\nimmutable map.\nTIP The implementation of the commit phase in optimistic concurrency control is\nuniversal. It can be used in any system where the data is represented by an immutable\nhash map.\nTheo That’s awesome!\nJoe Another cool thing is that handling concurrency doesn’t require any changes\nto the code in the calculation phase. From the calculation phase perspective,\nthe next version of the system data is computed in isolation as if no other muta-\ntions were running concurrently.\nJoe stands up to illustrate what he means on the whiteboard. While Theo looks at the draw-\ning in figure 5.1, Joe summarizes the information in table 5.1.\nTable 5.1 The two phases of a mutation with optimistic concurrency control\nPhase Responsibility State Implementation\nCalculation Compute next state in isolation Stateless Specific\nCommit Reconcile and update system state Stateful Common\n--- Page 122 ---\n94 CHAPTER 5 Basic concurrency control\nCalculation phase\nCapturesystem state\nComputenext version\nCommit phase\nYes No\nConcurrent mutations?\nYes No\nConflict?\nUpdatesystem state\nAbortmutation Reconcilemutations\nUpdatesystem state\nFigure 5.1 The logic flow\nof optimistic concurrency\ncontrol\n5.2 Reconciliation between concurrent mutations\nTheo Could you give me some examples of conflicting concurrent mutations?\nJoe Sure. One example would be two members trying to borrow the same book\ncopy. Another example might be when two librarians update the publication\nyear of the same book.\nTheo You mentioned that the code for the reconciliation logic in the commit phase\nis universal. What do you mean exactly by reconciliation logic?\nJoe It’s quite similar to what could happen in Git when you merge a branch back\ninto the main branch.\nTheo I love it when the main branch stays the same.\nJoe Yes, it’s nice when the merge has no conflicts and can be done automatically.\nDo you remember how Git handles the merge in that case?\nTheo Git does a fast-forward; it updates the main branch to be the same as the merge\nbranch.\nJoe Right! And what happens when you discover that, meanwhile, another devel-\noper has committed their code to the main branch?\nTheo Then Git does a three-way merge, trying to combine all the changes from the\ntwo merge branches with the main branch.\nJoe Does it always go smoothly?\nTheo Usually, yes, but it’s possible that two developers have modified the same line\nin the same file. I then have to manually resolve the conflict. I hate when that\nhappens!\nTIP In a production system, multiple mutations run concurrently. Before updating\nthe state, we need to reconcile the conflicts between possible concurrent mutations.\n--- Page 123 ---\n5.2 Reconciliation between concurrent mutations 95\nJoe In DOP, the reconciliation algorithm in the commit phase is quite similar to a\nmerge in Git, except instead of a manual conflict resolution, we abort the\nmutation. There are three possibilities to reconcile between possible concur-\nrent mutations: fast-forward, three-way merge, or abort.\nJoe goes to the whiteboard again. He draws the two diagrams shown in figures 5.2 and 5.3.\nYes No\nState has stayed the same\nYes No\nConcurrent mutations compatible?\nFast forward\n3-way Merge Abort\nFigure 5.2 The\nreconciliation flow\nThe version during\nthe Commit phase\ncurrent\nprevious\nnext\nThe base version\nfor the Calculation\nThe version Figure 5.3 When the commit phase\nphase\nreturned by the starts, there are three versions of the\nCalculation phase system state.\nTheo Could you explain in more detail?\nJoe When the commit phase of a mutation starts, we have three versions of the sys-\ntem state: previous, which is the version on which the calculation phase based\nits computation; current, which is the current version during the commit\nphase; and next, which is the version returned by the calculation phase.\nTheo Why would current be different than previous?\nJoe It happens when other mutations have run concurrently with our mutation.\nTheo I see.\nJoe If we are in a situation where the current state is the same as the previous state,\nit means that no mutations run concurrently. Therefore, as in Git, we can\nsafely fast-forward and update the state of the system with the next version.\nTheo What if the state has not stayed the same?\nJoe Then it means that mutations have run concurrently. We have to check for\nconflicts in a way similar to the three-way merge used by Git. The difference is\nthat instead of comparing lines, we compare fields of the system hash map.\nTheo Could you explain that?\n--- Page 124 ---\n96 CHAPTER 5 Basic concurrency control\nJoe We calculate the diff between previous and next and between previous and\ncurrent. If the two diffs have no fields in common, then there is no conflict\nbetween the mutations that have run concurrently. We can safely apply the\nchanges from previous to next into current.\nJoe makes his explanation visual with another diagram on the whiteboard. He then shows\nfigure 5.4 to Theo.\ndiffPreviousCurrent diffPreviousNext\ncurrent\nprevious merged\ndiffPreviousNext\nnext\nFigure 5.4 In a three-way merge, we calculate the diff between previous and\nnext, and we apply it to current.\nTheo What if there is a conflict?\nJoe Then we abort the mutation.\nTheo Aborting a user request seems unacceptable.\nJoe In fact, in a user-facing system, conflicting concurrent mutations are fairly rare.\nThat’s why it’s OK to abort and let the user run the mutation again. Here, let\nme draft a table to show you the differences between Git and DOP (table 5.2).\nTable 5.2 The analogy between Git and data-oriented programming\nData-oriented programming Git\nConcurrent mutations Different branches\nA version of the system data A commit\nState A reference\nCalculation phase Branching\nValidation Precommit hook\nReconciliation Merge\nFast-forward Fast-forward\nThree-way merge Three-way merge\nAbort Manual conflict resolution\nHash map Tree (folder)\nLeaf node Blob (file)\nData field Line of code\n--- Page 125 ---\n5.3 Reducing collections 97\nTheo Great! That helps, but in cases where two mutations update the same field of\nthe same entity, I think it’s fair enough to let the user know that the request\ncan’t be processed.\nTIP In a user-facing system, conflicting concurrent mutations are fairly rare.\n5.3 Reducing collections\nJoe Are you ready to challenge your mind with the implementation of the diff\nalgorithm?\nTheo Let’s take a short coffee break before, if you don’t mind. Then, I’ll be ready to\ntackle anything.\nAfter enjoying large mug of hot coffee and a few butter cookies, Theo and Joe are back to\nwork. Their discussion on the diff algorithm continues.\nJoe In the implementation of the diff algorithm, we’re going to reduce collections.\nTheo I heard about reducing collections in a talk about FP, but I don’t remember\nthe details. Could you remind me how this works?\nJoe Imagine you want to calculate the sum of the elements in a collection of num-\nbers. With Lodash’s _.reduce, it would look like this.\nListing5.1 Summing numbers with _.reduce\n_.reduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nTheo I don’t understand.\nJoe goes to the whiteboard and writes the description of _.reduce. Theo waits patiently\nuntil Joe puts the pen down before looking at the description.\nDescription of _.reduce\n_.reduce receives three arguments:\n coll—A collection of elements\n f—A function that receives two arguments\n initVal—A value\nLogic flow:\n1 Initialize currentRes with initVal.\n2 For each element x of coll, update currentRes with f(currentRes, x).\n3 Return currentRes.",
        "sections_found": []
      },
      "accurate_page_range": "102-125"
    },
    {
      "text": "- Summary",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "4 State management",
      "raw_line": "- Summary (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 37,
      "chapter_info": {
        "page": 102,
        "title": "State management",
        "pattern_matched": "Chapter 4",
        "text_preview": "74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead"
      },
      "chapter_sections": {
        "start_page": 102,
        "end_page": 125,
        "content": "\n--- Page 102 ---\n74 CHAPTER 4 State management\nTheo How does it work then?\nJoe It works by using a technique called structural sharing, where most of the data\nbetween subsequent versions of the state is shared instead of being copied.\nThis technique efficiently creates new versions of the system data, both in\nterms of memory and computation.\nTheo I’m intrigued.\nTIP With structural sharing, it’s efficient (in terms of memory and computation) to\ncreate new versions of data.\nJoe I’ll explain in detail how structural sharing works in a moment.\nTheo takes another look at the diagram in figure 4.1, which illustrates how the system state\nrefers to a version of the system data. Suddenly, a question emerges.\nTheo Are the previous versions of the system data kept?\nJoe In a simple application, previous versions are automatically removed by the\ngarbage collector. But, in some cases, we maintain historical references to pre-\nvious versions of the data.\nTheo What kind of cases?\nJoe For example, if we want to support time travel in our system, as in Git, we can\nmove the system back to a previous version of the state easily.\nTheo Now I understand what you mean by data is immutable, but the state reference\nis mutable!\n4.2 Structural sharing\nAs mentioned in the previous section, structural sharing enables the efficient cre-\nation of new versions of immutable data. In DOP, we use structural sharing in the\ncalculation phase of a mutation to compute the next state of the system based on\nthe current state of the system. Inside the calculation phase, we don’t have to deal\nwith state management; that is delayed to the commit phase. As a consequence, the\ncode involved in the calculation phase of a mutation is stateless and is as simple as\nthe code of a query.\nTheo I’m really intrigued by this more efficient way to create new versions of data.\nHow does it work?\nJoe Let’s take a simple example from our library system. Imagine that you want to\nmodify the value of a field in a book in the catalog; for instance, the publica-\ntion year of Watchmen. Can you tell me the information path for Watchmen’s\npublication year?\nTheo takes a quick look at the catalog data in figure 4.2. Then he answers Joe’s question.\n--- Page 103 ---\n4.2 Structural sharing 75\ncatalog\nbooksByIsbn authorsById\n978-1779501127 alan-moore\ntitle isbn name\nWatchmen 978-1779501127 Alan Moore\nauthorIds publicationYear bookIsbns\n1987\n1 0 0\nbookItems\ndave-gibbons alan-moore 978-1779501127\n1 0 dave-gibbons\nid id name\nbook-item-2 book-item-1 Dave Gibbons\nlibId libId bookIsbns\nla-central-lib nyc-cental-lib\n0\nisLent isLent\n978-1779501127\nfalse true\nFigure 4.2 Visualization of the catalog data. The nodes in the information path to Watchmen’s publication\nyear are marked with a dotted border.\nTheo The information path for Watchmen’s publication year is [\"catalog\", \"books-\nByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Now, let me show how you to use the immutable function _.set that Lodash\nalso provides.\nTheo Wait! What do you mean by an immutable function? When I looked at the\nLodash documentation for _.set on their website, it said that it mutates the\nobject.\nJoe You’re right, but the default Lodash functions are not immutable. In order to\nuse an immutable version of the functions, we need to use the Lodash FP mod-\nule as explained in the Lodash FP guide.\n NOTE See https://lodash.com/docs/4.17.15#set to view Lodash’s documentation\nfor _.set, and see https://github.com/lodash/lodash/wiki/FP-Guide to view the\nLodash FP guide.\nTheo Do the immutable functions have the same signature as the mutable functions?\nJoe By default, the order of the arguments in immutable functions is shuffled.\nThe Lodash FP guide explains how to resolve this. With this piece of code,\n--- Page 104 ---\n76 CHAPTER 4 State management\nthe signature of the immutable functions is exactly the same as the mutable\nfunctions.\nListing4.1 Configuring Lodash so immutable and mutable functions have same signature\n_ = fp.convert({\n\"cap\": false,\n\"curry\": false,\n\"fixed\": false,\n\"immutable\": true,\n\"rearg\": false\n});\nTIP In order to use Lodash immutable functions, we use Lodash’s FP module, and\nwe configure it so that the signature of the immutable functions is the same as in the\nLodash documentation web site.\nTheo So basically, I can still rely on Lodash documentation when using immutable\nversions of the functions.\nJoe Except for the piece in the documentation that says the function mutates the\nobject.\nTheo Of course!\nJoe Now I’ll show you how to write code that creates a version of the library data\nwith the immutable function _.set.\nJoe’s fingers fly across Theo’s keyboard. Theo then looks at Joe’s code, which creates a ver-\nsion of the library data where the Watchmen publication year is set to 1986.\nListing4.2 Using _.set as an immutable function\nvar nextLibraryData = _.set(libraryData,\n[\"catalog\", \"booksByIsbn\",\n\"978-1779501127\", \"publicationYear\"],\n1986);\n NOTE A function is said to be immutable when, instead of mutating the data, it cre-\nates a new version of the data without changing the data it receives.\nTheo You told me earlier that structural sharing allowed immutable functions to be\nefficient in terms of memory and computation. Can you tell me what makes\nthem efficient?\nJoe With pleasure, but before that, you have to answer a series of questions. Are\nyou ready?\nTheo Yes, sure...\nJoe What part of the library data is impacted by updating the Watchmen publication\nyear: the UserManagement or the Catalog?\n--- Page 105 ---\n4.2 Structural sharing 77\nTheo Only the Catalog.\nJoe What part of the Catalog?\nTheo Only the booksByIsbn index.\nJoe What part of the booksByIsbn index?\nTheo Only the Book record that holds the information about Watchmen.\nJoe What part of the Book record?\nTheo Only the publicationYear field.\nJoe Perfect! Now, suppose that the current version of the library data looks like\nthis.\nJoe goes to the whiteboard and draws a diagram. Figure 4.3 shows the result.\nLibrary\nCatalog UserManagement\nauthorsByld booksBylsbn ...\n... watchmen\ntitle:Watchmen publicationYear:1987 authorlds\n...\nFigure 4.3 High-level visualization of the current version of Library\nTheo So far, so good...\nJoe Next, let me show you what an immutable function does when you use it to cre-\nate a new version of Library, where the publication year of Watchmen is set to\n1986 instead of 1987.\nJoe updates his diagram on the whiteboard. It now looks like figure 4.4.\n--- Page 106 ---\n78 CHAPTER 4 State management\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.4 Structural sharing provides an efficient way to create a new version of the data.\nNext Library is recursively made of nodes that use the parts of Library that are\ncommon between the two.\nTheo Could you explain?\nJoe The immutable function creates a fresh Library hash map, which recursively\nuses the parts of the current Library that are common between the two ver-\nsions instead of deeply copying them.\nTheo It’s a bit abstract for me.\nJoe The next version of Library uses the same UserManagement hash map as the\nold one. The Catalog inside the next Library uses the same authorsById as\nthe current Catalog. The Watchmen Book record inside the next Catalog uses\nall the fields of the current Book except for the publicationYear field.\nTheo So, in fact, most parts of the data are shared between the two versions. Right?\nJoe Exactly! That’s why this technique is called structural sharing.\nTIP Structural sharing provides an efficient way (both in terms of memory and com-\nputation) to create a new version of the data by recursively sharing the parts that don’t\nneed to change.\nTheo That’s very cool!\nJoe Indeed. Now let’s look at how to write a mutation for adding a member using\nimmutable functions.\n--- Page 107 ---\n4.2 Structural sharing 79\nOnce again, Joe goes to the whiteboard. Figure 4.5 shows the diagram that Joe draws to\nillustrate how structural sharing looks when we add a member.\n«Next»\nLibrary\nLibrary\n«Next»\nUserManagement Catalog\nuserManagement\n«Next»\nmembers librarians ...\nmembers\nFigure 4.5 Adding a member\nwith structural sharing. Most of\nthe data is shared between the\n... member0 member1\ntwo versions.\nTheo Awesome! The Catalog and the librarians hash maps don’t have to be copied!\nJoe Now, in terms of code, we have to write a Library.addMember function that\ndelegates to UserManagement.addMember.\nTheo I guess it’s going to be similar to the code we wrote earlier to implement the\nsearch books query, where Library.searchBooksByTitleJSON delegates to\nCatalog.searchBooksByTitle.\nJoe Similar in the sense that all the functions are static, and they receive the data\nthey manipulate as an argument. But there are two differences. First, a muta-\ntion could fail, for instance, if the member to be added already exists. Second,\nthe code for Library.addMember is a bit more elaborate than the code for\nLibrary.searchBooksByTitleJSON because we have to create a new version\nof Library that refers to the new version of UserManagement. Here, let me\nshow you an example.\nListing4.3 The code for the mutation that adds a member\nUserManagement.addMember = function(userManagement, member) {\nvar email = _.get(member, \"email\");\nvar infoPath = [\"membersByEmail\", email];\nif(_.has(userManagement, infoPath)) {\nChecks if a member with\nthrow \"Member already exists.\";\nthe same email address\n}\nalready exists\nvar nextUserManagement = _.set(\nuserManagement,\nCreates a new version of\ninfoPath,\nuserManagement that\nmember);\nincludes the member\nreturn nextUserManagement;\n};\n--- Page 108 ---\n80 CHAPTER 4 State management\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library,\n\"userManagement\",\nnextUserManagement);\nCreates a new version of\nreturn nextLibrary;\nlibrary that contains the new\n};\nversion of userManagement\nTheo To me, it’s a bit weird that immutable functions return an updated version of\nthe data instead of changing it in place.\nJoe It was also weird for me when I first encountered immutable data in Clojure\nseven years ago.\nTheo How long did it take you to get used to it?\nJoe A couple of weeks.\n4.3 Implementing structural sharing\nWhen Joe leaves the office, Theo meets Dave near the coffee machine. Dave looks perplexed.\nDave Who’s the guy that just left the office?\nTheo It’s Joe. My DOP mentor.\nDave What’s DOP?\nTheo DOP refers to data-oriented programming.\nDave I never heard that term before.\nTheo It’s not well-known by programmers yet, but it’s quite a powerful programming\nparadigm. From what I’ve seen so far, it makes programming much simpler.\nDave Can you give me an example?\nTheo I just learned about structural sharing and how it makes it possible to create\nnew versions of data, effectively without copying.\nDave How does that work?\nTheo takes Dave to his office and shows him Joe’s diagram on the whiteboard (see figure 4.6).\nIt takes Theo a few minutes to explain to Dave what it does exactly, but in the end, Dave\ngets it.\nDave What does the implementation of structural sharing look like?\nTheo I don’t know. I used the _.set function from Lodash.\nDave It sounds like an interesting challenge.\nTheo Take the challenge if you want. Right now, I’m too tired for this recursive algo-\nrithmic stuff.\n--- Page 109 ---\n4.3 Implementing structural sharing 81\n«Next»\nLibrary\nLibrary\n«Next»\nCatalog UserManagement\nCatalog\n«Next»\nbooksByIsbn ... authorsById\nbooksByIsbn\n«Next»\nwatchmen ...\nwatchmen\n«Next»\npublicationYear:1987 title:Watchmen authorlds\npublicationYear:1986\n...\nFigure 4.6 Structural sharing in action\nThe next day, Theo stops by Dave’s cubicle before heading to his office. Dave, with a touch\nof pride, shows Theo his implementation of structural sharing. Theo is amazed by the fact\nthat it’s only 11 lines of JavaScript code!\nListing4.4 The implementation of structural sharing\nfunction setImmutable(map, path, v) {\nvar modifiedNode = v;\nvar k = path[0];\nvar restOfPath = path.slice(1);\nif (restOfPath.length > 0) {\nmodifiedNode = setImmutable(map[k], restOfPath, v);\n}\nvar res = Object.assign({}, map);\nShallow\nres[k] = modifiedNode;\nclones a map\nreturn res;\nin JavaScript.\n}\nTheo Dave, you’re brilliant!\nDave (smiling) Aw, shucks.\nTheo Oops, I have to go. I’m already late for my session with Joe! Joe is probably wait-\ning in my office, biting his nails.\n--- Page 110 ---\n82 CHAPTER 4 State management\n4.4 Data safety\nJoe is about to start the day’s lesson. Theo asks him a question about yesterday’s material\ninstead.\nTheo Something isn’t clear to me regarding this structural sharing stuff. What hap-\npens if we write code that modifies the data part that’s shared between the two\nversions of the data? Does the change affect both versions?\nJoe Could you please write a code snippet that illustrates your question?\nTheo starts typing on his laptop. He comes up with this code to illustrate modifying a piece\nof data shared between two versions.\nListing4.5 Modifying data that’s shared between two versions\nvar books = {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n};\nvar nextBooks = _.set(books, [\"978-1779501127\", \"publicationYear\"], 1986)\nconsole.log(\"Before:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\nbooks[\"978-1779501127\"][\"authorIds\"][1] = \"dave-chester-gibbons\";\nconsole.log(\"After:\", nextBooks[\"978-1779501127\"][\"authorIds\"][1]);\n// → Before: dave-gibbons\n// → After: dave-chester-gibbons\nTheo My question is, what is the value of isBlocked in updatedMember?\nJoe The answer is that mutating data via the native hash map setter is forbidden.\nAll the data manipulation must be done via immutable functions.\n NOTE All data manipulation must be done with immutable functions. It is forbid-\nden to use the native hash map setter.\nTheo When you say “forbidden,” you mean that it’s up to the developer to make sure\nit doesn’t happen. Right?\nJoe Exactly.\nTheo Is there a way to protect our system from a developer’s mistake?\nJoe Yes, there is a way to ensure the immutability of the data at the level of the data\nstructure. It’s called persistent data structures.\nTheo Are persistent data structures also efficient in terms of memory and computation?\nJoe Actually, the way data is organized inside persistent data structures make them\neven more efficient than immutable functions.\n--- Page 111 ---\n4.5 The commit phase of a mutation 83\nTIP Persistent data structures are immutable at the level of the data. There is no way\nto mutate them, even by mistake.\nTheo Are there libraries providing persistent data structures?\nJoe Definitely. I just happen to have a list of those libraries on my computer.\nJoe, being well-organized for a programmer, quickly brings up his list. He shows it to Theo:\n Immutable.js in JavaScript at https://immutable-js.com/\n Paguro in Java at https://github.com/GlenKPeterson/Paguro\n Immutable Collections in C# at http://mng.bz/y4Ke\n Pyrsistent in Python at https://github.com/tobgu/pyrsistent\n Hamster in Ruby at https://github.com/hamstergem/hamster\nTheo Why not use persistent data structures instead of immutable functions?\nJoe The drawback of persistent data structures is that they are not native. This\nmeans that working with them requires conversion from native to persistent\nand from persistent to native.\nTheo What approach would you recommend?\nJoe If you want to play around a bit, then start with immutable functions. But for a\nproduction application, I’d recommend using persistent data structures.\nTheo Too bad the native data structures aren’t persistent!\nJoe That’s one of the reasons why I love Clojure—the native data structures of the\nlanguage are immutable!\n4.5 The commit phase of a mutation\nSo far, we saw how to implement the calculation phase of a mutation. The calculation\nphase is stateless in the sense that it doesn’t make any change to the system. Now, let’s\nsee how to update the state of the system inside the commit phase.\nTheo takes another look at the code for Library.addMember. Something bothers him:\nthis function returns a new state of the library that contains an additional member, but it\ndoesn’t affect the current state of the library.\nListing4.6 The commit phase moves the system state forward\nLibrary.addMember = function(library, member) {\nvar currentUserManagement = _.get(library, \"userManagement\");\nvar nextUserManagement = UserManagement.addMember(\ncurrentUserManagement,\nmember);\nvar nextLibrary = _.set(library, \"userManagement\", nextUserManagement);\nreturn nextLibrary;\n};\nTheo I see that Library.addMember doesn’t change the state of the library. How\ndoes the library state get updated?\n--- Page 112 ---\n84 CHAPTER 4 State management\nJoe That’s an excellent question. Library.addMember deals only with data calcula-\ntion and is stateless. The state is updated in the commit phase by moving for-\nward the version of the state that the system state refers to.\nTheo What do you mean by that?\nJoe Here’s what happens when we add a member to the system. The calculation\nphase creates a version of the state that has two members. Before the commit\nphase, the system state refers to the version of the state with one member. The\nresponsibility of the commit phase is to move the system state forward so that it\nrefers to the version of the state with two members.\nTIP The responsibility of the commit phase is to move the system state forward to the\nversion of the state returned by the calculation phase.\nJoe draws another illustration on the whiteboard (figure 4.7). He hopes it helps to clear up\nany misunderstanding Theo may have.\nBefore Commit After Commit\nState with one State with one\nSystem State\nmember member\naddMember addMember\nState with two State with two\nSystem State\nmembers members\nFigure 4.7 The commit phase moves the system state forward.\nTheo How is this implemented?\nJoe The code is made of two classes: System, a singleton stateful class that imple-\nments the mutations, and SystemState, a singleton stateful class that manages\nthe system state.\nTheo It sounds to me like classic OOP.\nJoe Right, and this part of the system being stateful is OOP-like.\nTheo I’m happy to see that you still find some utility in OOP.\nJoe Meditation taught me that every part of our universe has a role to play.\nTheo Nice! Could you show me some code?\nJoe Sure.\nJoe thinks for a moment before starting to type. He wants to show the System class and its\nimplementation of the addMember mutation.\nListing4.7 The System class\nclass System {\naddMember(member) {\nvar previous = SystemState.get();\n--- Page 113 ---\n4.6 Ensuring system state integrity 85\nvar next = Library.addMember(previous, member);\nSystemState.commit(previous, next);\nSystemState is covered\n}\nin listing 4.8.\n}\nTheo What does SystemState look like?\nJoe I had a feeling you were going to ask that. Here’s the code for the System-\nState class, which is a stateful class!\nListing4.8 The SystemState class\nclass SystemState {\nsystemState;\nget() {\nreturn this.systemState;\n}\ncommit(previous, next) {\nthis.systemState = next;\n}\n}\nTheo I don’t get the point of SystemState. It’s a simple class with a getter and a\ncommit function, right?\nJoe In a moment, we are going to enrich the code of the SystemState.commit\nmethod so that it provides data validation and history tracking. For now, the\nimportant thing to notice is that the code of the calculation phase is stateless\nand is decoupled from the code of the commit phase, which is stateful.\nTIP The calculation phase is stateless. The commit phase is stateful.\n4.6 Ensuring system state integrity\nTheo Something still bothers me about the way functions manipulate immutable\ndata in the calculation phase. How do we preserve data integrity?\nJoe What do you mean?\nTheo In OOP, data is manipulated only by methods that belong to the same class as\nthe data. It prevents other classes from corrupting the inner state of the class.\nJoe Could you give me an example of an invalid state of the library?\nTheo For example, imagine that the code of a mutation adds a book item to the\nbook lendings of a member without marking the book item as lent in the cata-\nlog. Then the system data would be corrupted.\nJoe In DOP, we have the privilege of ensuring data integrity at the level of the\nwhole system instead of scattering the validation among many classes.\nTheo How does that work?\nJoe The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system data in a central place. At the beginning of the\ncommit phase, there is a step that checks whether the version of the system\n--- Page 114 ---\n86 CHAPTER 4 State management\nstate to be committed is valid. If the data is invalid, the commit is rejected.\nHere let me show you.\nListing4.9 Data validation inside the commit phase\nSystemState.commit = function(previous, next) {\nif(!SystemValidity.validate(previous, next)) { // not implemented for now\nthrow \"The system data to be committed is not valid!\";\n};\nthis.systemData = next;\n};\nTheo It sounds similar to a commit hook in Git.\nJoe I like your analogy!\nTheo Why are you passing the previous state in previous and the next state in next\nto SystemValidity.validate?\nJoe Because it allows SystemValidity.validate to optimize the validation in\nterms of computation. For example, we could validate just the data that has\nchanged.\nTIP In DOP, we validate the system data as a whole. Data validation is decoupled\nfrom data manipulation.\nTheo What does the code of SystemValidity.validate look like?\nJoe Someday, I will show you how to define a data schema and to validate that a\npiece of data conforms to a schema.\n NOTE See chapters 7 and 12 to see how Joe defines this data schema.\n4.7 Restoring previous states\nAnother advantage of the multi-version state approach with immutable data that is\nmanipulated via structural sharing is that we can keep track of the history of all the\nversions of the data without exploding the memory of our program. It allows us, for\ninstance, to restore the system back to an earlier state easily.\nTheo You told me earlier that it was easy to restore the system to a previous state.\nCould you show me how?\nJoe Happily, but before that, I’d like to make sure you understand why keeping\ntrack of all the versions of the data is efficient in terms of memory.\nTheo I think it’s related to the fact that immutable functions use structural sharing,\nand most of the data between subsequent versions of the state is shared.\nTIP Structural sharing allows us to keep many versions of the system state without\nexploding memory use.\nJoe Perfect! Now, I’ll show you how simple it is to undo a mutation. In order to\nimplement an undo mechanism, our SystemState class needs to have two\n--- Page 115 ---\n4.7 Restoring previous states 87\nreferences to the system data: systemData references the current state of the\nsystem, and previousSystemData references the previous state of the system.\nTheo That makes sense.\nJoe In the commit phase, we update both previousSystemData and systemData.\nTheo What does it take to implement an undo mechanism?\nJoe The undo is achieved by having systemData reference the same version of the\nsystem data as previousSystemData.\nTheo Could you walk me through an example?\nJoe To make things simple, I am going to give a number to each version of the sys-\ntem state. It starts at V0, and each time a mutation is committed, the version is\nincremented: V1, V2, V3, and so forth.\nTheo OK.\nJoe Let’s say that currently our system state is at V12 (see figure 4.8). In the\nSystemState object, systemData refers to V12, and previousSystemData\nrefers to V11.\npreviousSystemData\nMutationA Mutation B\nData V10 Data V11 Data V12\nsystemData\nFigure 4.8 When the system state is at V12, systemData refers to V12, and\npreviousSystemData refers to V11.\nTheo So far, so good...\nJoe Now, when a mutation is committed (for instance, adding a member), both\nreferences move forward: systemData refers to V13, and previousSystem-\nData refers to V12.\nJoe erases the whiteboard to make room for another diagram (figure 4.9). When he’s\nthrough with his drawing, he shows it to Theo.\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.9 When a mutation is committed, systemData refers to V13, and\npreviousSystemData refers to V12.\n--- Page 116 ---\n88 CHAPTER 4 State management\nTheo I suppose that when we undo the mutation, both references move backward.\nJoe In theory, yes, but in practice, it’s necessary to maintain a stack of all the state\nreferences. For now, to simplify things, we’ll maintain only a reference to the\nprevious version. As a consequence, when we undo the mutation, both refer-\nences refer to V12. Let me draw another diagram on the whiteboard that shows\nthis state (see figure 4.10).\npreviousSystemData\nMutationA Mutation B Mutation C\nData V10 Data V11 Data V12 Data V13\nsystemData\nFigure 4.10 When a mutation is undone, both systemData and previousSystemData refer\nto V12.\nTheo Could you show me how to implement this undo mechanism?\nJoe Actually, it takes only a couple of changes to the SystemState class. Pay atten-\ntion to the changes in the commit function. Inside systemDataBeforeUpdate,\nwe keep a reference to the current state of the system. If the validation and\nthe conflict resolution succeed, we update both previousSystemData and\nsystemData.\nListing4.10 The SystemState class with undo capability\nclass SystemState {\nsystemData;\npreviousSystemData;\nget() {\nreturn this.systemData;\n}\ncommit(previous, next) {\nvar systemDataBeforeUpdate = this.systemData;\nif(!Consistency.validate(previous, next)) {\nthrow \"The system data to be committed is not valid!\";\n}\nthis.systemData = next;\nthis.previousSystemData = systemDataBeforeUpdate;\n}\nundoLastMutation() {\nthis.systemData = this.previousSystemData;\n}\n}\n--- Page 117 ---\nSummary 89\nTheo I see that implementing System.undoLastMutation is simply a matter of hav-\ning systemData refer the same value as previousSystemData.\nJoe As I told you, if we need to allow multiple undos, the code would be a bit more\ncomplicated, but you get the idea.\nTheo I think so. Although Back to the Future belongs to the realm of science fiction, in\nDOP, time travel is real.\nSummary\n DOP principle #3 states that data is immutable.\n A mutation is an operation that changes the state of the system.\n In a multi-version approach to state management, mutations are split into cal-\nculation and commit phases.\n All data manipulation must be done via immutable functions. It is forbidden to\nuse the native hash map setter.\n Structural sharing allows us to create new versions of data efficiently (in terms of\nmemory and computation), where data that is common between the two ver-\nsions is shared instead of being copied.\n Structural sharing creates a new version of the data by recursively sharing the\nparts that don’t need to change.\n A mutation is split in two phases: calculation and commit.\n A function is said to be immutable when, instead of mutating the data, it creates\na new version of the data without changing the data it receives.\n During the calculation phase, data is manipulated with immutable functions that\nuse structural sharing.\n The calculation phase is stateless.\n During the commit phase, we update the system state.\n The responsibility of the commit phase is to move the system state forward to\nthe version of the state returned by the calculation phase.\n The data is immutable, but the state reference is mutable.\n The commit phase is stateful.\n We validate the system data as a whole. Data validation is decoupled from data\nmanipulation.\n The fact that the code for the commit phase is common to all the mutations\nallows us to validate the system state in a central place before we update the\nstate.\n Keeping the history of the versions of the system data is memory efficient due to\nstructural sharing.\n Restoring the system to one of its previous states is straightforward due to the\nclear separation between the calculation phase and the commit phase.\n--- Page 118 ---\n90 CHAPTER 4 State management\n In order to use Lodash immutable functions, we use the Lodash FP module\n(https://github.com/lodash/lodash/wiki/FP-Guide).\nLodash functions introduced in this chapter\nFunction Description\nset(map, path, value) Creates a map with the same fields as map with the addition of a\n<path, value> field\n--- Page 119 ---\nBasic concurrency control\nConflicts at home\nThis chapter covers\n Managing concurrent mutations with a lock-free\noptimistic concurrency control strategy\n Supporting high throughput of reads and writes\n Reconciliation between concurrent mutations\nThe changes required for system manage concurrency are only in the commit\nphase. They involve a reconciliation algorithm that is universal, in the sense that it\ncan be used in any system where data is represented as an immutable hash map.\nThe implementation of the reconciliation algorithm is efficient because subse-\nquent versions of the system state are created via structural sharing.\nIn the previous chapter, we illustrated the multiversion approach to state man-\nagement, where a mutation is split into two distinct phases: the calculation phase\nthat deals only with computation, and the commit phase that moves the state ref-\nerence forward. Usually, in a production system, mutations occur concurrently.\nMoving the state forward naively like we did in the previous chapter is not appro-\npriate. In the present chapter, we are going to learn how to handle concurrent\nmutations.\n91\n--- Page 120 ---\n92 CHAPTER 5 Basic concurrency control\nIn DOP, because only the code of the commit phase is stateful, that allows us to use\nan optimistic concurrency control strategy that doesn’t involve any locking mechanism. As\na consequence, the throughput of reads and writes is high. The modifications to the\ncode are not trivial, as we have to implement an algorithm that reconciles concurrent\nmutations. But the modifications impact only the commit phase. The code for the cal-\nculation phase stays the same as in the previous chapter.\n NOTE This chapter requires more of an effort to grasp. The flow of the reconcilia-\ntion algorithm is definitely not trivial, and the implementation involves a nontrivial\nrecursion.\n5.1 Optimistic concurrency control\nThis morning, before getting to work, Theo takes Joe to the fitness room in the office and,\nwhile running on the step machine, the two men talk about their personal lives again. Joe\ntalks about a fight he had last night with Kay, who thinks that he pays more attention to his\nwork than to his family. Theo recounts the painful conflict he had with Jane, his wife,\nabout house budget management. They went to see a therapist, an expert in Imago Rela-\ntionship Therapy. Imago allowed them to transform their conflict into an opportunity to\ngrow and heal.\nJoe’s ears perk up when he hears the word conflict because today’s lesson is going to be\nabout resolving conflicts and concurrent mutations. A different kind of conflict, though....\nAfter a shower and a healthy breakfast, Theo and Joe get down to work.\nJoe Yesterday, I showed you how to manage state with immutable data, assuming\nthat no mutations occur concurrently. Today, I am going to show you how to\ndeal with concurrency control in DOP.\nTheo I’m curious to discover what kind of lock mechanisms you use in DOP to syn-\nchronize concurrent mutations.\nJoe In fact, we don’t use any lock mechanism!\nTheo Why not?\nJoe Locks hit performance, and if you’re not careful, your system could get into a\ndeadlock.\nTheo So, how do you handle possible conflicts between concurrent mutations in\nDOP?\nJoe In DOP, we use a lock-free strategy called optimistic concurrency control. It’s a\nstrategy that allows databases like Elasticsearch to be highly scalable.\n NOTE See https://www.elastic.co/elasticsearch/ to find out more about Elastic-\nsearch.\nTheo You sound like my couples therapist and her anger-free, optimistic conflict\nresolution strategy.\nJoe Optimistic concurrency control and DOP fit together well. As you will see in a\nmoment, optimistic concurrency control is super efficient when the system\ndata is immutable.\n--- Page 121 ---\n5.1 Optimistic concurrency control 93\nTIP Optimistic concurrency control with immutable data is super efficient.\nTheo How does it work?\nJoe Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTIP Optimistic concurrency control occurs when we let mutations ask forgiveness\ninstead of permission.\nTheo What do you mean?\nJoe The calculation phase does its calculation as if it were the only mutation run-\nning. The commit phase is responsible for reconciling concurrent mutations\nwhen they don’t conflict or for aborting the mutation.\nTIP The calculation phase does its calculation as if it were the only mutation running.\nThe commit phase is responsible for trying to reconcile concurrent mutations.\nTheo That sounds quite challenging to implement.\nJoe Dealing with state is never trivial. But the good news is that the code for the\nreconciliation logic in the commit phase is universal.\nTheo Does that mean that the same code for the commit phase can be used in any\nDOP system?\nJoe Definitely. The code that implements the commit phase assumes nothing\nabout the details of the system except that the system data is represented as an\nimmutable map.\nTIP The implementation of the commit phase in optimistic concurrency control is\nuniversal. It can be used in any system where the data is represented by an immutable\nhash map.\nTheo That’s awesome!\nJoe Another cool thing is that handling concurrency doesn’t require any changes\nto the code in the calculation phase. From the calculation phase perspective,\nthe next version of the system data is computed in isolation as if no other muta-\ntions were running concurrently.\nJoe stands up to illustrate what he means on the whiteboard. While Theo looks at the draw-\ning in figure 5.1, Joe summarizes the information in table 5.1.\nTable 5.1 The two phases of a mutation with optimistic concurrency control\nPhase Responsibility State Implementation\nCalculation Compute next state in isolation Stateless Specific\nCommit Reconcile and update system state Stateful Common\n--- Page 122 ---\n94 CHAPTER 5 Basic concurrency control\nCalculation phase\nCapturesystem state\nComputenext version\nCommit phase\nYes No\nConcurrent mutations?\nYes No\nConflict?\nUpdatesystem state\nAbortmutation Reconcilemutations\nUpdatesystem state\nFigure 5.1 The logic flow\nof optimistic concurrency\ncontrol\n5.2 Reconciliation between concurrent mutations\nTheo Could you give me some examples of conflicting concurrent mutations?\nJoe Sure. One example would be two members trying to borrow the same book\ncopy. Another example might be when two librarians update the publication\nyear of the same book.\nTheo You mentioned that the code for the reconciliation logic in the commit phase\nis universal. What do you mean exactly by reconciliation logic?\nJoe It’s quite similar to what could happen in Git when you merge a branch back\ninto the main branch.\nTheo I love it when the main branch stays the same.\nJoe Yes, it’s nice when the merge has no conflicts and can be done automatically.\nDo you remember how Git handles the merge in that case?\nTheo Git does a fast-forward; it updates the main branch to be the same as the merge\nbranch.\nJoe Right! And what happens when you discover that, meanwhile, another devel-\noper has committed their code to the main branch?\nTheo Then Git does a three-way merge, trying to combine all the changes from the\ntwo merge branches with the main branch.\nJoe Does it always go smoothly?\nTheo Usually, yes, but it’s possible that two developers have modified the same line\nin the same file. I then have to manually resolve the conflict. I hate when that\nhappens!\nTIP In a production system, multiple mutations run concurrently. Before updating\nthe state, we need to reconcile the conflicts between possible concurrent mutations.\n--- Page 123 ---\n5.2 Reconciliation between concurrent mutations 95\nJoe In DOP, the reconciliation algorithm in the commit phase is quite similar to a\nmerge in Git, except instead of a manual conflict resolution, we abort the\nmutation. There are three possibilities to reconcile between possible concur-\nrent mutations: fast-forward, three-way merge, or abort.\nJoe goes to the whiteboard again. He draws the two diagrams shown in figures 5.2 and 5.3.\nYes No\nState has stayed the same\nYes No\nConcurrent mutations compatible?\nFast forward\n3-way Merge Abort\nFigure 5.2 The\nreconciliation flow\nThe version during\nthe Commit phase\ncurrent\nprevious\nnext\nThe base version\nfor the Calculation\nThe version Figure 5.3 When the commit phase\nphase\nreturned by the starts, there are three versions of the\nCalculation phase system state.\nTheo Could you explain in more detail?\nJoe When the commit phase of a mutation starts, we have three versions of the sys-\ntem state: previous, which is the version on which the calculation phase based\nits computation; current, which is the current version during the commit\nphase; and next, which is the version returned by the calculation phase.\nTheo Why would current be different than previous?\nJoe It happens when other mutations have run concurrently with our mutation.\nTheo I see.\nJoe If we are in a situation where the current state is the same as the previous state,\nit means that no mutations run concurrently. Therefore, as in Git, we can\nsafely fast-forward and update the state of the system with the next version.\nTheo What if the state has not stayed the same?\nJoe Then it means that mutations have run concurrently. We have to check for\nconflicts in a way similar to the three-way merge used by Git. The difference is\nthat instead of comparing lines, we compare fields of the system hash map.\nTheo Could you explain that?\n--- Page 124 ---\n96 CHAPTER 5 Basic concurrency control\nJoe We calculate the diff between previous and next and between previous and\ncurrent. If the two diffs have no fields in common, then there is no conflict\nbetween the mutations that have run concurrently. We can safely apply the\nchanges from previous to next into current.\nJoe makes his explanation visual with another diagram on the whiteboard. He then shows\nfigure 5.4 to Theo.\ndiffPreviousCurrent diffPreviousNext\ncurrent\nprevious merged\ndiffPreviousNext\nnext\nFigure 5.4 In a three-way merge, we calculate the diff between previous and\nnext, and we apply it to current.\nTheo What if there is a conflict?\nJoe Then we abort the mutation.\nTheo Aborting a user request seems unacceptable.\nJoe In fact, in a user-facing system, conflicting concurrent mutations are fairly rare.\nThat’s why it’s OK to abort and let the user run the mutation again. Here, let\nme draft a table to show you the differences between Git and DOP (table 5.2).\nTable 5.2 The analogy between Git and data-oriented programming\nData-oriented programming Git\nConcurrent mutations Different branches\nA version of the system data A commit\nState A reference\nCalculation phase Branching\nValidation Precommit hook\nReconciliation Merge\nFast-forward Fast-forward\nThree-way merge Three-way merge\nAbort Manual conflict resolution\nHash map Tree (folder)\nLeaf node Blob (file)\nData field Line of code\n--- Page 125 ---\n5.3 Reducing collections 97\nTheo Great! That helps, but in cases where two mutations update the same field of\nthe same entity, I think it’s fair enough to let the user know that the request\ncan’t be processed.\nTIP In a user-facing system, conflicting concurrent mutations are fairly rare.\n5.3 Reducing collections\nJoe Are you ready to challenge your mind with the implementation of the diff\nalgorithm?\nTheo Let’s take a short coffee break before, if you don’t mind. Then, I’ll be ready to\ntackle anything.\nAfter enjoying large mug of hot coffee and a few butter cookies, Theo and Joe are back to\nwork. Their discussion on the diff algorithm continues.\nJoe In the implementation of the diff algorithm, we’re going to reduce collections.\nTheo I heard about reducing collections in a talk about FP, but I don’t remember\nthe details. Could you remind me how this works?\nJoe Imagine you want to calculate the sum of the elements in a collection of num-\nbers. With Lodash’s _.reduce, it would look like this.\nListing5.1 Summing numbers with _.reduce\n_.reduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nTheo I don’t understand.\nJoe goes to the whiteboard and writes the description of _.reduce. Theo waits patiently\nuntil Joe puts the pen down before looking at the description.\nDescription of _.reduce\n_.reduce receives three arguments:\n coll—A collection of elements\n f—A function that receives two arguments\n initVal—A value\nLogic flow:\n1 Initialize currentRes with initVal.\n2 For each element x of coll, update currentRes with f(currentRes, x).\n3 Return currentRes.",
        "sections_found": []
      },
      "accurate_page_range": "102-125"
    }
  ]
}