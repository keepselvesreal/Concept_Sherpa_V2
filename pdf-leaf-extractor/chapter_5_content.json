{
  "chapter": "5",
  "title": "Basic concurrency control",
  "page_info": {
    "page": 126,
    "title": "Basic concurrency control",
    "pattern_matched": "Chapter 5",
    "text_preview": "98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. "
  },
  "leaf_nodes": [
    {
      "text": "- 5.0 Introduction (사용자 추가)",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "raw_line": "- 5.0 Introduction (사용자 추가) (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 38,
      "chapter_info": {
        "page": 126,
        "title": "Basic concurrency control",
        "pattern_matched": "Chapter 5",
        "text_preview": "98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. "
      },
      "chapter_sections": {
        "start_page": 126,
        "end_page": 151,
        "content": "\n--- Page 126 ---\n98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. It means that the first call to f will be f(0, 1). Then,\nwe’ll have f(f(0, 1), 2) and, finally, f(f(f(0, 1), 2), 3).\nJoe I like your manual expansion, Theo! Let’s make it visual.\nNow Theo goes to the whiteboard and draws a diagram. Figure 5.5 shows what that looks like.\nf\nf a\n2\nf a\n1\na 0 initVal Figure 5.5 Visualization\nof _.reduce\nTheo It’s much clearer now. I think that by implementing my custom version of\n_.reduce, it will make things 100% clear.\nIt takes Theo much less time than he expected to implement reduce(). In no time at all,\nhe shows Joe the code.\nListing5.2 Custom implementation of _.reduce\nfunction reduce(coll, f, initVal) {\nvar currentRes = initVal;\nfor (var i = 0; i < coll.length; i++) {\nWe could use\ncurrentRes = f(currentRes, coll[i])\nforEach instead\n}\nof a for loop.\nreturn currentRes;\n}\nAfter checking that Theo’s code works as expected (see listing 5.3), Joe is proud of Theo.\nHe seems to be catching on better than he anticipated.\nListing5.3 Testing the custom implementation of reduce()\nreduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nJoe Well done!\n--- Page 127 ---\n5.4 Structural difference 99\n5.4 Structural difference\n NOTE This section deals with the implementation of a structural diff algorithm. Feel\nfree to skip this section if you don’t want to challenge your mind right now with the\ndetails of a sophisticated use of recursion. It won’t prevent you from enjoying the rest\nof the book. You can come back to this section later.\nTheo How do you calculate the diff between various versions of the system state?\nJoe That’s the most challenging part of the reconciliation algorithm. We need to\nimplement a structural diff algorithm for hash maps.\nTheo In what sense is the diff structural?\nJoe The structural diff algorithm looks at the structure of the hash maps and\nignores the order of the fields.\nTheo Could you give me an example?\nJoe Let’s start with maps without nested fields. Basically, there are three kinds of\ndiffs: field replacement, field addition, and field deletion. In order to make\nthings not too complicated, for now, we’ll deal only with replacement and\naddition.\nJoe once again goes to the whiteboard and draws table 5.3, representing the three kinds of\ndiffs. Theo is thinking the whiteboard is really starting to fill up today.\nTable 5.3 Kinds of structural differences between maps without nested fields\nKind First map Second map Diff\nReplacement {\"a\": 1} {\"a\": 2} {\"a\": 2}\nAddition {\"a\": 1} {\"a\": 1, \"b\": 2} {\"b\": 2}\nDeletion {\"a\": 1, \"b\": 2} {\"a\": 1} Not supported\nTheo I notice that the order of the maps matters a lot. What about nested fields?\nJoe It’s the same idea, but the nesting makes it a bit more difficult to grasp.\nJoe changes several of the columns in table 5.3. When he’s through, he shows Theo the\nnested fields in table 5.4.\nTable 5.4 Kinds of structural differences between maps with nested fields\nKind First map Second map Diff\nReplacement { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 2 \"x\": 2\n} } }\n} } }\n--- Page 128 ---\n100 CHAPTER 5 Basic concurrency control\nTable 5.4 Kinds of structural differences between maps with nested fields (continued)\nKind First map Second map Diff\nAddition { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 1, \"y\": 2\n} \"y\": 2, }\n} } }\n}\nDeletion { { Not supported\n\"a\": { \"a\": {\n\"x\": 1, \"y\": 2\n\"y\": 2, }\n} }\n}\n NOTE The version of the structural diff algorithm illustrated in this chapter does\nnot deal with deletions. Dealing with deletions is definitely possible, but it requires a\nmore complicated algorithm.\nTheo As you said, it’s harder to grasp. What about arrays?\nJoe We compare the elements of the arrays in order: if they are equal, the diff is\nnull; if they differ, the diff has the value of the second array.\nJoe summarizes the various kinds of diffs in another table on the whiteboard. Theo looks\nat the result in table 5.5.\nTable 5.5 Kinds of structural differences between arrays without nested elements\nKind First array Second array Diff\nReplacement [1] [2] [2]\nAddition [1] [1, 2] [null, 2]\nDeletion [1, 2] [1] Not supported\nTheo This usage of null is a bit weird but OK. Is it complicated to implement the\nstructural diff algorithm?\nJoe Definitely! It took a good dose of mental gymnastics to come up with these 30\nlines of code.\nJoe downloads the code from one his personal repositories. Theo, with thumb and forefin-\ngers touching his chin and his forehead slightly tilted, studies the code.\nListing5.4 The implementation of a structural diff\nfunction diffObjects(data1, data2) {\n_.isArray checks whether\nvar emptyObject = _.isArray(data1) ? [] : {};\nits argument is an array.\nif(data1 == data2) {\n--- Page 129 ---\n5.4 Structural difference 101\nreturn emptyObject;\n_.union creates an\n} array of unique\nvar keys = _.union(_.keys(data1), _.keys(data2)); values from two\nreturn _.reduce(keys, arrays (like union of\nfunction (acc, k) { two sets in Maths).\nvar res = diff(\n_.get(data1, k),\n_.isObject checks\n_.get(data2, k));\nwhether its argument\nif((_.isObject(res) && _.isEmpty(res)) ||\nis a collection (either\na map or an array).\n(res == \"no-diff\")) {\nreturn acc;\n_.isEmpty }\nchecks return _.set(acc, [k], res);\nwhether its },\nargument\nemptyObject);\nis an empty\n} \"no-diff\" is how\ncollection.\nwe mark that\nfunction diff(data1, data2) { two values are\nif(_.isObject(data1) && _.isObject(data2)) { the same.\nreturn diffObjects(data1, data2);\n}\nif(data1 !== data2) {\nreturn data2;\n}\nreturn \"no-diff\";\n}\nTheo Wow! It involves a recursion inside a reduce! I’m sure Dave will love this, but\nI’m too tired to understand this code right now. Let’s focus on what it does\ninstead of how it does it.\nIn order familiarize himself with the structural diff algorithm, Theo runs the algorithm\nwith examples from the table that Joe drew on the whiteboard. While Theo occupies his\nfingers with more and more complicated examples, his mind wanders in the realm of\nperformance.\nListing5.5 An example of usage of a structural diff\nvar data1 = {\n\"a\": {\n\"x\": 1,\n\"y\": [2, 3],\n\"z\": 4\n}\n};\nvar data2 = {\n\"a\": {\n\"x\": 2,\n\"y\": [2, 4],\n\"z\": 4\n}\n}\n--- Page 130 ---\n102 CHAPTER 5 Basic concurrency control\ndiff(data1, data2);\n//{\n// \"a\": {\n// \"x\": 2,\n// \"y\": [\n// undefined,\n// 4\n// ]\n// }\n//}\nTheo What about the performance of the structural diff algorithm? It seems that the\nalgorithm goes over the leaves of both pieces of data?\nJoe In the general case, that’s true. But, in the case of system data that’s manipu-\nlated with structural sharing, the code is much more efficient.\nTheo What do you mean?\nJoe With structural sharing, most of the nested objects are shared between two ver-\nsions of the system state. Therefore, most of the time, when the code enters\ndiffObjects, it will immediately return because data1 and data2 are the same.\nTIP Calculating the diff between two versions of the state is efficient because two\nhash maps created via structural sharing from the same hash map have most of their\nnodes in common.\nTheo Another benefit of immutable data... Let me see how the diff algorithm\nbehaves with concurrent mutations. I think I’ll start with a tiny library with no\nusers and a catalog with a single book, Watchmen.\nListing5.6 The data for a tiny library\nvar library = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\n--- Page 131 ---\n5.4 Structural difference 103\nJoe I suggest that we start with nonconflicting mutations. What do you suggest?\nTheo A mutation that updates the publication year of Watchmen and a mutation that\nupdates both the title of Watchmen and the name of the author of Watchmen.\nOn his laptop, Theo creates three versions of the library. He shows Joe his code, where one\nmutation updates the publication year of Watchmen, and the other one updates the title of\nWatchmen and the author’s name.\nListing5.7 Two nonconflicting mutations\nvar previous = library;\nvar next = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"],\n1986);\nvar libraryWithUpdatedTitle = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"],\n\"The Watchmen\");\nvar current = _.set(\nlibraryWithUpdatedTitle,\n[\"catalog\", \"authorsById\", \"dave-gibbons\", \"name\"],\n\"David Chester Gibbons\");\nTheo I’m curious to see what the diff between previous and current looks like.\nJoe Run the code and you’ll see.\nTheo runs the code snippets for the structural diff between previous and next and for\nthe structural diff between previous and current. His curiosity satisfied, Theo finds it’s\nall beginning to make sense.\nListing5.8 Structural diff between maps with a single difference\ndiff(previous, next);\n//{\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"publicationYear\": 1986\n// }\n// }\n// }\n//}\nListing5.9 Structural diff between maps with two differences\ndiff(previous, current);\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\",\n--- Page 132 ---\n104 CHAPTER 5 Basic concurrency control\n// }\n// },\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\n//\nJoe Can you give me the information path of the single field in the structural diff\nbetween previous and next?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Right. And what are the information paths of the fields in the structural diff\nbetween previous and current?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"] for the book\ntitle and [\"authorsById\", \"dave-gibbons\", \"name\"] for the author’s name.\nJoe Perfect! Now, can you figure out how to detect conflicting mutations by\ninspecting the information paths of the structural diffs?\nTheo We need to check if they have an information path in common or not.\nJoe Exactly! If they have, it means the mutations are conflicting.\nTheo But I have no idea how to write code that retrieves the information paths of a\nnested map.\nJoe Once again, it’s a nontrivial piece of code that involves a recursion inside a\nreduce. Let me download another piece of code from my repository and show\nit to you.\nListing5.10 Calculating the information paths of a (nested) map\nfunction informationPaths (obj, path = []) {\nreturn _.reduce(obj,\nfunction(acc, v, k) {\nif (_.isObject(v)) {\nreturn _.concat(acc,\ninformationPaths(v,\n_.concat(path, k)));\n}\nreturn _.concat(acc, [_.concat(path, k)]);\n},\n[]);\n}\nTheo Let me see if your code works as expected with the structural diffs of the\nmutations.\nTheo tests Joe’s code with two code snippets. The first shows the information paths of the\nstructural diff between previous and next, and the second shows the information paths\nof the structural diff between previous and current.\n--- Page 133 ---\n5.4 Structural difference 105\nListing5.11 Fields that differ between previous and next\ninformationPaths(diff(previous, next));\n// → [\"catalog.booksByIsbn.978-1779501127.publicationYear\"]\nListing5.12 Fields that differ between previous and current\ninformationPaths(diff(previous, current));\n// [\n// [\n// \"catalog\",\n// \"booksByIsbn\",\n// \"978-1779501127\",\n// \"title\"\n// ],\n// [\n// \"authorsById\",\n// \"dave-gibbons\",\n// \"name\"\n// ]\n//]\nTheo Nice! I assume that Lodash has a function that checks whether two arrays have\nan element in common.\nJoe Almost. There is _.intersection, which returns an array of the unique values\nthat are in two given arrays. For our purpose, though, we need to check\nwhether the intersection is empty. Here, look at this example.\nListing5.13 Checking whether two diff maps have a common information path\nfunction havePathInCommon(diff1, diff2) {\nreturn !_.isEmpty(_.intersection(informationPaths(diff1),\ninformationPaths(diff2)));\n}\nTheo You told me earlier that in the case of nonconflicting mutations, we can\nsafely patch the changes induced by the transition from previous to next\ninto current. How do you implement that?\nJoe We do a recursive merge between current and the diff between previous and\nnext.\nTheo Does Lodash provide an immutable version of recursive merge?\nJoe Yes, here’s another example. Take a look at this code.\nListing5.14 Applying a patch\n_.merge(current, (diff(previous, next)));\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\"\n// }\n// },\n--- Page 134 ---\n106 CHAPTER 5 Basic concurrency control\n// \"catalog\": {\n// \"authorsById\": {\n// \"alan-moore\": {\n// \"bookIsbns\": [\"978-1779501127\"]\n// \"name\": \"Alan Moore\"\n// },\n// \"dave-gibbons\": {\n// \"bookIsbns\": [\"978-1779501127\"],\n// \"name\": \"Dave Gibbons\"\n// },\n// },\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n// \"isbn\": \"978-1779501127\",\n// \"publicationYear\": 1986,\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\nTheo Could it be as simple as this?\nJoe Indeed.\n5.5 Implementing the reconciliation algorithm\nJoe All the pieces are now in place to implement our reconciliation algorithm.\nTheo What kind of changes are required?\nJoe It only requires changes in the code of SystemState.commit. Here, look at\nthis example on my laptop.\nListing5.15 The SystemState class\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nvar nextSystemData = SystemConsistency.reconcile(\nthis.systemData,\nSystemConsistency class is\nprevious,\nimplemented in listing 5.16.\nnext);\nif(!SystemValidity.validate(previous, nextSystemData)) {\nthrow \"The system data to be committed is not valid!\";\n};\n--- Page 135 ---\n5.5 Implementing the reconciliation algorithm 107\nthis.systemData = nextSystemData;\n}\n}\nTheo How does SystemConsistency do the reconciliation?\nJoe The SystemConsistency class starts the reconciliation process by comparing\nprevious and current. If they are the same, then we fast-forward and return\nnext. Look at this code for SystemConsistency.\nListing5.16 The reconciliation flow in action\nclass SystemConsistency {\nstatic threeWayMerge(current, previous, next) {\nvar previousToCurrent = diff(previous, current);\nvar previousToNext = diff(previous, next);\nif(havePathInCommon(previousToCurrent, previousToNext)) { When the system\nreturn _.merge(current, previousToNext); state is the same\n} as the state used\nthrow \"Conflicting concurrent mutations.\"; by the calculation\n} phase, we fast-\nstatic reconcile(current, previous, next) { forward.\nif(current == previous) {\nreturn next;\n}\nreturn SystemConsistency.threeWayMerge(current,\nprevious,\nnext);\n}\n}\nTheo Wait a minute! Why do you compare previous and current by reference?\nYou should be comparing them by value, right? And, it would be quite expen-\nsive to compare all the leaves of the two nested hash maps!\nJoe That’s another benefit of immutable data. When the data is not mutated, it is\nsafe to compare references. If they are the same, we know for sure that the data\nis the same.\nTIP When data is immutable, it is safe to compare by reference, which is super fast.\nWhen the references are the same, it means that the data is the same.\nTheo What about the implementation of the three-way merge algorithm?\nJoe When previous differs from current, it means that concurrent mutations\nhave run. In order to determine whether there is a conflict, we calculate two\ndiffs: the diff between previous and current and the diff between previous\nand next. If the intersection between the two diffs is empty, it means there is\nno conflict. We can safely patch the changes between previous to next into\ncurrent.\nTheo takes a closer look at the code for the SystemConsistency class in listing 5.16. He\ntries to figure out if the code is thread-safe or not.\n--- Page 136 ---\n108 CHAPTER 5 Basic concurrency control\nTheo I think the code for SystemConsistency class is not thread-safe! If there’s a\ncontext switch between checking whether the system has changed in the\nSystemConsistency class and the updating of the state in SystemData class, a\nmutation might override the changes of a previous mutation.\nJoe You are totally right! The code works fine in a single-threaded environment\nlike JavaScript, where concurrency is handled via an event loop. However, in a\nmulti-threaded environment, the code needs to be refined in order to be\nthread-safe. I’ll show you some day.\n NOTE The SystemConsistency class is not thread-safe. We will make it thread-safe\nin chapter 8.\nTheo I think I understand why you called it optimistic concurrency control. It’s\nbecause we assume that conflicts don’t occur too often. Right?\nJoe Correct! It makes me wonder what your therapist would say about conflicts that\ncannot be resolved. Are there some cases where it’s not possible to reconcile\nthe couple?\nTheo I don’t think she ever mentioned such a possibility.\nJoe She must be a very optimistic person.\nSummary\n Optimistic concurrency control allows mutations to ask forgiveness instead of\npermission.\n Optimistic concurrency control is lock-free.\n Managing concurrent mutations of our system state with optimistic concurrency\ncontrol allows our system to support a high throughput of reads and writes.\n Optimistic concurrency control with immutable data is super efficient.\n Before updating the state, we need to reconcile the conflicts between possible con-\ncurrent mutations.\n We reconcile between concurrent mutations in a way that is similar to how Git han-\ndles a merge between two branches: either a fast-forward or a three-way merge.\n The changes required to let our system manage concurrency are only in the\ncommit phase.\n The calculation phase does its calculation as if it were the only mutation running.\n The commit phase is responsible for trying to reconcile concurrent mutations.\n The reconciliation algorithm is universal in the sense that it can be used in any sys-\ntem where the system data is represented as an immutable hash map.\n The implementation of the reconciliation algorithm is efficient, as it leverages\nthe fact that subsequent versions of the system state are created via structural\nsharing.\n In a user-facing system, conflicting concurrent mutations are fairly rare.\n When we cannot safely reconcile between concurrent mutations, we abort the\nmutation and ask the user to try again.\n--- Page 137 ---\nSummary 109\n Calculating the structural diff between two versions of the state is efficient because\ntwo hash maps created via structural sharing from the same hash map have most\nof their nodes in common.\n When data is immutable, it is safe to compare by reference, which is fast. When\nthe references are the same, it means that the data is the same.\n There are three kinds of structural differences between two nested hash maps:\nreplacement, addition, and deletion.\n Our structural diff algorithm supports replacements and additions but not\ndeletions.\nLodash functions introduced in this chapter\nFunction Description\nconcat(arrA, arrB) Creates an new array, concatenating arrA and arrB\nintersection(arrA, arrB) Creates an array of unique values both in arrA and arrB\nunion(arrA, arrB) Creates an array of unique values from arrA and arrB\nfind(coll, pred) Iterates over elements of coll, returning the first element for\nwhich pred returns true\nisEmpty(coll) Checks if coll is empty\nreduce(coll, f, initVal) Reduces coll to a value that is the accumulated result of running\neach element in coll through f, where each successive invoca-\ntion is supplied the return value of the previous\nisArray(coll) Checks if coll is an array\nisObject(coll) Checks if coll is a collection\n--- Page 138 ---\nUnit tests\nProgramming at a coffee shop\nThis chapter covers\n Generation of the minimal data input for a\ntest case\n Comparison of the output of a function with\nthe expected output\n Guidance about the quality and the quantity\nof the test cases\nIn a data-oriented system, our code deals mainly with data manipulation: most of\nour functions receive data and return data. As a consequence, it’s quite easy to\nwrite unit tests to check whether our code behaves as expected. A unit test is made\nof test cases that generate data input and compare the data output of the function\nwith the expected data output. In this chapter, we write unit tests for the queries\nand mutations that we wrote in the previous chapters.\n6.1 The simplicity of data-oriented test cases\nTheo and Joe are seated around a large wooden table in a corner of “La vie est belle,” a\nnice little French coffee shop, located near the Golden Gate Bridge. Theo orders a café\nau lait with a croissant, and Joe orders a tight espresso with a pain au chocolat. Instead\nof the usual general discussions about programming and life when they’re out of the\n110\n--- Page 139 ---\n6.1 The simplicity of data-oriented test cases 111\noffice, Joe leads the discussion towards a very concrete topic—unit tests. Theo asks Joe for\nan explanation.\nTheo Are unit tests such a simple topic that we can tackle it here in a coffee shop?\nJoe Unit tests in general, no. But unit tests for data-oriented code, yes!\nTheo Why does that make a difference?\nJoe The vast majority of the code base of a data-oriented system deals with data\nmanipulation.\nTheo Yeah. I noticed that almost all the functions we wrote so far receive data and\nreturn data.\nTIP Most of the code in a data-oriented system deals with data manipulation.\nJoe Writing a test case for functions that deal with data is only about generating\ndata input and expected output, and comparing the output of the function\nwith the expected output.\nThe steps of a test case\n1 Generate data input: dataIn\n2 Generate expected output: dataOut\n3 Compare the output of the function with the expected output: f(dataIn) and\ndataOut\nTheo That’s it?\nJoe Yes. As you’ll see in a moment, in DOP, there’s usually no need for mock\nfunctions.\nTheo I understand how to compare primitive values like strings or numbers, but I’m\nnot sure how I would compare data collections like maps.\nJoe You compare field by field.\nTheo Recursively?\nJoe Yes!\nTheo Oh no! I’m not able to write any recursive code in a coffee shop. I need the\ncalm of my office for that kind of stuff.\nJoe Don’t worry. In DOP, data is represented in a generic way. There is a generic\nfunction in Lodash called _.isEqual for recursive comparison of data collec-\ntions. It works with both maps and arrays.\nJoe opens his laptop. He is able to convince Theo by executing a few code snippets with\n_.isEqual to compare an equal data collection with a non-equal one.\nListing6.1 Comparing an equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n--- Page 140 ---\n112 CHAPTER 6 Unit tests\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n});\n// → true\nListing6.2 Comparing a non-equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"bad-isbn\"]\n});\n// → false\nTheo Nice!\nJoe Most of the test cases in DOP follow this pattern.\nTheo decides he wants to try this out. He fires up his laptop and types a few lines of\npseudocode.\nListing6.3 The general pattern of a data-oriented test case\nvar dataIn = {\n// input\n};\nvar dataOut = {\n// expected output\n};\n_.isEqual(f(dataIn), dataOut);\nTIP It’s straightforward to write unit tests for code that deals with data manipulation.\nTheo Indeed, this looks like something we can tackle in a coffee shop!\n6.2 Unit tests for data manipulation code\nA waiter in an elegant bow tie brings Theo his croissant and Joe his pain au chocolat. The\ntwo friends momentarily interrupt their discussion to savor their French pastries. When\nthey’re done, they ask the waiter to bring them their drinks. Meanwhile, they resume the\ndiscussion.\nJoe Do you remember the code flow of the implementation of the search query?\nTheo Let me look again at the code that implements the search query.\nTheo brings up the implementation of the search query on his laptop. Noticing that Joe is\nchewing on his nails again, he quickly checks out the code.\n--- Page 141 ---\n6.2 Unit tests for data manipulation code 113\nListing6.4 The code involved in the implementation of the search query\nclass Catalog {\nstatic authorNames(catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n}\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\nreturn bookInfo;\n}\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\n}\n6.2.1 The tree of function calls\nThe waiter brings Theo his café au lait and Joe his tight espresso. They continue their dis-\ncussion while enjoying their coffees.\nJoe Before writing a unit test for a code flow, I find it useful to visualize the tree of\nfunction calls of the code flow.\nTheo What do you mean by a tree of function calls?\nJoe Here, I’ll draw the tree of function calls for the Library.searchBooksBy-\nTitleJSON code flow.\nJoe puts down his espresso and takes a napkin from the dispenser. He carefully places it\nflat on the table and starts to draw. When he is done, he shows the illustration to Theo (see\nfigure 6.1).\n--- Page 142 ---\n114 CHAPTER 6 Unit tests\nLibrary.searchBooksByTitleJSON\n_.get JSON.stringify Catalog.searchBooksByTitle\n_.get _.map _.filter Catalog.bookInfo\n_.get Catalog.authorNames\n_.get _.map\nFigure 6.1 The tree of function calls for the search query code flow\nTheo Nice! Can you teach me how to draw a tree of function calls like that?\nJoe Sure. The root of the tree is the name of the function for which you draw the\ntree, in our case, Library.searchBooksByTitleJSON. The children of a\nnode in the tree are the names of the functions called by the function. For exam-\nple, if you look again at the code for Library.searchBooksByTitleJSON (list-\ning 6.4), you’ll see that it calls Catalog.searchBooksByTitle, _.get, and\nJSON.stringify.\nTheo How long would I continue to recursively expand the tree?\nJoe You continue until you reach a function that doesn’t belong to the code base\nof your application. Those nodes are the leaves of our tree; for example, the\nfunctions from Lodash: _.get, _.map, and so forth.\nTheo What if the code of a function doesn’t call any other functions?\nJoe A function that doesn’t call any other function would be a leaf in the tree.\nTheo What about functions that are called inside anonymous functions like Catalog\n.bookInfo?\nJoe Catalog.bookInfo appears in the code of Catalog.searchBooksByTitle.\nTherefore, it is considered to be a child node of Catalog.searchBooksBy-\nTitle. The fact that it is nested inside an anonymous function is not relevant\nin the context of the tree of function calls.\n NOTE A tree of function calls for a function f is a tree where the root is f, and the\nchildren of a node g in the tree are the functions called by g. The leaves of the tree are\nfunctions that are not part of the code base of the application. These are functions\nthat don’t call any other functions.\nTheo It’s very cool to visualize my code as a tree, but I don’t see how it relates to\nunittests.\n--- Page 143 ---\n6.2 Unit tests for data manipulation code 115\nJoe The tree of function calls guides us about the quality and the quantity of test\ncases we should write.\nTheo How?\nJoe You’ll see in a moment.\n6.2.2 Unit tests for functions down the tree\nJoe Let’s start from the function that appears in the deepest node in our tree:\nCatalog.authorNames. Take a look at the code for Catalog.authorNames\nand tell me what are the input and the output of Catalog.authorNames.\nJoe turns his laptop so Theo can a closer look at the code. Theo takes a sip of his café au\nlait as he looks over what’s on Joe’s laptop.\nListing6.5 The code of Catalog.authorNames\nCatalog.authorNames = function (catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n};\nTheo The input of Catalog.authorNames is catalogData and authorIds. The\noutput is authorNames.\nJoe Would you do me a favor and express it visually?\nTheo Sure.\nIt’s Theo’s turn to grab a napkin. He draws a small rectangle with two inward arrows and\none outward arrow as in figure 6.2.\ncatalogData authorIds\nCatalog.authorNames()\nFigure 6.2 Visualization of the input\nauthorNames and output of Catalog.authorNames\nJoe Excellent! Now, how many combinations of input would you include in the\nunit test for Catalog.authorNames?\nTheo Let me see.\nTheo reaches for another napkin. This time he creates a table to gather his thoughts\n(table 6.1).\n--- Page 144 ---\n116 CHAPTER 6 Unit tests\nTable 6.1 The table of test cases for Catalog.authorNames\ncatalogData authorIds authorNames\nCatalog with two authors Empty array Empty array\nCatalog with two authors Array with one author ID Array with one author name\nCatalog with two authors Array with two author IDs Array with two author names\nTheo To begin with, I would have a catalogData with two author IDs and call\nCatalog.authorNames with three arguments: an empty array, an array with a\nsingle author ID, and an array with two author IDs.\nJoe How would you generate the catalogData?\nTheo Exactly as we generated it before.\nTurning to his laptop, Theo writes the code for catalogData. He shows it to Joe.\nListing6.6 A complete catalogData map\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\n--- Page 145 ---\n6.2 Unit tests for data manipulation code 117\nJoe You could use your big catalogData map for the unit test, but you could also\nuse a smaller map in the context of Catalog.authorNames. You can get rid of\nthe booksByIsbn field of the catalogData and the bookIsbns fields of the\nauthors.\nJoe deletes a few lines from catalogData and gets a much smaller map. He shows the revi-\nsion to Theo.\nListing6.7 A minimal version of catalogData\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nTheo Wait a minute! This catalogData is not valid.\nJoe In DOP, data validity depends on the context. In the context of Library\n.searchBooksByTitleJSON and Catalog.searchBooksByTitle, the mini-\nmal version of catalogData is indeed not valid. However, in the context of\nCatalog.bookInfo and Catalog.authorNames, it is perfectly valid. The reason\nis that those two functions access only the authorsById field of catalogData.\nTIP The validity of the data depends on the context.\nTheo Why is it better to use a minimal version of the data in a test case?\nJoe For a very simple reason—the smaller the data, the easier it is to manipulate.\nTIP The smaller the data, the easier it is to manipulate.\nTheo I’ll appreciate that when I write the unit tests!\nJoe Definitely! One last thing before we start coding: how would you check that the\noutput of Catalog.authorNames is as expected?\nTheo I would check that the value returned by Catalog.authorNames is an array\nwith the expected author names.\nJoe How would you handle the array comparison?\nTheo Let me think. I want to compare by value, not by reference. I guess I’ll have to\ncheck that the array is of the expected size and then check member by mem-\nber, recursively.\nJoe That’s too much of a mental burden when you’re in a coffee shop. As I showed\nyou earlier (see listing 6.1), we can recursively compare two data collections by\nvalue with _.isEqual from Lodash.\n--- Page 146 ---\n118 CHAPTER 6 Unit tests\nTIP We can compare the output and the expected output of our functions with\n_.isEqual.\nTheo Sounds good! Let me write the test cases.\nTheo starts typing on his laptop. After a few minutes, he has some test cases for Catalog\n.authorNames, each made from a function call to Catalog.authorNames wrapped in\n_.isEqual.\nListing6.8 Unit test for Catalog.authorNames\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(\ncatalogData,\n[\"alan-moore\"]),\n[\"Alan Moore\"]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\", \"dave-gibbons\"]),\n[\"Alan Moore\", \"Dave Gibbons\"]);\nJoe Well done! Can you think of more test cases?\nTheo Yes. There are test cases where the author ID doesn’t appear in the catalog\ndata, and test cases with empty catalog data. With minimal catalog data and\n_.isEqual, it’s really easy to write lots of test cases!\nTheo really enjoys this challenge. He creates a few more test cases to present to Joe.\nListing6.9 More test cases for Catalog.authorNames\n_.isEqual(Catalog.authorNames({}, []), []);\n_.isEqual(Catalog.authorNames({}, [\"alan-moore\"]), [undefined]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\",\n\"albert-einstein\"]), [\"Alan Moore\", undefined]);\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(catalogData, [\"albert-einstein\"]),\n[undefined]);\nTheo How do I run these unit tests?\nJoe You use your preferred test framework.\n--- Page 147 ---\n6.2 Unit tests for data manipulation code 119\n NOTE We don’t deal here with test runners and test frameworks. We deal only with\nthe logic of the test cases.\n6.2.3 Unit tests for nodes in the tree\nTheo I’m curious to see what unit tests for an upper node in the tree of function calls\nlook like.\nJoe Sure. Let’s write a unit test for Catalog.bookInfo. How many test cases would\nyou have for Catalog.bookInfo?\nListing6.10 The code of Catalog.bookInfo\nCatalog.bookInfo = function (catalogData, book) {\nreturn {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\n};\nTheo takes another look at the code for Catalog.bookInfo on his laptop. Then, reaching\nfor another napkin, he draws a diagram of its input and output (see figure 6.3).\ncatalogData book\nCatalog.bookInfo()\nFigure 6.3 Visualization of the input\nbookInfo and output of Catalog.bookInfo\nTheo I would have a similar number of test cases for Catalog.authorNames: a book\nwith a single author, with two authors, with existing authors, with non-existent\nauthors, with...\nJoe Whoa! That’s not necessary. Given that we have already written unit tests for\nCatalog.authorNames, we don’t need to check all the cases again. We simply\nneed to write a minimal test case to confirm that the code works.\nTIP When we write a unit test for a function, we assume that the functions called by\nthis function are covered by unit tests and work as expected. It significantly reduces\nthe quantity of test cases in our unit tests.\nTheo That makes sense.\nJoe How would you write a minimal test case for Catalog.bookInfo?\nTheo once again takes a look at the code for Catalog.bookInfo (see listing 6.10). Now he\ncan answer Joe’s question.\n--- Page 148 ---\n120 CHAPTER 6 Unit tests\nTheo I would use the same catalog data as for Catalog.authorNames and a book\nrecord. I’d test that the function behaves as expected by comparing its return\nvalue with a book info record using _.isEqual. Here, let me show you.\nIt takes Theo a bit more time to write the unit test. The reason is that the input and the\noutput of Catalog.authorNames are both records. Dealing with a record is more complex\nthan dealing with an array of strings (as it was the case for Catalog.authorNames). Theo\nappreciates the fact that _.isEqual saves him from writing code that compares the two\nmaps property by property. When he’s through, he shows the result to Joe and takes a nap-\nkin to wipe his forehead.\nListing6.11 Unit test for Catalog.bookInfo\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nvar book = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n};\nvar expectedResult = {\n\"authorNames\": [\"Alan Moore\", \"Dave Gibbons\"],\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n};\nvar result = Catalog.bookInfo(catalogData, book);\n_.isEqual(result, expectedResult);\nJoe Perfect! Now, how would you compare the kind of unit tests for Catalog\n.bookInfo with the unit tests for Catalog.authorNames?\nTheo On one hand, there is only a single test case in the unit test for Catalog.book-\nInfo. On the other hand, the data involved in the test case is more complex\nthan the data involved in the test cases for Catalog.authorNames.\nJoe Exactly! Functions that appear in a deep node in the tree of function calls tend\nto require more test cases, but the data involved in the test cases is less complex.\nTIP Functions that appear in a lower level in the tree of function calls tend to\ninvolve less complex data than functions that appear in a higher level in the tree\n(see table 6.2).\n--- Page 149 ---\n6.3 Unit tests for queries 121\nTable 6.2 The correlation between the depth of a function in the tree of function calls and the\nquality and quantity of the test cases\nDepth in the tree Complexity of the data Number of test cases\nLower Higher Lower\nHigher Lower Higher\n6.3 Unit tests for queries\nIn the previous section, we saw how to write unit tests for utility functions like Catalog\n.bookInfo and Catalog.authorNames. Now, we are going to see how to write unit tests\nfor the nodes of a query tree of function calls that are close to the root of the tree.\nJoe Theo, how would you write a unit test for the code of the entry point of the\nsearch query?\nTo recall the particulars, Theo checks the code for Library.searchBooksByTitleJSON.\nAlthough Joe was right about today’s topic being easy enough to enjoy the ambience of a\ncoffee shop, he has been doing quite a lot of coding this morning.\nListing6.12 The code of Library.searchBooksByTitleJSON\nLibrary.searchBooksByTitleJSON = function (libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n};\nHe then takes a moment to think about how he’d write a unit test for that code. After\nanother Aha! moment, now he’s got it.\nTheo The inputs of Library.searchBooksByTitleJSON are library data and a\nquery string, and the output is a JSON string (see figure 6.4). So, I would cre-\nate a library data record with a single book and write tests with query strings\nthat match the name of the book and ones that don’t match.\nlibraryData query\nLibrary.searchBooksByTitleJSON()\nFigure 6.4 The input and output of\nresultsJSON Library.searchBooksByTitleJSON\nJoe What about the expected results of the test cases?\n--- Page 150 ---\n122 CHAPTER 6 Unit tests\nTheo In cases where the query string matches, the expected result is a JSON string\nwith the book info. In cases where the query string doesn’t match, the\nexpected result is a JSON string with an empty array.\nJoe Hmm...\nTheo What?\nJoe I don’t like your answer.\nTheo Why?\nJoe Because your test case relies on a string comparison instead of a data comparison.\nTheo What difference does it make? After all, the strings I’m comparing come from\nthe serialization of data.\nJoe It’s inherently much more complex to compare JSON strings than it is to com-\npare data. For example, two different strings might be the serialization of the\nsame piece of data.\nTheo Really? How?\nJoe Take a look at these two strings. They are the serialization of the same data.\nThey’re different strings because the fields appear in a different order, but in\nfact, they serialize the same data!\nJoe turns his laptop to Theo. As Theo looks at the code, he realizes that, once again, Joe\niscorrect.\nListing6.13 Two different strings that serialize the same data\nvar stringA = \"{\\\"title\\\":\\\"Watchmen\\\",\\\"publicationYear\\\":1987}\";\nvar stringB = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nTIP Avoid using a string comparison in unit tests for functions that deal with data.\nTheo I see.... Well, what can I do instead?\nJoe Instead of comparing the output of Library.searchBooksByTitleJSON with\na string, you could deserialize the output and compare it to the expected data.\nTheo What do you mean by deserialize a string?\nJoe Deserializing a string s, for example, means to generate a piece of data whose\nserialization is s.\nTheo Is there a Lodash function for string deserialization?\nJoe Actually, there is a native JavaScript function for string deserialization; it’s\ncalled JSON.parse.\nJoe retrieves his laptop and shows Theo an example of string deserialization. The code\nillustrates a common usage of JSON.parse.\nListing6.14 Example of string deserialization\nvar myString = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nvar myData = JSON.parse(myString);\n--- Page 151 ---\n6.3 Unit tests for queries 123\n_.get(myData, \"title\");\n// → \"Watchmen\"\nTheo Cool! Let me try writing a unit test for Library.searchBooksByTitleJSON\nusing JSON.parse.\nIt doesn’t take Theo too much time to come up with a piece of code. Using his laptop, he\ninputs the unit test.\nListing6.15 Unit test for Library.searchBooksByTitleJSON\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Watchmen\")),\n[bookInfo]);\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Batman\")),\n[]);\nJoe Well done! I think you’re ready to move on to the last piece of the puzzle and\nwrite the unit test for Catalog.searchBooksByTitle.",
        "sections_found": []
      },
      "accurate_page_range": "126-151"
    },
    {
      "text": "- 5.1 Optimistic concurrency control",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "raw_line": "- 5.1 Optimistic concurrency control (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 39,
      "chapter_info": {
        "page": 126,
        "title": "Basic concurrency control",
        "pattern_matched": "Chapter 5",
        "text_preview": "98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. "
      },
      "chapter_sections": {
        "start_page": 126,
        "end_page": 151,
        "content": "\n--- Page 126 ---\n98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. It means that the first call to f will be f(0, 1). Then,\nwe’ll have f(f(0, 1), 2) and, finally, f(f(f(0, 1), 2), 3).\nJoe I like your manual expansion, Theo! Let’s make it visual.\nNow Theo goes to the whiteboard and draws a diagram. Figure 5.5 shows what that looks like.\nf\nf a\n2\nf a\n1\na 0 initVal Figure 5.5 Visualization\nof _.reduce\nTheo It’s much clearer now. I think that by implementing my custom version of\n_.reduce, it will make things 100% clear.\nIt takes Theo much less time than he expected to implement reduce(). In no time at all,\nhe shows Joe the code.\nListing5.2 Custom implementation of _.reduce\nfunction reduce(coll, f, initVal) {\nvar currentRes = initVal;\nfor (var i = 0; i < coll.length; i++) {\nWe could use\ncurrentRes = f(currentRes, coll[i])\nforEach instead\n}\nof a for loop.\nreturn currentRes;\n}\nAfter checking that Theo’s code works as expected (see listing 5.3), Joe is proud of Theo.\nHe seems to be catching on better than he anticipated.\nListing5.3 Testing the custom implementation of reduce()\nreduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nJoe Well done!\n--- Page 127 ---\n5.4 Structural difference 99\n5.4 Structural difference\n NOTE This section deals with the implementation of a structural diff algorithm. Feel\nfree to skip this section if you don’t want to challenge your mind right now with the\ndetails of a sophisticated use of recursion. It won’t prevent you from enjoying the rest\nof the book. You can come back to this section later.\nTheo How do you calculate the diff between various versions of the system state?\nJoe That’s the most challenging part of the reconciliation algorithm. We need to\nimplement a structural diff algorithm for hash maps.\nTheo In what sense is the diff structural?\nJoe The structural diff algorithm looks at the structure of the hash maps and\nignores the order of the fields.\nTheo Could you give me an example?\nJoe Let’s start with maps without nested fields. Basically, there are three kinds of\ndiffs: field replacement, field addition, and field deletion. In order to make\nthings not too complicated, for now, we’ll deal only with replacement and\naddition.\nJoe once again goes to the whiteboard and draws table 5.3, representing the three kinds of\ndiffs. Theo is thinking the whiteboard is really starting to fill up today.\nTable 5.3 Kinds of structural differences between maps without nested fields\nKind First map Second map Diff\nReplacement {\"a\": 1} {\"a\": 2} {\"a\": 2}\nAddition {\"a\": 1} {\"a\": 1, \"b\": 2} {\"b\": 2}\nDeletion {\"a\": 1, \"b\": 2} {\"a\": 1} Not supported\nTheo I notice that the order of the maps matters a lot. What about nested fields?\nJoe It’s the same idea, but the nesting makes it a bit more difficult to grasp.\nJoe changes several of the columns in table 5.3. When he’s through, he shows Theo the\nnested fields in table 5.4.\nTable 5.4 Kinds of structural differences between maps with nested fields\nKind First map Second map Diff\nReplacement { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 2 \"x\": 2\n} } }\n} } }\n--- Page 128 ---\n100 CHAPTER 5 Basic concurrency control\nTable 5.4 Kinds of structural differences between maps with nested fields (continued)\nKind First map Second map Diff\nAddition { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 1, \"y\": 2\n} \"y\": 2, }\n} } }\n}\nDeletion { { Not supported\n\"a\": { \"a\": {\n\"x\": 1, \"y\": 2\n\"y\": 2, }\n} }\n}\n NOTE The version of the structural diff algorithm illustrated in this chapter does\nnot deal with deletions. Dealing with deletions is definitely possible, but it requires a\nmore complicated algorithm.\nTheo As you said, it’s harder to grasp. What about arrays?\nJoe We compare the elements of the arrays in order: if they are equal, the diff is\nnull; if they differ, the diff has the value of the second array.\nJoe summarizes the various kinds of diffs in another table on the whiteboard. Theo looks\nat the result in table 5.5.\nTable 5.5 Kinds of structural differences between arrays without nested elements\nKind First array Second array Diff\nReplacement [1] [2] [2]\nAddition [1] [1, 2] [null, 2]\nDeletion [1, 2] [1] Not supported\nTheo This usage of null is a bit weird but OK. Is it complicated to implement the\nstructural diff algorithm?\nJoe Definitely! It took a good dose of mental gymnastics to come up with these 30\nlines of code.\nJoe downloads the code from one his personal repositories. Theo, with thumb and forefin-\ngers touching his chin and his forehead slightly tilted, studies the code.\nListing5.4 The implementation of a structural diff\nfunction diffObjects(data1, data2) {\n_.isArray checks whether\nvar emptyObject = _.isArray(data1) ? [] : {};\nits argument is an array.\nif(data1 == data2) {\n--- Page 129 ---\n5.4 Structural difference 101\nreturn emptyObject;\n_.union creates an\n} array of unique\nvar keys = _.union(_.keys(data1), _.keys(data2)); values from two\nreturn _.reduce(keys, arrays (like union of\nfunction (acc, k) { two sets in Maths).\nvar res = diff(\n_.get(data1, k),\n_.isObject checks\n_.get(data2, k));\nwhether its argument\nif((_.isObject(res) && _.isEmpty(res)) ||\nis a collection (either\na map or an array).\n(res == \"no-diff\")) {\nreturn acc;\n_.isEmpty }\nchecks return _.set(acc, [k], res);\nwhether its },\nargument\nemptyObject);\nis an empty\n} \"no-diff\" is how\ncollection.\nwe mark that\nfunction diff(data1, data2) { two values are\nif(_.isObject(data1) && _.isObject(data2)) { the same.\nreturn diffObjects(data1, data2);\n}\nif(data1 !== data2) {\nreturn data2;\n}\nreturn \"no-diff\";\n}\nTheo Wow! It involves a recursion inside a reduce! I’m sure Dave will love this, but\nI’m too tired to understand this code right now. Let’s focus on what it does\ninstead of how it does it.\nIn order familiarize himself with the structural diff algorithm, Theo runs the algorithm\nwith examples from the table that Joe drew on the whiteboard. While Theo occupies his\nfingers with more and more complicated examples, his mind wanders in the realm of\nperformance.\nListing5.5 An example of usage of a structural diff\nvar data1 = {\n\"a\": {\n\"x\": 1,\n\"y\": [2, 3],\n\"z\": 4\n}\n};\nvar data2 = {\n\"a\": {\n\"x\": 2,\n\"y\": [2, 4],\n\"z\": 4\n}\n}\n--- Page 130 ---\n102 CHAPTER 5 Basic concurrency control\ndiff(data1, data2);\n//{\n// \"a\": {\n// \"x\": 2,\n// \"y\": [\n// undefined,\n// 4\n// ]\n// }\n//}\nTheo What about the performance of the structural diff algorithm? It seems that the\nalgorithm goes over the leaves of both pieces of data?\nJoe In the general case, that’s true. But, in the case of system data that’s manipu-\nlated with structural sharing, the code is much more efficient.\nTheo What do you mean?\nJoe With structural sharing, most of the nested objects are shared between two ver-\nsions of the system state. Therefore, most of the time, when the code enters\ndiffObjects, it will immediately return because data1 and data2 are the same.\nTIP Calculating the diff between two versions of the state is efficient because two\nhash maps created via structural sharing from the same hash map have most of their\nnodes in common.\nTheo Another benefit of immutable data... Let me see how the diff algorithm\nbehaves with concurrent mutations. I think I’ll start with a tiny library with no\nusers and a catalog with a single book, Watchmen.\nListing5.6 The data for a tiny library\nvar library = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\n--- Page 131 ---\n5.4 Structural difference 103\nJoe I suggest that we start with nonconflicting mutations. What do you suggest?\nTheo A mutation that updates the publication year of Watchmen and a mutation that\nupdates both the title of Watchmen and the name of the author of Watchmen.\nOn his laptop, Theo creates three versions of the library. He shows Joe his code, where one\nmutation updates the publication year of Watchmen, and the other one updates the title of\nWatchmen and the author’s name.\nListing5.7 Two nonconflicting mutations\nvar previous = library;\nvar next = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"],\n1986);\nvar libraryWithUpdatedTitle = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"],\n\"The Watchmen\");\nvar current = _.set(\nlibraryWithUpdatedTitle,\n[\"catalog\", \"authorsById\", \"dave-gibbons\", \"name\"],\n\"David Chester Gibbons\");\nTheo I’m curious to see what the diff between previous and current looks like.\nJoe Run the code and you’ll see.\nTheo runs the code snippets for the structural diff between previous and next and for\nthe structural diff between previous and current. His curiosity satisfied, Theo finds it’s\nall beginning to make sense.\nListing5.8 Structural diff between maps with a single difference\ndiff(previous, next);\n//{\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"publicationYear\": 1986\n// }\n// }\n// }\n//}\nListing5.9 Structural diff between maps with two differences\ndiff(previous, current);\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\",\n--- Page 132 ---\n104 CHAPTER 5 Basic concurrency control\n// }\n// },\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\n//\nJoe Can you give me the information path of the single field in the structural diff\nbetween previous and next?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Right. And what are the information paths of the fields in the structural diff\nbetween previous and current?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"] for the book\ntitle and [\"authorsById\", \"dave-gibbons\", \"name\"] for the author’s name.\nJoe Perfect! Now, can you figure out how to detect conflicting mutations by\ninspecting the information paths of the structural diffs?\nTheo We need to check if they have an information path in common or not.\nJoe Exactly! If they have, it means the mutations are conflicting.\nTheo But I have no idea how to write code that retrieves the information paths of a\nnested map.\nJoe Once again, it’s a nontrivial piece of code that involves a recursion inside a\nreduce. Let me download another piece of code from my repository and show\nit to you.\nListing5.10 Calculating the information paths of a (nested) map\nfunction informationPaths (obj, path = []) {\nreturn _.reduce(obj,\nfunction(acc, v, k) {\nif (_.isObject(v)) {\nreturn _.concat(acc,\ninformationPaths(v,\n_.concat(path, k)));\n}\nreturn _.concat(acc, [_.concat(path, k)]);\n},\n[]);\n}\nTheo Let me see if your code works as expected with the structural diffs of the\nmutations.\nTheo tests Joe’s code with two code snippets. The first shows the information paths of the\nstructural diff between previous and next, and the second shows the information paths\nof the structural diff between previous and current.\n--- Page 133 ---\n5.4 Structural difference 105\nListing5.11 Fields that differ between previous and next\ninformationPaths(diff(previous, next));\n// → [\"catalog.booksByIsbn.978-1779501127.publicationYear\"]\nListing5.12 Fields that differ between previous and current\ninformationPaths(diff(previous, current));\n// [\n// [\n// \"catalog\",\n// \"booksByIsbn\",\n// \"978-1779501127\",\n// \"title\"\n// ],\n// [\n// \"authorsById\",\n// \"dave-gibbons\",\n// \"name\"\n// ]\n//]\nTheo Nice! I assume that Lodash has a function that checks whether two arrays have\nan element in common.\nJoe Almost. There is _.intersection, which returns an array of the unique values\nthat are in two given arrays. For our purpose, though, we need to check\nwhether the intersection is empty. Here, look at this example.\nListing5.13 Checking whether two diff maps have a common information path\nfunction havePathInCommon(diff1, diff2) {\nreturn !_.isEmpty(_.intersection(informationPaths(diff1),\ninformationPaths(diff2)));\n}\nTheo You told me earlier that in the case of nonconflicting mutations, we can\nsafely patch the changes induced by the transition from previous to next\ninto current. How do you implement that?\nJoe We do a recursive merge between current and the diff between previous and\nnext.\nTheo Does Lodash provide an immutable version of recursive merge?\nJoe Yes, here’s another example. Take a look at this code.\nListing5.14 Applying a patch\n_.merge(current, (diff(previous, next)));\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\"\n// }\n// },\n--- Page 134 ---\n106 CHAPTER 5 Basic concurrency control\n// \"catalog\": {\n// \"authorsById\": {\n// \"alan-moore\": {\n// \"bookIsbns\": [\"978-1779501127\"]\n// \"name\": \"Alan Moore\"\n// },\n// \"dave-gibbons\": {\n// \"bookIsbns\": [\"978-1779501127\"],\n// \"name\": \"Dave Gibbons\"\n// },\n// },\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n// \"isbn\": \"978-1779501127\",\n// \"publicationYear\": 1986,\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\nTheo Could it be as simple as this?\nJoe Indeed.\n5.5 Implementing the reconciliation algorithm\nJoe All the pieces are now in place to implement our reconciliation algorithm.\nTheo What kind of changes are required?\nJoe It only requires changes in the code of SystemState.commit. Here, look at\nthis example on my laptop.\nListing5.15 The SystemState class\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nvar nextSystemData = SystemConsistency.reconcile(\nthis.systemData,\nSystemConsistency class is\nprevious,\nimplemented in listing 5.16.\nnext);\nif(!SystemValidity.validate(previous, nextSystemData)) {\nthrow \"The system data to be committed is not valid!\";\n};\n--- Page 135 ---\n5.5 Implementing the reconciliation algorithm 107\nthis.systemData = nextSystemData;\n}\n}\nTheo How does SystemConsistency do the reconciliation?\nJoe The SystemConsistency class starts the reconciliation process by comparing\nprevious and current. If they are the same, then we fast-forward and return\nnext. Look at this code for SystemConsistency.\nListing5.16 The reconciliation flow in action\nclass SystemConsistency {\nstatic threeWayMerge(current, previous, next) {\nvar previousToCurrent = diff(previous, current);\nvar previousToNext = diff(previous, next);\nif(havePathInCommon(previousToCurrent, previousToNext)) { When the system\nreturn _.merge(current, previousToNext); state is the same\n} as the state used\nthrow \"Conflicting concurrent mutations.\"; by the calculation\n} phase, we fast-\nstatic reconcile(current, previous, next) { forward.\nif(current == previous) {\nreturn next;\n}\nreturn SystemConsistency.threeWayMerge(current,\nprevious,\nnext);\n}\n}\nTheo Wait a minute! Why do you compare previous and current by reference?\nYou should be comparing them by value, right? And, it would be quite expen-\nsive to compare all the leaves of the two nested hash maps!\nJoe That’s another benefit of immutable data. When the data is not mutated, it is\nsafe to compare references. If they are the same, we know for sure that the data\nis the same.\nTIP When data is immutable, it is safe to compare by reference, which is super fast.\nWhen the references are the same, it means that the data is the same.\nTheo What about the implementation of the three-way merge algorithm?\nJoe When previous differs from current, it means that concurrent mutations\nhave run. In order to determine whether there is a conflict, we calculate two\ndiffs: the diff between previous and current and the diff between previous\nand next. If the intersection between the two diffs is empty, it means there is\nno conflict. We can safely patch the changes between previous to next into\ncurrent.\nTheo takes a closer look at the code for the SystemConsistency class in listing 5.16. He\ntries to figure out if the code is thread-safe or not.\n--- Page 136 ---\n108 CHAPTER 5 Basic concurrency control\nTheo I think the code for SystemConsistency class is not thread-safe! If there’s a\ncontext switch between checking whether the system has changed in the\nSystemConsistency class and the updating of the state in SystemData class, a\nmutation might override the changes of a previous mutation.\nJoe You are totally right! The code works fine in a single-threaded environment\nlike JavaScript, where concurrency is handled via an event loop. However, in a\nmulti-threaded environment, the code needs to be refined in order to be\nthread-safe. I’ll show you some day.\n NOTE The SystemConsistency class is not thread-safe. We will make it thread-safe\nin chapter 8.\nTheo I think I understand why you called it optimistic concurrency control. It’s\nbecause we assume that conflicts don’t occur too often. Right?\nJoe Correct! It makes me wonder what your therapist would say about conflicts that\ncannot be resolved. Are there some cases where it’s not possible to reconcile\nthe couple?\nTheo I don’t think she ever mentioned such a possibility.\nJoe She must be a very optimistic person.\nSummary\n Optimistic concurrency control allows mutations to ask forgiveness instead of\npermission.\n Optimistic concurrency control is lock-free.\n Managing concurrent mutations of our system state with optimistic concurrency\ncontrol allows our system to support a high throughput of reads and writes.\n Optimistic concurrency control with immutable data is super efficient.\n Before updating the state, we need to reconcile the conflicts between possible con-\ncurrent mutations.\n We reconcile between concurrent mutations in a way that is similar to how Git han-\ndles a merge between two branches: either a fast-forward or a three-way merge.\n The changes required to let our system manage concurrency are only in the\ncommit phase.\n The calculation phase does its calculation as if it were the only mutation running.\n The commit phase is responsible for trying to reconcile concurrent mutations.\n The reconciliation algorithm is universal in the sense that it can be used in any sys-\ntem where the system data is represented as an immutable hash map.\n The implementation of the reconciliation algorithm is efficient, as it leverages\nthe fact that subsequent versions of the system state are created via structural\nsharing.\n In a user-facing system, conflicting concurrent mutations are fairly rare.\n When we cannot safely reconcile between concurrent mutations, we abort the\nmutation and ask the user to try again.\n--- Page 137 ---\nSummary 109\n Calculating the structural diff between two versions of the state is efficient because\ntwo hash maps created via structural sharing from the same hash map have most\nof their nodes in common.\n When data is immutable, it is safe to compare by reference, which is fast. When\nthe references are the same, it means that the data is the same.\n There are three kinds of structural differences between two nested hash maps:\nreplacement, addition, and deletion.\n Our structural diff algorithm supports replacements and additions but not\ndeletions.\nLodash functions introduced in this chapter\nFunction Description\nconcat(arrA, arrB) Creates an new array, concatenating arrA and arrB\nintersection(arrA, arrB) Creates an array of unique values both in arrA and arrB\nunion(arrA, arrB) Creates an array of unique values from arrA and arrB\nfind(coll, pred) Iterates over elements of coll, returning the first element for\nwhich pred returns true\nisEmpty(coll) Checks if coll is empty\nreduce(coll, f, initVal) Reduces coll to a value that is the accumulated result of running\neach element in coll through f, where each successive invoca-\ntion is supplied the return value of the previous\nisArray(coll) Checks if coll is an array\nisObject(coll) Checks if coll is a collection\n--- Page 138 ---\nUnit tests\nProgramming at a coffee shop\nThis chapter covers\n Generation of the minimal data input for a\ntest case\n Comparison of the output of a function with\nthe expected output\n Guidance about the quality and the quantity\nof the test cases\nIn a data-oriented system, our code deals mainly with data manipulation: most of\nour functions receive data and return data. As a consequence, it’s quite easy to\nwrite unit tests to check whether our code behaves as expected. A unit test is made\nof test cases that generate data input and compare the data output of the function\nwith the expected data output. In this chapter, we write unit tests for the queries\nand mutations that we wrote in the previous chapters.\n6.1 The simplicity of data-oriented test cases\nTheo and Joe are seated around a large wooden table in a corner of “La vie est belle,” a\nnice little French coffee shop, located near the Golden Gate Bridge. Theo orders a café\nau lait with a croissant, and Joe orders a tight espresso with a pain au chocolat. Instead\nof the usual general discussions about programming and life when they’re out of the\n110\n--- Page 139 ---\n6.1 The simplicity of data-oriented test cases 111\noffice, Joe leads the discussion towards a very concrete topic—unit tests. Theo asks Joe for\nan explanation.\nTheo Are unit tests such a simple topic that we can tackle it here in a coffee shop?\nJoe Unit tests in general, no. But unit tests for data-oriented code, yes!\nTheo Why does that make a difference?\nJoe The vast majority of the code base of a data-oriented system deals with data\nmanipulation.\nTheo Yeah. I noticed that almost all the functions we wrote so far receive data and\nreturn data.\nTIP Most of the code in a data-oriented system deals with data manipulation.\nJoe Writing a test case for functions that deal with data is only about generating\ndata input and expected output, and comparing the output of the function\nwith the expected output.\nThe steps of a test case\n1 Generate data input: dataIn\n2 Generate expected output: dataOut\n3 Compare the output of the function with the expected output: f(dataIn) and\ndataOut\nTheo That’s it?\nJoe Yes. As you’ll see in a moment, in DOP, there’s usually no need for mock\nfunctions.\nTheo I understand how to compare primitive values like strings or numbers, but I’m\nnot sure how I would compare data collections like maps.\nJoe You compare field by field.\nTheo Recursively?\nJoe Yes!\nTheo Oh no! I’m not able to write any recursive code in a coffee shop. I need the\ncalm of my office for that kind of stuff.\nJoe Don’t worry. In DOP, data is represented in a generic way. There is a generic\nfunction in Lodash called _.isEqual for recursive comparison of data collec-\ntions. It works with both maps and arrays.\nJoe opens his laptop. He is able to convince Theo by executing a few code snippets with\n_.isEqual to compare an equal data collection with a non-equal one.\nListing6.1 Comparing an equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n--- Page 140 ---\n112 CHAPTER 6 Unit tests\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n});\n// → true\nListing6.2 Comparing a non-equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"bad-isbn\"]\n});\n// → false\nTheo Nice!\nJoe Most of the test cases in DOP follow this pattern.\nTheo decides he wants to try this out. He fires up his laptop and types a few lines of\npseudocode.\nListing6.3 The general pattern of a data-oriented test case\nvar dataIn = {\n// input\n};\nvar dataOut = {\n// expected output\n};\n_.isEqual(f(dataIn), dataOut);\nTIP It’s straightforward to write unit tests for code that deals with data manipulation.\nTheo Indeed, this looks like something we can tackle in a coffee shop!\n6.2 Unit tests for data manipulation code\nA waiter in an elegant bow tie brings Theo his croissant and Joe his pain au chocolat. The\ntwo friends momentarily interrupt their discussion to savor their French pastries. When\nthey’re done, they ask the waiter to bring them their drinks. Meanwhile, they resume the\ndiscussion.\nJoe Do you remember the code flow of the implementation of the search query?\nTheo Let me look again at the code that implements the search query.\nTheo brings up the implementation of the search query on his laptop. Noticing that Joe is\nchewing on his nails again, he quickly checks out the code.\n--- Page 141 ---\n6.2 Unit tests for data manipulation code 113\nListing6.4 The code involved in the implementation of the search query\nclass Catalog {\nstatic authorNames(catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n}\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\nreturn bookInfo;\n}\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\n}\n6.2.1 The tree of function calls\nThe waiter brings Theo his café au lait and Joe his tight espresso. They continue their dis-\ncussion while enjoying their coffees.\nJoe Before writing a unit test for a code flow, I find it useful to visualize the tree of\nfunction calls of the code flow.\nTheo What do you mean by a tree of function calls?\nJoe Here, I’ll draw the tree of function calls for the Library.searchBooksBy-\nTitleJSON code flow.\nJoe puts down his espresso and takes a napkin from the dispenser. He carefully places it\nflat on the table and starts to draw. When he is done, he shows the illustration to Theo (see\nfigure 6.1).\n--- Page 142 ---\n114 CHAPTER 6 Unit tests\nLibrary.searchBooksByTitleJSON\n_.get JSON.stringify Catalog.searchBooksByTitle\n_.get _.map _.filter Catalog.bookInfo\n_.get Catalog.authorNames\n_.get _.map\nFigure 6.1 The tree of function calls for the search query code flow\nTheo Nice! Can you teach me how to draw a tree of function calls like that?\nJoe Sure. The root of the tree is the name of the function for which you draw the\ntree, in our case, Library.searchBooksByTitleJSON. The children of a\nnode in the tree are the names of the functions called by the function. For exam-\nple, if you look again at the code for Library.searchBooksByTitleJSON (list-\ning 6.4), you’ll see that it calls Catalog.searchBooksByTitle, _.get, and\nJSON.stringify.\nTheo How long would I continue to recursively expand the tree?\nJoe You continue until you reach a function that doesn’t belong to the code base\nof your application. Those nodes are the leaves of our tree; for example, the\nfunctions from Lodash: _.get, _.map, and so forth.\nTheo What if the code of a function doesn’t call any other functions?\nJoe A function that doesn’t call any other function would be a leaf in the tree.\nTheo What about functions that are called inside anonymous functions like Catalog\n.bookInfo?\nJoe Catalog.bookInfo appears in the code of Catalog.searchBooksByTitle.\nTherefore, it is considered to be a child node of Catalog.searchBooksBy-\nTitle. The fact that it is nested inside an anonymous function is not relevant\nin the context of the tree of function calls.\n NOTE A tree of function calls for a function f is a tree where the root is f, and the\nchildren of a node g in the tree are the functions called by g. The leaves of the tree are\nfunctions that are not part of the code base of the application. These are functions\nthat don’t call any other functions.\nTheo It’s very cool to visualize my code as a tree, but I don’t see how it relates to\nunittests.\n--- Page 143 ---\n6.2 Unit tests for data manipulation code 115\nJoe The tree of function calls guides us about the quality and the quantity of test\ncases we should write.\nTheo How?\nJoe You’ll see in a moment.\n6.2.2 Unit tests for functions down the tree\nJoe Let’s start from the function that appears in the deepest node in our tree:\nCatalog.authorNames. Take a look at the code for Catalog.authorNames\nand tell me what are the input and the output of Catalog.authorNames.\nJoe turns his laptop so Theo can a closer look at the code. Theo takes a sip of his café au\nlait as he looks over what’s on Joe’s laptop.\nListing6.5 The code of Catalog.authorNames\nCatalog.authorNames = function (catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n};\nTheo The input of Catalog.authorNames is catalogData and authorIds. The\noutput is authorNames.\nJoe Would you do me a favor and express it visually?\nTheo Sure.\nIt’s Theo’s turn to grab a napkin. He draws a small rectangle with two inward arrows and\none outward arrow as in figure 6.2.\ncatalogData authorIds\nCatalog.authorNames()\nFigure 6.2 Visualization of the input\nauthorNames and output of Catalog.authorNames\nJoe Excellent! Now, how many combinations of input would you include in the\nunit test for Catalog.authorNames?\nTheo Let me see.\nTheo reaches for another napkin. This time he creates a table to gather his thoughts\n(table 6.1).\n--- Page 144 ---\n116 CHAPTER 6 Unit tests\nTable 6.1 The table of test cases for Catalog.authorNames\ncatalogData authorIds authorNames\nCatalog with two authors Empty array Empty array\nCatalog with two authors Array with one author ID Array with one author name\nCatalog with two authors Array with two author IDs Array with two author names\nTheo To begin with, I would have a catalogData with two author IDs and call\nCatalog.authorNames with three arguments: an empty array, an array with a\nsingle author ID, and an array with two author IDs.\nJoe How would you generate the catalogData?\nTheo Exactly as we generated it before.\nTurning to his laptop, Theo writes the code for catalogData. He shows it to Joe.\nListing6.6 A complete catalogData map\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\n--- Page 145 ---\n6.2 Unit tests for data manipulation code 117\nJoe You could use your big catalogData map for the unit test, but you could also\nuse a smaller map in the context of Catalog.authorNames. You can get rid of\nthe booksByIsbn field of the catalogData and the bookIsbns fields of the\nauthors.\nJoe deletes a few lines from catalogData and gets a much smaller map. He shows the revi-\nsion to Theo.\nListing6.7 A minimal version of catalogData\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nTheo Wait a minute! This catalogData is not valid.\nJoe In DOP, data validity depends on the context. In the context of Library\n.searchBooksByTitleJSON and Catalog.searchBooksByTitle, the mini-\nmal version of catalogData is indeed not valid. However, in the context of\nCatalog.bookInfo and Catalog.authorNames, it is perfectly valid. The reason\nis that those two functions access only the authorsById field of catalogData.\nTIP The validity of the data depends on the context.\nTheo Why is it better to use a minimal version of the data in a test case?\nJoe For a very simple reason—the smaller the data, the easier it is to manipulate.\nTIP The smaller the data, the easier it is to manipulate.\nTheo I’ll appreciate that when I write the unit tests!\nJoe Definitely! One last thing before we start coding: how would you check that the\noutput of Catalog.authorNames is as expected?\nTheo I would check that the value returned by Catalog.authorNames is an array\nwith the expected author names.\nJoe How would you handle the array comparison?\nTheo Let me think. I want to compare by value, not by reference. I guess I’ll have to\ncheck that the array is of the expected size and then check member by mem-\nber, recursively.\nJoe That’s too much of a mental burden when you’re in a coffee shop. As I showed\nyou earlier (see listing 6.1), we can recursively compare two data collections by\nvalue with _.isEqual from Lodash.\n--- Page 146 ---\n118 CHAPTER 6 Unit tests\nTIP We can compare the output and the expected output of our functions with\n_.isEqual.\nTheo Sounds good! Let me write the test cases.\nTheo starts typing on his laptop. After a few minutes, he has some test cases for Catalog\n.authorNames, each made from a function call to Catalog.authorNames wrapped in\n_.isEqual.\nListing6.8 Unit test for Catalog.authorNames\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(\ncatalogData,\n[\"alan-moore\"]),\n[\"Alan Moore\"]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\", \"dave-gibbons\"]),\n[\"Alan Moore\", \"Dave Gibbons\"]);\nJoe Well done! Can you think of more test cases?\nTheo Yes. There are test cases where the author ID doesn’t appear in the catalog\ndata, and test cases with empty catalog data. With minimal catalog data and\n_.isEqual, it’s really easy to write lots of test cases!\nTheo really enjoys this challenge. He creates a few more test cases to present to Joe.\nListing6.9 More test cases for Catalog.authorNames\n_.isEqual(Catalog.authorNames({}, []), []);\n_.isEqual(Catalog.authorNames({}, [\"alan-moore\"]), [undefined]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\",\n\"albert-einstein\"]), [\"Alan Moore\", undefined]);\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(catalogData, [\"albert-einstein\"]),\n[undefined]);\nTheo How do I run these unit tests?\nJoe You use your preferred test framework.\n--- Page 147 ---\n6.2 Unit tests for data manipulation code 119\n NOTE We don’t deal here with test runners and test frameworks. We deal only with\nthe logic of the test cases.\n6.2.3 Unit tests for nodes in the tree\nTheo I’m curious to see what unit tests for an upper node in the tree of function calls\nlook like.\nJoe Sure. Let’s write a unit test for Catalog.bookInfo. How many test cases would\nyou have for Catalog.bookInfo?\nListing6.10 The code of Catalog.bookInfo\nCatalog.bookInfo = function (catalogData, book) {\nreturn {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\n};\nTheo takes another look at the code for Catalog.bookInfo on his laptop. Then, reaching\nfor another napkin, he draws a diagram of its input and output (see figure 6.3).\ncatalogData book\nCatalog.bookInfo()\nFigure 6.3 Visualization of the input\nbookInfo and output of Catalog.bookInfo\nTheo I would have a similar number of test cases for Catalog.authorNames: a book\nwith a single author, with two authors, with existing authors, with non-existent\nauthors, with...\nJoe Whoa! That’s not necessary. Given that we have already written unit tests for\nCatalog.authorNames, we don’t need to check all the cases again. We simply\nneed to write a minimal test case to confirm that the code works.\nTIP When we write a unit test for a function, we assume that the functions called by\nthis function are covered by unit tests and work as expected. It significantly reduces\nthe quantity of test cases in our unit tests.\nTheo That makes sense.\nJoe How would you write a minimal test case for Catalog.bookInfo?\nTheo once again takes a look at the code for Catalog.bookInfo (see listing 6.10). Now he\ncan answer Joe’s question.\n--- Page 148 ---\n120 CHAPTER 6 Unit tests\nTheo I would use the same catalog data as for Catalog.authorNames and a book\nrecord. I’d test that the function behaves as expected by comparing its return\nvalue with a book info record using _.isEqual. Here, let me show you.\nIt takes Theo a bit more time to write the unit test. The reason is that the input and the\noutput of Catalog.authorNames are both records. Dealing with a record is more complex\nthan dealing with an array of strings (as it was the case for Catalog.authorNames). Theo\nappreciates the fact that _.isEqual saves him from writing code that compares the two\nmaps property by property. When he’s through, he shows the result to Joe and takes a nap-\nkin to wipe his forehead.\nListing6.11 Unit test for Catalog.bookInfo\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nvar book = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n};\nvar expectedResult = {\n\"authorNames\": [\"Alan Moore\", \"Dave Gibbons\"],\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n};\nvar result = Catalog.bookInfo(catalogData, book);\n_.isEqual(result, expectedResult);\nJoe Perfect! Now, how would you compare the kind of unit tests for Catalog\n.bookInfo with the unit tests for Catalog.authorNames?\nTheo On one hand, there is only a single test case in the unit test for Catalog.book-\nInfo. On the other hand, the data involved in the test case is more complex\nthan the data involved in the test cases for Catalog.authorNames.\nJoe Exactly! Functions that appear in a deep node in the tree of function calls tend\nto require more test cases, but the data involved in the test cases is less complex.\nTIP Functions that appear in a lower level in the tree of function calls tend to\ninvolve less complex data than functions that appear in a higher level in the tree\n(see table 6.2).\n--- Page 149 ---\n6.3 Unit tests for queries 121\nTable 6.2 The correlation between the depth of a function in the tree of function calls and the\nquality and quantity of the test cases\nDepth in the tree Complexity of the data Number of test cases\nLower Higher Lower\nHigher Lower Higher\n6.3 Unit tests for queries\nIn the previous section, we saw how to write unit tests for utility functions like Catalog\n.bookInfo and Catalog.authorNames. Now, we are going to see how to write unit tests\nfor the nodes of a query tree of function calls that are close to the root of the tree.\nJoe Theo, how would you write a unit test for the code of the entry point of the\nsearch query?\nTo recall the particulars, Theo checks the code for Library.searchBooksByTitleJSON.\nAlthough Joe was right about today’s topic being easy enough to enjoy the ambience of a\ncoffee shop, he has been doing quite a lot of coding this morning.\nListing6.12 The code of Library.searchBooksByTitleJSON\nLibrary.searchBooksByTitleJSON = function (libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n};\nHe then takes a moment to think about how he’d write a unit test for that code. After\nanother Aha! moment, now he’s got it.\nTheo The inputs of Library.searchBooksByTitleJSON are library data and a\nquery string, and the output is a JSON string (see figure 6.4). So, I would cre-\nate a library data record with a single book and write tests with query strings\nthat match the name of the book and ones that don’t match.\nlibraryData query\nLibrary.searchBooksByTitleJSON()\nFigure 6.4 The input and output of\nresultsJSON Library.searchBooksByTitleJSON\nJoe What about the expected results of the test cases?\n--- Page 150 ---\n122 CHAPTER 6 Unit tests\nTheo In cases where the query string matches, the expected result is a JSON string\nwith the book info. In cases where the query string doesn’t match, the\nexpected result is a JSON string with an empty array.\nJoe Hmm...\nTheo What?\nJoe I don’t like your answer.\nTheo Why?\nJoe Because your test case relies on a string comparison instead of a data comparison.\nTheo What difference does it make? After all, the strings I’m comparing come from\nthe serialization of data.\nJoe It’s inherently much more complex to compare JSON strings than it is to com-\npare data. For example, two different strings might be the serialization of the\nsame piece of data.\nTheo Really? How?\nJoe Take a look at these two strings. They are the serialization of the same data.\nThey’re different strings because the fields appear in a different order, but in\nfact, they serialize the same data!\nJoe turns his laptop to Theo. As Theo looks at the code, he realizes that, once again, Joe\niscorrect.\nListing6.13 Two different strings that serialize the same data\nvar stringA = \"{\\\"title\\\":\\\"Watchmen\\\",\\\"publicationYear\\\":1987}\";\nvar stringB = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nTIP Avoid using a string comparison in unit tests for functions that deal with data.\nTheo I see.... Well, what can I do instead?\nJoe Instead of comparing the output of Library.searchBooksByTitleJSON with\na string, you could deserialize the output and compare it to the expected data.\nTheo What do you mean by deserialize a string?\nJoe Deserializing a string s, for example, means to generate a piece of data whose\nserialization is s.\nTheo Is there a Lodash function for string deserialization?\nJoe Actually, there is a native JavaScript function for string deserialization; it’s\ncalled JSON.parse.\nJoe retrieves his laptop and shows Theo an example of string deserialization. The code\nillustrates a common usage of JSON.parse.\nListing6.14 Example of string deserialization\nvar myString = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nvar myData = JSON.parse(myString);\n--- Page 151 ---\n6.3 Unit tests for queries 123\n_.get(myData, \"title\");\n// → \"Watchmen\"\nTheo Cool! Let me try writing a unit test for Library.searchBooksByTitleJSON\nusing JSON.parse.\nIt doesn’t take Theo too much time to come up with a piece of code. Using his laptop, he\ninputs the unit test.\nListing6.15 Unit test for Library.searchBooksByTitleJSON\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Watchmen\")),\n[bookInfo]);\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Batman\")),\n[]);\nJoe Well done! I think you’re ready to move on to the last piece of the puzzle and\nwrite the unit test for Catalog.searchBooksByTitle.",
        "sections_found": []
      },
      "accurate_page_range": "126-151"
    },
    {
      "text": "- 5.2 Reconciliation between concurrent mutations",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "raw_line": "- 5.2 Reconciliation between concurrent mutations (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 40,
      "chapter_info": {
        "page": 126,
        "title": "Basic concurrency control",
        "pattern_matched": "Chapter 5",
        "text_preview": "98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. "
      },
      "chapter_sections": {
        "start_page": 126,
        "end_page": 151,
        "content": "\n--- Page 126 ---\n98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. It means that the first call to f will be f(0, 1). Then,\nwe’ll have f(f(0, 1), 2) and, finally, f(f(f(0, 1), 2), 3).\nJoe I like your manual expansion, Theo! Let’s make it visual.\nNow Theo goes to the whiteboard and draws a diagram. Figure 5.5 shows what that looks like.\nf\nf a\n2\nf a\n1\na 0 initVal Figure 5.5 Visualization\nof _.reduce\nTheo It’s much clearer now. I think that by implementing my custom version of\n_.reduce, it will make things 100% clear.\nIt takes Theo much less time than he expected to implement reduce(). In no time at all,\nhe shows Joe the code.\nListing5.2 Custom implementation of _.reduce\nfunction reduce(coll, f, initVal) {\nvar currentRes = initVal;\nfor (var i = 0; i < coll.length; i++) {\nWe could use\ncurrentRes = f(currentRes, coll[i])\nforEach instead\n}\nof a for loop.\nreturn currentRes;\n}\nAfter checking that Theo’s code works as expected (see listing 5.3), Joe is proud of Theo.\nHe seems to be catching on better than he anticipated.\nListing5.3 Testing the custom implementation of reduce()\nreduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nJoe Well done!\n--- Page 127 ---\n5.4 Structural difference 99\n5.4 Structural difference\n NOTE This section deals with the implementation of a structural diff algorithm. Feel\nfree to skip this section if you don’t want to challenge your mind right now with the\ndetails of a sophisticated use of recursion. It won’t prevent you from enjoying the rest\nof the book. You can come back to this section later.\nTheo How do you calculate the diff between various versions of the system state?\nJoe That’s the most challenging part of the reconciliation algorithm. We need to\nimplement a structural diff algorithm for hash maps.\nTheo In what sense is the diff structural?\nJoe The structural diff algorithm looks at the structure of the hash maps and\nignores the order of the fields.\nTheo Could you give me an example?\nJoe Let’s start with maps without nested fields. Basically, there are three kinds of\ndiffs: field replacement, field addition, and field deletion. In order to make\nthings not too complicated, for now, we’ll deal only with replacement and\naddition.\nJoe once again goes to the whiteboard and draws table 5.3, representing the three kinds of\ndiffs. Theo is thinking the whiteboard is really starting to fill up today.\nTable 5.3 Kinds of structural differences between maps without nested fields\nKind First map Second map Diff\nReplacement {\"a\": 1} {\"a\": 2} {\"a\": 2}\nAddition {\"a\": 1} {\"a\": 1, \"b\": 2} {\"b\": 2}\nDeletion {\"a\": 1, \"b\": 2} {\"a\": 1} Not supported\nTheo I notice that the order of the maps matters a lot. What about nested fields?\nJoe It’s the same idea, but the nesting makes it a bit more difficult to grasp.\nJoe changes several of the columns in table 5.3. When he’s through, he shows Theo the\nnested fields in table 5.4.\nTable 5.4 Kinds of structural differences between maps with nested fields\nKind First map Second map Diff\nReplacement { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 2 \"x\": 2\n} } }\n} } }\n--- Page 128 ---\n100 CHAPTER 5 Basic concurrency control\nTable 5.4 Kinds of structural differences between maps with nested fields (continued)\nKind First map Second map Diff\nAddition { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 1, \"y\": 2\n} \"y\": 2, }\n} } }\n}\nDeletion { { Not supported\n\"a\": { \"a\": {\n\"x\": 1, \"y\": 2\n\"y\": 2, }\n} }\n}\n NOTE The version of the structural diff algorithm illustrated in this chapter does\nnot deal with deletions. Dealing with deletions is definitely possible, but it requires a\nmore complicated algorithm.\nTheo As you said, it’s harder to grasp. What about arrays?\nJoe We compare the elements of the arrays in order: if they are equal, the diff is\nnull; if they differ, the diff has the value of the second array.\nJoe summarizes the various kinds of diffs in another table on the whiteboard. Theo looks\nat the result in table 5.5.\nTable 5.5 Kinds of structural differences between arrays without nested elements\nKind First array Second array Diff\nReplacement [1] [2] [2]\nAddition [1] [1, 2] [null, 2]\nDeletion [1, 2] [1] Not supported\nTheo This usage of null is a bit weird but OK. Is it complicated to implement the\nstructural diff algorithm?\nJoe Definitely! It took a good dose of mental gymnastics to come up with these 30\nlines of code.\nJoe downloads the code from one his personal repositories. Theo, with thumb and forefin-\ngers touching his chin and his forehead slightly tilted, studies the code.\nListing5.4 The implementation of a structural diff\nfunction diffObjects(data1, data2) {\n_.isArray checks whether\nvar emptyObject = _.isArray(data1) ? [] : {};\nits argument is an array.\nif(data1 == data2) {\n--- Page 129 ---\n5.4 Structural difference 101\nreturn emptyObject;\n_.union creates an\n} array of unique\nvar keys = _.union(_.keys(data1), _.keys(data2)); values from two\nreturn _.reduce(keys, arrays (like union of\nfunction (acc, k) { two sets in Maths).\nvar res = diff(\n_.get(data1, k),\n_.isObject checks\n_.get(data2, k));\nwhether its argument\nif((_.isObject(res) && _.isEmpty(res)) ||\nis a collection (either\na map or an array).\n(res == \"no-diff\")) {\nreturn acc;\n_.isEmpty }\nchecks return _.set(acc, [k], res);\nwhether its },\nargument\nemptyObject);\nis an empty\n} \"no-diff\" is how\ncollection.\nwe mark that\nfunction diff(data1, data2) { two values are\nif(_.isObject(data1) && _.isObject(data2)) { the same.\nreturn diffObjects(data1, data2);\n}\nif(data1 !== data2) {\nreturn data2;\n}\nreturn \"no-diff\";\n}\nTheo Wow! It involves a recursion inside a reduce! I’m sure Dave will love this, but\nI’m too tired to understand this code right now. Let’s focus on what it does\ninstead of how it does it.\nIn order familiarize himself with the structural diff algorithm, Theo runs the algorithm\nwith examples from the table that Joe drew on the whiteboard. While Theo occupies his\nfingers with more and more complicated examples, his mind wanders in the realm of\nperformance.\nListing5.5 An example of usage of a structural diff\nvar data1 = {\n\"a\": {\n\"x\": 1,\n\"y\": [2, 3],\n\"z\": 4\n}\n};\nvar data2 = {\n\"a\": {\n\"x\": 2,\n\"y\": [2, 4],\n\"z\": 4\n}\n}\n--- Page 130 ---\n102 CHAPTER 5 Basic concurrency control\ndiff(data1, data2);\n//{\n// \"a\": {\n// \"x\": 2,\n// \"y\": [\n// undefined,\n// 4\n// ]\n// }\n//}\nTheo What about the performance of the structural diff algorithm? It seems that the\nalgorithm goes over the leaves of both pieces of data?\nJoe In the general case, that’s true. But, in the case of system data that’s manipu-\nlated with structural sharing, the code is much more efficient.\nTheo What do you mean?\nJoe With structural sharing, most of the nested objects are shared between two ver-\nsions of the system state. Therefore, most of the time, when the code enters\ndiffObjects, it will immediately return because data1 and data2 are the same.\nTIP Calculating the diff between two versions of the state is efficient because two\nhash maps created via structural sharing from the same hash map have most of their\nnodes in common.\nTheo Another benefit of immutable data... Let me see how the diff algorithm\nbehaves with concurrent mutations. I think I’ll start with a tiny library with no\nusers and a catalog with a single book, Watchmen.\nListing5.6 The data for a tiny library\nvar library = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\n--- Page 131 ---\n5.4 Structural difference 103\nJoe I suggest that we start with nonconflicting mutations. What do you suggest?\nTheo A mutation that updates the publication year of Watchmen and a mutation that\nupdates both the title of Watchmen and the name of the author of Watchmen.\nOn his laptop, Theo creates three versions of the library. He shows Joe his code, where one\nmutation updates the publication year of Watchmen, and the other one updates the title of\nWatchmen and the author’s name.\nListing5.7 Two nonconflicting mutations\nvar previous = library;\nvar next = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"],\n1986);\nvar libraryWithUpdatedTitle = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"],\n\"The Watchmen\");\nvar current = _.set(\nlibraryWithUpdatedTitle,\n[\"catalog\", \"authorsById\", \"dave-gibbons\", \"name\"],\n\"David Chester Gibbons\");\nTheo I’m curious to see what the diff between previous and current looks like.\nJoe Run the code and you’ll see.\nTheo runs the code snippets for the structural diff between previous and next and for\nthe structural diff between previous and current. His curiosity satisfied, Theo finds it’s\nall beginning to make sense.\nListing5.8 Structural diff between maps with a single difference\ndiff(previous, next);\n//{\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"publicationYear\": 1986\n// }\n// }\n// }\n//}\nListing5.9 Structural diff between maps with two differences\ndiff(previous, current);\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\",\n--- Page 132 ---\n104 CHAPTER 5 Basic concurrency control\n// }\n// },\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\n//\nJoe Can you give me the information path of the single field in the structural diff\nbetween previous and next?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Right. And what are the information paths of the fields in the structural diff\nbetween previous and current?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"] for the book\ntitle and [\"authorsById\", \"dave-gibbons\", \"name\"] for the author’s name.\nJoe Perfect! Now, can you figure out how to detect conflicting mutations by\ninspecting the information paths of the structural diffs?\nTheo We need to check if they have an information path in common or not.\nJoe Exactly! If they have, it means the mutations are conflicting.\nTheo But I have no idea how to write code that retrieves the information paths of a\nnested map.\nJoe Once again, it’s a nontrivial piece of code that involves a recursion inside a\nreduce. Let me download another piece of code from my repository and show\nit to you.\nListing5.10 Calculating the information paths of a (nested) map\nfunction informationPaths (obj, path = []) {\nreturn _.reduce(obj,\nfunction(acc, v, k) {\nif (_.isObject(v)) {\nreturn _.concat(acc,\ninformationPaths(v,\n_.concat(path, k)));\n}\nreturn _.concat(acc, [_.concat(path, k)]);\n},\n[]);\n}\nTheo Let me see if your code works as expected with the structural diffs of the\nmutations.\nTheo tests Joe’s code with two code snippets. The first shows the information paths of the\nstructural diff between previous and next, and the second shows the information paths\nof the structural diff between previous and current.\n--- Page 133 ---\n5.4 Structural difference 105\nListing5.11 Fields that differ between previous and next\ninformationPaths(diff(previous, next));\n// → [\"catalog.booksByIsbn.978-1779501127.publicationYear\"]\nListing5.12 Fields that differ between previous and current\ninformationPaths(diff(previous, current));\n// [\n// [\n// \"catalog\",\n// \"booksByIsbn\",\n// \"978-1779501127\",\n// \"title\"\n// ],\n// [\n// \"authorsById\",\n// \"dave-gibbons\",\n// \"name\"\n// ]\n//]\nTheo Nice! I assume that Lodash has a function that checks whether two arrays have\nan element in common.\nJoe Almost. There is _.intersection, which returns an array of the unique values\nthat are in two given arrays. For our purpose, though, we need to check\nwhether the intersection is empty. Here, look at this example.\nListing5.13 Checking whether two diff maps have a common information path\nfunction havePathInCommon(diff1, diff2) {\nreturn !_.isEmpty(_.intersection(informationPaths(diff1),\ninformationPaths(diff2)));\n}\nTheo You told me earlier that in the case of nonconflicting mutations, we can\nsafely patch the changes induced by the transition from previous to next\ninto current. How do you implement that?\nJoe We do a recursive merge between current and the diff between previous and\nnext.\nTheo Does Lodash provide an immutable version of recursive merge?\nJoe Yes, here’s another example. Take a look at this code.\nListing5.14 Applying a patch\n_.merge(current, (diff(previous, next)));\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\"\n// }\n// },\n--- Page 134 ---\n106 CHAPTER 5 Basic concurrency control\n// \"catalog\": {\n// \"authorsById\": {\n// \"alan-moore\": {\n// \"bookIsbns\": [\"978-1779501127\"]\n// \"name\": \"Alan Moore\"\n// },\n// \"dave-gibbons\": {\n// \"bookIsbns\": [\"978-1779501127\"],\n// \"name\": \"Dave Gibbons\"\n// },\n// },\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n// \"isbn\": \"978-1779501127\",\n// \"publicationYear\": 1986,\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\nTheo Could it be as simple as this?\nJoe Indeed.\n5.5 Implementing the reconciliation algorithm\nJoe All the pieces are now in place to implement our reconciliation algorithm.\nTheo What kind of changes are required?\nJoe It only requires changes in the code of SystemState.commit. Here, look at\nthis example on my laptop.\nListing5.15 The SystemState class\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nvar nextSystemData = SystemConsistency.reconcile(\nthis.systemData,\nSystemConsistency class is\nprevious,\nimplemented in listing 5.16.\nnext);\nif(!SystemValidity.validate(previous, nextSystemData)) {\nthrow \"The system data to be committed is not valid!\";\n};\n--- Page 135 ---\n5.5 Implementing the reconciliation algorithm 107\nthis.systemData = nextSystemData;\n}\n}\nTheo How does SystemConsistency do the reconciliation?\nJoe The SystemConsistency class starts the reconciliation process by comparing\nprevious and current. If they are the same, then we fast-forward and return\nnext. Look at this code for SystemConsistency.\nListing5.16 The reconciliation flow in action\nclass SystemConsistency {\nstatic threeWayMerge(current, previous, next) {\nvar previousToCurrent = diff(previous, current);\nvar previousToNext = diff(previous, next);\nif(havePathInCommon(previousToCurrent, previousToNext)) { When the system\nreturn _.merge(current, previousToNext); state is the same\n} as the state used\nthrow \"Conflicting concurrent mutations.\"; by the calculation\n} phase, we fast-\nstatic reconcile(current, previous, next) { forward.\nif(current == previous) {\nreturn next;\n}\nreturn SystemConsistency.threeWayMerge(current,\nprevious,\nnext);\n}\n}\nTheo Wait a minute! Why do you compare previous and current by reference?\nYou should be comparing them by value, right? And, it would be quite expen-\nsive to compare all the leaves of the two nested hash maps!\nJoe That’s another benefit of immutable data. When the data is not mutated, it is\nsafe to compare references. If they are the same, we know for sure that the data\nis the same.\nTIP When data is immutable, it is safe to compare by reference, which is super fast.\nWhen the references are the same, it means that the data is the same.\nTheo What about the implementation of the three-way merge algorithm?\nJoe When previous differs from current, it means that concurrent mutations\nhave run. In order to determine whether there is a conflict, we calculate two\ndiffs: the diff between previous and current and the diff between previous\nand next. If the intersection between the two diffs is empty, it means there is\nno conflict. We can safely patch the changes between previous to next into\ncurrent.\nTheo takes a closer look at the code for the SystemConsistency class in listing 5.16. He\ntries to figure out if the code is thread-safe or not.\n--- Page 136 ---\n108 CHAPTER 5 Basic concurrency control\nTheo I think the code for SystemConsistency class is not thread-safe! If there’s a\ncontext switch between checking whether the system has changed in the\nSystemConsistency class and the updating of the state in SystemData class, a\nmutation might override the changes of a previous mutation.\nJoe You are totally right! The code works fine in a single-threaded environment\nlike JavaScript, where concurrency is handled via an event loop. However, in a\nmulti-threaded environment, the code needs to be refined in order to be\nthread-safe. I’ll show you some day.\n NOTE The SystemConsistency class is not thread-safe. We will make it thread-safe\nin chapter 8.\nTheo I think I understand why you called it optimistic concurrency control. It’s\nbecause we assume that conflicts don’t occur too often. Right?\nJoe Correct! It makes me wonder what your therapist would say about conflicts that\ncannot be resolved. Are there some cases where it’s not possible to reconcile\nthe couple?\nTheo I don’t think she ever mentioned such a possibility.\nJoe She must be a very optimistic person.\nSummary\n Optimistic concurrency control allows mutations to ask forgiveness instead of\npermission.\n Optimistic concurrency control is lock-free.\n Managing concurrent mutations of our system state with optimistic concurrency\ncontrol allows our system to support a high throughput of reads and writes.\n Optimistic concurrency control with immutable data is super efficient.\n Before updating the state, we need to reconcile the conflicts between possible con-\ncurrent mutations.\n We reconcile between concurrent mutations in a way that is similar to how Git han-\ndles a merge between two branches: either a fast-forward or a three-way merge.\n The changes required to let our system manage concurrency are only in the\ncommit phase.\n The calculation phase does its calculation as if it were the only mutation running.\n The commit phase is responsible for trying to reconcile concurrent mutations.\n The reconciliation algorithm is universal in the sense that it can be used in any sys-\ntem where the system data is represented as an immutable hash map.\n The implementation of the reconciliation algorithm is efficient, as it leverages\nthe fact that subsequent versions of the system state are created via structural\nsharing.\n In a user-facing system, conflicting concurrent mutations are fairly rare.\n When we cannot safely reconcile between concurrent mutations, we abort the\nmutation and ask the user to try again.\n--- Page 137 ---\nSummary 109\n Calculating the structural diff between two versions of the state is efficient because\ntwo hash maps created via structural sharing from the same hash map have most\nof their nodes in common.\n When data is immutable, it is safe to compare by reference, which is fast. When\nthe references are the same, it means that the data is the same.\n There are three kinds of structural differences between two nested hash maps:\nreplacement, addition, and deletion.\n Our structural diff algorithm supports replacements and additions but not\ndeletions.\nLodash functions introduced in this chapter\nFunction Description\nconcat(arrA, arrB) Creates an new array, concatenating arrA and arrB\nintersection(arrA, arrB) Creates an array of unique values both in arrA and arrB\nunion(arrA, arrB) Creates an array of unique values from arrA and arrB\nfind(coll, pred) Iterates over elements of coll, returning the first element for\nwhich pred returns true\nisEmpty(coll) Checks if coll is empty\nreduce(coll, f, initVal) Reduces coll to a value that is the accumulated result of running\neach element in coll through f, where each successive invoca-\ntion is supplied the return value of the previous\nisArray(coll) Checks if coll is an array\nisObject(coll) Checks if coll is a collection\n--- Page 138 ---\nUnit tests\nProgramming at a coffee shop\nThis chapter covers\n Generation of the minimal data input for a\ntest case\n Comparison of the output of a function with\nthe expected output\n Guidance about the quality and the quantity\nof the test cases\nIn a data-oriented system, our code deals mainly with data manipulation: most of\nour functions receive data and return data. As a consequence, it’s quite easy to\nwrite unit tests to check whether our code behaves as expected. A unit test is made\nof test cases that generate data input and compare the data output of the function\nwith the expected data output. In this chapter, we write unit tests for the queries\nand mutations that we wrote in the previous chapters.\n6.1 The simplicity of data-oriented test cases\nTheo and Joe are seated around a large wooden table in a corner of “La vie est belle,” a\nnice little French coffee shop, located near the Golden Gate Bridge. Theo orders a café\nau lait with a croissant, and Joe orders a tight espresso with a pain au chocolat. Instead\nof the usual general discussions about programming and life when they’re out of the\n110\n--- Page 139 ---\n6.1 The simplicity of data-oriented test cases 111\noffice, Joe leads the discussion towards a very concrete topic—unit tests. Theo asks Joe for\nan explanation.\nTheo Are unit tests such a simple topic that we can tackle it here in a coffee shop?\nJoe Unit tests in general, no. But unit tests for data-oriented code, yes!\nTheo Why does that make a difference?\nJoe The vast majority of the code base of a data-oriented system deals with data\nmanipulation.\nTheo Yeah. I noticed that almost all the functions we wrote so far receive data and\nreturn data.\nTIP Most of the code in a data-oriented system deals with data manipulation.\nJoe Writing a test case for functions that deal with data is only about generating\ndata input and expected output, and comparing the output of the function\nwith the expected output.\nThe steps of a test case\n1 Generate data input: dataIn\n2 Generate expected output: dataOut\n3 Compare the output of the function with the expected output: f(dataIn) and\ndataOut\nTheo That’s it?\nJoe Yes. As you’ll see in a moment, in DOP, there’s usually no need for mock\nfunctions.\nTheo I understand how to compare primitive values like strings or numbers, but I’m\nnot sure how I would compare data collections like maps.\nJoe You compare field by field.\nTheo Recursively?\nJoe Yes!\nTheo Oh no! I’m not able to write any recursive code in a coffee shop. I need the\ncalm of my office for that kind of stuff.\nJoe Don’t worry. In DOP, data is represented in a generic way. There is a generic\nfunction in Lodash called _.isEqual for recursive comparison of data collec-\ntions. It works with both maps and arrays.\nJoe opens his laptop. He is able to convince Theo by executing a few code snippets with\n_.isEqual to compare an equal data collection with a non-equal one.\nListing6.1 Comparing an equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n--- Page 140 ---\n112 CHAPTER 6 Unit tests\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n});\n// → true\nListing6.2 Comparing a non-equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"bad-isbn\"]\n});\n// → false\nTheo Nice!\nJoe Most of the test cases in DOP follow this pattern.\nTheo decides he wants to try this out. He fires up his laptop and types a few lines of\npseudocode.\nListing6.3 The general pattern of a data-oriented test case\nvar dataIn = {\n// input\n};\nvar dataOut = {\n// expected output\n};\n_.isEqual(f(dataIn), dataOut);\nTIP It’s straightforward to write unit tests for code that deals with data manipulation.\nTheo Indeed, this looks like something we can tackle in a coffee shop!\n6.2 Unit tests for data manipulation code\nA waiter in an elegant bow tie brings Theo his croissant and Joe his pain au chocolat. The\ntwo friends momentarily interrupt their discussion to savor their French pastries. When\nthey’re done, they ask the waiter to bring them their drinks. Meanwhile, they resume the\ndiscussion.\nJoe Do you remember the code flow of the implementation of the search query?\nTheo Let me look again at the code that implements the search query.\nTheo brings up the implementation of the search query on his laptop. Noticing that Joe is\nchewing on his nails again, he quickly checks out the code.\n--- Page 141 ---\n6.2 Unit tests for data manipulation code 113\nListing6.4 The code involved in the implementation of the search query\nclass Catalog {\nstatic authorNames(catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n}\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\nreturn bookInfo;\n}\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\n}\n6.2.1 The tree of function calls\nThe waiter brings Theo his café au lait and Joe his tight espresso. They continue their dis-\ncussion while enjoying their coffees.\nJoe Before writing a unit test for a code flow, I find it useful to visualize the tree of\nfunction calls of the code flow.\nTheo What do you mean by a tree of function calls?\nJoe Here, I’ll draw the tree of function calls for the Library.searchBooksBy-\nTitleJSON code flow.\nJoe puts down his espresso and takes a napkin from the dispenser. He carefully places it\nflat on the table and starts to draw. When he is done, he shows the illustration to Theo (see\nfigure 6.1).\n--- Page 142 ---\n114 CHAPTER 6 Unit tests\nLibrary.searchBooksByTitleJSON\n_.get JSON.stringify Catalog.searchBooksByTitle\n_.get _.map _.filter Catalog.bookInfo\n_.get Catalog.authorNames\n_.get _.map\nFigure 6.1 The tree of function calls for the search query code flow\nTheo Nice! Can you teach me how to draw a tree of function calls like that?\nJoe Sure. The root of the tree is the name of the function for which you draw the\ntree, in our case, Library.searchBooksByTitleJSON. The children of a\nnode in the tree are the names of the functions called by the function. For exam-\nple, if you look again at the code for Library.searchBooksByTitleJSON (list-\ning 6.4), you’ll see that it calls Catalog.searchBooksByTitle, _.get, and\nJSON.stringify.\nTheo How long would I continue to recursively expand the tree?\nJoe You continue until you reach a function that doesn’t belong to the code base\nof your application. Those nodes are the leaves of our tree; for example, the\nfunctions from Lodash: _.get, _.map, and so forth.\nTheo What if the code of a function doesn’t call any other functions?\nJoe A function that doesn’t call any other function would be a leaf in the tree.\nTheo What about functions that are called inside anonymous functions like Catalog\n.bookInfo?\nJoe Catalog.bookInfo appears in the code of Catalog.searchBooksByTitle.\nTherefore, it is considered to be a child node of Catalog.searchBooksBy-\nTitle. The fact that it is nested inside an anonymous function is not relevant\nin the context of the tree of function calls.\n NOTE A tree of function calls for a function f is a tree where the root is f, and the\nchildren of a node g in the tree are the functions called by g. The leaves of the tree are\nfunctions that are not part of the code base of the application. These are functions\nthat don’t call any other functions.\nTheo It’s very cool to visualize my code as a tree, but I don’t see how it relates to\nunittests.\n--- Page 143 ---\n6.2 Unit tests for data manipulation code 115\nJoe The tree of function calls guides us about the quality and the quantity of test\ncases we should write.\nTheo How?\nJoe You’ll see in a moment.\n6.2.2 Unit tests for functions down the tree\nJoe Let’s start from the function that appears in the deepest node in our tree:\nCatalog.authorNames. Take a look at the code for Catalog.authorNames\nand tell me what are the input and the output of Catalog.authorNames.\nJoe turns his laptop so Theo can a closer look at the code. Theo takes a sip of his café au\nlait as he looks over what’s on Joe’s laptop.\nListing6.5 The code of Catalog.authorNames\nCatalog.authorNames = function (catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n};\nTheo The input of Catalog.authorNames is catalogData and authorIds. The\noutput is authorNames.\nJoe Would you do me a favor and express it visually?\nTheo Sure.\nIt’s Theo’s turn to grab a napkin. He draws a small rectangle with two inward arrows and\none outward arrow as in figure 6.2.\ncatalogData authorIds\nCatalog.authorNames()\nFigure 6.2 Visualization of the input\nauthorNames and output of Catalog.authorNames\nJoe Excellent! Now, how many combinations of input would you include in the\nunit test for Catalog.authorNames?\nTheo Let me see.\nTheo reaches for another napkin. This time he creates a table to gather his thoughts\n(table 6.1).\n--- Page 144 ---\n116 CHAPTER 6 Unit tests\nTable 6.1 The table of test cases for Catalog.authorNames\ncatalogData authorIds authorNames\nCatalog with two authors Empty array Empty array\nCatalog with two authors Array with one author ID Array with one author name\nCatalog with two authors Array with two author IDs Array with two author names\nTheo To begin with, I would have a catalogData with two author IDs and call\nCatalog.authorNames with three arguments: an empty array, an array with a\nsingle author ID, and an array with two author IDs.\nJoe How would you generate the catalogData?\nTheo Exactly as we generated it before.\nTurning to his laptop, Theo writes the code for catalogData. He shows it to Joe.\nListing6.6 A complete catalogData map\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\n--- Page 145 ---\n6.2 Unit tests for data manipulation code 117\nJoe You could use your big catalogData map for the unit test, but you could also\nuse a smaller map in the context of Catalog.authorNames. You can get rid of\nthe booksByIsbn field of the catalogData and the bookIsbns fields of the\nauthors.\nJoe deletes a few lines from catalogData and gets a much smaller map. He shows the revi-\nsion to Theo.\nListing6.7 A minimal version of catalogData\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nTheo Wait a minute! This catalogData is not valid.\nJoe In DOP, data validity depends on the context. In the context of Library\n.searchBooksByTitleJSON and Catalog.searchBooksByTitle, the mini-\nmal version of catalogData is indeed not valid. However, in the context of\nCatalog.bookInfo and Catalog.authorNames, it is perfectly valid. The reason\nis that those two functions access only the authorsById field of catalogData.\nTIP The validity of the data depends on the context.\nTheo Why is it better to use a minimal version of the data in a test case?\nJoe For a very simple reason—the smaller the data, the easier it is to manipulate.\nTIP The smaller the data, the easier it is to manipulate.\nTheo I’ll appreciate that when I write the unit tests!\nJoe Definitely! One last thing before we start coding: how would you check that the\noutput of Catalog.authorNames is as expected?\nTheo I would check that the value returned by Catalog.authorNames is an array\nwith the expected author names.\nJoe How would you handle the array comparison?\nTheo Let me think. I want to compare by value, not by reference. I guess I’ll have to\ncheck that the array is of the expected size and then check member by mem-\nber, recursively.\nJoe That’s too much of a mental burden when you’re in a coffee shop. As I showed\nyou earlier (see listing 6.1), we can recursively compare two data collections by\nvalue with _.isEqual from Lodash.\n--- Page 146 ---\n118 CHAPTER 6 Unit tests\nTIP We can compare the output and the expected output of our functions with\n_.isEqual.\nTheo Sounds good! Let me write the test cases.\nTheo starts typing on his laptop. After a few minutes, he has some test cases for Catalog\n.authorNames, each made from a function call to Catalog.authorNames wrapped in\n_.isEqual.\nListing6.8 Unit test for Catalog.authorNames\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(\ncatalogData,\n[\"alan-moore\"]),\n[\"Alan Moore\"]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\", \"dave-gibbons\"]),\n[\"Alan Moore\", \"Dave Gibbons\"]);\nJoe Well done! Can you think of more test cases?\nTheo Yes. There are test cases where the author ID doesn’t appear in the catalog\ndata, and test cases with empty catalog data. With minimal catalog data and\n_.isEqual, it’s really easy to write lots of test cases!\nTheo really enjoys this challenge. He creates a few more test cases to present to Joe.\nListing6.9 More test cases for Catalog.authorNames\n_.isEqual(Catalog.authorNames({}, []), []);\n_.isEqual(Catalog.authorNames({}, [\"alan-moore\"]), [undefined]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\",\n\"albert-einstein\"]), [\"Alan Moore\", undefined]);\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(catalogData, [\"albert-einstein\"]),\n[undefined]);\nTheo How do I run these unit tests?\nJoe You use your preferred test framework.\n--- Page 147 ---\n6.2 Unit tests for data manipulation code 119\n NOTE We don’t deal here with test runners and test frameworks. We deal only with\nthe logic of the test cases.\n6.2.3 Unit tests for nodes in the tree\nTheo I’m curious to see what unit tests for an upper node in the tree of function calls\nlook like.\nJoe Sure. Let’s write a unit test for Catalog.bookInfo. How many test cases would\nyou have for Catalog.bookInfo?\nListing6.10 The code of Catalog.bookInfo\nCatalog.bookInfo = function (catalogData, book) {\nreturn {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\n};\nTheo takes another look at the code for Catalog.bookInfo on his laptop. Then, reaching\nfor another napkin, he draws a diagram of its input and output (see figure 6.3).\ncatalogData book\nCatalog.bookInfo()\nFigure 6.3 Visualization of the input\nbookInfo and output of Catalog.bookInfo\nTheo I would have a similar number of test cases for Catalog.authorNames: a book\nwith a single author, with two authors, with existing authors, with non-existent\nauthors, with...\nJoe Whoa! That’s not necessary. Given that we have already written unit tests for\nCatalog.authorNames, we don’t need to check all the cases again. We simply\nneed to write a minimal test case to confirm that the code works.\nTIP When we write a unit test for a function, we assume that the functions called by\nthis function are covered by unit tests and work as expected. It significantly reduces\nthe quantity of test cases in our unit tests.\nTheo That makes sense.\nJoe How would you write a minimal test case for Catalog.bookInfo?\nTheo once again takes a look at the code for Catalog.bookInfo (see listing 6.10). Now he\ncan answer Joe’s question.\n--- Page 148 ---\n120 CHAPTER 6 Unit tests\nTheo I would use the same catalog data as for Catalog.authorNames and a book\nrecord. I’d test that the function behaves as expected by comparing its return\nvalue with a book info record using _.isEqual. Here, let me show you.\nIt takes Theo a bit more time to write the unit test. The reason is that the input and the\noutput of Catalog.authorNames are both records. Dealing with a record is more complex\nthan dealing with an array of strings (as it was the case for Catalog.authorNames). Theo\nappreciates the fact that _.isEqual saves him from writing code that compares the two\nmaps property by property. When he’s through, he shows the result to Joe and takes a nap-\nkin to wipe his forehead.\nListing6.11 Unit test for Catalog.bookInfo\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nvar book = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n};\nvar expectedResult = {\n\"authorNames\": [\"Alan Moore\", \"Dave Gibbons\"],\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n};\nvar result = Catalog.bookInfo(catalogData, book);\n_.isEqual(result, expectedResult);\nJoe Perfect! Now, how would you compare the kind of unit tests for Catalog\n.bookInfo with the unit tests for Catalog.authorNames?\nTheo On one hand, there is only a single test case in the unit test for Catalog.book-\nInfo. On the other hand, the data involved in the test case is more complex\nthan the data involved in the test cases for Catalog.authorNames.\nJoe Exactly! Functions that appear in a deep node in the tree of function calls tend\nto require more test cases, but the data involved in the test cases is less complex.\nTIP Functions that appear in a lower level in the tree of function calls tend to\ninvolve less complex data than functions that appear in a higher level in the tree\n(see table 6.2).\n--- Page 149 ---\n6.3 Unit tests for queries 121\nTable 6.2 The correlation between the depth of a function in the tree of function calls and the\nquality and quantity of the test cases\nDepth in the tree Complexity of the data Number of test cases\nLower Higher Lower\nHigher Lower Higher\n6.3 Unit tests for queries\nIn the previous section, we saw how to write unit tests for utility functions like Catalog\n.bookInfo and Catalog.authorNames. Now, we are going to see how to write unit tests\nfor the nodes of a query tree of function calls that are close to the root of the tree.\nJoe Theo, how would you write a unit test for the code of the entry point of the\nsearch query?\nTo recall the particulars, Theo checks the code for Library.searchBooksByTitleJSON.\nAlthough Joe was right about today’s topic being easy enough to enjoy the ambience of a\ncoffee shop, he has been doing quite a lot of coding this morning.\nListing6.12 The code of Library.searchBooksByTitleJSON\nLibrary.searchBooksByTitleJSON = function (libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n};\nHe then takes a moment to think about how he’d write a unit test for that code. After\nanother Aha! moment, now he’s got it.\nTheo The inputs of Library.searchBooksByTitleJSON are library data and a\nquery string, and the output is a JSON string (see figure 6.4). So, I would cre-\nate a library data record with a single book and write tests with query strings\nthat match the name of the book and ones that don’t match.\nlibraryData query\nLibrary.searchBooksByTitleJSON()\nFigure 6.4 The input and output of\nresultsJSON Library.searchBooksByTitleJSON\nJoe What about the expected results of the test cases?\n--- Page 150 ---\n122 CHAPTER 6 Unit tests\nTheo In cases where the query string matches, the expected result is a JSON string\nwith the book info. In cases where the query string doesn’t match, the\nexpected result is a JSON string with an empty array.\nJoe Hmm...\nTheo What?\nJoe I don’t like your answer.\nTheo Why?\nJoe Because your test case relies on a string comparison instead of a data comparison.\nTheo What difference does it make? After all, the strings I’m comparing come from\nthe serialization of data.\nJoe It’s inherently much more complex to compare JSON strings than it is to com-\npare data. For example, two different strings might be the serialization of the\nsame piece of data.\nTheo Really? How?\nJoe Take a look at these two strings. They are the serialization of the same data.\nThey’re different strings because the fields appear in a different order, but in\nfact, they serialize the same data!\nJoe turns his laptop to Theo. As Theo looks at the code, he realizes that, once again, Joe\niscorrect.\nListing6.13 Two different strings that serialize the same data\nvar stringA = \"{\\\"title\\\":\\\"Watchmen\\\",\\\"publicationYear\\\":1987}\";\nvar stringB = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nTIP Avoid using a string comparison in unit tests for functions that deal with data.\nTheo I see.... Well, what can I do instead?\nJoe Instead of comparing the output of Library.searchBooksByTitleJSON with\na string, you could deserialize the output and compare it to the expected data.\nTheo What do you mean by deserialize a string?\nJoe Deserializing a string s, for example, means to generate a piece of data whose\nserialization is s.\nTheo Is there a Lodash function for string deserialization?\nJoe Actually, there is a native JavaScript function for string deserialization; it’s\ncalled JSON.parse.\nJoe retrieves his laptop and shows Theo an example of string deserialization. The code\nillustrates a common usage of JSON.parse.\nListing6.14 Example of string deserialization\nvar myString = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nvar myData = JSON.parse(myString);\n--- Page 151 ---\n6.3 Unit tests for queries 123\n_.get(myData, \"title\");\n// → \"Watchmen\"\nTheo Cool! Let me try writing a unit test for Library.searchBooksByTitleJSON\nusing JSON.parse.\nIt doesn’t take Theo too much time to come up with a piece of code. Using his laptop, he\ninputs the unit test.\nListing6.15 Unit test for Library.searchBooksByTitleJSON\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Watchmen\")),\n[bookInfo]);\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Batman\")),\n[]);\nJoe Well done! I think you’re ready to move on to the last piece of the puzzle and\nwrite the unit test for Catalog.searchBooksByTitle.",
        "sections_found": []
      },
      "accurate_page_range": "126-151"
    },
    {
      "text": "- 5.3 Reducing collections",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "raw_line": "- 5.3 Reducing collections (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 41,
      "chapter_info": {
        "page": 126,
        "title": "Basic concurrency control",
        "pattern_matched": "Chapter 5",
        "text_preview": "98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. "
      },
      "chapter_sections": {
        "start_page": 126,
        "end_page": 151,
        "content": "\n--- Page 126 ---\n98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. It means that the first call to f will be f(0, 1). Then,\nwe’ll have f(f(0, 1), 2) and, finally, f(f(f(0, 1), 2), 3).\nJoe I like your manual expansion, Theo! Let’s make it visual.\nNow Theo goes to the whiteboard and draws a diagram. Figure 5.5 shows what that looks like.\nf\nf a\n2\nf a\n1\na 0 initVal Figure 5.5 Visualization\nof _.reduce\nTheo It’s much clearer now. I think that by implementing my custom version of\n_.reduce, it will make things 100% clear.\nIt takes Theo much less time than he expected to implement reduce(). In no time at all,\nhe shows Joe the code.\nListing5.2 Custom implementation of _.reduce\nfunction reduce(coll, f, initVal) {\nvar currentRes = initVal;\nfor (var i = 0; i < coll.length; i++) {\nWe could use\ncurrentRes = f(currentRes, coll[i])\nforEach instead\n}\nof a for loop.\nreturn currentRes;\n}\nAfter checking that Theo’s code works as expected (see listing 5.3), Joe is proud of Theo.\nHe seems to be catching on better than he anticipated.\nListing5.3 Testing the custom implementation of reduce()\nreduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nJoe Well done!\n--- Page 127 ---\n5.4 Structural difference 99\n5.4 Structural difference\n NOTE This section deals with the implementation of a structural diff algorithm. Feel\nfree to skip this section if you don’t want to challenge your mind right now with the\ndetails of a sophisticated use of recursion. It won’t prevent you from enjoying the rest\nof the book. You can come back to this section later.\nTheo How do you calculate the diff between various versions of the system state?\nJoe That’s the most challenging part of the reconciliation algorithm. We need to\nimplement a structural diff algorithm for hash maps.\nTheo In what sense is the diff structural?\nJoe The structural diff algorithm looks at the structure of the hash maps and\nignores the order of the fields.\nTheo Could you give me an example?\nJoe Let’s start with maps without nested fields. Basically, there are three kinds of\ndiffs: field replacement, field addition, and field deletion. In order to make\nthings not too complicated, for now, we’ll deal only with replacement and\naddition.\nJoe once again goes to the whiteboard and draws table 5.3, representing the three kinds of\ndiffs. Theo is thinking the whiteboard is really starting to fill up today.\nTable 5.3 Kinds of structural differences between maps without nested fields\nKind First map Second map Diff\nReplacement {\"a\": 1} {\"a\": 2} {\"a\": 2}\nAddition {\"a\": 1} {\"a\": 1, \"b\": 2} {\"b\": 2}\nDeletion {\"a\": 1, \"b\": 2} {\"a\": 1} Not supported\nTheo I notice that the order of the maps matters a lot. What about nested fields?\nJoe It’s the same idea, but the nesting makes it a bit more difficult to grasp.\nJoe changes several of the columns in table 5.3. When he’s through, he shows Theo the\nnested fields in table 5.4.\nTable 5.4 Kinds of structural differences between maps with nested fields\nKind First map Second map Diff\nReplacement { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 2 \"x\": 2\n} } }\n} } }\n--- Page 128 ---\n100 CHAPTER 5 Basic concurrency control\nTable 5.4 Kinds of structural differences between maps with nested fields (continued)\nKind First map Second map Diff\nAddition { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 1, \"y\": 2\n} \"y\": 2, }\n} } }\n}\nDeletion { { Not supported\n\"a\": { \"a\": {\n\"x\": 1, \"y\": 2\n\"y\": 2, }\n} }\n}\n NOTE The version of the structural diff algorithm illustrated in this chapter does\nnot deal with deletions. Dealing with deletions is definitely possible, but it requires a\nmore complicated algorithm.\nTheo As you said, it’s harder to grasp. What about arrays?\nJoe We compare the elements of the arrays in order: if they are equal, the diff is\nnull; if they differ, the diff has the value of the second array.\nJoe summarizes the various kinds of diffs in another table on the whiteboard. Theo looks\nat the result in table 5.5.\nTable 5.5 Kinds of structural differences between arrays without nested elements\nKind First array Second array Diff\nReplacement [1] [2] [2]\nAddition [1] [1, 2] [null, 2]\nDeletion [1, 2] [1] Not supported\nTheo This usage of null is a bit weird but OK. Is it complicated to implement the\nstructural diff algorithm?\nJoe Definitely! It took a good dose of mental gymnastics to come up with these 30\nlines of code.\nJoe downloads the code from one his personal repositories. Theo, with thumb and forefin-\ngers touching his chin and his forehead slightly tilted, studies the code.\nListing5.4 The implementation of a structural diff\nfunction diffObjects(data1, data2) {\n_.isArray checks whether\nvar emptyObject = _.isArray(data1) ? [] : {};\nits argument is an array.\nif(data1 == data2) {\n--- Page 129 ---\n5.4 Structural difference 101\nreturn emptyObject;\n_.union creates an\n} array of unique\nvar keys = _.union(_.keys(data1), _.keys(data2)); values from two\nreturn _.reduce(keys, arrays (like union of\nfunction (acc, k) { two sets in Maths).\nvar res = diff(\n_.get(data1, k),\n_.isObject checks\n_.get(data2, k));\nwhether its argument\nif((_.isObject(res) && _.isEmpty(res)) ||\nis a collection (either\na map or an array).\n(res == \"no-diff\")) {\nreturn acc;\n_.isEmpty }\nchecks return _.set(acc, [k], res);\nwhether its },\nargument\nemptyObject);\nis an empty\n} \"no-diff\" is how\ncollection.\nwe mark that\nfunction diff(data1, data2) { two values are\nif(_.isObject(data1) && _.isObject(data2)) { the same.\nreturn diffObjects(data1, data2);\n}\nif(data1 !== data2) {\nreturn data2;\n}\nreturn \"no-diff\";\n}\nTheo Wow! It involves a recursion inside a reduce! I’m sure Dave will love this, but\nI’m too tired to understand this code right now. Let’s focus on what it does\ninstead of how it does it.\nIn order familiarize himself with the structural diff algorithm, Theo runs the algorithm\nwith examples from the table that Joe drew on the whiteboard. While Theo occupies his\nfingers with more and more complicated examples, his mind wanders in the realm of\nperformance.\nListing5.5 An example of usage of a structural diff\nvar data1 = {\n\"a\": {\n\"x\": 1,\n\"y\": [2, 3],\n\"z\": 4\n}\n};\nvar data2 = {\n\"a\": {\n\"x\": 2,\n\"y\": [2, 4],\n\"z\": 4\n}\n}\n--- Page 130 ---\n102 CHAPTER 5 Basic concurrency control\ndiff(data1, data2);\n//{\n// \"a\": {\n// \"x\": 2,\n// \"y\": [\n// undefined,\n// 4\n// ]\n// }\n//}\nTheo What about the performance of the structural diff algorithm? It seems that the\nalgorithm goes over the leaves of both pieces of data?\nJoe In the general case, that’s true. But, in the case of system data that’s manipu-\nlated with structural sharing, the code is much more efficient.\nTheo What do you mean?\nJoe With structural sharing, most of the nested objects are shared between two ver-\nsions of the system state. Therefore, most of the time, when the code enters\ndiffObjects, it will immediately return because data1 and data2 are the same.\nTIP Calculating the diff between two versions of the state is efficient because two\nhash maps created via structural sharing from the same hash map have most of their\nnodes in common.\nTheo Another benefit of immutable data... Let me see how the diff algorithm\nbehaves with concurrent mutations. I think I’ll start with a tiny library with no\nusers and a catalog with a single book, Watchmen.\nListing5.6 The data for a tiny library\nvar library = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\n--- Page 131 ---\n5.4 Structural difference 103\nJoe I suggest that we start with nonconflicting mutations. What do you suggest?\nTheo A mutation that updates the publication year of Watchmen and a mutation that\nupdates both the title of Watchmen and the name of the author of Watchmen.\nOn his laptop, Theo creates three versions of the library. He shows Joe his code, where one\nmutation updates the publication year of Watchmen, and the other one updates the title of\nWatchmen and the author’s name.\nListing5.7 Two nonconflicting mutations\nvar previous = library;\nvar next = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"],\n1986);\nvar libraryWithUpdatedTitle = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"],\n\"The Watchmen\");\nvar current = _.set(\nlibraryWithUpdatedTitle,\n[\"catalog\", \"authorsById\", \"dave-gibbons\", \"name\"],\n\"David Chester Gibbons\");\nTheo I’m curious to see what the diff between previous and current looks like.\nJoe Run the code and you’ll see.\nTheo runs the code snippets for the structural diff between previous and next and for\nthe structural diff between previous and current. His curiosity satisfied, Theo finds it’s\nall beginning to make sense.\nListing5.8 Structural diff between maps with a single difference\ndiff(previous, next);\n//{\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"publicationYear\": 1986\n// }\n// }\n// }\n//}\nListing5.9 Structural diff between maps with two differences\ndiff(previous, current);\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\",\n--- Page 132 ---\n104 CHAPTER 5 Basic concurrency control\n// }\n// },\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\n//\nJoe Can you give me the information path of the single field in the structural diff\nbetween previous and next?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Right. And what are the information paths of the fields in the structural diff\nbetween previous and current?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"] for the book\ntitle and [\"authorsById\", \"dave-gibbons\", \"name\"] for the author’s name.\nJoe Perfect! Now, can you figure out how to detect conflicting mutations by\ninspecting the information paths of the structural diffs?\nTheo We need to check if they have an information path in common or not.\nJoe Exactly! If they have, it means the mutations are conflicting.\nTheo But I have no idea how to write code that retrieves the information paths of a\nnested map.\nJoe Once again, it’s a nontrivial piece of code that involves a recursion inside a\nreduce. Let me download another piece of code from my repository and show\nit to you.\nListing5.10 Calculating the information paths of a (nested) map\nfunction informationPaths (obj, path = []) {\nreturn _.reduce(obj,\nfunction(acc, v, k) {\nif (_.isObject(v)) {\nreturn _.concat(acc,\ninformationPaths(v,\n_.concat(path, k)));\n}\nreturn _.concat(acc, [_.concat(path, k)]);\n},\n[]);\n}\nTheo Let me see if your code works as expected with the structural diffs of the\nmutations.\nTheo tests Joe’s code with two code snippets. The first shows the information paths of the\nstructural diff between previous and next, and the second shows the information paths\nof the structural diff between previous and current.\n--- Page 133 ---\n5.4 Structural difference 105\nListing5.11 Fields that differ between previous and next\ninformationPaths(diff(previous, next));\n// → [\"catalog.booksByIsbn.978-1779501127.publicationYear\"]\nListing5.12 Fields that differ between previous and current\ninformationPaths(diff(previous, current));\n// [\n// [\n// \"catalog\",\n// \"booksByIsbn\",\n// \"978-1779501127\",\n// \"title\"\n// ],\n// [\n// \"authorsById\",\n// \"dave-gibbons\",\n// \"name\"\n// ]\n//]\nTheo Nice! I assume that Lodash has a function that checks whether two arrays have\nan element in common.\nJoe Almost. There is _.intersection, which returns an array of the unique values\nthat are in two given arrays. For our purpose, though, we need to check\nwhether the intersection is empty. Here, look at this example.\nListing5.13 Checking whether two diff maps have a common information path\nfunction havePathInCommon(diff1, diff2) {\nreturn !_.isEmpty(_.intersection(informationPaths(diff1),\ninformationPaths(diff2)));\n}\nTheo You told me earlier that in the case of nonconflicting mutations, we can\nsafely patch the changes induced by the transition from previous to next\ninto current. How do you implement that?\nJoe We do a recursive merge between current and the diff between previous and\nnext.\nTheo Does Lodash provide an immutable version of recursive merge?\nJoe Yes, here’s another example. Take a look at this code.\nListing5.14 Applying a patch\n_.merge(current, (diff(previous, next)));\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\"\n// }\n// },\n--- Page 134 ---\n106 CHAPTER 5 Basic concurrency control\n// \"catalog\": {\n// \"authorsById\": {\n// \"alan-moore\": {\n// \"bookIsbns\": [\"978-1779501127\"]\n// \"name\": \"Alan Moore\"\n// },\n// \"dave-gibbons\": {\n// \"bookIsbns\": [\"978-1779501127\"],\n// \"name\": \"Dave Gibbons\"\n// },\n// },\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n// \"isbn\": \"978-1779501127\",\n// \"publicationYear\": 1986,\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\nTheo Could it be as simple as this?\nJoe Indeed.\n5.5 Implementing the reconciliation algorithm\nJoe All the pieces are now in place to implement our reconciliation algorithm.\nTheo What kind of changes are required?\nJoe It only requires changes in the code of SystemState.commit. Here, look at\nthis example on my laptop.\nListing5.15 The SystemState class\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nvar nextSystemData = SystemConsistency.reconcile(\nthis.systemData,\nSystemConsistency class is\nprevious,\nimplemented in listing 5.16.\nnext);\nif(!SystemValidity.validate(previous, nextSystemData)) {\nthrow \"The system data to be committed is not valid!\";\n};\n--- Page 135 ---\n5.5 Implementing the reconciliation algorithm 107\nthis.systemData = nextSystemData;\n}\n}\nTheo How does SystemConsistency do the reconciliation?\nJoe The SystemConsistency class starts the reconciliation process by comparing\nprevious and current. If they are the same, then we fast-forward and return\nnext. Look at this code for SystemConsistency.\nListing5.16 The reconciliation flow in action\nclass SystemConsistency {\nstatic threeWayMerge(current, previous, next) {\nvar previousToCurrent = diff(previous, current);\nvar previousToNext = diff(previous, next);\nif(havePathInCommon(previousToCurrent, previousToNext)) { When the system\nreturn _.merge(current, previousToNext); state is the same\n} as the state used\nthrow \"Conflicting concurrent mutations.\"; by the calculation\n} phase, we fast-\nstatic reconcile(current, previous, next) { forward.\nif(current == previous) {\nreturn next;\n}\nreturn SystemConsistency.threeWayMerge(current,\nprevious,\nnext);\n}\n}\nTheo Wait a minute! Why do you compare previous and current by reference?\nYou should be comparing them by value, right? And, it would be quite expen-\nsive to compare all the leaves of the two nested hash maps!\nJoe That’s another benefit of immutable data. When the data is not mutated, it is\nsafe to compare references. If they are the same, we know for sure that the data\nis the same.\nTIP When data is immutable, it is safe to compare by reference, which is super fast.\nWhen the references are the same, it means that the data is the same.\nTheo What about the implementation of the three-way merge algorithm?\nJoe When previous differs from current, it means that concurrent mutations\nhave run. In order to determine whether there is a conflict, we calculate two\ndiffs: the diff between previous and current and the diff between previous\nand next. If the intersection between the two diffs is empty, it means there is\nno conflict. We can safely patch the changes between previous to next into\ncurrent.\nTheo takes a closer look at the code for the SystemConsistency class in listing 5.16. He\ntries to figure out if the code is thread-safe or not.\n--- Page 136 ---\n108 CHAPTER 5 Basic concurrency control\nTheo I think the code for SystemConsistency class is not thread-safe! If there’s a\ncontext switch between checking whether the system has changed in the\nSystemConsistency class and the updating of the state in SystemData class, a\nmutation might override the changes of a previous mutation.\nJoe You are totally right! The code works fine in a single-threaded environment\nlike JavaScript, where concurrency is handled via an event loop. However, in a\nmulti-threaded environment, the code needs to be refined in order to be\nthread-safe. I’ll show you some day.\n NOTE The SystemConsistency class is not thread-safe. We will make it thread-safe\nin chapter 8.\nTheo I think I understand why you called it optimistic concurrency control. It’s\nbecause we assume that conflicts don’t occur too often. Right?\nJoe Correct! It makes me wonder what your therapist would say about conflicts that\ncannot be resolved. Are there some cases where it’s not possible to reconcile\nthe couple?\nTheo I don’t think she ever mentioned such a possibility.\nJoe She must be a very optimistic person.\nSummary\n Optimistic concurrency control allows mutations to ask forgiveness instead of\npermission.\n Optimistic concurrency control is lock-free.\n Managing concurrent mutations of our system state with optimistic concurrency\ncontrol allows our system to support a high throughput of reads and writes.\n Optimistic concurrency control with immutable data is super efficient.\n Before updating the state, we need to reconcile the conflicts between possible con-\ncurrent mutations.\n We reconcile between concurrent mutations in a way that is similar to how Git han-\ndles a merge between two branches: either a fast-forward or a three-way merge.\n The changes required to let our system manage concurrency are only in the\ncommit phase.\n The calculation phase does its calculation as if it were the only mutation running.\n The commit phase is responsible for trying to reconcile concurrent mutations.\n The reconciliation algorithm is universal in the sense that it can be used in any sys-\ntem where the system data is represented as an immutable hash map.\n The implementation of the reconciliation algorithm is efficient, as it leverages\nthe fact that subsequent versions of the system state are created via structural\nsharing.\n In a user-facing system, conflicting concurrent mutations are fairly rare.\n When we cannot safely reconcile between concurrent mutations, we abort the\nmutation and ask the user to try again.\n--- Page 137 ---\nSummary 109\n Calculating the structural diff between two versions of the state is efficient because\ntwo hash maps created via structural sharing from the same hash map have most\nof their nodes in common.\n When data is immutable, it is safe to compare by reference, which is fast. When\nthe references are the same, it means that the data is the same.\n There are three kinds of structural differences between two nested hash maps:\nreplacement, addition, and deletion.\n Our structural diff algorithm supports replacements and additions but not\ndeletions.\nLodash functions introduced in this chapter\nFunction Description\nconcat(arrA, arrB) Creates an new array, concatenating arrA and arrB\nintersection(arrA, arrB) Creates an array of unique values both in arrA and arrB\nunion(arrA, arrB) Creates an array of unique values from arrA and arrB\nfind(coll, pred) Iterates over elements of coll, returning the first element for\nwhich pred returns true\nisEmpty(coll) Checks if coll is empty\nreduce(coll, f, initVal) Reduces coll to a value that is the accumulated result of running\neach element in coll through f, where each successive invoca-\ntion is supplied the return value of the previous\nisArray(coll) Checks if coll is an array\nisObject(coll) Checks if coll is a collection\n--- Page 138 ---\nUnit tests\nProgramming at a coffee shop\nThis chapter covers\n Generation of the minimal data input for a\ntest case\n Comparison of the output of a function with\nthe expected output\n Guidance about the quality and the quantity\nof the test cases\nIn a data-oriented system, our code deals mainly with data manipulation: most of\nour functions receive data and return data. As a consequence, it’s quite easy to\nwrite unit tests to check whether our code behaves as expected. A unit test is made\nof test cases that generate data input and compare the data output of the function\nwith the expected data output. In this chapter, we write unit tests for the queries\nand mutations that we wrote in the previous chapters.\n6.1 The simplicity of data-oriented test cases\nTheo and Joe are seated around a large wooden table in a corner of “La vie est belle,” a\nnice little French coffee shop, located near the Golden Gate Bridge. Theo orders a café\nau lait with a croissant, and Joe orders a tight espresso with a pain au chocolat. Instead\nof the usual general discussions about programming and life when they’re out of the\n110\n--- Page 139 ---\n6.1 The simplicity of data-oriented test cases 111\noffice, Joe leads the discussion towards a very concrete topic—unit tests. Theo asks Joe for\nan explanation.\nTheo Are unit tests such a simple topic that we can tackle it here in a coffee shop?\nJoe Unit tests in general, no. But unit tests for data-oriented code, yes!\nTheo Why does that make a difference?\nJoe The vast majority of the code base of a data-oriented system deals with data\nmanipulation.\nTheo Yeah. I noticed that almost all the functions we wrote so far receive data and\nreturn data.\nTIP Most of the code in a data-oriented system deals with data manipulation.\nJoe Writing a test case for functions that deal with data is only about generating\ndata input and expected output, and comparing the output of the function\nwith the expected output.\nThe steps of a test case\n1 Generate data input: dataIn\n2 Generate expected output: dataOut\n3 Compare the output of the function with the expected output: f(dataIn) and\ndataOut\nTheo That’s it?\nJoe Yes. As you’ll see in a moment, in DOP, there’s usually no need for mock\nfunctions.\nTheo I understand how to compare primitive values like strings or numbers, but I’m\nnot sure how I would compare data collections like maps.\nJoe You compare field by field.\nTheo Recursively?\nJoe Yes!\nTheo Oh no! I’m not able to write any recursive code in a coffee shop. I need the\ncalm of my office for that kind of stuff.\nJoe Don’t worry. In DOP, data is represented in a generic way. There is a generic\nfunction in Lodash called _.isEqual for recursive comparison of data collec-\ntions. It works with both maps and arrays.\nJoe opens his laptop. He is able to convince Theo by executing a few code snippets with\n_.isEqual to compare an equal data collection with a non-equal one.\nListing6.1 Comparing an equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n--- Page 140 ---\n112 CHAPTER 6 Unit tests\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n});\n// → true\nListing6.2 Comparing a non-equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"bad-isbn\"]\n});\n// → false\nTheo Nice!\nJoe Most of the test cases in DOP follow this pattern.\nTheo decides he wants to try this out. He fires up his laptop and types a few lines of\npseudocode.\nListing6.3 The general pattern of a data-oriented test case\nvar dataIn = {\n// input\n};\nvar dataOut = {\n// expected output\n};\n_.isEqual(f(dataIn), dataOut);\nTIP It’s straightforward to write unit tests for code that deals with data manipulation.\nTheo Indeed, this looks like something we can tackle in a coffee shop!\n6.2 Unit tests for data manipulation code\nA waiter in an elegant bow tie brings Theo his croissant and Joe his pain au chocolat. The\ntwo friends momentarily interrupt their discussion to savor their French pastries. When\nthey’re done, they ask the waiter to bring them their drinks. Meanwhile, they resume the\ndiscussion.\nJoe Do you remember the code flow of the implementation of the search query?\nTheo Let me look again at the code that implements the search query.\nTheo brings up the implementation of the search query on his laptop. Noticing that Joe is\nchewing on his nails again, he quickly checks out the code.\n--- Page 141 ---\n6.2 Unit tests for data manipulation code 113\nListing6.4 The code involved in the implementation of the search query\nclass Catalog {\nstatic authorNames(catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n}\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\nreturn bookInfo;\n}\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\n}\n6.2.1 The tree of function calls\nThe waiter brings Theo his café au lait and Joe his tight espresso. They continue their dis-\ncussion while enjoying their coffees.\nJoe Before writing a unit test for a code flow, I find it useful to visualize the tree of\nfunction calls of the code flow.\nTheo What do you mean by a tree of function calls?\nJoe Here, I’ll draw the tree of function calls for the Library.searchBooksBy-\nTitleJSON code flow.\nJoe puts down his espresso and takes a napkin from the dispenser. He carefully places it\nflat on the table and starts to draw. When he is done, he shows the illustration to Theo (see\nfigure 6.1).\n--- Page 142 ---\n114 CHAPTER 6 Unit tests\nLibrary.searchBooksByTitleJSON\n_.get JSON.stringify Catalog.searchBooksByTitle\n_.get _.map _.filter Catalog.bookInfo\n_.get Catalog.authorNames\n_.get _.map\nFigure 6.1 The tree of function calls for the search query code flow\nTheo Nice! Can you teach me how to draw a tree of function calls like that?\nJoe Sure. The root of the tree is the name of the function for which you draw the\ntree, in our case, Library.searchBooksByTitleJSON. The children of a\nnode in the tree are the names of the functions called by the function. For exam-\nple, if you look again at the code for Library.searchBooksByTitleJSON (list-\ning 6.4), you’ll see that it calls Catalog.searchBooksByTitle, _.get, and\nJSON.stringify.\nTheo How long would I continue to recursively expand the tree?\nJoe You continue until you reach a function that doesn’t belong to the code base\nof your application. Those nodes are the leaves of our tree; for example, the\nfunctions from Lodash: _.get, _.map, and so forth.\nTheo What if the code of a function doesn’t call any other functions?\nJoe A function that doesn’t call any other function would be a leaf in the tree.\nTheo What about functions that are called inside anonymous functions like Catalog\n.bookInfo?\nJoe Catalog.bookInfo appears in the code of Catalog.searchBooksByTitle.\nTherefore, it is considered to be a child node of Catalog.searchBooksBy-\nTitle. The fact that it is nested inside an anonymous function is not relevant\nin the context of the tree of function calls.\n NOTE A tree of function calls for a function f is a tree where the root is f, and the\nchildren of a node g in the tree are the functions called by g. The leaves of the tree are\nfunctions that are not part of the code base of the application. These are functions\nthat don’t call any other functions.\nTheo It’s very cool to visualize my code as a tree, but I don’t see how it relates to\nunittests.\n--- Page 143 ---\n6.2 Unit tests for data manipulation code 115\nJoe The tree of function calls guides us about the quality and the quantity of test\ncases we should write.\nTheo How?\nJoe You’ll see in a moment.\n6.2.2 Unit tests for functions down the tree\nJoe Let’s start from the function that appears in the deepest node in our tree:\nCatalog.authorNames. Take a look at the code for Catalog.authorNames\nand tell me what are the input and the output of Catalog.authorNames.\nJoe turns his laptop so Theo can a closer look at the code. Theo takes a sip of his café au\nlait as he looks over what’s on Joe’s laptop.\nListing6.5 The code of Catalog.authorNames\nCatalog.authorNames = function (catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n};\nTheo The input of Catalog.authorNames is catalogData and authorIds. The\noutput is authorNames.\nJoe Would you do me a favor and express it visually?\nTheo Sure.\nIt’s Theo’s turn to grab a napkin. He draws a small rectangle with two inward arrows and\none outward arrow as in figure 6.2.\ncatalogData authorIds\nCatalog.authorNames()\nFigure 6.2 Visualization of the input\nauthorNames and output of Catalog.authorNames\nJoe Excellent! Now, how many combinations of input would you include in the\nunit test for Catalog.authorNames?\nTheo Let me see.\nTheo reaches for another napkin. This time he creates a table to gather his thoughts\n(table 6.1).\n--- Page 144 ---\n116 CHAPTER 6 Unit tests\nTable 6.1 The table of test cases for Catalog.authorNames\ncatalogData authorIds authorNames\nCatalog with two authors Empty array Empty array\nCatalog with two authors Array with one author ID Array with one author name\nCatalog with two authors Array with two author IDs Array with two author names\nTheo To begin with, I would have a catalogData with two author IDs and call\nCatalog.authorNames with three arguments: an empty array, an array with a\nsingle author ID, and an array with two author IDs.\nJoe How would you generate the catalogData?\nTheo Exactly as we generated it before.\nTurning to his laptop, Theo writes the code for catalogData. He shows it to Joe.\nListing6.6 A complete catalogData map\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\n--- Page 145 ---\n6.2 Unit tests for data manipulation code 117\nJoe You could use your big catalogData map for the unit test, but you could also\nuse a smaller map in the context of Catalog.authorNames. You can get rid of\nthe booksByIsbn field of the catalogData and the bookIsbns fields of the\nauthors.\nJoe deletes a few lines from catalogData and gets a much smaller map. He shows the revi-\nsion to Theo.\nListing6.7 A minimal version of catalogData\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nTheo Wait a minute! This catalogData is not valid.\nJoe In DOP, data validity depends on the context. In the context of Library\n.searchBooksByTitleJSON and Catalog.searchBooksByTitle, the mini-\nmal version of catalogData is indeed not valid. However, in the context of\nCatalog.bookInfo and Catalog.authorNames, it is perfectly valid. The reason\nis that those two functions access only the authorsById field of catalogData.\nTIP The validity of the data depends on the context.\nTheo Why is it better to use a minimal version of the data in a test case?\nJoe For a very simple reason—the smaller the data, the easier it is to manipulate.\nTIP The smaller the data, the easier it is to manipulate.\nTheo I’ll appreciate that when I write the unit tests!\nJoe Definitely! One last thing before we start coding: how would you check that the\noutput of Catalog.authorNames is as expected?\nTheo I would check that the value returned by Catalog.authorNames is an array\nwith the expected author names.\nJoe How would you handle the array comparison?\nTheo Let me think. I want to compare by value, not by reference. I guess I’ll have to\ncheck that the array is of the expected size and then check member by mem-\nber, recursively.\nJoe That’s too much of a mental burden when you’re in a coffee shop. As I showed\nyou earlier (see listing 6.1), we can recursively compare two data collections by\nvalue with _.isEqual from Lodash.\n--- Page 146 ---\n118 CHAPTER 6 Unit tests\nTIP We can compare the output and the expected output of our functions with\n_.isEqual.\nTheo Sounds good! Let me write the test cases.\nTheo starts typing on his laptop. After a few minutes, he has some test cases for Catalog\n.authorNames, each made from a function call to Catalog.authorNames wrapped in\n_.isEqual.\nListing6.8 Unit test for Catalog.authorNames\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(\ncatalogData,\n[\"alan-moore\"]),\n[\"Alan Moore\"]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\", \"dave-gibbons\"]),\n[\"Alan Moore\", \"Dave Gibbons\"]);\nJoe Well done! Can you think of more test cases?\nTheo Yes. There are test cases where the author ID doesn’t appear in the catalog\ndata, and test cases with empty catalog data. With minimal catalog data and\n_.isEqual, it’s really easy to write lots of test cases!\nTheo really enjoys this challenge. He creates a few more test cases to present to Joe.\nListing6.9 More test cases for Catalog.authorNames\n_.isEqual(Catalog.authorNames({}, []), []);\n_.isEqual(Catalog.authorNames({}, [\"alan-moore\"]), [undefined]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\",\n\"albert-einstein\"]), [\"Alan Moore\", undefined]);\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(catalogData, [\"albert-einstein\"]),\n[undefined]);\nTheo How do I run these unit tests?\nJoe You use your preferred test framework.\n--- Page 147 ---\n6.2 Unit tests for data manipulation code 119\n NOTE We don’t deal here with test runners and test frameworks. We deal only with\nthe logic of the test cases.\n6.2.3 Unit tests for nodes in the tree\nTheo I’m curious to see what unit tests for an upper node in the tree of function calls\nlook like.\nJoe Sure. Let’s write a unit test for Catalog.bookInfo. How many test cases would\nyou have for Catalog.bookInfo?\nListing6.10 The code of Catalog.bookInfo\nCatalog.bookInfo = function (catalogData, book) {\nreturn {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\n};\nTheo takes another look at the code for Catalog.bookInfo on his laptop. Then, reaching\nfor another napkin, he draws a diagram of its input and output (see figure 6.3).\ncatalogData book\nCatalog.bookInfo()\nFigure 6.3 Visualization of the input\nbookInfo and output of Catalog.bookInfo\nTheo I would have a similar number of test cases for Catalog.authorNames: a book\nwith a single author, with two authors, with existing authors, with non-existent\nauthors, with...\nJoe Whoa! That’s not necessary. Given that we have already written unit tests for\nCatalog.authorNames, we don’t need to check all the cases again. We simply\nneed to write a minimal test case to confirm that the code works.\nTIP When we write a unit test for a function, we assume that the functions called by\nthis function are covered by unit tests and work as expected. It significantly reduces\nthe quantity of test cases in our unit tests.\nTheo That makes sense.\nJoe How would you write a minimal test case for Catalog.bookInfo?\nTheo once again takes a look at the code for Catalog.bookInfo (see listing 6.10). Now he\ncan answer Joe’s question.\n--- Page 148 ---\n120 CHAPTER 6 Unit tests\nTheo I would use the same catalog data as for Catalog.authorNames and a book\nrecord. I’d test that the function behaves as expected by comparing its return\nvalue with a book info record using _.isEqual. Here, let me show you.\nIt takes Theo a bit more time to write the unit test. The reason is that the input and the\noutput of Catalog.authorNames are both records. Dealing with a record is more complex\nthan dealing with an array of strings (as it was the case for Catalog.authorNames). Theo\nappreciates the fact that _.isEqual saves him from writing code that compares the two\nmaps property by property. When he’s through, he shows the result to Joe and takes a nap-\nkin to wipe his forehead.\nListing6.11 Unit test for Catalog.bookInfo\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nvar book = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n};\nvar expectedResult = {\n\"authorNames\": [\"Alan Moore\", \"Dave Gibbons\"],\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n};\nvar result = Catalog.bookInfo(catalogData, book);\n_.isEqual(result, expectedResult);\nJoe Perfect! Now, how would you compare the kind of unit tests for Catalog\n.bookInfo with the unit tests for Catalog.authorNames?\nTheo On one hand, there is only a single test case in the unit test for Catalog.book-\nInfo. On the other hand, the data involved in the test case is more complex\nthan the data involved in the test cases for Catalog.authorNames.\nJoe Exactly! Functions that appear in a deep node in the tree of function calls tend\nto require more test cases, but the data involved in the test cases is less complex.\nTIP Functions that appear in a lower level in the tree of function calls tend to\ninvolve less complex data than functions that appear in a higher level in the tree\n(see table 6.2).\n--- Page 149 ---\n6.3 Unit tests for queries 121\nTable 6.2 The correlation between the depth of a function in the tree of function calls and the\nquality and quantity of the test cases\nDepth in the tree Complexity of the data Number of test cases\nLower Higher Lower\nHigher Lower Higher\n6.3 Unit tests for queries\nIn the previous section, we saw how to write unit tests for utility functions like Catalog\n.bookInfo and Catalog.authorNames. Now, we are going to see how to write unit tests\nfor the nodes of a query tree of function calls that are close to the root of the tree.\nJoe Theo, how would you write a unit test for the code of the entry point of the\nsearch query?\nTo recall the particulars, Theo checks the code for Library.searchBooksByTitleJSON.\nAlthough Joe was right about today’s topic being easy enough to enjoy the ambience of a\ncoffee shop, he has been doing quite a lot of coding this morning.\nListing6.12 The code of Library.searchBooksByTitleJSON\nLibrary.searchBooksByTitleJSON = function (libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n};\nHe then takes a moment to think about how he’d write a unit test for that code. After\nanother Aha! moment, now he’s got it.\nTheo The inputs of Library.searchBooksByTitleJSON are library data and a\nquery string, and the output is a JSON string (see figure 6.4). So, I would cre-\nate a library data record with a single book and write tests with query strings\nthat match the name of the book and ones that don’t match.\nlibraryData query\nLibrary.searchBooksByTitleJSON()\nFigure 6.4 The input and output of\nresultsJSON Library.searchBooksByTitleJSON\nJoe What about the expected results of the test cases?\n--- Page 150 ---\n122 CHAPTER 6 Unit tests\nTheo In cases where the query string matches, the expected result is a JSON string\nwith the book info. In cases where the query string doesn’t match, the\nexpected result is a JSON string with an empty array.\nJoe Hmm...\nTheo What?\nJoe I don’t like your answer.\nTheo Why?\nJoe Because your test case relies on a string comparison instead of a data comparison.\nTheo What difference does it make? After all, the strings I’m comparing come from\nthe serialization of data.\nJoe It’s inherently much more complex to compare JSON strings than it is to com-\npare data. For example, two different strings might be the serialization of the\nsame piece of data.\nTheo Really? How?\nJoe Take a look at these two strings. They are the serialization of the same data.\nThey’re different strings because the fields appear in a different order, but in\nfact, they serialize the same data!\nJoe turns his laptop to Theo. As Theo looks at the code, he realizes that, once again, Joe\niscorrect.\nListing6.13 Two different strings that serialize the same data\nvar stringA = \"{\\\"title\\\":\\\"Watchmen\\\",\\\"publicationYear\\\":1987}\";\nvar stringB = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nTIP Avoid using a string comparison in unit tests for functions that deal with data.\nTheo I see.... Well, what can I do instead?\nJoe Instead of comparing the output of Library.searchBooksByTitleJSON with\na string, you could deserialize the output and compare it to the expected data.\nTheo What do you mean by deserialize a string?\nJoe Deserializing a string s, for example, means to generate a piece of data whose\nserialization is s.\nTheo Is there a Lodash function for string deserialization?\nJoe Actually, there is a native JavaScript function for string deserialization; it’s\ncalled JSON.parse.\nJoe retrieves his laptop and shows Theo an example of string deserialization. The code\nillustrates a common usage of JSON.parse.\nListing6.14 Example of string deserialization\nvar myString = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nvar myData = JSON.parse(myString);\n--- Page 151 ---\n6.3 Unit tests for queries 123\n_.get(myData, \"title\");\n// → \"Watchmen\"\nTheo Cool! Let me try writing a unit test for Library.searchBooksByTitleJSON\nusing JSON.parse.\nIt doesn’t take Theo too much time to come up with a piece of code. Using his laptop, he\ninputs the unit test.\nListing6.15 Unit test for Library.searchBooksByTitleJSON\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Watchmen\")),\n[bookInfo]);\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Batman\")),\n[]);\nJoe Well done! I think you’re ready to move on to the last piece of the puzzle and\nwrite the unit test for Catalog.searchBooksByTitle.",
        "sections_found": []
      },
      "accurate_page_range": "126-151"
    },
    {
      "text": "- 5.4 Structural difference",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "raw_line": "- 5.4 Structural difference (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 42,
      "chapter_info": {
        "page": 126,
        "title": "Basic concurrency control",
        "pattern_matched": "Chapter 5",
        "text_preview": "98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. "
      },
      "chapter_sections": {
        "start_page": 126,
        "end_page": 151,
        "content": "\n--- Page 126 ---\n98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. It means that the first call to f will be f(0, 1). Then,\nwe’ll have f(f(0, 1), 2) and, finally, f(f(f(0, 1), 2), 3).\nJoe I like your manual expansion, Theo! Let’s make it visual.\nNow Theo goes to the whiteboard and draws a diagram. Figure 5.5 shows what that looks like.\nf\nf a\n2\nf a\n1\na 0 initVal Figure 5.5 Visualization\nof _.reduce\nTheo It’s much clearer now. I think that by implementing my custom version of\n_.reduce, it will make things 100% clear.\nIt takes Theo much less time than he expected to implement reduce(). In no time at all,\nhe shows Joe the code.\nListing5.2 Custom implementation of _.reduce\nfunction reduce(coll, f, initVal) {\nvar currentRes = initVal;\nfor (var i = 0; i < coll.length; i++) {\nWe could use\ncurrentRes = f(currentRes, coll[i])\nforEach instead\n}\nof a for loop.\nreturn currentRes;\n}\nAfter checking that Theo’s code works as expected (see listing 5.3), Joe is proud of Theo.\nHe seems to be catching on better than he anticipated.\nListing5.3 Testing the custom implementation of reduce()\nreduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nJoe Well done!\n--- Page 127 ---\n5.4 Structural difference 99\n5.4 Structural difference\n NOTE This section deals with the implementation of a structural diff algorithm. Feel\nfree to skip this section if you don’t want to challenge your mind right now with the\ndetails of a sophisticated use of recursion. It won’t prevent you from enjoying the rest\nof the book. You can come back to this section later.\nTheo How do you calculate the diff between various versions of the system state?\nJoe That’s the most challenging part of the reconciliation algorithm. We need to\nimplement a structural diff algorithm for hash maps.\nTheo In what sense is the diff structural?\nJoe The structural diff algorithm looks at the structure of the hash maps and\nignores the order of the fields.\nTheo Could you give me an example?\nJoe Let’s start with maps without nested fields. Basically, there are three kinds of\ndiffs: field replacement, field addition, and field deletion. In order to make\nthings not too complicated, for now, we’ll deal only with replacement and\naddition.\nJoe once again goes to the whiteboard and draws table 5.3, representing the three kinds of\ndiffs. Theo is thinking the whiteboard is really starting to fill up today.\nTable 5.3 Kinds of structural differences between maps without nested fields\nKind First map Second map Diff\nReplacement {\"a\": 1} {\"a\": 2} {\"a\": 2}\nAddition {\"a\": 1} {\"a\": 1, \"b\": 2} {\"b\": 2}\nDeletion {\"a\": 1, \"b\": 2} {\"a\": 1} Not supported\nTheo I notice that the order of the maps matters a lot. What about nested fields?\nJoe It’s the same idea, but the nesting makes it a bit more difficult to grasp.\nJoe changes several of the columns in table 5.3. When he’s through, he shows Theo the\nnested fields in table 5.4.\nTable 5.4 Kinds of structural differences between maps with nested fields\nKind First map Second map Diff\nReplacement { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 2 \"x\": 2\n} } }\n} } }\n--- Page 128 ---\n100 CHAPTER 5 Basic concurrency control\nTable 5.4 Kinds of structural differences between maps with nested fields (continued)\nKind First map Second map Diff\nAddition { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 1, \"y\": 2\n} \"y\": 2, }\n} } }\n}\nDeletion { { Not supported\n\"a\": { \"a\": {\n\"x\": 1, \"y\": 2\n\"y\": 2, }\n} }\n}\n NOTE The version of the structural diff algorithm illustrated in this chapter does\nnot deal with deletions. Dealing with deletions is definitely possible, but it requires a\nmore complicated algorithm.\nTheo As you said, it’s harder to grasp. What about arrays?\nJoe We compare the elements of the arrays in order: if they are equal, the diff is\nnull; if they differ, the diff has the value of the second array.\nJoe summarizes the various kinds of diffs in another table on the whiteboard. Theo looks\nat the result in table 5.5.\nTable 5.5 Kinds of structural differences between arrays without nested elements\nKind First array Second array Diff\nReplacement [1] [2] [2]\nAddition [1] [1, 2] [null, 2]\nDeletion [1, 2] [1] Not supported\nTheo This usage of null is a bit weird but OK. Is it complicated to implement the\nstructural diff algorithm?\nJoe Definitely! It took a good dose of mental gymnastics to come up with these 30\nlines of code.\nJoe downloads the code from one his personal repositories. Theo, with thumb and forefin-\ngers touching his chin and his forehead slightly tilted, studies the code.\nListing5.4 The implementation of a structural diff\nfunction diffObjects(data1, data2) {\n_.isArray checks whether\nvar emptyObject = _.isArray(data1) ? [] : {};\nits argument is an array.\nif(data1 == data2) {\n--- Page 129 ---\n5.4 Structural difference 101\nreturn emptyObject;\n_.union creates an\n} array of unique\nvar keys = _.union(_.keys(data1), _.keys(data2)); values from two\nreturn _.reduce(keys, arrays (like union of\nfunction (acc, k) { two sets in Maths).\nvar res = diff(\n_.get(data1, k),\n_.isObject checks\n_.get(data2, k));\nwhether its argument\nif((_.isObject(res) && _.isEmpty(res)) ||\nis a collection (either\na map or an array).\n(res == \"no-diff\")) {\nreturn acc;\n_.isEmpty }\nchecks return _.set(acc, [k], res);\nwhether its },\nargument\nemptyObject);\nis an empty\n} \"no-diff\" is how\ncollection.\nwe mark that\nfunction diff(data1, data2) { two values are\nif(_.isObject(data1) && _.isObject(data2)) { the same.\nreturn diffObjects(data1, data2);\n}\nif(data1 !== data2) {\nreturn data2;\n}\nreturn \"no-diff\";\n}\nTheo Wow! It involves a recursion inside a reduce! I’m sure Dave will love this, but\nI’m too tired to understand this code right now. Let’s focus on what it does\ninstead of how it does it.\nIn order familiarize himself with the structural diff algorithm, Theo runs the algorithm\nwith examples from the table that Joe drew on the whiteboard. While Theo occupies his\nfingers with more and more complicated examples, his mind wanders in the realm of\nperformance.\nListing5.5 An example of usage of a structural diff\nvar data1 = {\n\"a\": {\n\"x\": 1,\n\"y\": [2, 3],\n\"z\": 4\n}\n};\nvar data2 = {\n\"a\": {\n\"x\": 2,\n\"y\": [2, 4],\n\"z\": 4\n}\n}\n--- Page 130 ---\n102 CHAPTER 5 Basic concurrency control\ndiff(data1, data2);\n//{\n// \"a\": {\n// \"x\": 2,\n// \"y\": [\n// undefined,\n// 4\n// ]\n// }\n//}\nTheo What about the performance of the structural diff algorithm? It seems that the\nalgorithm goes over the leaves of both pieces of data?\nJoe In the general case, that’s true. But, in the case of system data that’s manipu-\nlated with structural sharing, the code is much more efficient.\nTheo What do you mean?\nJoe With structural sharing, most of the nested objects are shared between two ver-\nsions of the system state. Therefore, most of the time, when the code enters\ndiffObjects, it will immediately return because data1 and data2 are the same.\nTIP Calculating the diff between two versions of the state is efficient because two\nhash maps created via structural sharing from the same hash map have most of their\nnodes in common.\nTheo Another benefit of immutable data... Let me see how the diff algorithm\nbehaves with concurrent mutations. I think I’ll start with a tiny library with no\nusers and a catalog with a single book, Watchmen.\nListing5.6 The data for a tiny library\nvar library = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\n--- Page 131 ---\n5.4 Structural difference 103\nJoe I suggest that we start with nonconflicting mutations. What do you suggest?\nTheo A mutation that updates the publication year of Watchmen and a mutation that\nupdates both the title of Watchmen and the name of the author of Watchmen.\nOn his laptop, Theo creates three versions of the library. He shows Joe his code, where one\nmutation updates the publication year of Watchmen, and the other one updates the title of\nWatchmen and the author’s name.\nListing5.7 Two nonconflicting mutations\nvar previous = library;\nvar next = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"],\n1986);\nvar libraryWithUpdatedTitle = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"],\n\"The Watchmen\");\nvar current = _.set(\nlibraryWithUpdatedTitle,\n[\"catalog\", \"authorsById\", \"dave-gibbons\", \"name\"],\n\"David Chester Gibbons\");\nTheo I’m curious to see what the diff between previous and current looks like.\nJoe Run the code and you’ll see.\nTheo runs the code snippets for the structural diff between previous and next and for\nthe structural diff between previous and current. His curiosity satisfied, Theo finds it’s\nall beginning to make sense.\nListing5.8 Structural diff between maps with a single difference\ndiff(previous, next);\n//{\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"publicationYear\": 1986\n// }\n// }\n// }\n//}\nListing5.9 Structural diff between maps with two differences\ndiff(previous, current);\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\",\n--- Page 132 ---\n104 CHAPTER 5 Basic concurrency control\n// }\n// },\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\n//\nJoe Can you give me the information path of the single field in the structural diff\nbetween previous and next?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Right. And what are the information paths of the fields in the structural diff\nbetween previous and current?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"] for the book\ntitle and [\"authorsById\", \"dave-gibbons\", \"name\"] for the author’s name.\nJoe Perfect! Now, can you figure out how to detect conflicting mutations by\ninspecting the information paths of the structural diffs?\nTheo We need to check if they have an information path in common or not.\nJoe Exactly! If they have, it means the mutations are conflicting.\nTheo But I have no idea how to write code that retrieves the information paths of a\nnested map.\nJoe Once again, it’s a nontrivial piece of code that involves a recursion inside a\nreduce. Let me download another piece of code from my repository and show\nit to you.\nListing5.10 Calculating the information paths of a (nested) map\nfunction informationPaths (obj, path = []) {\nreturn _.reduce(obj,\nfunction(acc, v, k) {\nif (_.isObject(v)) {\nreturn _.concat(acc,\ninformationPaths(v,\n_.concat(path, k)));\n}\nreturn _.concat(acc, [_.concat(path, k)]);\n},\n[]);\n}\nTheo Let me see if your code works as expected with the structural diffs of the\nmutations.\nTheo tests Joe’s code with two code snippets. The first shows the information paths of the\nstructural diff between previous and next, and the second shows the information paths\nof the structural diff between previous and current.\n--- Page 133 ---\n5.4 Structural difference 105\nListing5.11 Fields that differ between previous and next\ninformationPaths(diff(previous, next));\n// → [\"catalog.booksByIsbn.978-1779501127.publicationYear\"]\nListing5.12 Fields that differ between previous and current\ninformationPaths(diff(previous, current));\n// [\n// [\n// \"catalog\",\n// \"booksByIsbn\",\n// \"978-1779501127\",\n// \"title\"\n// ],\n// [\n// \"authorsById\",\n// \"dave-gibbons\",\n// \"name\"\n// ]\n//]\nTheo Nice! I assume that Lodash has a function that checks whether two arrays have\nan element in common.\nJoe Almost. There is _.intersection, which returns an array of the unique values\nthat are in two given arrays. For our purpose, though, we need to check\nwhether the intersection is empty. Here, look at this example.\nListing5.13 Checking whether two diff maps have a common information path\nfunction havePathInCommon(diff1, diff2) {\nreturn !_.isEmpty(_.intersection(informationPaths(diff1),\ninformationPaths(diff2)));\n}\nTheo You told me earlier that in the case of nonconflicting mutations, we can\nsafely patch the changes induced by the transition from previous to next\ninto current. How do you implement that?\nJoe We do a recursive merge between current and the diff between previous and\nnext.\nTheo Does Lodash provide an immutable version of recursive merge?\nJoe Yes, here’s another example. Take a look at this code.\nListing5.14 Applying a patch\n_.merge(current, (diff(previous, next)));\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\"\n// }\n// },\n--- Page 134 ---\n106 CHAPTER 5 Basic concurrency control\n// \"catalog\": {\n// \"authorsById\": {\n// \"alan-moore\": {\n// \"bookIsbns\": [\"978-1779501127\"]\n// \"name\": \"Alan Moore\"\n// },\n// \"dave-gibbons\": {\n// \"bookIsbns\": [\"978-1779501127\"],\n// \"name\": \"Dave Gibbons\"\n// },\n// },\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n// \"isbn\": \"978-1779501127\",\n// \"publicationYear\": 1986,\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\nTheo Could it be as simple as this?\nJoe Indeed.\n5.5 Implementing the reconciliation algorithm\nJoe All the pieces are now in place to implement our reconciliation algorithm.\nTheo What kind of changes are required?\nJoe It only requires changes in the code of SystemState.commit. Here, look at\nthis example on my laptop.\nListing5.15 The SystemState class\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nvar nextSystemData = SystemConsistency.reconcile(\nthis.systemData,\nSystemConsistency class is\nprevious,\nimplemented in listing 5.16.\nnext);\nif(!SystemValidity.validate(previous, nextSystemData)) {\nthrow \"The system data to be committed is not valid!\";\n};\n--- Page 135 ---\n5.5 Implementing the reconciliation algorithm 107\nthis.systemData = nextSystemData;\n}\n}\nTheo How does SystemConsistency do the reconciliation?\nJoe The SystemConsistency class starts the reconciliation process by comparing\nprevious and current. If they are the same, then we fast-forward and return\nnext. Look at this code for SystemConsistency.\nListing5.16 The reconciliation flow in action\nclass SystemConsistency {\nstatic threeWayMerge(current, previous, next) {\nvar previousToCurrent = diff(previous, current);\nvar previousToNext = diff(previous, next);\nif(havePathInCommon(previousToCurrent, previousToNext)) { When the system\nreturn _.merge(current, previousToNext); state is the same\n} as the state used\nthrow \"Conflicting concurrent mutations.\"; by the calculation\n} phase, we fast-\nstatic reconcile(current, previous, next) { forward.\nif(current == previous) {\nreturn next;\n}\nreturn SystemConsistency.threeWayMerge(current,\nprevious,\nnext);\n}\n}\nTheo Wait a minute! Why do you compare previous and current by reference?\nYou should be comparing them by value, right? And, it would be quite expen-\nsive to compare all the leaves of the two nested hash maps!\nJoe That’s another benefit of immutable data. When the data is not mutated, it is\nsafe to compare references. If they are the same, we know for sure that the data\nis the same.\nTIP When data is immutable, it is safe to compare by reference, which is super fast.\nWhen the references are the same, it means that the data is the same.\nTheo What about the implementation of the three-way merge algorithm?\nJoe When previous differs from current, it means that concurrent mutations\nhave run. In order to determine whether there is a conflict, we calculate two\ndiffs: the diff between previous and current and the diff between previous\nand next. If the intersection between the two diffs is empty, it means there is\nno conflict. We can safely patch the changes between previous to next into\ncurrent.\nTheo takes a closer look at the code for the SystemConsistency class in listing 5.16. He\ntries to figure out if the code is thread-safe or not.\n--- Page 136 ---\n108 CHAPTER 5 Basic concurrency control\nTheo I think the code for SystemConsistency class is not thread-safe! If there’s a\ncontext switch between checking whether the system has changed in the\nSystemConsistency class and the updating of the state in SystemData class, a\nmutation might override the changes of a previous mutation.\nJoe You are totally right! The code works fine in a single-threaded environment\nlike JavaScript, where concurrency is handled via an event loop. However, in a\nmulti-threaded environment, the code needs to be refined in order to be\nthread-safe. I’ll show you some day.\n NOTE The SystemConsistency class is not thread-safe. We will make it thread-safe\nin chapter 8.\nTheo I think I understand why you called it optimistic concurrency control. It’s\nbecause we assume that conflicts don’t occur too often. Right?\nJoe Correct! It makes me wonder what your therapist would say about conflicts that\ncannot be resolved. Are there some cases where it’s not possible to reconcile\nthe couple?\nTheo I don’t think she ever mentioned such a possibility.\nJoe She must be a very optimistic person.\nSummary\n Optimistic concurrency control allows mutations to ask forgiveness instead of\npermission.\n Optimistic concurrency control is lock-free.\n Managing concurrent mutations of our system state with optimistic concurrency\ncontrol allows our system to support a high throughput of reads and writes.\n Optimistic concurrency control with immutable data is super efficient.\n Before updating the state, we need to reconcile the conflicts between possible con-\ncurrent mutations.\n We reconcile between concurrent mutations in a way that is similar to how Git han-\ndles a merge between two branches: either a fast-forward or a three-way merge.\n The changes required to let our system manage concurrency are only in the\ncommit phase.\n The calculation phase does its calculation as if it were the only mutation running.\n The commit phase is responsible for trying to reconcile concurrent mutations.\n The reconciliation algorithm is universal in the sense that it can be used in any sys-\ntem where the system data is represented as an immutable hash map.\n The implementation of the reconciliation algorithm is efficient, as it leverages\nthe fact that subsequent versions of the system state are created via structural\nsharing.\n In a user-facing system, conflicting concurrent mutations are fairly rare.\n When we cannot safely reconcile between concurrent mutations, we abort the\nmutation and ask the user to try again.\n--- Page 137 ---\nSummary 109\n Calculating the structural diff between two versions of the state is efficient because\ntwo hash maps created via structural sharing from the same hash map have most\nof their nodes in common.\n When data is immutable, it is safe to compare by reference, which is fast. When\nthe references are the same, it means that the data is the same.\n There are three kinds of structural differences between two nested hash maps:\nreplacement, addition, and deletion.\n Our structural diff algorithm supports replacements and additions but not\ndeletions.\nLodash functions introduced in this chapter\nFunction Description\nconcat(arrA, arrB) Creates an new array, concatenating arrA and arrB\nintersection(arrA, arrB) Creates an array of unique values both in arrA and arrB\nunion(arrA, arrB) Creates an array of unique values from arrA and arrB\nfind(coll, pred) Iterates over elements of coll, returning the first element for\nwhich pred returns true\nisEmpty(coll) Checks if coll is empty\nreduce(coll, f, initVal) Reduces coll to a value that is the accumulated result of running\neach element in coll through f, where each successive invoca-\ntion is supplied the return value of the previous\nisArray(coll) Checks if coll is an array\nisObject(coll) Checks if coll is a collection\n--- Page 138 ---\nUnit tests\nProgramming at a coffee shop\nThis chapter covers\n Generation of the minimal data input for a\ntest case\n Comparison of the output of a function with\nthe expected output\n Guidance about the quality and the quantity\nof the test cases\nIn a data-oriented system, our code deals mainly with data manipulation: most of\nour functions receive data and return data. As a consequence, it’s quite easy to\nwrite unit tests to check whether our code behaves as expected. A unit test is made\nof test cases that generate data input and compare the data output of the function\nwith the expected data output. In this chapter, we write unit tests for the queries\nand mutations that we wrote in the previous chapters.\n6.1 The simplicity of data-oriented test cases\nTheo and Joe are seated around a large wooden table in a corner of “La vie est belle,” a\nnice little French coffee shop, located near the Golden Gate Bridge. Theo orders a café\nau lait with a croissant, and Joe orders a tight espresso with a pain au chocolat. Instead\nof the usual general discussions about programming and life when they’re out of the\n110\n--- Page 139 ---\n6.1 The simplicity of data-oriented test cases 111\noffice, Joe leads the discussion towards a very concrete topic—unit tests. Theo asks Joe for\nan explanation.\nTheo Are unit tests such a simple topic that we can tackle it here in a coffee shop?\nJoe Unit tests in general, no. But unit tests for data-oriented code, yes!\nTheo Why does that make a difference?\nJoe The vast majority of the code base of a data-oriented system deals with data\nmanipulation.\nTheo Yeah. I noticed that almost all the functions we wrote so far receive data and\nreturn data.\nTIP Most of the code in a data-oriented system deals with data manipulation.\nJoe Writing a test case for functions that deal with data is only about generating\ndata input and expected output, and comparing the output of the function\nwith the expected output.\nThe steps of a test case\n1 Generate data input: dataIn\n2 Generate expected output: dataOut\n3 Compare the output of the function with the expected output: f(dataIn) and\ndataOut\nTheo That’s it?\nJoe Yes. As you’ll see in a moment, in DOP, there’s usually no need for mock\nfunctions.\nTheo I understand how to compare primitive values like strings or numbers, but I’m\nnot sure how I would compare data collections like maps.\nJoe You compare field by field.\nTheo Recursively?\nJoe Yes!\nTheo Oh no! I’m not able to write any recursive code in a coffee shop. I need the\ncalm of my office for that kind of stuff.\nJoe Don’t worry. In DOP, data is represented in a generic way. There is a generic\nfunction in Lodash called _.isEqual for recursive comparison of data collec-\ntions. It works with both maps and arrays.\nJoe opens his laptop. He is able to convince Theo by executing a few code snippets with\n_.isEqual to compare an equal data collection with a non-equal one.\nListing6.1 Comparing an equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n--- Page 140 ---\n112 CHAPTER 6 Unit tests\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n});\n// → true\nListing6.2 Comparing a non-equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"bad-isbn\"]\n});\n// → false\nTheo Nice!\nJoe Most of the test cases in DOP follow this pattern.\nTheo decides he wants to try this out. He fires up his laptop and types a few lines of\npseudocode.\nListing6.3 The general pattern of a data-oriented test case\nvar dataIn = {\n// input\n};\nvar dataOut = {\n// expected output\n};\n_.isEqual(f(dataIn), dataOut);\nTIP It’s straightforward to write unit tests for code that deals with data manipulation.\nTheo Indeed, this looks like something we can tackle in a coffee shop!\n6.2 Unit tests for data manipulation code\nA waiter in an elegant bow tie brings Theo his croissant and Joe his pain au chocolat. The\ntwo friends momentarily interrupt their discussion to savor their French pastries. When\nthey’re done, they ask the waiter to bring them their drinks. Meanwhile, they resume the\ndiscussion.\nJoe Do you remember the code flow of the implementation of the search query?\nTheo Let me look again at the code that implements the search query.\nTheo brings up the implementation of the search query on his laptop. Noticing that Joe is\nchewing on his nails again, he quickly checks out the code.\n--- Page 141 ---\n6.2 Unit tests for data manipulation code 113\nListing6.4 The code involved in the implementation of the search query\nclass Catalog {\nstatic authorNames(catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n}\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\nreturn bookInfo;\n}\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\n}\n6.2.1 The tree of function calls\nThe waiter brings Theo his café au lait and Joe his tight espresso. They continue their dis-\ncussion while enjoying their coffees.\nJoe Before writing a unit test for a code flow, I find it useful to visualize the tree of\nfunction calls of the code flow.\nTheo What do you mean by a tree of function calls?\nJoe Here, I’ll draw the tree of function calls for the Library.searchBooksBy-\nTitleJSON code flow.\nJoe puts down his espresso and takes a napkin from the dispenser. He carefully places it\nflat on the table and starts to draw. When he is done, he shows the illustration to Theo (see\nfigure 6.1).\n--- Page 142 ---\n114 CHAPTER 6 Unit tests\nLibrary.searchBooksByTitleJSON\n_.get JSON.stringify Catalog.searchBooksByTitle\n_.get _.map _.filter Catalog.bookInfo\n_.get Catalog.authorNames\n_.get _.map\nFigure 6.1 The tree of function calls for the search query code flow\nTheo Nice! Can you teach me how to draw a tree of function calls like that?\nJoe Sure. The root of the tree is the name of the function for which you draw the\ntree, in our case, Library.searchBooksByTitleJSON. The children of a\nnode in the tree are the names of the functions called by the function. For exam-\nple, if you look again at the code for Library.searchBooksByTitleJSON (list-\ning 6.4), you’ll see that it calls Catalog.searchBooksByTitle, _.get, and\nJSON.stringify.\nTheo How long would I continue to recursively expand the tree?\nJoe You continue until you reach a function that doesn’t belong to the code base\nof your application. Those nodes are the leaves of our tree; for example, the\nfunctions from Lodash: _.get, _.map, and so forth.\nTheo What if the code of a function doesn’t call any other functions?\nJoe A function that doesn’t call any other function would be a leaf in the tree.\nTheo What about functions that are called inside anonymous functions like Catalog\n.bookInfo?\nJoe Catalog.bookInfo appears in the code of Catalog.searchBooksByTitle.\nTherefore, it is considered to be a child node of Catalog.searchBooksBy-\nTitle. The fact that it is nested inside an anonymous function is not relevant\nin the context of the tree of function calls.\n NOTE A tree of function calls for a function f is a tree where the root is f, and the\nchildren of a node g in the tree are the functions called by g. The leaves of the tree are\nfunctions that are not part of the code base of the application. These are functions\nthat don’t call any other functions.\nTheo It’s very cool to visualize my code as a tree, but I don’t see how it relates to\nunittests.\n--- Page 143 ---\n6.2 Unit tests for data manipulation code 115\nJoe The tree of function calls guides us about the quality and the quantity of test\ncases we should write.\nTheo How?\nJoe You’ll see in a moment.\n6.2.2 Unit tests for functions down the tree\nJoe Let’s start from the function that appears in the deepest node in our tree:\nCatalog.authorNames. Take a look at the code for Catalog.authorNames\nand tell me what are the input and the output of Catalog.authorNames.\nJoe turns his laptop so Theo can a closer look at the code. Theo takes a sip of his café au\nlait as he looks over what’s on Joe’s laptop.\nListing6.5 The code of Catalog.authorNames\nCatalog.authorNames = function (catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n};\nTheo The input of Catalog.authorNames is catalogData and authorIds. The\noutput is authorNames.\nJoe Would you do me a favor and express it visually?\nTheo Sure.\nIt’s Theo’s turn to grab a napkin. He draws a small rectangle with two inward arrows and\none outward arrow as in figure 6.2.\ncatalogData authorIds\nCatalog.authorNames()\nFigure 6.2 Visualization of the input\nauthorNames and output of Catalog.authorNames\nJoe Excellent! Now, how many combinations of input would you include in the\nunit test for Catalog.authorNames?\nTheo Let me see.\nTheo reaches for another napkin. This time he creates a table to gather his thoughts\n(table 6.1).\n--- Page 144 ---\n116 CHAPTER 6 Unit tests\nTable 6.1 The table of test cases for Catalog.authorNames\ncatalogData authorIds authorNames\nCatalog with two authors Empty array Empty array\nCatalog with two authors Array with one author ID Array with one author name\nCatalog with two authors Array with two author IDs Array with two author names\nTheo To begin with, I would have a catalogData with two author IDs and call\nCatalog.authorNames with three arguments: an empty array, an array with a\nsingle author ID, and an array with two author IDs.\nJoe How would you generate the catalogData?\nTheo Exactly as we generated it before.\nTurning to his laptop, Theo writes the code for catalogData. He shows it to Joe.\nListing6.6 A complete catalogData map\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\n--- Page 145 ---\n6.2 Unit tests for data manipulation code 117\nJoe You could use your big catalogData map for the unit test, but you could also\nuse a smaller map in the context of Catalog.authorNames. You can get rid of\nthe booksByIsbn field of the catalogData and the bookIsbns fields of the\nauthors.\nJoe deletes a few lines from catalogData and gets a much smaller map. He shows the revi-\nsion to Theo.\nListing6.7 A minimal version of catalogData\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nTheo Wait a minute! This catalogData is not valid.\nJoe In DOP, data validity depends on the context. In the context of Library\n.searchBooksByTitleJSON and Catalog.searchBooksByTitle, the mini-\nmal version of catalogData is indeed not valid. However, in the context of\nCatalog.bookInfo and Catalog.authorNames, it is perfectly valid. The reason\nis that those two functions access only the authorsById field of catalogData.\nTIP The validity of the data depends on the context.\nTheo Why is it better to use a minimal version of the data in a test case?\nJoe For a very simple reason—the smaller the data, the easier it is to manipulate.\nTIP The smaller the data, the easier it is to manipulate.\nTheo I’ll appreciate that when I write the unit tests!\nJoe Definitely! One last thing before we start coding: how would you check that the\noutput of Catalog.authorNames is as expected?\nTheo I would check that the value returned by Catalog.authorNames is an array\nwith the expected author names.\nJoe How would you handle the array comparison?\nTheo Let me think. I want to compare by value, not by reference. I guess I’ll have to\ncheck that the array is of the expected size and then check member by mem-\nber, recursively.\nJoe That’s too much of a mental burden when you’re in a coffee shop. As I showed\nyou earlier (see listing 6.1), we can recursively compare two data collections by\nvalue with _.isEqual from Lodash.\n--- Page 146 ---\n118 CHAPTER 6 Unit tests\nTIP We can compare the output and the expected output of our functions with\n_.isEqual.\nTheo Sounds good! Let me write the test cases.\nTheo starts typing on his laptop. After a few minutes, he has some test cases for Catalog\n.authorNames, each made from a function call to Catalog.authorNames wrapped in\n_.isEqual.\nListing6.8 Unit test for Catalog.authorNames\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(\ncatalogData,\n[\"alan-moore\"]),\n[\"Alan Moore\"]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\", \"dave-gibbons\"]),\n[\"Alan Moore\", \"Dave Gibbons\"]);\nJoe Well done! Can you think of more test cases?\nTheo Yes. There are test cases where the author ID doesn’t appear in the catalog\ndata, and test cases with empty catalog data. With minimal catalog data and\n_.isEqual, it’s really easy to write lots of test cases!\nTheo really enjoys this challenge. He creates a few more test cases to present to Joe.\nListing6.9 More test cases for Catalog.authorNames\n_.isEqual(Catalog.authorNames({}, []), []);\n_.isEqual(Catalog.authorNames({}, [\"alan-moore\"]), [undefined]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\",\n\"albert-einstein\"]), [\"Alan Moore\", undefined]);\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(catalogData, [\"albert-einstein\"]),\n[undefined]);\nTheo How do I run these unit tests?\nJoe You use your preferred test framework.\n--- Page 147 ---\n6.2 Unit tests for data manipulation code 119\n NOTE We don’t deal here with test runners and test frameworks. We deal only with\nthe logic of the test cases.\n6.2.3 Unit tests for nodes in the tree\nTheo I’m curious to see what unit tests for an upper node in the tree of function calls\nlook like.\nJoe Sure. Let’s write a unit test for Catalog.bookInfo. How many test cases would\nyou have for Catalog.bookInfo?\nListing6.10 The code of Catalog.bookInfo\nCatalog.bookInfo = function (catalogData, book) {\nreturn {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\n};\nTheo takes another look at the code for Catalog.bookInfo on his laptop. Then, reaching\nfor another napkin, he draws a diagram of its input and output (see figure 6.3).\ncatalogData book\nCatalog.bookInfo()\nFigure 6.3 Visualization of the input\nbookInfo and output of Catalog.bookInfo\nTheo I would have a similar number of test cases for Catalog.authorNames: a book\nwith a single author, with two authors, with existing authors, with non-existent\nauthors, with...\nJoe Whoa! That’s not necessary. Given that we have already written unit tests for\nCatalog.authorNames, we don’t need to check all the cases again. We simply\nneed to write a minimal test case to confirm that the code works.\nTIP When we write a unit test for a function, we assume that the functions called by\nthis function are covered by unit tests and work as expected. It significantly reduces\nthe quantity of test cases in our unit tests.\nTheo That makes sense.\nJoe How would you write a minimal test case for Catalog.bookInfo?\nTheo once again takes a look at the code for Catalog.bookInfo (see listing 6.10). Now he\ncan answer Joe’s question.\n--- Page 148 ---\n120 CHAPTER 6 Unit tests\nTheo I would use the same catalog data as for Catalog.authorNames and a book\nrecord. I’d test that the function behaves as expected by comparing its return\nvalue with a book info record using _.isEqual. Here, let me show you.\nIt takes Theo a bit more time to write the unit test. The reason is that the input and the\noutput of Catalog.authorNames are both records. Dealing with a record is more complex\nthan dealing with an array of strings (as it was the case for Catalog.authorNames). Theo\nappreciates the fact that _.isEqual saves him from writing code that compares the two\nmaps property by property. When he’s through, he shows the result to Joe and takes a nap-\nkin to wipe his forehead.\nListing6.11 Unit test for Catalog.bookInfo\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nvar book = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n};\nvar expectedResult = {\n\"authorNames\": [\"Alan Moore\", \"Dave Gibbons\"],\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n};\nvar result = Catalog.bookInfo(catalogData, book);\n_.isEqual(result, expectedResult);\nJoe Perfect! Now, how would you compare the kind of unit tests for Catalog\n.bookInfo with the unit tests for Catalog.authorNames?\nTheo On one hand, there is only a single test case in the unit test for Catalog.book-\nInfo. On the other hand, the data involved in the test case is more complex\nthan the data involved in the test cases for Catalog.authorNames.\nJoe Exactly! Functions that appear in a deep node in the tree of function calls tend\nto require more test cases, but the data involved in the test cases is less complex.\nTIP Functions that appear in a lower level in the tree of function calls tend to\ninvolve less complex data than functions that appear in a higher level in the tree\n(see table 6.2).\n--- Page 149 ---\n6.3 Unit tests for queries 121\nTable 6.2 The correlation between the depth of a function in the tree of function calls and the\nquality and quantity of the test cases\nDepth in the tree Complexity of the data Number of test cases\nLower Higher Lower\nHigher Lower Higher\n6.3 Unit tests for queries\nIn the previous section, we saw how to write unit tests for utility functions like Catalog\n.bookInfo and Catalog.authorNames. Now, we are going to see how to write unit tests\nfor the nodes of a query tree of function calls that are close to the root of the tree.\nJoe Theo, how would you write a unit test for the code of the entry point of the\nsearch query?\nTo recall the particulars, Theo checks the code for Library.searchBooksByTitleJSON.\nAlthough Joe was right about today’s topic being easy enough to enjoy the ambience of a\ncoffee shop, he has been doing quite a lot of coding this morning.\nListing6.12 The code of Library.searchBooksByTitleJSON\nLibrary.searchBooksByTitleJSON = function (libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n};\nHe then takes a moment to think about how he’d write a unit test for that code. After\nanother Aha! moment, now he’s got it.\nTheo The inputs of Library.searchBooksByTitleJSON are library data and a\nquery string, and the output is a JSON string (see figure 6.4). So, I would cre-\nate a library data record with a single book and write tests with query strings\nthat match the name of the book and ones that don’t match.\nlibraryData query\nLibrary.searchBooksByTitleJSON()\nFigure 6.4 The input and output of\nresultsJSON Library.searchBooksByTitleJSON\nJoe What about the expected results of the test cases?\n--- Page 150 ---\n122 CHAPTER 6 Unit tests\nTheo In cases where the query string matches, the expected result is a JSON string\nwith the book info. In cases where the query string doesn’t match, the\nexpected result is a JSON string with an empty array.\nJoe Hmm...\nTheo What?\nJoe I don’t like your answer.\nTheo Why?\nJoe Because your test case relies on a string comparison instead of a data comparison.\nTheo What difference does it make? After all, the strings I’m comparing come from\nthe serialization of data.\nJoe It’s inherently much more complex to compare JSON strings than it is to com-\npare data. For example, two different strings might be the serialization of the\nsame piece of data.\nTheo Really? How?\nJoe Take a look at these two strings. They are the serialization of the same data.\nThey’re different strings because the fields appear in a different order, but in\nfact, they serialize the same data!\nJoe turns his laptop to Theo. As Theo looks at the code, he realizes that, once again, Joe\niscorrect.\nListing6.13 Two different strings that serialize the same data\nvar stringA = \"{\\\"title\\\":\\\"Watchmen\\\",\\\"publicationYear\\\":1987}\";\nvar stringB = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nTIP Avoid using a string comparison in unit tests for functions that deal with data.\nTheo I see.... Well, what can I do instead?\nJoe Instead of comparing the output of Library.searchBooksByTitleJSON with\na string, you could deserialize the output and compare it to the expected data.\nTheo What do you mean by deserialize a string?\nJoe Deserializing a string s, for example, means to generate a piece of data whose\nserialization is s.\nTheo Is there a Lodash function for string deserialization?\nJoe Actually, there is a native JavaScript function for string deserialization; it’s\ncalled JSON.parse.\nJoe retrieves his laptop and shows Theo an example of string deserialization. The code\nillustrates a common usage of JSON.parse.\nListing6.14 Example of string deserialization\nvar myString = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nvar myData = JSON.parse(myString);\n--- Page 151 ---\n6.3 Unit tests for queries 123\n_.get(myData, \"title\");\n// → \"Watchmen\"\nTheo Cool! Let me try writing a unit test for Library.searchBooksByTitleJSON\nusing JSON.parse.\nIt doesn’t take Theo too much time to come up with a piece of code. Using his laptop, he\ninputs the unit test.\nListing6.15 Unit test for Library.searchBooksByTitleJSON\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Watchmen\")),\n[bookInfo]);\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Batman\")),\n[]);\nJoe Well done! I think you’re ready to move on to the last piece of the puzzle and\nwrite the unit test for Catalog.searchBooksByTitle.",
        "sections_found": []
      },
      "accurate_page_range": "126-151"
    },
    {
      "text": "- 5.5 Implementing the reconciliation algorithm",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "raw_line": "- 5.5 Implementing the reconciliation algorithm (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 43,
      "chapter_info": {
        "page": 126,
        "title": "Basic concurrency control",
        "pattern_matched": "Chapter 5",
        "text_preview": "98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. "
      },
      "chapter_sections": {
        "start_page": 126,
        "end_page": 151,
        "content": "\n--- Page 126 ---\n98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. It means that the first call to f will be f(0, 1). Then,\nwe’ll have f(f(0, 1), 2) and, finally, f(f(f(0, 1), 2), 3).\nJoe I like your manual expansion, Theo! Let’s make it visual.\nNow Theo goes to the whiteboard and draws a diagram. Figure 5.5 shows what that looks like.\nf\nf a\n2\nf a\n1\na 0 initVal Figure 5.5 Visualization\nof _.reduce\nTheo It’s much clearer now. I think that by implementing my custom version of\n_.reduce, it will make things 100% clear.\nIt takes Theo much less time than he expected to implement reduce(). In no time at all,\nhe shows Joe the code.\nListing5.2 Custom implementation of _.reduce\nfunction reduce(coll, f, initVal) {\nvar currentRes = initVal;\nfor (var i = 0; i < coll.length; i++) {\nWe could use\ncurrentRes = f(currentRes, coll[i])\nforEach instead\n}\nof a for loop.\nreturn currentRes;\n}\nAfter checking that Theo’s code works as expected (see listing 5.3), Joe is proud of Theo.\nHe seems to be catching on better than he anticipated.\nListing5.3 Testing the custom implementation of reduce()\nreduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nJoe Well done!\n--- Page 127 ---\n5.4 Structural difference 99\n5.4 Structural difference\n NOTE This section deals with the implementation of a structural diff algorithm. Feel\nfree to skip this section if you don’t want to challenge your mind right now with the\ndetails of a sophisticated use of recursion. It won’t prevent you from enjoying the rest\nof the book. You can come back to this section later.\nTheo How do you calculate the diff between various versions of the system state?\nJoe That’s the most challenging part of the reconciliation algorithm. We need to\nimplement a structural diff algorithm for hash maps.\nTheo In what sense is the diff structural?\nJoe The structural diff algorithm looks at the structure of the hash maps and\nignores the order of the fields.\nTheo Could you give me an example?\nJoe Let’s start with maps without nested fields. Basically, there are three kinds of\ndiffs: field replacement, field addition, and field deletion. In order to make\nthings not too complicated, for now, we’ll deal only with replacement and\naddition.\nJoe once again goes to the whiteboard and draws table 5.3, representing the three kinds of\ndiffs. Theo is thinking the whiteboard is really starting to fill up today.\nTable 5.3 Kinds of structural differences between maps without nested fields\nKind First map Second map Diff\nReplacement {\"a\": 1} {\"a\": 2} {\"a\": 2}\nAddition {\"a\": 1} {\"a\": 1, \"b\": 2} {\"b\": 2}\nDeletion {\"a\": 1, \"b\": 2} {\"a\": 1} Not supported\nTheo I notice that the order of the maps matters a lot. What about nested fields?\nJoe It’s the same idea, but the nesting makes it a bit more difficult to grasp.\nJoe changes several of the columns in table 5.3. When he’s through, he shows Theo the\nnested fields in table 5.4.\nTable 5.4 Kinds of structural differences between maps with nested fields\nKind First map Second map Diff\nReplacement { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 2 \"x\": 2\n} } }\n} } }\n--- Page 128 ---\n100 CHAPTER 5 Basic concurrency control\nTable 5.4 Kinds of structural differences between maps with nested fields (continued)\nKind First map Second map Diff\nAddition { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 1, \"y\": 2\n} \"y\": 2, }\n} } }\n}\nDeletion { { Not supported\n\"a\": { \"a\": {\n\"x\": 1, \"y\": 2\n\"y\": 2, }\n} }\n}\n NOTE The version of the structural diff algorithm illustrated in this chapter does\nnot deal with deletions. Dealing with deletions is definitely possible, but it requires a\nmore complicated algorithm.\nTheo As you said, it’s harder to grasp. What about arrays?\nJoe We compare the elements of the arrays in order: if they are equal, the diff is\nnull; if they differ, the diff has the value of the second array.\nJoe summarizes the various kinds of diffs in another table on the whiteboard. Theo looks\nat the result in table 5.5.\nTable 5.5 Kinds of structural differences between arrays without nested elements\nKind First array Second array Diff\nReplacement [1] [2] [2]\nAddition [1] [1, 2] [null, 2]\nDeletion [1, 2] [1] Not supported\nTheo This usage of null is a bit weird but OK. Is it complicated to implement the\nstructural diff algorithm?\nJoe Definitely! It took a good dose of mental gymnastics to come up with these 30\nlines of code.\nJoe downloads the code from one his personal repositories. Theo, with thumb and forefin-\ngers touching his chin and his forehead slightly tilted, studies the code.\nListing5.4 The implementation of a structural diff\nfunction diffObjects(data1, data2) {\n_.isArray checks whether\nvar emptyObject = _.isArray(data1) ? [] : {};\nits argument is an array.\nif(data1 == data2) {\n--- Page 129 ---\n5.4 Structural difference 101\nreturn emptyObject;\n_.union creates an\n} array of unique\nvar keys = _.union(_.keys(data1), _.keys(data2)); values from two\nreturn _.reduce(keys, arrays (like union of\nfunction (acc, k) { two sets in Maths).\nvar res = diff(\n_.get(data1, k),\n_.isObject checks\n_.get(data2, k));\nwhether its argument\nif((_.isObject(res) && _.isEmpty(res)) ||\nis a collection (either\na map or an array).\n(res == \"no-diff\")) {\nreturn acc;\n_.isEmpty }\nchecks return _.set(acc, [k], res);\nwhether its },\nargument\nemptyObject);\nis an empty\n} \"no-diff\" is how\ncollection.\nwe mark that\nfunction diff(data1, data2) { two values are\nif(_.isObject(data1) && _.isObject(data2)) { the same.\nreturn diffObjects(data1, data2);\n}\nif(data1 !== data2) {\nreturn data2;\n}\nreturn \"no-diff\";\n}\nTheo Wow! It involves a recursion inside a reduce! I’m sure Dave will love this, but\nI’m too tired to understand this code right now. Let’s focus on what it does\ninstead of how it does it.\nIn order familiarize himself with the structural diff algorithm, Theo runs the algorithm\nwith examples from the table that Joe drew on the whiteboard. While Theo occupies his\nfingers with more and more complicated examples, his mind wanders in the realm of\nperformance.\nListing5.5 An example of usage of a structural diff\nvar data1 = {\n\"a\": {\n\"x\": 1,\n\"y\": [2, 3],\n\"z\": 4\n}\n};\nvar data2 = {\n\"a\": {\n\"x\": 2,\n\"y\": [2, 4],\n\"z\": 4\n}\n}\n--- Page 130 ---\n102 CHAPTER 5 Basic concurrency control\ndiff(data1, data2);\n//{\n// \"a\": {\n// \"x\": 2,\n// \"y\": [\n// undefined,\n// 4\n// ]\n// }\n//}\nTheo What about the performance of the structural diff algorithm? It seems that the\nalgorithm goes over the leaves of both pieces of data?\nJoe In the general case, that’s true. But, in the case of system data that’s manipu-\nlated with structural sharing, the code is much more efficient.\nTheo What do you mean?\nJoe With structural sharing, most of the nested objects are shared between two ver-\nsions of the system state. Therefore, most of the time, when the code enters\ndiffObjects, it will immediately return because data1 and data2 are the same.\nTIP Calculating the diff between two versions of the state is efficient because two\nhash maps created via structural sharing from the same hash map have most of their\nnodes in common.\nTheo Another benefit of immutable data... Let me see how the diff algorithm\nbehaves with concurrent mutations. I think I’ll start with a tiny library with no\nusers and a catalog with a single book, Watchmen.\nListing5.6 The data for a tiny library\nvar library = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\n--- Page 131 ---\n5.4 Structural difference 103\nJoe I suggest that we start with nonconflicting mutations. What do you suggest?\nTheo A mutation that updates the publication year of Watchmen and a mutation that\nupdates both the title of Watchmen and the name of the author of Watchmen.\nOn his laptop, Theo creates three versions of the library. He shows Joe his code, where one\nmutation updates the publication year of Watchmen, and the other one updates the title of\nWatchmen and the author’s name.\nListing5.7 Two nonconflicting mutations\nvar previous = library;\nvar next = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"],\n1986);\nvar libraryWithUpdatedTitle = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"],\n\"The Watchmen\");\nvar current = _.set(\nlibraryWithUpdatedTitle,\n[\"catalog\", \"authorsById\", \"dave-gibbons\", \"name\"],\n\"David Chester Gibbons\");\nTheo I’m curious to see what the diff between previous and current looks like.\nJoe Run the code and you’ll see.\nTheo runs the code snippets for the structural diff between previous and next and for\nthe structural diff between previous and current. His curiosity satisfied, Theo finds it’s\nall beginning to make sense.\nListing5.8 Structural diff between maps with a single difference\ndiff(previous, next);\n//{\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"publicationYear\": 1986\n// }\n// }\n// }\n//}\nListing5.9 Structural diff between maps with two differences\ndiff(previous, current);\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\",\n--- Page 132 ---\n104 CHAPTER 5 Basic concurrency control\n// }\n// },\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\n//\nJoe Can you give me the information path of the single field in the structural diff\nbetween previous and next?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Right. And what are the information paths of the fields in the structural diff\nbetween previous and current?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"] for the book\ntitle and [\"authorsById\", \"dave-gibbons\", \"name\"] for the author’s name.\nJoe Perfect! Now, can you figure out how to detect conflicting mutations by\ninspecting the information paths of the structural diffs?\nTheo We need to check if they have an information path in common or not.\nJoe Exactly! If they have, it means the mutations are conflicting.\nTheo But I have no idea how to write code that retrieves the information paths of a\nnested map.\nJoe Once again, it’s a nontrivial piece of code that involves a recursion inside a\nreduce. Let me download another piece of code from my repository and show\nit to you.\nListing5.10 Calculating the information paths of a (nested) map\nfunction informationPaths (obj, path = []) {\nreturn _.reduce(obj,\nfunction(acc, v, k) {\nif (_.isObject(v)) {\nreturn _.concat(acc,\ninformationPaths(v,\n_.concat(path, k)));\n}\nreturn _.concat(acc, [_.concat(path, k)]);\n},\n[]);\n}\nTheo Let me see if your code works as expected with the structural diffs of the\nmutations.\nTheo tests Joe’s code with two code snippets. The first shows the information paths of the\nstructural diff between previous and next, and the second shows the information paths\nof the structural diff between previous and current.\n--- Page 133 ---\n5.4 Structural difference 105\nListing5.11 Fields that differ between previous and next\ninformationPaths(diff(previous, next));\n// → [\"catalog.booksByIsbn.978-1779501127.publicationYear\"]\nListing5.12 Fields that differ between previous and current\ninformationPaths(diff(previous, current));\n// [\n// [\n// \"catalog\",\n// \"booksByIsbn\",\n// \"978-1779501127\",\n// \"title\"\n// ],\n// [\n// \"authorsById\",\n// \"dave-gibbons\",\n// \"name\"\n// ]\n//]\nTheo Nice! I assume that Lodash has a function that checks whether two arrays have\nan element in common.\nJoe Almost. There is _.intersection, which returns an array of the unique values\nthat are in two given arrays. For our purpose, though, we need to check\nwhether the intersection is empty. Here, look at this example.\nListing5.13 Checking whether two diff maps have a common information path\nfunction havePathInCommon(diff1, diff2) {\nreturn !_.isEmpty(_.intersection(informationPaths(diff1),\ninformationPaths(diff2)));\n}\nTheo You told me earlier that in the case of nonconflicting mutations, we can\nsafely patch the changes induced by the transition from previous to next\ninto current. How do you implement that?\nJoe We do a recursive merge between current and the diff between previous and\nnext.\nTheo Does Lodash provide an immutable version of recursive merge?\nJoe Yes, here’s another example. Take a look at this code.\nListing5.14 Applying a patch\n_.merge(current, (diff(previous, next)));\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\"\n// }\n// },\n--- Page 134 ---\n106 CHAPTER 5 Basic concurrency control\n// \"catalog\": {\n// \"authorsById\": {\n// \"alan-moore\": {\n// \"bookIsbns\": [\"978-1779501127\"]\n// \"name\": \"Alan Moore\"\n// },\n// \"dave-gibbons\": {\n// \"bookIsbns\": [\"978-1779501127\"],\n// \"name\": \"Dave Gibbons\"\n// },\n// },\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n// \"isbn\": \"978-1779501127\",\n// \"publicationYear\": 1986,\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\nTheo Could it be as simple as this?\nJoe Indeed.\n5.5 Implementing the reconciliation algorithm\nJoe All the pieces are now in place to implement our reconciliation algorithm.\nTheo What kind of changes are required?\nJoe It only requires changes in the code of SystemState.commit. Here, look at\nthis example on my laptop.\nListing5.15 The SystemState class\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nvar nextSystemData = SystemConsistency.reconcile(\nthis.systemData,\nSystemConsistency class is\nprevious,\nimplemented in listing 5.16.\nnext);\nif(!SystemValidity.validate(previous, nextSystemData)) {\nthrow \"The system data to be committed is not valid!\";\n};\n--- Page 135 ---\n5.5 Implementing the reconciliation algorithm 107\nthis.systemData = nextSystemData;\n}\n}\nTheo How does SystemConsistency do the reconciliation?\nJoe The SystemConsistency class starts the reconciliation process by comparing\nprevious and current. If they are the same, then we fast-forward and return\nnext. Look at this code for SystemConsistency.\nListing5.16 The reconciliation flow in action\nclass SystemConsistency {\nstatic threeWayMerge(current, previous, next) {\nvar previousToCurrent = diff(previous, current);\nvar previousToNext = diff(previous, next);\nif(havePathInCommon(previousToCurrent, previousToNext)) { When the system\nreturn _.merge(current, previousToNext); state is the same\n} as the state used\nthrow \"Conflicting concurrent mutations.\"; by the calculation\n} phase, we fast-\nstatic reconcile(current, previous, next) { forward.\nif(current == previous) {\nreturn next;\n}\nreturn SystemConsistency.threeWayMerge(current,\nprevious,\nnext);\n}\n}\nTheo Wait a minute! Why do you compare previous and current by reference?\nYou should be comparing them by value, right? And, it would be quite expen-\nsive to compare all the leaves of the two nested hash maps!\nJoe That’s another benefit of immutable data. When the data is not mutated, it is\nsafe to compare references. If they are the same, we know for sure that the data\nis the same.\nTIP When data is immutable, it is safe to compare by reference, which is super fast.\nWhen the references are the same, it means that the data is the same.\nTheo What about the implementation of the three-way merge algorithm?\nJoe When previous differs from current, it means that concurrent mutations\nhave run. In order to determine whether there is a conflict, we calculate two\ndiffs: the diff between previous and current and the diff between previous\nand next. If the intersection between the two diffs is empty, it means there is\nno conflict. We can safely patch the changes between previous to next into\ncurrent.\nTheo takes a closer look at the code for the SystemConsistency class in listing 5.16. He\ntries to figure out if the code is thread-safe or not.\n--- Page 136 ---\n108 CHAPTER 5 Basic concurrency control\nTheo I think the code for SystemConsistency class is not thread-safe! If there’s a\ncontext switch between checking whether the system has changed in the\nSystemConsistency class and the updating of the state in SystemData class, a\nmutation might override the changes of a previous mutation.\nJoe You are totally right! The code works fine in a single-threaded environment\nlike JavaScript, where concurrency is handled via an event loop. However, in a\nmulti-threaded environment, the code needs to be refined in order to be\nthread-safe. I’ll show you some day.\n NOTE The SystemConsistency class is not thread-safe. We will make it thread-safe\nin chapter 8.\nTheo I think I understand why you called it optimistic concurrency control. It’s\nbecause we assume that conflicts don’t occur too often. Right?\nJoe Correct! It makes me wonder what your therapist would say about conflicts that\ncannot be resolved. Are there some cases where it’s not possible to reconcile\nthe couple?\nTheo I don’t think she ever mentioned such a possibility.\nJoe She must be a very optimistic person.\nSummary\n Optimistic concurrency control allows mutations to ask forgiveness instead of\npermission.\n Optimistic concurrency control is lock-free.\n Managing concurrent mutations of our system state with optimistic concurrency\ncontrol allows our system to support a high throughput of reads and writes.\n Optimistic concurrency control with immutable data is super efficient.\n Before updating the state, we need to reconcile the conflicts between possible con-\ncurrent mutations.\n We reconcile between concurrent mutations in a way that is similar to how Git han-\ndles a merge between two branches: either a fast-forward or a three-way merge.\n The changes required to let our system manage concurrency are only in the\ncommit phase.\n The calculation phase does its calculation as if it were the only mutation running.\n The commit phase is responsible for trying to reconcile concurrent mutations.\n The reconciliation algorithm is universal in the sense that it can be used in any sys-\ntem where the system data is represented as an immutable hash map.\n The implementation of the reconciliation algorithm is efficient, as it leverages\nthe fact that subsequent versions of the system state are created via structural\nsharing.\n In a user-facing system, conflicting concurrent mutations are fairly rare.\n When we cannot safely reconcile between concurrent mutations, we abort the\nmutation and ask the user to try again.\n--- Page 137 ---\nSummary 109\n Calculating the structural diff between two versions of the state is efficient because\ntwo hash maps created via structural sharing from the same hash map have most\nof their nodes in common.\n When data is immutable, it is safe to compare by reference, which is fast. When\nthe references are the same, it means that the data is the same.\n There are three kinds of structural differences between two nested hash maps:\nreplacement, addition, and deletion.\n Our structural diff algorithm supports replacements and additions but not\ndeletions.\nLodash functions introduced in this chapter\nFunction Description\nconcat(arrA, arrB) Creates an new array, concatenating arrA and arrB\nintersection(arrA, arrB) Creates an array of unique values both in arrA and arrB\nunion(arrA, arrB) Creates an array of unique values from arrA and arrB\nfind(coll, pred) Iterates over elements of coll, returning the first element for\nwhich pred returns true\nisEmpty(coll) Checks if coll is empty\nreduce(coll, f, initVal) Reduces coll to a value that is the accumulated result of running\neach element in coll through f, where each successive invoca-\ntion is supplied the return value of the previous\nisArray(coll) Checks if coll is an array\nisObject(coll) Checks if coll is a collection\n--- Page 138 ---\nUnit tests\nProgramming at a coffee shop\nThis chapter covers\n Generation of the minimal data input for a\ntest case\n Comparison of the output of a function with\nthe expected output\n Guidance about the quality and the quantity\nof the test cases\nIn a data-oriented system, our code deals mainly with data manipulation: most of\nour functions receive data and return data. As a consequence, it’s quite easy to\nwrite unit tests to check whether our code behaves as expected. A unit test is made\nof test cases that generate data input and compare the data output of the function\nwith the expected data output. In this chapter, we write unit tests for the queries\nand mutations that we wrote in the previous chapters.\n6.1 The simplicity of data-oriented test cases\nTheo and Joe are seated around a large wooden table in a corner of “La vie est belle,” a\nnice little French coffee shop, located near the Golden Gate Bridge. Theo orders a café\nau lait with a croissant, and Joe orders a tight espresso with a pain au chocolat. Instead\nof the usual general discussions about programming and life when they’re out of the\n110\n--- Page 139 ---\n6.1 The simplicity of data-oriented test cases 111\noffice, Joe leads the discussion towards a very concrete topic—unit tests. Theo asks Joe for\nan explanation.\nTheo Are unit tests such a simple topic that we can tackle it here in a coffee shop?\nJoe Unit tests in general, no. But unit tests for data-oriented code, yes!\nTheo Why does that make a difference?\nJoe The vast majority of the code base of a data-oriented system deals with data\nmanipulation.\nTheo Yeah. I noticed that almost all the functions we wrote so far receive data and\nreturn data.\nTIP Most of the code in a data-oriented system deals with data manipulation.\nJoe Writing a test case for functions that deal with data is only about generating\ndata input and expected output, and comparing the output of the function\nwith the expected output.\nThe steps of a test case\n1 Generate data input: dataIn\n2 Generate expected output: dataOut\n3 Compare the output of the function with the expected output: f(dataIn) and\ndataOut\nTheo That’s it?\nJoe Yes. As you’ll see in a moment, in DOP, there’s usually no need for mock\nfunctions.\nTheo I understand how to compare primitive values like strings or numbers, but I’m\nnot sure how I would compare data collections like maps.\nJoe You compare field by field.\nTheo Recursively?\nJoe Yes!\nTheo Oh no! I’m not able to write any recursive code in a coffee shop. I need the\ncalm of my office for that kind of stuff.\nJoe Don’t worry. In DOP, data is represented in a generic way. There is a generic\nfunction in Lodash called _.isEqual for recursive comparison of data collec-\ntions. It works with both maps and arrays.\nJoe opens his laptop. He is able to convince Theo by executing a few code snippets with\n_.isEqual to compare an equal data collection with a non-equal one.\nListing6.1 Comparing an equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n--- Page 140 ---\n112 CHAPTER 6 Unit tests\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n});\n// → true\nListing6.2 Comparing a non-equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"bad-isbn\"]\n});\n// → false\nTheo Nice!\nJoe Most of the test cases in DOP follow this pattern.\nTheo decides he wants to try this out. He fires up his laptop and types a few lines of\npseudocode.\nListing6.3 The general pattern of a data-oriented test case\nvar dataIn = {\n// input\n};\nvar dataOut = {\n// expected output\n};\n_.isEqual(f(dataIn), dataOut);\nTIP It’s straightforward to write unit tests for code that deals with data manipulation.\nTheo Indeed, this looks like something we can tackle in a coffee shop!\n6.2 Unit tests for data manipulation code\nA waiter in an elegant bow tie brings Theo his croissant and Joe his pain au chocolat. The\ntwo friends momentarily interrupt their discussion to savor their French pastries. When\nthey’re done, they ask the waiter to bring them their drinks. Meanwhile, they resume the\ndiscussion.\nJoe Do you remember the code flow of the implementation of the search query?\nTheo Let me look again at the code that implements the search query.\nTheo brings up the implementation of the search query on his laptop. Noticing that Joe is\nchewing on his nails again, he quickly checks out the code.\n--- Page 141 ---\n6.2 Unit tests for data manipulation code 113\nListing6.4 The code involved in the implementation of the search query\nclass Catalog {\nstatic authorNames(catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n}\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\nreturn bookInfo;\n}\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\n}\n6.2.1 The tree of function calls\nThe waiter brings Theo his café au lait and Joe his tight espresso. They continue their dis-\ncussion while enjoying their coffees.\nJoe Before writing a unit test for a code flow, I find it useful to visualize the tree of\nfunction calls of the code flow.\nTheo What do you mean by a tree of function calls?\nJoe Here, I’ll draw the tree of function calls for the Library.searchBooksBy-\nTitleJSON code flow.\nJoe puts down his espresso and takes a napkin from the dispenser. He carefully places it\nflat on the table and starts to draw. When he is done, he shows the illustration to Theo (see\nfigure 6.1).\n--- Page 142 ---\n114 CHAPTER 6 Unit tests\nLibrary.searchBooksByTitleJSON\n_.get JSON.stringify Catalog.searchBooksByTitle\n_.get _.map _.filter Catalog.bookInfo\n_.get Catalog.authorNames\n_.get _.map\nFigure 6.1 The tree of function calls for the search query code flow\nTheo Nice! Can you teach me how to draw a tree of function calls like that?\nJoe Sure. The root of the tree is the name of the function for which you draw the\ntree, in our case, Library.searchBooksByTitleJSON. The children of a\nnode in the tree are the names of the functions called by the function. For exam-\nple, if you look again at the code for Library.searchBooksByTitleJSON (list-\ning 6.4), you’ll see that it calls Catalog.searchBooksByTitle, _.get, and\nJSON.stringify.\nTheo How long would I continue to recursively expand the tree?\nJoe You continue until you reach a function that doesn’t belong to the code base\nof your application. Those nodes are the leaves of our tree; for example, the\nfunctions from Lodash: _.get, _.map, and so forth.\nTheo What if the code of a function doesn’t call any other functions?\nJoe A function that doesn’t call any other function would be a leaf in the tree.\nTheo What about functions that are called inside anonymous functions like Catalog\n.bookInfo?\nJoe Catalog.bookInfo appears in the code of Catalog.searchBooksByTitle.\nTherefore, it is considered to be a child node of Catalog.searchBooksBy-\nTitle. The fact that it is nested inside an anonymous function is not relevant\nin the context of the tree of function calls.\n NOTE A tree of function calls for a function f is a tree where the root is f, and the\nchildren of a node g in the tree are the functions called by g. The leaves of the tree are\nfunctions that are not part of the code base of the application. These are functions\nthat don’t call any other functions.\nTheo It’s very cool to visualize my code as a tree, but I don’t see how it relates to\nunittests.\n--- Page 143 ---\n6.2 Unit tests for data manipulation code 115\nJoe The tree of function calls guides us about the quality and the quantity of test\ncases we should write.\nTheo How?\nJoe You’ll see in a moment.\n6.2.2 Unit tests for functions down the tree\nJoe Let’s start from the function that appears in the deepest node in our tree:\nCatalog.authorNames. Take a look at the code for Catalog.authorNames\nand tell me what are the input and the output of Catalog.authorNames.\nJoe turns his laptop so Theo can a closer look at the code. Theo takes a sip of his café au\nlait as he looks over what’s on Joe’s laptop.\nListing6.5 The code of Catalog.authorNames\nCatalog.authorNames = function (catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n};\nTheo The input of Catalog.authorNames is catalogData and authorIds. The\noutput is authorNames.\nJoe Would you do me a favor and express it visually?\nTheo Sure.\nIt’s Theo’s turn to grab a napkin. He draws a small rectangle with two inward arrows and\none outward arrow as in figure 6.2.\ncatalogData authorIds\nCatalog.authorNames()\nFigure 6.2 Visualization of the input\nauthorNames and output of Catalog.authorNames\nJoe Excellent! Now, how many combinations of input would you include in the\nunit test for Catalog.authorNames?\nTheo Let me see.\nTheo reaches for another napkin. This time he creates a table to gather his thoughts\n(table 6.1).\n--- Page 144 ---\n116 CHAPTER 6 Unit tests\nTable 6.1 The table of test cases for Catalog.authorNames\ncatalogData authorIds authorNames\nCatalog with two authors Empty array Empty array\nCatalog with two authors Array with one author ID Array with one author name\nCatalog with two authors Array with two author IDs Array with two author names\nTheo To begin with, I would have a catalogData with two author IDs and call\nCatalog.authorNames with three arguments: an empty array, an array with a\nsingle author ID, and an array with two author IDs.\nJoe How would you generate the catalogData?\nTheo Exactly as we generated it before.\nTurning to his laptop, Theo writes the code for catalogData. He shows it to Joe.\nListing6.6 A complete catalogData map\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\n--- Page 145 ---\n6.2 Unit tests for data manipulation code 117\nJoe You could use your big catalogData map for the unit test, but you could also\nuse a smaller map in the context of Catalog.authorNames. You can get rid of\nthe booksByIsbn field of the catalogData and the bookIsbns fields of the\nauthors.\nJoe deletes a few lines from catalogData and gets a much smaller map. He shows the revi-\nsion to Theo.\nListing6.7 A minimal version of catalogData\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nTheo Wait a minute! This catalogData is not valid.\nJoe In DOP, data validity depends on the context. In the context of Library\n.searchBooksByTitleJSON and Catalog.searchBooksByTitle, the mini-\nmal version of catalogData is indeed not valid. However, in the context of\nCatalog.bookInfo and Catalog.authorNames, it is perfectly valid. The reason\nis that those two functions access only the authorsById field of catalogData.\nTIP The validity of the data depends on the context.\nTheo Why is it better to use a minimal version of the data in a test case?\nJoe For a very simple reason—the smaller the data, the easier it is to manipulate.\nTIP The smaller the data, the easier it is to manipulate.\nTheo I’ll appreciate that when I write the unit tests!\nJoe Definitely! One last thing before we start coding: how would you check that the\noutput of Catalog.authorNames is as expected?\nTheo I would check that the value returned by Catalog.authorNames is an array\nwith the expected author names.\nJoe How would you handle the array comparison?\nTheo Let me think. I want to compare by value, not by reference. I guess I’ll have to\ncheck that the array is of the expected size and then check member by mem-\nber, recursively.\nJoe That’s too much of a mental burden when you’re in a coffee shop. As I showed\nyou earlier (see listing 6.1), we can recursively compare two data collections by\nvalue with _.isEqual from Lodash.\n--- Page 146 ---\n118 CHAPTER 6 Unit tests\nTIP We can compare the output and the expected output of our functions with\n_.isEqual.\nTheo Sounds good! Let me write the test cases.\nTheo starts typing on his laptop. After a few minutes, he has some test cases for Catalog\n.authorNames, each made from a function call to Catalog.authorNames wrapped in\n_.isEqual.\nListing6.8 Unit test for Catalog.authorNames\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(\ncatalogData,\n[\"alan-moore\"]),\n[\"Alan Moore\"]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\", \"dave-gibbons\"]),\n[\"Alan Moore\", \"Dave Gibbons\"]);\nJoe Well done! Can you think of more test cases?\nTheo Yes. There are test cases where the author ID doesn’t appear in the catalog\ndata, and test cases with empty catalog data. With minimal catalog data and\n_.isEqual, it’s really easy to write lots of test cases!\nTheo really enjoys this challenge. He creates a few more test cases to present to Joe.\nListing6.9 More test cases for Catalog.authorNames\n_.isEqual(Catalog.authorNames({}, []), []);\n_.isEqual(Catalog.authorNames({}, [\"alan-moore\"]), [undefined]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\",\n\"albert-einstein\"]), [\"Alan Moore\", undefined]);\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(catalogData, [\"albert-einstein\"]),\n[undefined]);\nTheo How do I run these unit tests?\nJoe You use your preferred test framework.\n--- Page 147 ---\n6.2 Unit tests for data manipulation code 119\n NOTE We don’t deal here with test runners and test frameworks. We deal only with\nthe logic of the test cases.\n6.2.3 Unit tests for nodes in the tree\nTheo I’m curious to see what unit tests for an upper node in the tree of function calls\nlook like.\nJoe Sure. Let’s write a unit test for Catalog.bookInfo. How many test cases would\nyou have for Catalog.bookInfo?\nListing6.10 The code of Catalog.bookInfo\nCatalog.bookInfo = function (catalogData, book) {\nreturn {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\n};\nTheo takes another look at the code for Catalog.bookInfo on his laptop. Then, reaching\nfor another napkin, he draws a diagram of its input and output (see figure 6.3).\ncatalogData book\nCatalog.bookInfo()\nFigure 6.3 Visualization of the input\nbookInfo and output of Catalog.bookInfo\nTheo I would have a similar number of test cases for Catalog.authorNames: a book\nwith a single author, with two authors, with existing authors, with non-existent\nauthors, with...\nJoe Whoa! That’s not necessary. Given that we have already written unit tests for\nCatalog.authorNames, we don’t need to check all the cases again. We simply\nneed to write a minimal test case to confirm that the code works.\nTIP When we write a unit test for a function, we assume that the functions called by\nthis function are covered by unit tests and work as expected. It significantly reduces\nthe quantity of test cases in our unit tests.\nTheo That makes sense.\nJoe How would you write a minimal test case for Catalog.bookInfo?\nTheo once again takes a look at the code for Catalog.bookInfo (see listing 6.10). Now he\ncan answer Joe’s question.\n--- Page 148 ---\n120 CHAPTER 6 Unit tests\nTheo I would use the same catalog data as for Catalog.authorNames and a book\nrecord. I’d test that the function behaves as expected by comparing its return\nvalue with a book info record using _.isEqual. Here, let me show you.\nIt takes Theo a bit more time to write the unit test. The reason is that the input and the\noutput of Catalog.authorNames are both records. Dealing with a record is more complex\nthan dealing with an array of strings (as it was the case for Catalog.authorNames). Theo\nappreciates the fact that _.isEqual saves him from writing code that compares the two\nmaps property by property. When he’s through, he shows the result to Joe and takes a nap-\nkin to wipe his forehead.\nListing6.11 Unit test for Catalog.bookInfo\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nvar book = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n};\nvar expectedResult = {\n\"authorNames\": [\"Alan Moore\", \"Dave Gibbons\"],\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n};\nvar result = Catalog.bookInfo(catalogData, book);\n_.isEqual(result, expectedResult);\nJoe Perfect! Now, how would you compare the kind of unit tests for Catalog\n.bookInfo with the unit tests for Catalog.authorNames?\nTheo On one hand, there is only a single test case in the unit test for Catalog.book-\nInfo. On the other hand, the data involved in the test case is more complex\nthan the data involved in the test cases for Catalog.authorNames.\nJoe Exactly! Functions that appear in a deep node in the tree of function calls tend\nto require more test cases, but the data involved in the test cases is less complex.\nTIP Functions that appear in a lower level in the tree of function calls tend to\ninvolve less complex data than functions that appear in a higher level in the tree\n(see table 6.2).\n--- Page 149 ---\n6.3 Unit tests for queries 121\nTable 6.2 The correlation between the depth of a function in the tree of function calls and the\nquality and quantity of the test cases\nDepth in the tree Complexity of the data Number of test cases\nLower Higher Lower\nHigher Lower Higher\n6.3 Unit tests for queries\nIn the previous section, we saw how to write unit tests for utility functions like Catalog\n.bookInfo and Catalog.authorNames. Now, we are going to see how to write unit tests\nfor the nodes of a query tree of function calls that are close to the root of the tree.\nJoe Theo, how would you write a unit test for the code of the entry point of the\nsearch query?\nTo recall the particulars, Theo checks the code for Library.searchBooksByTitleJSON.\nAlthough Joe was right about today’s topic being easy enough to enjoy the ambience of a\ncoffee shop, he has been doing quite a lot of coding this morning.\nListing6.12 The code of Library.searchBooksByTitleJSON\nLibrary.searchBooksByTitleJSON = function (libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n};\nHe then takes a moment to think about how he’d write a unit test for that code. After\nanother Aha! moment, now he’s got it.\nTheo The inputs of Library.searchBooksByTitleJSON are library data and a\nquery string, and the output is a JSON string (see figure 6.4). So, I would cre-\nate a library data record with a single book and write tests with query strings\nthat match the name of the book and ones that don’t match.\nlibraryData query\nLibrary.searchBooksByTitleJSON()\nFigure 6.4 The input and output of\nresultsJSON Library.searchBooksByTitleJSON\nJoe What about the expected results of the test cases?\n--- Page 150 ---\n122 CHAPTER 6 Unit tests\nTheo In cases where the query string matches, the expected result is a JSON string\nwith the book info. In cases where the query string doesn’t match, the\nexpected result is a JSON string with an empty array.\nJoe Hmm...\nTheo What?\nJoe I don’t like your answer.\nTheo Why?\nJoe Because your test case relies on a string comparison instead of a data comparison.\nTheo What difference does it make? After all, the strings I’m comparing come from\nthe serialization of data.\nJoe It’s inherently much more complex to compare JSON strings than it is to com-\npare data. For example, two different strings might be the serialization of the\nsame piece of data.\nTheo Really? How?\nJoe Take a look at these two strings. They are the serialization of the same data.\nThey’re different strings because the fields appear in a different order, but in\nfact, they serialize the same data!\nJoe turns his laptop to Theo. As Theo looks at the code, he realizes that, once again, Joe\niscorrect.\nListing6.13 Two different strings that serialize the same data\nvar stringA = \"{\\\"title\\\":\\\"Watchmen\\\",\\\"publicationYear\\\":1987}\";\nvar stringB = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nTIP Avoid using a string comparison in unit tests for functions that deal with data.\nTheo I see.... Well, what can I do instead?\nJoe Instead of comparing the output of Library.searchBooksByTitleJSON with\na string, you could deserialize the output and compare it to the expected data.\nTheo What do you mean by deserialize a string?\nJoe Deserializing a string s, for example, means to generate a piece of data whose\nserialization is s.\nTheo Is there a Lodash function for string deserialization?\nJoe Actually, there is a native JavaScript function for string deserialization; it’s\ncalled JSON.parse.\nJoe retrieves his laptop and shows Theo an example of string deserialization. The code\nillustrates a common usage of JSON.parse.\nListing6.14 Example of string deserialization\nvar myString = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nvar myData = JSON.parse(myString);\n--- Page 151 ---\n6.3 Unit tests for queries 123\n_.get(myData, \"title\");\n// → \"Watchmen\"\nTheo Cool! Let me try writing a unit test for Library.searchBooksByTitleJSON\nusing JSON.parse.\nIt doesn’t take Theo too much time to come up with a piece of code. Using his laptop, he\ninputs the unit test.\nListing6.15 Unit test for Library.searchBooksByTitleJSON\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Watchmen\")),\n[bookInfo]);\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Batman\")),\n[]);\nJoe Well done! I think you’re ready to move on to the last piece of the puzzle and\nwrite the unit test for Catalog.searchBooksByTitle.",
        "sections_found": []
      },
      "accurate_page_range": "126-151"
    },
    {
      "text": "- Summary",
      "node_level": 3,
      "part": "Part1—Flexibility",
      "chapter": "5 Basic concurrency control",
      "raw_line": "- Summary (node3) **[LEAF]**",
      "is_part_intro": false,
      "id": 44,
      "chapter_info": {
        "page": 126,
        "title": "Basic concurrency control",
        "pattern_matched": "Chapter 5",
        "text_preview": "98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. "
      },
      "chapter_sections": {
        "start_page": 126,
        "end_page": 151,
        "content": "\n--- Page 126 ---\n98 CHAPTER 5 Basic concurrency control\nTheo Would you mind if I manually expand the logic flow of that code you just wrote\nfor _.reduce?\nJoe I think it’s a great idea!\nTheo In our case, initVal is 0. It means that the first call to f will be f(0, 1). Then,\nwe’ll have f(f(0, 1), 2) and, finally, f(f(f(0, 1), 2), 3).\nJoe I like your manual expansion, Theo! Let’s make it visual.\nNow Theo goes to the whiteboard and draws a diagram. Figure 5.5 shows what that looks like.\nf\nf a\n2\nf a\n1\na 0 initVal Figure 5.5 Visualization\nof _.reduce\nTheo It’s much clearer now. I think that by implementing my custom version of\n_.reduce, it will make things 100% clear.\nIt takes Theo much less time than he expected to implement reduce(). In no time at all,\nhe shows Joe the code.\nListing5.2 Custom implementation of _.reduce\nfunction reduce(coll, f, initVal) {\nvar currentRes = initVal;\nfor (var i = 0; i < coll.length; i++) {\nWe could use\ncurrentRes = f(currentRes, coll[i])\nforEach instead\n}\nof a for loop.\nreturn currentRes;\n}\nAfter checking that Theo’s code works as expected (see listing 5.3), Joe is proud of Theo.\nHe seems to be catching on better than he anticipated.\nListing5.3 Testing the custom implementation of reduce()\nreduce([1, 2, 3], function(res, elem) {\nreturn res + elem;\n}, 0);\n// → 6\nJoe Well done!\n--- Page 127 ---\n5.4 Structural difference 99\n5.4 Structural difference\n NOTE This section deals with the implementation of a structural diff algorithm. Feel\nfree to skip this section if you don’t want to challenge your mind right now with the\ndetails of a sophisticated use of recursion. It won’t prevent you from enjoying the rest\nof the book. You can come back to this section later.\nTheo How do you calculate the diff between various versions of the system state?\nJoe That’s the most challenging part of the reconciliation algorithm. We need to\nimplement a structural diff algorithm for hash maps.\nTheo In what sense is the diff structural?\nJoe The structural diff algorithm looks at the structure of the hash maps and\nignores the order of the fields.\nTheo Could you give me an example?\nJoe Let’s start with maps without nested fields. Basically, there are three kinds of\ndiffs: field replacement, field addition, and field deletion. In order to make\nthings not too complicated, for now, we’ll deal only with replacement and\naddition.\nJoe once again goes to the whiteboard and draws table 5.3, representing the three kinds of\ndiffs. Theo is thinking the whiteboard is really starting to fill up today.\nTable 5.3 Kinds of structural differences between maps without nested fields\nKind First map Second map Diff\nReplacement {\"a\": 1} {\"a\": 2} {\"a\": 2}\nAddition {\"a\": 1} {\"a\": 1, \"b\": 2} {\"b\": 2}\nDeletion {\"a\": 1, \"b\": 2} {\"a\": 1} Not supported\nTheo I notice that the order of the maps matters a lot. What about nested fields?\nJoe It’s the same idea, but the nesting makes it a bit more difficult to grasp.\nJoe changes several of the columns in table 5.3. When he’s through, he shows Theo the\nnested fields in table 5.4.\nTable 5.4 Kinds of structural differences between maps with nested fields\nKind First map Second map Diff\nReplacement { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 2 \"x\": 2\n} } }\n} } }\n--- Page 128 ---\n100 CHAPTER 5 Basic concurrency control\nTable 5.4 Kinds of structural differences between maps with nested fields (continued)\nKind First map Second map Diff\nAddition { { {\n\"a\": { \"a\": { \"a\": {\n\"x\": 1 \"x\": 1, \"y\": 2\n} \"y\": 2, }\n} } }\n}\nDeletion { { Not supported\n\"a\": { \"a\": {\n\"x\": 1, \"y\": 2\n\"y\": 2, }\n} }\n}\n NOTE The version of the structural diff algorithm illustrated in this chapter does\nnot deal with deletions. Dealing with deletions is definitely possible, but it requires a\nmore complicated algorithm.\nTheo As you said, it’s harder to grasp. What about arrays?\nJoe We compare the elements of the arrays in order: if they are equal, the diff is\nnull; if they differ, the diff has the value of the second array.\nJoe summarizes the various kinds of diffs in another table on the whiteboard. Theo looks\nat the result in table 5.5.\nTable 5.5 Kinds of structural differences between arrays without nested elements\nKind First array Second array Diff\nReplacement [1] [2] [2]\nAddition [1] [1, 2] [null, 2]\nDeletion [1, 2] [1] Not supported\nTheo This usage of null is a bit weird but OK. Is it complicated to implement the\nstructural diff algorithm?\nJoe Definitely! It took a good dose of mental gymnastics to come up with these 30\nlines of code.\nJoe downloads the code from one his personal repositories. Theo, with thumb and forefin-\ngers touching his chin and his forehead slightly tilted, studies the code.\nListing5.4 The implementation of a structural diff\nfunction diffObjects(data1, data2) {\n_.isArray checks whether\nvar emptyObject = _.isArray(data1) ? [] : {};\nits argument is an array.\nif(data1 == data2) {\n--- Page 129 ---\n5.4 Structural difference 101\nreturn emptyObject;\n_.union creates an\n} array of unique\nvar keys = _.union(_.keys(data1), _.keys(data2)); values from two\nreturn _.reduce(keys, arrays (like union of\nfunction (acc, k) { two sets in Maths).\nvar res = diff(\n_.get(data1, k),\n_.isObject checks\n_.get(data2, k));\nwhether its argument\nif((_.isObject(res) && _.isEmpty(res)) ||\nis a collection (either\na map or an array).\n(res == \"no-diff\")) {\nreturn acc;\n_.isEmpty }\nchecks return _.set(acc, [k], res);\nwhether its },\nargument\nemptyObject);\nis an empty\n} \"no-diff\" is how\ncollection.\nwe mark that\nfunction diff(data1, data2) { two values are\nif(_.isObject(data1) && _.isObject(data2)) { the same.\nreturn diffObjects(data1, data2);\n}\nif(data1 !== data2) {\nreturn data2;\n}\nreturn \"no-diff\";\n}\nTheo Wow! It involves a recursion inside a reduce! I’m sure Dave will love this, but\nI’m too tired to understand this code right now. Let’s focus on what it does\ninstead of how it does it.\nIn order familiarize himself with the structural diff algorithm, Theo runs the algorithm\nwith examples from the table that Joe drew on the whiteboard. While Theo occupies his\nfingers with more and more complicated examples, his mind wanders in the realm of\nperformance.\nListing5.5 An example of usage of a structural diff\nvar data1 = {\n\"a\": {\n\"x\": 1,\n\"y\": [2, 3],\n\"z\": 4\n}\n};\nvar data2 = {\n\"a\": {\n\"x\": 2,\n\"y\": [2, 4],\n\"z\": 4\n}\n}\n--- Page 130 ---\n102 CHAPTER 5 Basic concurrency control\ndiff(data1, data2);\n//{\n// \"a\": {\n// \"x\": 2,\n// \"y\": [\n// undefined,\n// 4\n// ]\n// }\n//}\nTheo What about the performance of the structural diff algorithm? It seems that the\nalgorithm goes over the leaves of both pieces of data?\nJoe In the general case, that’s true. But, in the case of system data that’s manipu-\nlated with structural sharing, the code is much more efficient.\nTheo What do you mean?\nJoe With structural sharing, most of the nested objects are shared between two ver-\nsions of the system state. Therefore, most of the time, when the code enters\ndiffObjects, it will immediately return because data1 and data2 are the same.\nTIP Calculating the diff between two versions of the state is efficient because two\nhash maps created via structural sharing from the same hash map have most of their\nnodes in common.\nTheo Another benefit of immutable data... Let me see how the diff algorithm\nbehaves with concurrent mutations. I think I’ll start with a tiny library with no\nusers and a catalog with a single book, Watchmen.\nListing5.6 The data for a tiny library\nvar library = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\n--- Page 131 ---\n5.4 Structural difference 103\nJoe I suggest that we start with nonconflicting mutations. What do you suggest?\nTheo A mutation that updates the publication year of Watchmen and a mutation that\nupdates both the title of Watchmen and the name of the author of Watchmen.\nOn his laptop, Theo creates three versions of the library. He shows Joe his code, where one\nmutation updates the publication year of Watchmen, and the other one updates the title of\nWatchmen and the author’s name.\nListing5.7 Two nonconflicting mutations\nvar previous = library;\nvar next = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"],\n1986);\nvar libraryWithUpdatedTitle = _.set(\nlibrary,\n[\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"],\n\"The Watchmen\");\nvar current = _.set(\nlibraryWithUpdatedTitle,\n[\"catalog\", \"authorsById\", \"dave-gibbons\", \"name\"],\n\"David Chester Gibbons\");\nTheo I’m curious to see what the diff between previous and current looks like.\nJoe Run the code and you’ll see.\nTheo runs the code snippets for the structural diff between previous and next and for\nthe structural diff between previous and current. His curiosity satisfied, Theo finds it’s\nall beginning to make sense.\nListing5.8 Structural diff between maps with a single difference\ndiff(previous, next);\n//{\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"publicationYear\": 1986\n// }\n// }\n// }\n//}\nListing5.9 Structural diff between maps with two differences\ndiff(previous, current);\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\",\n--- Page 132 ---\n104 CHAPTER 5 Basic concurrency control\n// }\n// },\n// \"catalog\": {\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\n//\nJoe Can you give me the information path of the single field in the structural diff\nbetween previous and next?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"publicationYear\"].\nJoe Right. And what are the information paths of the fields in the structural diff\nbetween previous and current?\nTheo It’s [\"catalog\", \"booksByIsbn\", \"978-1779501127\", \"title\"] for the book\ntitle and [\"authorsById\", \"dave-gibbons\", \"name\"] for the author’s name.\nJoe Perfect! Now, can you figure out how to detect conflicting mutations by\ninspecting the information paths of the structural diffs?\nTheo We need to check if they have an information path in common or not.\nJoe Exactly! If they have, it means the mutations are conflicting.\nTheo But I have no idea how to write code that retrieves the information paths of a\nnested map.\nJoe Once again, it’s a nontrivial piece of code that involves a recursion inside a\nreduce. Let me download another piece of code from my repository and show\nit to you.\nListing5.10 Calculating the information paths of a (nested) map\nfunction informationPaths (obj, path = []) {\nreturn _.reduce(obj,\nfunction(acc, v, k) {\nif (_.isObject(v)) {\nreturn _.concat(acc,\ninformationPaths(v,\n_.concat(path, k)));\n}\nreturn _.concat(acc, [_.concat(path, k)]);\n},\n[]);\n}\nTheo Let me see if your code works as expected with the structural diffs of the\nmutations.\nTheo tests Joe’s code with two code snippets. The first shows the information paths of the\nstructural diff between previous and next, and the second shows the information paths\nof the structural diff between previous and current.\n--- Page 133 ---\n5.4 Structural difference 105\nListing5.11 Fields that differ between previous and next\ninformationPaths(diff(previous, next));\n// → [\"catalog.booksByIsbn.978-1779501127.publicationYear\"]\nListing5.12 Fields that differ between previous and current\ninformationPaths(diff(previous, current));\n// [\n// [\n// \"catalog\",\n// \"booksByIsbn\",\n// \"978-1779501127\",\n// \"title\"\n// ],\n// [\n// \"authorsById\",\n// \"dave-gibbons\",\n// \"name\"\n// ]\n//]\nTheo Nice! I assume that Lodash has a function that checks whether two arrays have\nan element in common.\nJoe Almost. There is _.intersection, which returns an array of the unique values\nthat are in two given arrays. For our purpose, though, we need to check\nwhether the intersection is empty. Here, look at this example.\nListing5.13 Checking whether two diff maps have a common information path\nfunction havePathInCommon(diff1, diff2) {\nreturn !_.isEmpty(_.intersection(informationPaths(diff1),\ninformationPaths(diff2)));\n}\nTheo You told me earlier that in the case of nonconflicting mutations, we can\nsafely patch the changes induced by the transition from previous to next\ninto current. How do you implement that?\nJoe We do a recursive merge between current and the diff between previous and\nnext.\nTheo Does Lodash provide an immutable version of recursive merge?\nJoe Yes, here’s another example. Take a look at this code.\nListing5.14 Applying a patch\n_.merge(current, (diff(previous, next)));\n//{\n// \"authorsById\": {\n// \"dave-gibbons\": {\n// \"name\": \"David Chester Gibbons\"\n// }\n// },\n--- Page 134 ---\n106 CHAPTER 5 Basic concurrency control\n// \"catalog\": {\n// \"authorsById\": {\n// \"alan-moore\": {\n// \"bookIsbns\": [\"978-1779501127\"]\n// \"name\": \"Alan Moore\"\n// },\n// \"dave-gibbons\": {\n// \"bookIsbns\": [\"978-1779501127\"],\n// \"name\": \"Dave Gibbons\"\n// },\n// },\n// \"booksByIsbn\": {\n// \"978-1779501127\": {\n// \"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n// \"isbn\": \"978-1779501127\",\n// \"publicationYear\": 1986,\n// \"title\": \"The Watchmen\"\n// }\n// }\n// }\n//}\nTheo Could it be as simple as this?\nJoe Indeed.\n5.5 Implementing the reconciliation algorithm\nJoe All the pieces are now in place to implement our reconciliation algorithm.\nTheo What kind of changes are required?\nJoe It only requires changes in the code of SystemState.commit. Here, look at\nthis example on my laptop.\nListing5.15 The SystemState class\nclass SystemState {\nsystemData;\nget() {\nreturn this.systemData;\n}\nset(_systemData) {\nthis.systemData = _systemData;\n}\ncommit(previous, next) {\nvar nextSystemData = SystemConsistency.reconcile(\nthis.systemData,\nSystemConsistency class is\nprevious,\nimplemented in listing 5.16.\nnext);\nif(!SystemValidity.validate(previous, nextSystemData)) {\nthrow \"The system data to be committed is not valid!\";\n};\n--- Page 135 ---\n5.5 Implementing the reconciliation algorithm 107\nthis.systemData = nextSystemData;\n}\n}\nTheo How does SystemConsistency do the reconciliation?\nJoe The SystemConsistency class starts the reconciliation process by comparing\nprevious and current. If they are the same, then we fast-forward and return\nnext. Look at this code for SystemConsistency.\nListing5.16 The reconciliation flow in action\nclass SystemConsistency {\nstatic threeWayMerge(current, previous, next) {\nvar previousToCurrent = diff(previous, current);\nvar previousToNext = diff(previous, next);\nif(havePathInCommon(previousToCurrent, previousToNext)) { When the system\nreturn _.merge(current, previousToNext); state is the same\n} as the state used\nthrow \"Conflicting concurrent mutations.\"; by the calculation\n} phase, we fast-\nstatic reconcile(current, previous, next) { forward.\nif(current == previous) {\nreturn next;\n}\nreturn SystemConsistency.threeWayMerge(current,\nprevious,\nnext);\n}\n}\nTheo Wait a minute! Why do you compare previous and current by reference?\nYou should be comparing them by value, right? And, it would be quite expen-\nsive to compare all the leaves of the two nested hash maps!\nJoe That’s another benefit of immutable data. When the data is not mutated, it is\nsafe to compare references. If they are the same, we know for sure that the data\nis the same.\nTIP When data is immutable, it is safe to compare by reference, which is super fast.\nWhen the references are the same, it means that the data is the same.\nTheo What about the implementation of the three-way merge algorithm?\nJoe When previous differs from current, it means that concurrent mutations\nhave run. In order to determine whether there is a conflict, we calculate two\ndiffs: the diff between previous and current and the diff between previous\nand next. If the intersection between the two diffs is empty, it means there is\nno conflict. We can safely patch the changes between previous to next into\ncurrent.\nTheo takes a closer look at the code for the SystemConsistency class in listing 5.16. He\ntries to figure out if the code is thread-safe or not.\n--- Page 136 ---\n108 CHAPTER 5 Basic concurrency control\nTheo I think the code for SystemConsistency class is not thread-safe! If there’s a\ncontext switch between checking whether the system has changed in the\nSystemConsistency class and the updating of the state in SystemData class, a\nmutation might override the changes of a previous mutation.\nJoe You are totally right! The code works fine in a single-threaded environment\nlike JavaScript, where concurrency is handled via an event loop. However, in a\nmulti-threaded environment, the code needs to be refined in order to be\nthread-safe. I’ll show you some day.\n NOTE The SystemConsistency class is not thread-safe. We will make it thread-safe\nin chapter 8.\nTheo I think I understand why you called it optimistic concurrency control. It’s\nbecause we assume that conflicts don’t occur too often. Right?\nJoe Correct! It makes me wonder what your therapist would say about conflicts that\ncannot be resolved. Are there some cases where it’s not possible to reconcile\nthe couple?\nTheo I don’t think she ever mentioned such a possibility.\nJoe She must be a very optimistic person.\nSummary\n Optimistic concurrency control allows mutations to ask forgiveness instead of\npermission.\n Optimistic concurrency control is lock-free.\n Managing concurrent mutations of our system state with optimistic concurrency\ncontrol allows our system to support a high throughput of reads and writes.\n Optimistic concurrency control with immutable data is super efficient.\n Before updating the state, we need to reconcile the conflicts between possible con-\ncurrent mutations.\n We reconcile between concurrent mutations in a way that is similar to how Git han-\ndles a merge between two branches: either a fast-forward or a three-way merge.\n The changes required to let our system manage concurrency are only in the\ncommit phase.\n The calculation phase does its calculation as if it were the only mutation running.\n The commit phase is responsible for trying to reconcile concurrent mutations.\n The reconciliation algorithm is universal in the sense that it can be used in any sys-\ntem where the system data is represented as an immutable hash map.\n The implementation of the reconciliation algorithm is efficient, as it leverages\nthe fact that subsequent versions of the system state are created via structural\nsharing.\n In a user-facing system, conflicting concurrent mutations are fairly rare.\n When we cannot safely reconcile between concurrent mutations, we abort the\nmutation and ask the user to try again.\n--- Page 137 ---\nSummary 109\n Calculating the structural diff between two versions of the state is efficient because\ntwo hash maps created via structural sharing from the same hash map have most\nof their nodes in common.\n When data is immutable, it is safe to compare by reference, which is fast. When\nthe references are the same, it means that the data is the same.\n There are three kinds of structural differences between two nested hash maps:\nreplacement, addition, and deletion.\n Our structural diff algorithm supports replacements and additions but not\ndeletions.\nLodash functions introduced in this chapter\nFunction Description\nconcat(arrA, arrB) Creates an new array, concatenating arrA and arrB\nintersection(arrA, arrB) Creates an array of unique values both in arrA and arrB\nunion(arrA, arrB) Creates an array of unique values from arrA and arrB\nfind(coll, pred) Iterates over elements of coll, returning the first element for\nwhich pred returns true\nisEmpty(coll) Checks if coll is empty\nreduce(coll, f, initVal) Reduces coll to a value that is the accumulated result of running\neach element in coll through f, where each successive invoca-\ntion is supplied the return value of the previous\nisArray(coll) Checks if coll is an array\nisObject(coll) Checks if coll is a collection\n--- Page 138 ---\nUnit tests\nProgramming at a coffee shop\nThis chapter covers\n Generation of the minimal data input for a\ntest case\n Comparison of the output of a function with\nthe expected output\n Guidance about the quality and the quantity\nof the test cases\nIn a data-oriented system, our code deals mainly with data manipulation: most of\nour functions receive data and return data. As a consequence, it’s quite easy to\nwrite unit tests to check whether our code behaves as expected. A unit test is made\nof test cases that generate data input and compare the data output of the function\nwith the expected data output. In this chapter, we write unit tests for the queries\nand mutations that we wrote in the previous chapters.\n6.1 The simplicity of data-oriented test cases\nTheo and Joe are seated around a large wooden table in a corner of “La vie est belle,” a\nnice little French coffee shop, located near the Golden Gate Bridge. Theo orders a café\nau lait with a croissant, and Joe orders a tight espresso with a pain au chocolat. Instead\nof the usual general discussions about programming and life when they’re out of the\n110\n--- Page 139 ---\n6.1 The simplicity of data-oriented test cases 111\noffice, Joe leads the discussion towards a very concrete topic—unit tests. Theo asks Joe for\nan explanation.\nTheo Are unit tests such a simple topic that we can tackle it here in a coffee shop?\nJoe Unit tests in general, no. But unit tests for data-oriented code, yes!\nTheo Why does that make a difference?\nJoe The vast majority of the code base of a data-oriented system deals with data\nmanipulation.\nTheo Yeah. I noticed that almost all the functions we wrote so far receive data and\nreturn data.\nTIP Most of the code in a data-oriented system deals with data manipulation.\nJoe Writing a test case for functions that deal with data is only about generating\ndata input and expected output, and comparing the output of the function\nwith the expected output.\nThe steps of a test case\n1 Generate data input: dataIn\n2 Generate expected output: dataOut\n3 Compare the output of the function with the expected output: f(dataIn) and\ndataOut\nTheo That’s it?\nJoe Yes. As you’ll see in a moment, in DOP, there’s usually no need for mock\nfunctions.\nTheo I understand how to compare primitive values like strings or numbers, but I’m\nnot sure how I would compare data collections like maps.\nJoe You compare field by field.\nTheo Recursively?\nJoe Yes!\nTheo Oh no! I’m not able to write any recursive code in a coffee shop. I need the\ncalm of my office for that kind of stuff.\nJoe Don’t worry. In DOP, data is represented in a generic way. There is a generic\nfunction in Lodash called _.isEqual for recursive comparison of data collec-\ntions. It works with both maps and arrays.\nJoe opens his laptop. He is able to convince Theo by executing a few code snippets with\n_.isEqual to compare an equal data collection with a non-equal one.\nListing6.1 Comparing an equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n--- Page 140 ---\n112 CHAPTER 6 Unit tests\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n});\n// → true\nListing6.2 Comparing a non-equal data collection recursively\n_.isEqual({\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n}, {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"bad-isbn\"]\n});\n// → false\nTheo Nice!\nJoe Most of the test cases in DOP follow this pattern.\nTheo decides he wants to try this out. He fires up his laptop and types a few lines of\npseudocode.\nListing6.3 The general pattern of a data-oriented test case\nvar dataIn = {\n// input\n};\nvar dataOut = {\n// expected output\n};\n_.isEqual(f(dataIn), dataOut);\nTIP It’s straightforward to write unit tests for code that deals with data manipulation.\nTheo Indeed, this looks like something we can tackle in a coffee shop!\n6.2 Unit tests for data manipulation code\nA waiter in an elegant bow tie brings Theo his croissant and Joe his pain au chocolat. The\ntwo friends momentarily interrupt their discussion to savor their French pastries. When\nthey’re done, they ask the waiter to bring them their drinks. Meanwhile, they resume the\ndiscussion.\nJoe Do you remember the code flow of the implementation of the search query?\nTheo Let me look again at the code that implements the search query.\nTheo brings up the implementation of the search query on his laptop. Noticing that Joe is\nchewing on his nails again, he quickly checks out the code.\n--- Page 141 ---\n6.2 Unit tests for data manipulation code 113\nListing6.4 The code involved in the implementation of the search query\nclass Catalog {\nstatic authorNames(catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n}\nstatic bookInfo(catalogData, book) {\nvar bookInfo = {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\nreturn bookInfo;\n}\nstatic searchBooksByTitle(catalogData, query) {\nvar allBooks = _.get(catalogData, \"booksByIsbn\");\nvar matchingBooks = _.filter(allBooks, function(book) {\nreturn _.get(book, \"title\").includes(query);\n});\nvar bookInfos = _.map(matchingBooks, function(book) {\nreturn Catalog.bookInfo(catalogData, book);\n});\nreturn bookInfos;\n}\n}\nclass Library {\nstatic searchBooksByTitleJSON(libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n}\n}\n6.2.1 The tree of function calls\nThe waiter brings Theo his café au lait and Joe his tight espresso. They continue their dis-\ncussion while enjoying their coffees.\nJoe Before writing a unit test for a code flow, I find it useful to visualize the tree of\nfunction calls of the code flow.\nTheo What do you mean by a tree of function calls?\nJoe Here, I’ll draw the tree of function calls for the Library.searchBooksBy-\nTitleJSON code flow.\nJoe puts down his espresso and takes a napkin from the dispenser. He carefully places it\nflat on the table and starts to draw. When he is done, he shows the illustration to Theo (see\nfigure 6.1).\n--- Page 142 ---\n114 CHAPTER 6 Unit tests\nLibrary.searchBooksByTitleJSON\n_.get JSON.stringify Catalog.searchBooksByTitle\n_.get _.map _.filter Catalog.bookInfo\n_.get Catalog.authorNames\n_.get _.map\nFigure 6.1 The tree of function calls for the search query code flow\nTheo Nice! Can you teach me how to draw a tree of function calls like that?\nJoe Sure. The root of the tree is the name of the function for which you draw the\ntree, in our case, Library.searchBooksByTitleJSON. The children of a\nnode in the tree are the names of the functions called by the function. For exam-\nple, if you look again at the code for Library.searchBooksByTitleJSON (list-\ning 6.4), you’ll see that it calls Catalog.searchBooksByTitle, _.get, and\nJSON.stringify.\nTheo How long would I continue to recursively expand the tree?\nJoe You continue until you reach a function that doesn’t belong to the code base\nof your application. Those nodes are the leaves of our tree; for example, the\nfunctions from Lodash: _.get, _.map, and so forth.\nTheo What if the code of a function doesn’t call any other functions?\nJoe A function that doesn’t call any other function would be a leaf in the tree.\nTheo What about functions that are called inside anonymous functions like Catalog\n.bookInfo?\nJoe Catalog.bookInfo appears in the code of Catalog.searchBooksByTitle.\nTherefore, it is considered to be a child node of Catalog.searchBooksBy-\nTitle. The fact that it is nested inside an anonymous function is not relevant\nin the context of the tree of function calls.\n NOTE A tree of function calls for a function f is a tree where the root is f, and the\nchildren of a node g in the tree are the functions called by g. The leaves of the tree are\nfunctions that are not part of the code base of the application. These are functions\nthat don’t call any other functions.\nTheo It’s very cool to visualize my code as a tree, but I don’t see how it relates to\nunittests.\n--- Page 143 ---\n6.2 Unit tests for data manipulation code 115\nJoe The tree of function calls guides us about the quality and the quantity of test\ncases we should write.\nTheo How?\nJoe You’ll see in a moment.\n6.2.2 Unit tests for functions down the tree\nJoe Let’s start from the function that appears in the deepest node in our tree:\nCatalog.authorNames. Take a look at the code for Catalog.authorNames\nand tell me what are the input and the output of Catalog.authorNames.\nJoe turns his laptop so Theo can a closer look at the code. Theo takes a sip of his café au\nlait as he looks over what’s on Joe’s laptop.\nListing6.5 The code of Catalog.authorNames\nCatalog.authorNames = function (catalogData, authorIds) {\nreturn _.map(authorIds, function(authorId) {\nreturn _.get(catalogData, [\"authorsById\", authorId, \"name\"]);\n});\n};\nTheo The input of Catalog.authorNames is catalogData and authorIds. The\noutput is authorNames.\nJoe Would you do me a favor and express it visually?\nTheo Sure.\nIt’s Theo’s turn to grab a napkin. He draws a small rectangle with two inward arrows and\none outward arrow as in figure 6.2.\ncatalogData authorIds\nCatalog.authorNames()\nFigure 6.2 Visualization of the input\nauthorNames and output of Catalog.authorNames\nJoe Excellent! Now, how many combinations of input would you include in the\nunit test for Catalog.authorNames?\nTheo Let me see.\nTheo reaches for another napkin. This time he creates a table to gather his thoughts\n(table 6.1).\n--- Page 144 ---\n116 CHAPTER 6 Unit tests\nTable 6.1 The table of test cases for Catalog.authorNames\ncatalogData authorIds authorNames\nCatalog with two authors Empty array Empty array\nCatalog with two authors Array with one author ID Array with one author name\nCatalog with two authors Array with two author IDs Array with two author names\nTheo To begin with, I would have a catalogData with two author IDs and call\nCatalog.authorNames with three arguments: an empty array, an array with a\nsingle author ID, and an array with two author IDs.\nJoe How would you generate the catalogData?\nTheo Exactly as we generated it before.\nTurning to his laptop, Theo writes the code for catalogData. He shows it to Joe.\nListing6.6 A complete catalogData map\nvar catalogData = {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"],\n\"bookItems\": [\n{\n\"id\": \"book-item-1\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": true\n},\n{\n\"id\": \"book-item-2\",\n\"libId\": \"nyc-central-lib\",\n\"isLent\": false\n}\n]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n};\n--- Page 145 ---\n6.2 Unit tests for data manipulation code 117\nJoe You could use your big catalogData map for the unit test, but you could also\nuse a smaller map in the context of Catalog.authorNames. You can get rid of\nthe booksByIsbn field of the catalogData and the bookIsbns fields of the\nauthors.\nJoe deletes a few lines from catalogData and gets a much smaller map. He shows the revi-\nsion to Theo.\nListing6.7 A minimal version of catalogData\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nTheo Wait a minute! This catalogData is not valid.\nJoe In DOP, data validity depends on the context. In the context of Library\n.searchBooksByTitleJSON and Catalog.searchBooksByTitle, the mini-\nmal version of catalogData is indeed not valid. However, in the context of\nCatalog.bookInfo and Catalog.authorNames, it is perfectly valid. The reason\nis that those two functions access only the authorsById field of catalogData.\nTIP The validity of the data depends on the context.\nTheo Why is it better to use a minimal version of the data in a test case?\nJoe For a very simple reason—the smaller the data, the easier it is to manipulate.\nTIP The smaller the data, the easier it is to manipulate.\nTheo I’ll appreciate that when I write the unit tests!\nJoe Definitely! One last thing before we start coding: how would you check that the\noutput of Catalog.authorNames is as expected?\nTheo I would check that the value returned by Catalog.authorNames is an array\nwith the expected author names.\nJoe How would you handle the array comparison?\nTheo Let me think. I want to compare by value, not by reference. I guess I’ll have to\ncheck that the array is of the expected size and then check member by mem-\nber, recursively.\nJoe That’s too much of a mental burden when you’re in a coffee shop. As I showed\nyou earlier (see listing 6.1), we can recursively compare two data collections by\nvalue with _.isEqual from Lodash.\n--- Page 146 ---\n118 CHAPTER 6 Unit tests\nTIP We can compare the output and the expected output of our functions with\n_.isEqual.\nTheo Sounds good! Let me write the test cases.\nTheo starts typing on his laptop. After a few minutes, he has some test cases for Catalog\n.authorNames, each made from a function call to Catalog.authorNames wrapped in\n_.isEqual.\nListing6.8 Unit test for Catalog.authorNames\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(\ncatalogData,\n[\"alan-moore\"]),\n[\"Alan Moore\"]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\", \"dave-gibbons\"]),\n[\"Alan Moore\", \"Dave Gibbons\"]);\nJoe Well done! Can you think of more test cases?\nTheo Yes. There are test cases where the author ID doesn’t appear in the catalog\ndata, and test cases with empty catalog data. With minimal catalog data and\n_.isEqual, it’s really easy to write lots of test cases!\nTheo really enjoys this challenge. He creates a few more test cases to present to Joe.\nListing6.9 More test cases for Catalog.authorNames\n_.isEqual(Catalog.authorNames({}, []), []);\n_.isEqual(Catalog.authorNames({}, [\"alan-moore\"]), [undefined]);\n_.isEqual(Catalog.authorNames(catalogData, [\"alan-moore\",\n\"albert-einstein\"]), [\"Alan Moore\", undefined]);\n_.isEqual(Catalog.authorNames(catalogData, []), []);\n_.isEqual(Catalog.authorNames(catalogData, [\"albert-einstein\"]),\n[undefined]);\nTheo How do I run these unit tests?\nJoe You use your preferred test framework.\n--- Page 147 ---\n6.2 Unit tests for data manipulation code 119\n NOTE We don’t deal here with test runners and test frameworks. We deal only with\nthe logic of the test cases.\n6.2.3 Unit tests for nodes in the tree\nTheo I’m curious to see what unit tests for an upper node in the tree of function calls\nlook like.\nJoe Sure. Let’s write a unit test for Catalog.bookInfo. How many test cases would\nyou have for Catalog.bookInfo?\nListing6.10 The code of Catalog.bookInfo\nCatalog.bookInfo = function (catalogData, book) {\nreturn {\n\"title\": _.get(book, \"title\"),\n\"isbn\": _.get(book, \"isbn\"),\n\"authorNames\": Catalog.authorNames(catalogData,\n_.get(book, \"authorIds\"))\n};\n};\nTheo takes another look at the code for Catalog.bookInfo on his laptop. Then, reaching\nfor another napkin, he draws a diagram of its input and output (see figure 6.3).\ncatalogData book\nCatalog.bookInfo()\nFigure 6.3 Visualization of the input\nbookInfo and output of Catalog.bookInfo\nTheo I would have a similar number of test cases for Catalog.authorNames: a book\nwith a single author, with two authors, with existing authors, with non-existent\nauthors, with...\nJoe Whoa! That’s not necessary. Given that we have already written unit tests for\nCatalog.authorNames, we don’t need to check all the cases again. We simply\nneed to write a minimal test case to confirm that the code works.\nTIP When we write a unit test for a function, we assume that the functions called by\nthis function are covered by unit tests and work as expected. It significantly reduces\nthe quantity of test cases in our unit tests.\nTheo That makes sense.\nJoe How would you write a minimal test case for Catalog.bookInfo?\nTheo once again takes a look at the code for Catalog.bookInfo (see listing 6.10). Now he\ncan answer Joe’s question.\n--- Page 148 ---\n120 CHAPTER 6 Unit tests\nTheo I would use the same catalog data as for Catalog.authorNames and a book\nrecord. I’d test that the function behaves as expected by comparing its return\nvalue with a book info record using _.isEqual. Here, let me show you.\nIt takes Theo a bit more time to write the unit test. The reason is that the input and the\noutput of Catalog.authorNames are both records. Dealing with a record is more complex\nthan dealing with an array of strings (as it was the case for Catalog.authorNames). Theo\nappreciates the fact that _.isEqual saves him from writing code that compares the two\nmaps property by property. When he’s through, he shows the result to Joe and takes a nap-\nkin to wipe his forehead.\nListing6.11 Unit test for Catalog.bookInfo\nvar catalogData = {\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\"\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\"\n}\n}\n};\nvar book = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\", \"dave-gibbons\"]\n};\nvar expectedResult = {\n\"authorNames\": [\"Alan Moore\", \"Dave Gibbons\"],\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n};\nvar result = Catalog.bookInfo(catalogData, book);\n_.isEqual(result, expectedResult);\nJoe Perfect! Now, how would you compare the kind of unit tests for Catalog\n.bookInfo with the unit tests for Catalog.authorNames?\nTheo On one hand, there is only a single test case in the unit test for Catalog.book-\nInfo. On the other hand, the data involved in the test case is more complex\nthan the data involved in the test cases for Catalog.authorNames.\nJoe Exactly! Functions that appear in a deep node in the tree of function calls tend\nto require more test cases, but the data involved in the test cases is less complex.\nTIP Functions that appear in a lower level in the tree of function calls tend to\ninvolve less complex data than functions that appear in a higher level in the tree\n(see table 6.2).\n--- Page 149 ---\n6.3 Unit tests for queries 121\nTable 6.2 The correlation between the depth of a function in the tree of function calls and the\nquality and quantity of the test cases\nDepth in the tree Complexity of the data Number of test cases\nLower Higher Lower\nHigher Lower Higher\n6.3 Unit tests for queries\nIn the previous section, we saw how to write unit tests for utility functions like Catalog\n.bookInfo and Catalog.authorNames. Now, we are going to see how to write unit tests\nfor the nodes of a query tree of function calls that are close to the root of the tree.\nJoe Theo, how would you write a unit test for the code of the entry point of the\nsearch query?\nTo recall the particulars, Theo checks the code for Library.searchBooksByTitleJSON.\nAlthough Joe was right about today’s topic being easy enough to enjoy the ambience of a\ncoffee shop, he has been doing quite a lot of coding this morning.\nListing6.12 The code of Library.searchBooksByTitleJSON\nLibrary.searchBooksByTitleJSON = function (libraryData, query) {\nvar catalogData = _.get(libraryData, \"catalog\");\nvar results = Catalog.searchBooksByTitle(catalogData, query);\nvar resultsJSON = JSON.stringify(results);\nreturn resultsJSON;\n};\nHe then takes a moment to think about how he’d write a unit test for that code. After\nanother Aha! moment, now he’s got it.\nTheo The inputs of Library.searchBooksByTitleJSON are library data and a\nquery string, and the output is a JSON string (see figure 6.4). So, I would cre-\nate a library data record with a single book and write tests with query strings\nthat match the name of the book and ones that don’t match.\nlibraryData query\nLibrary.searchBooksByTitleJSON()\nFigure 6.4 The input and output of\nresultsJSON Library.searchBooksByTitleJSON\nJoe What about the expected results of the test cases?\n--- Page 150 ---\n122 CHAPTER 6 Unit tests\nTheo In cases where the query string matches, the expected result is a JSON string\nwith the book info. In cases where the query string doesn’t match, the\nexpected result is a JSON string with an empty array.\nJoe Hmm...\nTheo What?\nJoe I don’t like your answer.\nTheo Why?\nJoe Because your test case relies on a string comparison instead of a data comparison.\nTheo What difference does it make? After all, the strings I’m comparing come from\nthe serialization of data.\nJoe It’s inherently much more complex to compare JSON strings than it is to com-\npare data. For example, two different strings might be the serialization of the\nsame piece of data.\nTheo Really? How?\nJoe Take a look at these two strings. They are the serialization of the same data.\nThey’re different strings because the fields appear in a different order, but in\nfact, they serialize the same data!\nJoe turns his laptop to Theo. As Theo looks at the code, he realizes that, once again, Joe\niscorrect.\nListing6.13 Two different strings that serialize the same data\nvar stringA = \"{\\\"title\\\":\\\"Watchmen\\\",\\\"publicationYear\\\":1987}\";\nvar stringB = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nTIP Avoid using a string comparison in unit tests for functions that deal with data.\nTheo I see.... Well, what can I do instead?\nJoe Instead of comparing the output of Library.searchBooksByTitleJSON with\na string, you could deserialize the output and compare it to the expected data.\nTheo What do you mean by deserialize a string?\nJoe Deserializing a string s, for example, means to generate a piece of data whose\nserialization is s.\nTheo Is there a Lodash function for string deserialization?\nJoe Actually, there is a native JavaScript function for string deserialization; it’s\ncalled JSON.parse.\nJoe retrieves his laptop and shows Theo an example of string deserialization. The code\nillustrates a common usage of JSON.parse.\nListing6.14 Example of string deserialization\nvar myString = \"{\\\"publicationYear\\\":1987,\\\"title\\\":\\\"Watchmen\\\"}\";\nvar myData = JSON.parse(myString);\n--- Page 151 ---\n6.3 Unit tests for queries 123\n_.get(myData, \"title\");\n// → \"Watchmen\"\nTheo Cool! Let me try writing a unit test for Library.searchBooksByTitleJSON\nusing JSON.parse.\nIt doesn’t take Theo too much time to come up with a piece of code. Using his laptop, he\ninputs the unit test.\nListing6.15 Unit test for Library.searchBooksByTitleJSON\nvar libraryData = {\n\"catalog\": {\n\"booksByIsbn\": {\n\"978-1779501127\": {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"publicationYear\": 1987,\n\"authorIds\": [\"alan-moore\",\n\"dave-gibbons\"]\n}\n},\n\"authorsById\": {\n\"alan-moore\": {\n\"name\": \"Alan Moore\",\n\"bookIsbns\": [\"978-1779501127\"]\n},\n\"dave-gibbons\": {\n\"name\": \"Dave Gibbons\",\n\"bookIsbns\": [\"978-1779501127\"]\n}\n}\n}\n};\nvar bookInfo = {\n\"isbn\": \"978-1779501127\",\n\"title\": \"Watchmen\",\n\"authorNames\": [\"Alan Moore\",\n\"Dave Gibbons\"]\n};\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Watchmen\")),\n[bookInfo]);\n_.isEqual(JSON.parse(Library.searchBooksByTitleJSON(libraryData,\n\"Batman\")),\n[]);\nJoe Well done! I think you’re ready to move on to the last piece of the puzzle and\nwrite the unit test for Catalog.searchBooksByTitle.",
        "sections_found": []
      },
      "accurate_page_range": "126-151"
    }
  ]
}